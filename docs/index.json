[{"categories":["Linux Kernel Internals"],"content":" 尽管数值系统并非 C 语言所持有，但在 Linux 核心大量存在 u8/u16/u32/u64 这样通过 typedef 所定义的类型，伴随着各种 alignment 存取，如果对数值系统的认知不够充分，可能立即就被阻拦在探索 Linux 核心之外——毕竟你完全搞不清楚，为何 Linux 核心存取特定资料需要绕一大圈。 原文地址 ","date":"2024-02-20","objectID":"/posts/c-numerics/:0:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 数值系统","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":"Balanced ternary balanced ternary 三进制中 -, 0, + 在数学上具备对称性质。它相对于二进制编码的优势在于，其本身就可以表示正负数 (通过 +-, 0, +)，而二进制需要考虑 unsigned 和 signed 的情况，从而决定最高位所表示的数值。 相关的运算规则: $+\\ (add)\\ - = 0$ $0\\ (add)\\ + = +$ $0\\ (add)\\ - = -$ 以上运算规则都比较直观，这也决定了 balanced ternary 在编码上的对称性 (减法等价于加上逆元，逆元非常容易获得)。但是需要注意，上面的运算规则并没有涉及到相同位运算的规则，例如 $+\\ (add)\\ +$，这种运算也是 balanced ternary 相对于二进制编码的劣势，可以自行推导一下这种运算的规则。 The Balanced Ternary Machines of Soviet Russia ","date":"2024-02-20","objectID":"/posts/c-numerics/:1:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 数值系统","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":"数值编码与阿贝尔群 阿贝尔群也用于指示为什么使用二补数编码来表示整数: 存在唯一的单位元 (二补数中单位元 0 的编码是唯一的) 每个元素都有逆元 (在二补数中几乎每个数都有逆元) 浮点数 IEEE 754: Conversión de un número binario a formato IEEE 754 单精度浮点数相对于整数 在某些情況下不满足結合律和交换律，所以不构成 阿贝尔群，在编写程序时需要注意这一点。即使编写程序时谨慎处理了单精度浮点数运算，但是编译器优化可能会将我们的处理破划掉。所以涉及到单精度浮点数，都需要注意其运算。 信息 你所不知道的 C 语言: 编译器和最佳化原理篇 ","date":"2024-02-20","objectID":"/posts/c-numerics/:2:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 数值系统","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":"Integer Overflow ","date":"2024-02-20","objectID":"/posts/c-numerics/:3:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 数值系统","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":"2002 年 FreeBSD [53] #define KSIZE 1024 char kbuf[KSIZE]; int copy_from_kernel(void *user_dest, int maxlen) { int len = KSIZE \u003c maxlen ? KSIZE : maxlen; memcpy(user_dest, kbuf, len); return len; } 假设将“负”的数值带入 maxlen，那么在上述的程式码第 4 行时 len 会被赋值为 maxlen，在第 5 行中，根据 memcpy 的原型声明 void *memcpy(void *dest, const void *src, size_t n); 会将 len (=maxlen) 解释为 size_t 类型，关于 size_t 类型 C99 [7.17 Common definitions \u003cstddef.h\u003e] size_t which is the unsigned integer type of the result of the sizeof operator; 所以在 5 行中 memcpy 会将 len 这个“负“的数值按照无符号数的编码进行解释，这会导致将 len 解释为一个超级大的无符号数，可能远比 KSIZE 这个限制大。copy_from_kernel 这个函数是运行在 kernel 中的，这样可能会造成潜在的 kernel 信息数据泄露问题。 ","date":"2024-02-20","objectID":"/posts/c-numerics/:3:1","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 数值系统","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":"2002 年 External data representation (XDR) [62] void *copy_elements(void *ele_src[], int ele_cnt, int ele_size) { void *result = malloc(ele_cnt * ele_size); if (result==NULL) return NULL; void *next = result; for (int i = 0; i \u003c ele_cnt; i++) { memcpy(next, ele_src[i], ele_size); next += ele_size; } return result; } 假设将 ele_cnt = $2^{20}+1$, ele_size=$2^{12}$ 代入，显然在第 2 行的 ele_cnt * ele_size 会超出 32 位整数表示的最大值，导致 overflow。又因为 malloc 的原型声明 void *malloc(size_t size); malloc 会将 ele_cnt * ele_size 溢出后保留的值解释为 size_t，这会导致 malloc 分配的内存空间远小于 ele_cnt * ele_size Bytes (这是 malloc 成功的情况，malloc 也有可能会失败，返回 NULL)。 因为 malloc 成功分配空间，所以会通过第 3 行的测试。在第 5~8 行的 for 循环，根据 ele_cnt 和 ele_size 的值进行 memcpy，但是因为分配的空间远远小于 ele_cnt * ele_size，所以这样会覆写被分配空间外的内存区域，可能会造成 kernel 的信息数据被覆盖。 ","date":"2024-02-20","objectID":"/posts/c-numerics/:3:2","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 数值系统","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":"Bitwise 3Blue1Brown: How to count to 1000 on two hands [YouTube] 本质上是使用无符号数的二进制编码来进行计数，将手指/脚趾视为数值的 bit 信息 解读计算机编码 ","date":"2024-02-20","objectID":"/posts/c-numerics/:4:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 数值系统","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":"Power of two 通过以下程式码可以判断 x 是否为 2 的次方 x \u0026 (x - 1) == 0 通过值为 1 的最低位来进行归纳法证明，例如，对 0b00000001, 0b00000010, 0b00000100, … 来进行归纳证明 (还需要证明 x 中只能有一个 bit 为值 1，不过这个比较简单)。 ","date":"2024-02-20","objectID":"/posts/c-numerics/:4:1","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 数值系统","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":"ASCII table 通过 ASCII table 中对 ASCII 编码的分布规律，可以实现大小写转换的 constant-time function // 字符转小写 (x | ' ') // 字符转大写 (x \u0026 ' ') // 大小写互转 (x ^ ' ') ","date":"2024-02-20","objectID":"/posts/c-numerics/:4:2","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 数值系统","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":"XOR swap 通过 xor 运算符可以实现无需临时变量的，交换两个数值的程式码 void xorSwap(int *x, int *y) { *x ^= *y; *y ^= *x; *x ^= *y; } 第 3 行的 *y ^= *x 的结果等价于 *y ^ *x ^ *y，整数满足交换律和结合律，所以结果为 *x 第 4 行的 *x ^= *y 的结果等价于 *x ^ *y ^ *x，整数满足交换律和结合律，所以结果为 *y ","date":"2024-02-20","objectID":"/posts/c-numerics/:4:3","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 数值系统","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":"避免 overflow 整数运算 (x + y) / 2 可能会导致 overflow (如果 x, y 数值都接近 UINT32_MAX)，可以改写为以下不会导致 overflow 的程式码 (x \u0026 y) + (x ^ y) \u003e\u003e 1 使用加法器来思考: 对于 x + y，x \u0026 y 表示进位，x ^ y 表示位元和，所以 x + y 等价于 (x \u0026 y) \u003c\u003c 1 + (x ^ y) 这个运算不会导致 overflow (因为使用了 bitwise 运算)。因此 (x + y) / 2 等价于 ((x \u0026 y) \u003c\u003c 1 + (x ^ y)) \u003e\u003e 1 = (x \u0026 y) \u003c\u003c 1 \u003e\u003e 1 + (x ^ y) \u003e\u003e 1 = (x \u0026 y) + (x ^ y) \u003e\u003e 1 整数满足交换律和结合律 ","date":"2024-02-20","objectID":"/posts/c-numerics/:4:4","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 数值系统","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":"macro DIRECT","date":"2024-02-20","objectID":"/posts/c-numerics/:4:5","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 数值系统","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":"预期目标 + 开发环境设置 ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:0","tags":["Sysprog","Linux","C"],"title":"Linux 核心设计: Lab0","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"程序分析工具 Cppcheck 是 静态 程序分析工具，即无需运行程序就可以分析出程序潜在的问题，当然会有一定的误差，类似的工具有 cargo-check Valgrind 是 动态 程序分析工具，即需要将程序运行起来再进行分析，通常用于检测内存泄漏 (memory leak) ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:1","tags":["Sysprog","Linux","C"],"title":"Linux 核心设计: Lab0","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"Queue 相关的 LeetCode 题目的实作情况: LeetCode 2095. Delete the Middle Node of a Linked List LeetCode 82. Remove Duplicates from Sorted List II LeetCode 24. Swap Nodes in Pairs LeetCode 25. Reverse Nodes in k-Group LeetCode 2487. Remove Nodes From Linked List / 参考题解 LeetCode 23. Merge k Sorted Lists q_free 在遍历时需要释放当前节点所在元素的空间，所以需要使用 list_for_each_entry_safe，而 q_size 无需在遍历时修改当前节点，所以使用 list_for_each 就足够了。 ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:2","tags":["Sysprog","Linux","C"],"title":"Linux 核心设计: Lab0","uri":"/posts/linux2023-lab0/"},{"categories":["Rust"],"content":" In this stream, we started implementing the ubiquitous TCP protocol that underlies much of the traffic on the internet! In particular, we followed RFC 793 — https://tools.ietf.org/html/rfc793 — which describes the original protocol, with the goal of being able to set up and tear down a connection with a “real” TCP stack at the other end (netcat in particular). We’re writing it using a user-space networking interface (see https://www.kernel.org/doc/Documentation/networking/tuntap.txt and the Rust bindings at https://docs.rs/tun-tap/). 整理自 John Gjengset 的影片: Part 1 ","date":"2024-02-17","objectID":"/posts/rust-tcp/:0:0","tags":["Rust","TCP","Network"],"title":"Implementing TCP/IP in Rust","uri":"/posts/rust-tcp/"},{"categories":["Rust"],"content":"影片注解 Part 1 ","date":"2024-02-17","objectID":"/posts/rust-tcp/:1:0","tags":["Rust","TCP","Network"],"title":"Implementing TCP/IP in Rust","uri":"/posts/rust-tcp/"},{"categories":["Rust"],"content":"Raw socket vs TUN/TAP device Raw sockets [Wikipedia] TUN/TAP [Wikipedia] Raw socket vs TUN device [Stack Overflow] Universal TUN/TAP device driver [Linux kernel documentation] Raw socket: Internet –\u003e NIC –\u003e kernel –\u003e user space Internet \u003c– NIC \u003c– kernel \u003c– user space Host interact with other hosts in Internet. TUN/TAP device: kernel –\u003e | TUN/TAP | –\u003e user space kernel \u003c– | TUN/TAP | \u003c– user space Kernel interact with programs in user space in the same host. 和其他物理网卡一样，用户进程创建的 TUN/TAP 设备仍然是被 kernel 所拥有的 (kernel 可以使用设备进行发送/接收)，只不过用户进程也可以像操作 管道 (pipe) 那样，操作所创建的 TUN/TAP 设备 (可以使用该设备进行发送/接收)，从而与 kernel 的物理网卡进行通信。 Universal TUN/TAP device driver [Linux kernel documentation] 3.2 Frame format: If flag IFF_NO_PI is not set each frame format is: Flags [2 bytes] Proto [2 bytes] Raw protocol(IP, IPv6, etc) frame. 通过 TUN/TAP 设备接收的封包，会拥有 Flags 和 Proto 这两个字段 (共 4 个字节，这也是 iface 的 without_packet_info 和 recv 方法所描述的 prepended packet info)，然后才是原始协议的 frame。其中的 Proto 字段是 EtherType [Wikipedia]，可以根据里面的 values 来判断接受封包的协议类型 (0x0800 表示 IPv4，0x86DD 表示 IPv6)。 ","date":"2024-02-17","objectID":"/posts/rust-tcp/:1:1","tags":["Rust","TCP","Network"],"title":"Implementing TCP/IP in Rust","uri":"/posts/rust-tcp/"},{"categories":["Rust"],"content":"setcap setcap [Linux manual page] cap_from_text [Linux manual page] 因为 TUN/TAP 是由 kernel 提供的，所以需要赋予我们项目的可执行文件权限，使它能访问我们创建的 TUN/TAP 设备 (为了简单起见，下面只列出 release 版本的方法，debug 版本的方法类似)。 # 编译 $ cargo build --release # 设置文件权限 $ sudo setcap cap_net_admin=eip target/release/trust # 运行 $ cargo run --release 在另一终端输入命令 ip addr 就可以看到此时会多出一个名为 tun0 的设备，这正是我们创建的 TUN 设备。 ip-address [Linux manual page] ip-link [Linux manual page] 在另一个终端中输入: # 列出当前所有的网络设备 $ ip addr # 配置设备 tun0 的 IP 地址 $ sudo ip addr add 192.168.0.1/24 dev tun0 # 启动设备 tun0 $ sudo ip link set up dev tun0 每次编译后都需要执行一遍这个流程 (因为重新编译生成的可执行文件需要重新设置权限)，我们将这些流程的逻辑写成一个脚本 run.sh。这个脚本为了输出的美观性增加了额外逻辑，例如将 trust 放在后台执行，将脚本设置为等待 trust 执行完成后才结束执行。 ","date":"2024-02-17","objectID":"/posts/rust-tcp/:1:2","tags":["Rust","TCP","Network"],"title":"Implementing TCP/IP in Rust","uri":"/posts/rust-tcp/"},{"categories":["Rust"],"content":"Endianness Endianness [Wikipedia] Why is network-byte-order defined to be big-endian? [Stack Overflow] Rust 提供了 Trait std::simd::ToBytes 用于大小端字节序之间的相互转换，方法 from_be_bytes 是将大端字节序的一系列字节转换成对应表示的数值。 ","date":"2024-02-17","objectID":"/posts/rust-tcp/:1:3","tags":["Rust","TCP","Network"],"title":"Implementing TCP/IP in Rust","uri":"/posts/rust-tcp/"},{"categories":["Rust"],"content":"IP 因为 TUN 只是在 Network layer 的虚拟设备 (TAP 则是 Data link layer 层)，所以需要手动解析 IP 封包。 RFC 791 3.1. Internet Header Format List of IP protocol numbers [Wikipedia] 可以按照上面的格式来解析封包头，也可以引入 Crate etherparse 来解析 IP 封包头。 ping 命令使用的是 Network layer 上的 ICMP 协议，可以用于测试 TUN 是否成功配置并能接收封包。 $ ping -I tun0 192.168.0.2 ping (networking utility) [Wikipedia] ping [Linux man page] nc 命令用于发送 TCP 封包 $ nc 192.168.0.2 80 nc [Linux man page] 注意 ping, nc 这些命令使用的都是 kernel 的协议栈来实现，所以在创建虚拟设备 tun0 之后，使用以上 ping, nc 命令表示 kernel 发送相应的 ICMP, TCP 封包给创建 tun0 的进程 (process)。 可以使用 tshark (Terminal Wireshark) 工具来抓包，配合 ping,nc 命令可以分析 tun0 的封包传送。 $ sudo apt install tshark $ sudo tshark -i tun0 Wireshark [Wikipedia] tshark [Manual Page] ","date":"2024-02-17","objectID":"/posts/rust-tcp/:1:4","tags":["Rust","TCP","Network"],"title":"Implementing TCP/IP in Rust","uri":"/posts/rust-tcp/"},{"categories":["Rust"],"content":"TCP [RFC 793] 3.2 Terminology The state diagram in figure 6 illustrates only state changes, together with the causing events and resulting actions, but addresses neither error conditions nor actions which are not connected with state changes. 这里面提到的 Figure 6. TCP Connection State Diagram 在其中我们可以看到 TCP 的状态转换，非常有利于直观理解 TCP 建立连接时的三次握手过程。 警告 NOTE BENE: this diagram is only a summary and must not be taken as the total specification. Time to live [Wikipedia] In the IPv4 header, TTL is the 9th octet of 20. In the IPv6 header, it is the 8th octet of 40. The maximum TTL value is 255, the maximum value of a single octet. A recommended initial value is 64. ","date":"2024-02-17","objectID":"/posts/rust-tcp/:1:5","tags":["Rust","TCP","Network"],"title":"Implementing TCP/IP in Rust","uri":"/posts/rust-tcp/"},{"categories":["Rust"],"content":"Documentations 这里列举视频中一些概念相关的 documentation 学习的一手资料是官方文档，请务必自主学会阅读规格书之类的资料 ","date":"2024-02-17","objectID":"/posts/rust-tcp/:2:0","tags":["Rust","TCP","Network"],"title":"Implementing TCP/IP in Rust","uri":"/posts/rust-tcp/"},{"categories":["Rust"],"content":"Crate std Module std::io Type Alias std::io::Result Module std::collections::hash_map method std::collections::hash_map::HashMap::entry method std::collections::hash_map::Entry::or_default Trait std::default::Default Module std::net Macro std::eprintln method std::result::Result::expect method u16::from_be_bytes ","date":"2024-02-17","objectID":"/posts/rust-tcp/:2:1","tags":["Rust","TCP","Network"],"title":"Implementing TCP/IP in Rust","uri":"/posts/rust-tcp/"},{"categories":["Rust"],"content":"Crate tun_tap Enum tun_tap::Mode ","date":"2024-02-17","objectID":"/posts/rust-tcp/:2:2","tags":["Rust","TCP","Network"],"title":"Implementing TCP/IP in Rust","uri":"/posts/rust-tcp/"},{"categories":["Rust"],"content":"Crate etherparse Struct etherparse::Ipv4HeaderSlice Struct etherparse::Ipv4Header Struct etherparse::TcpHeaderSlice Struct etherparse::TcpHeader ","date":"2024-02-17","objectID":"/posts/rust-tcp/:2:3","tags":["Rust","TCP","Network"],"title":"Implementing TCP/IP in Rust","uri":"/posts/rust-tcp/"},{"categories":["Rust"],"content":"References https://datatracker.ietf.org/doc/html/rfc793 https://datatracker.ietf.org/doc/html/rfc1122 https://datatracker.ietf.org/doc/html/rfc7414#section-2 https://datatracker.ietf.org/doc/html/rfc2398 https://datatracker.ietf.org/doc/html/rfc2525 https://datatracker.ietf.org/doc/html/rfc791 注意 RFC 793 描述了原始的 TCP 协议的内容 RFC 1122 则是对原始的 TCP 功能的一些扩展进行说明 RFC 7414 的 Section 2 则对 TCP 的核心功能进行了简要描述 RFC 2398 描述了对实现的 TCP 的一些测试方法和工具 RFC 2525 说明了在实现 TCP 过程中可能会出现的错误，并指出可能导致错误的潜在问题 RFC 791 描述了 IP 协议 ","date":"2024-02-17","objectID":"/posts/rust-tcp/:3:0","tags":["Rust","TCP","Network"],"title":"Implementing TCP/IP in Rust","uri":"/posts/rust-tcp/"},{"categories":["Linux Kernel Internals"],"content":"Source ","date":"2024-02-16","objectID":"/posts/linux-quiz1/:0:0","tags":["Sysprog","Linux","C"],"title":"Linux 核心设计: 第 1 周测验题","uri":"/posts/linux-quiz1/"},{"categories":["Linux Kernel Internals"],"content":"2018q1 第 4 週測驗題 ","date":"2024-02-16","objectID":"/posts/linux-quiz1/:1:0","tags":["Sysprog","Linux","C"],"title":"Linux 核心设计: 第 1 周测验题","uri":"/posts/linux-quiz1/"},{"categories":["Linux Kernel Internals"],"content":"测验 1 FuncA 的作用是 (e) 建立新節點，內容是 value，並安插在結尾 FuncB 的作用是 (d) 建立新節點，內容是 value，並安插在開頭 FuncC 的作用是 (e) 找到節點內容為 value2 的節點，並在之後插入新節點，內容為 value1 在 main 函数调用 display 函数之前，链表分布为: 48 -\u003e 51 -\u003e 63 -\u003e 72 -\u003e 86 在程式輸出中，訊息 Traversal in forward direction 後依序印出哪幾個數字呢？ (d) 48 (c) 51 (a) 63 (e) 72 (b) 86 在程式輸出中，訊息 Traversal in reverse direction 後依序印出哪幾個數字呢？ (b) 86 (e) 72 (a) 63 (c) 51 (d) 48 技巧 延伸題目： 在上述 doubly-linked list 實作氣泡排序和合併排序，並提出需要額外實作哪些函示才足以達成目標 引入統計模型，隨機新增和刪除節點，然後評估上述合併排序程式的時間複雜度和效能分佈 (需要製圖和數學分析) ","date":"2024-02-16","objectID":"/posts/linux-quiz1/:1:1","tags":["Sysprog","Linux","C"],"title":"Linux 核心设计: 第 1 周测验题","uri":"/posts/linux-quiz1/"},{"categories":["Linux Kernel Internals"],"content":"测验 2 FuncX 的作用是 (涵蓋程式執行行為的正確描述最多者) (f) 判斷是否為 circular linked list，若為 circular 則回傳 0，其他非零值，過程中計算走訪的節點總數 K1 » 後面接的輸出為何 (b) Yes K2 » 後面接的輸出為何 (a) No K3 » 後面接的輸出為何 (a) No K4 » 後面接的輸出為何 (a) No K5 » 後面接的輸出為何 (f) 0 count » 後面接的輸出為何 (f) 0 ","date":"2024-02-16","objectID":"/posts/linux-quiz1/:1:2","tags":["Sysprog","Linux","C"],"title":"Linux 核心设计: 第 1 周测验题","uri":"/posts/linux-quiz1/"},{"categories":["Linux Kernel Internals"],"content":" 面對原始程式碼超越 3 千萬行規模的 Linux 核心 (2023 年)，最令人感到挫折的，絕非缺乏程式註解，而是就算見到滿滿的註解，自己卻有如文盲，全然無從理解起。為什麼呢？往往是因為對作業系統的認知太侷限。 原文地址 ","date":"2024-02-15","objectID":"/posts/linux-concepts/:0:0","tags":["Sysprog","Linux"],"title":"Linux 核心设计: 操作系统术语及概念","uri":"/posts/linux-concepts/"},{"categories":["Linux Kernel Internals"],"content":"Linux 核心发展 虚拟化 (Virtualization) 技术分为 CPU 层级的虚拟化技术，例如 KVM 和 RVM，也有操作系统层级的虚拟化技术，例如 Docker。 Plan 9 from Bell Labs [Wikipedia] LXC [Wikipedia] 信息 從 Revolution OS 看作業系統生態變化 Linux 核心設計: 透過 eBPF 觀察作業系統行為 ","date":"2024-02-15","objectID":"/posts/linux-concepts/:1:0","tags":["Sysprog","Linux"],"title":"Linux 核心设计: 操作系统术语及概念","uri":"/posts/linux-concepts/"},{"categories":["Linux Kernel Internals"],"content":"看漫画学 Linux 原文地址 inside the linux kernel 整理上图，可以得到 自底向上 的 Linux 系统结构: 地下层: 文件系统 (File System) 中央大厅层: 进程表 (process table) 内存管理 (memory management) 信息安全 (security) 看门狗 (watchdog) httpd cron 管道 (pipe) FTP SSH Wine GNOME 最上层 tty / terminal wiki: Pipeline (Unix) [Wikipedia] Process identifier [Wikipedia] watchdog [Linux man page] init [Wikipedia] systemd [Wikipedia] fork [Linux man page] clone [Linux man page] Project Genie [Wikipedia] posix_spawn [Linux man page] Native POSIX Thread Library [Wikipedia] 极客漫画: 不要使用 SIGKILL 的原因 wait [Linux man page] signal [Linux man page] TUX web server [Wikipedia] -[x] cron 技巧 Multics 采用了当时背景下的几乎所有的先进技术，可以参考该系统获取系统领域的灵感。 虚拟内存管理与现代银行的运行逻辑类似，通过 malloc 分配的有效虚拟地址并不能保证真正可用，类似于支票得去银行兑现时才知道银行真正的现金储备。但是根据统计学公式，虚拟地址和银行现金可以保证在大部分情况下，都可以满足需求，当然突发的大规模虚拟内存使用、现金兑现时就无法保证了。这部分的原理推导需要学习概率论、统计学等数理课程。 信息 Linux 核心设计: Linux 核心設計: 檔案系統概念及實作手法 Linux 核心設計: 不僅是個執行單元的 Process Linux 核心設計: 不只挑選任務的排程器 UNIX 作業系統 fork/exec 系統呼叫的前世今生 Linux 核心設計: 記憶體管理 Linux 核心設計: 發展動態回顧 Linux 核心設計: 針對事件驅動的 I/O 模型演化 Linux 核心設計: Scalability 議題 Effective System Call Aggregation (ESCA) 你所不知道的 C 語言: Stream I/O, EOF 和例外處理 Unix-like 工具使用技巧: Mastering UNIX pipes, Part 1 Mastering UNIX pipes, Part 2 ","date":"2024-02-15","objectID":"/posts/linux-concepts/:2:0","tags":["Sysprog","Linux"],"title":"Linux 核心设计: 操作系统术语及概念","uri":"/posts/linux-concepts/"},{"categories":["Linux Kernel Internals"],"content":"高阶观点 投影片: Linux Kernel: Introduction ✅ 对投影片的 重点描述 一些概念理解: 1963 Timesharing: A Solution to Computer Bottlenecks [YouTube] Supervisory program [Wikipedia] ","date":"2024-02-15","objectID":"/posts/linux-concepts/:3:0","tags":["Sysprog","Linux"],"title":"Linux 核心设计: 操作系统术语及概念","uri":"/posts/linux-concepts/"},{"categories":["Linux Kernel Internals"],"content":"虚拟化 MicroVM 和 Unikernel 都是使用 CPU 层级的虚拟化技术，在 Host OS 上面构建的 GuestOS: MicroVM 会减少硬件驱动方面的初始化，从而加快启动和服务速度 (在云服务器方面很常见，服务器端并不需要进行硬件驱动)。 Unikernel 则更激进，将 programs 和 kernel 一起进行动态编译，并且限制只能运行一个 process (例如只运行一个数据库进程，这样云服务器很常见)，这样就减少了一些系统调用的呼叫，例如 fork (因为只能运行一个 process)，提升了安全性 (因为 fork 系统调用可能会造成一些漏洞)。Unikernel 又叫 Library OS，可以理解为分时多人多工操作系统的另一个对立面，拥有极高的运行速度 (因为只有一个 process)。 Container Sandbox 使用的是 OS 层级的虚拟化技术，即它是将一组进程隔离起来构建为容器，这样可能会导致这一组进程就耗尽了系统的资源，其他进程无法使用系统的资源。同时因为是进程级的隔离，所以安全性不及 CPU 层级的 MicroVM 和 Unikernel。 信息 相关演讲、录影: YouTube: Inside the Mac OS X Kernel YouTube: What Are MicroVMs? And Why Should I Care? YouTube: From the Ground Up: How We Built the Nanos Unikernel 相关论文阅读: ","date":"2024-02-15","objectID":"/posts/linux-concepts/:3:1","tags":["Sysprog","Linux"],"title":"Linux 核心设计: 操作系统术语及概念","uri":"/posts/linux-concepts/"},{"categories":["Linux Kernel Internals"],"content":"Scalability Wikipedia: scalability A system whose performance improves after adding hardware, proportionally to the capacity added, is said to be a scalable system. lock-free sequence lock RCU algorithm complexity ","date":"2024-02-15","objectID":"/posts/linux-concepts/:3:2","tags":["Sysprog","Linux"],"title":"Linux 核心设计: 操作系统术语及概念","uri":"/posts/linux-concepts/"},{"categories":["Linux Kernel Internals"],"content":"细节切入点 CPU 和 OS 的基本概念科普网站: Putting the “You” in CPU 相当于科普版 CSAPP 技巧 UNSW COMP9242: Advanced Operating Systems (2023/T3) 这门课可以作为辅助材料，讲得深入浅出，可以作为进阶材料阅读。 ","date":"2024-02-15","objectID":"/posts/linux-concepts/:4:0","tags":["Sysprog","Linux"],"title":"Linux 核心设计: 操作系统术语及概念","uri":"/posts/linux-concepts/"},{"categories":["Rust"],"content":" In this third Crust of Rust video, we cover iterators and trait bounds, by re-implementing the “flatten” Iterator method from the standard library. As part of that, we cover some of the weirder trait bounds that are required, including what’s needed to extend the implementation to support backwards iteration. 整理自 John Gjengset 的影片 ","date":"2024-02-05","objectID":"/posts/iterators/:0:0","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"影片注解 ","date":"2024-02-05","objectID":"/posts/iterators/:1:0","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"Generic traits vs associated types trait Iterator { type Item; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e; } trait Iterator\u003cItem\u003e { fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e; } 为什么使用上面的 associated type 而不是下面的 generic 来实现 Iterator？因为使用 generic 来实现的话，可以对一个类型实现多个 Iterator trait 例如 Iterator\u003ci32\u003e, Iterator\u003cf64，而从语言表达上讲，我们希望一个类型只能实现一个 Iterator trait，所以使用 associated type 来实现 Iterator trait，防止二义性。 for v in vs.iter() { // borrow vs, \u0026 to v } for v in \u0026vs { // equivalent to vs.iter() } 这两条 for 语句虽然效果一样，但是后者是使用 \u003c\u0026vs\u003e into_iter 讲 \u0026vs 转为 iterator，而不是调用 iter() 方法。 ","date":"2024-02-05","objectID":"/posts/iterators/:1:1","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"Iterator::flatten method std::iter::Iterator::flatten Creates an iterator that flattens nested structure. This is useful when you have an iterator of iterators or an iterator of things that can be turned into iterators and you want to remove one level of indirection. flatten() 的本质是将一种 Iterator 类型转换成另一种 Iterator 类型，所以调用者和返回值 Flatten 都满足 trait Iterator，因为都是迭代器，只是将原先的 n-level 压扁为 1-level 的 Iterator 了。录影视频里只考虑 2-level 的情况。 ","date":"2024-02-05","objectID":"/posts/iterators/:1:2","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"DoubleEndedIterator Trait std::iter::DoubleEndedIterator It is important to note that both back and forth work on the same range, and do not cross: iteration is over when they meet in the middle. 也就是说，back 和 front 的迭代器类似于双指针，但是这两个迭代器并不会越过对方。 ","date":"2024-02-05","objectID":"/posts/iterators/:1:3","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"Homework 信息 实作说明: 尝试实现 Iterator 的 flat_map 方法 参考资料: method std::iter::Iterator::flat_map struct std::iter::FlatMap ","date":"2024-02-05","objectID":"/posts/iterators/:2:0","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"Documentations 这里列举视频中一些概念相关的 documentation 学习的一手资料是官方文档，请务必自主学会阅读规格书之类的资料 ","date":"2024-02-05","objectID":"/posts/iterators/:3:0","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"Crate std 可以使用这里提供的搜素栏进行搜索 (BTW 不要浪费时间在 Google 搜寻上！) Trait std::iter::Iterator method std::iter::Iterator::flatten method std::iter::Iterator::rev method std::iter::Iterator::flat_map Trait std::iter::IntoIterator Struct std::iter::Flatten function std::iter::empty function std::iter::once Trait std::iter::DoubleEndedIterator Enum std::option::Option method std::option::Option::and_then method std::option::Option::as_mut Trait std::marker::Sized ","date":"2024-02-05","objectID":"/posts/iterators/:4:0","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"References What is the difference between iter and into_iter? [Stack Overflow] ","date":"2024-02-05","objectID":"/posts/iterators/:5:0","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Linux Kernel Internals"],"content":" 无论是操作系统核心、C 语言函数库内部、程序开发框架，到应用程序，都不难见到 linked list 的身影，包含多种针对性能和安全议题所做的 linked list 变形，又还要考虑应用程序的泛用性 (generic programming)，是很好的进阶题材。 原文地址 ","date":"2024-02-03","objectID":"/posts/c-linked-list/:0:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: linked list 和非连续内存","uri":"/posts/c-linked-list/"},{"categories":["Linux Kernel Internals"],"content":"Linux 核心的艺术 The mind behind Linux | Linus Torvalds | TED [YouTube] 事实上 special case 和 indirect pointer 这两种写法在 clang 的最佳优化下效能并没有什么区别，我们可以不使用 indirect pointer 来写程序，但是我们需要学习 indirect pointer 这种思维方式，即 good taste。 把握程序的本质，即本质上是修改指针的值，所以可以使用指针的指针来实现，无需进行特判。 在 Unix-like 的操作系统中，类型名带有后缀 _t 表示这个类型是由 typedef 定义的，而不是语言原生的类型名，e.g. typedef struct list_entry { int value; struct list_entry *next; } list_entry_t; ","date":"2024-02-03","objectID":"/posts/c-linked-list/:1:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: linked list 和非连续内存","uri":"/posts/c-linked-list/"},{"categories":["Linux Kernel Internals"],"content":"linked list append \u0026 remove Source 信息 The mind behind Linux Linus on Understanding Pointers ","date":"2024-02-03","objectID":"/posts/c-linked-list/:1:1","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: linked list 和非连续内存","uri":"/posts/c-linked-list/"},{"categories":["Linux Kernel Internals"],"content":"LeetCode Source LeetCode 21. Merge Two Sorted Lists LeetCode 23. Merge k Sorted Lists Leetcode 2095. Delete the Middle Node of a Linked List LeetCode 86. Partition List 注意 原文对于 LeetCode 23. Merge k Sorted Lists 给出了 3 种解法，其时间复杂度分别为： $O(m \\cdot n)$ $O(m \\cdot n)$ $O(m \\cdot logn)$ $n$ 为 listsSize，$m$ 为 merge linked list 过程中产生的 linked list 的最大长度。 如果你对第 3 种解法的时间复杂度感到疑惑，请参考 Josh Hug 在 CS61B 的 Merge Sort 复杂度讲解。 ","date":"2024-02-03","objectID":"/posts/c-linked-list/:1:2","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: linked list 和非连续内存","uri":"/posts/c-linked-list/"},{"categories":["Linux Kernel Internals"],"content":"Circular linked list 单向 linked list 相对于双向 linked list 的优势在于，一个 cache line 可以容纳更多的 list node，而且很容易进行反向查询，这弥补了反向查询时的效能差距。例如在 64 位处理器上，地址为 64 Bit 即 8 Byte，如果 list node 的数据域存放一个 2 Byte 的整数，那么一个单向的 list node 大小为 10 Byte，双向的则为 18 Byte，又因为一般的 cache line 的大小为 64 Byte，则对于单向的 node 来说，cache line 可以存放 $64 / 10 = 6$ 个 list node，但是仅能存放 $64 / 18 = 3$ 个 list node，cache 效率明显降低。 这部分内容可以参考 jserv 的讲座 \u003c現代處理器設計: Cache 原理和實際影響\u003e ","date":"2024-02-03","objectID":"/posts/c-linked-list/:2:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: linked list 和非连续内存","uri":"/posts/c-linked-list/"},{"categories":["Linux Kernel Internals"],"content":"Floyd’s Cycle detection 这个“龟兔赛跑”算法保证兔子在跑两次循环圈后，一定会和刚完成一次循环圈的乌龟相遇。因为已知乌龟每次移动一步，兔子每次移动两步，可以假设在相遇点处乌龟移动的 $X$ 步，则兔子移动了 $2X$ 步，$2X$ 必为偶数，所以兔子必能在移动了 $2X$ 步后与乌龟相遇，不会出现兔子因为每次移动两步而刚好越过乌龟一步的情况。 $\\lambda$ is the length of the loop to be found, $\\mu$ is the index of the first element of the cycle. Source LeetCode 141. Linked List Cycle LeetCode 142. Linked List Cycle II LeetCode 146. LRU Cache 金刀的算法小册子 Linked List 专题 LeetCode 206. Reverse Linked List 信息 探索 Floyd Cycle Detection Algorithm ","date":"2024-02-03","objectID":"/posts/c-linked-list/:2:1","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: linked list 和非连续内存","uri":"/posts/c-linked-list/"},{"categories":["Linux Kernel Internals"],"content":"Merge Sort 实现了 recursion, non-recursion 的 merge sort Source 信息 Merge Sort 与它的变化 ","date":"2024-02-03","objectID":"/posts/c-linked-list/:3:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: linked list 和非连续内存","uri":"/posts/c-linked-list/"},{"categories":["Linux Kernel Internals"],"content":"Linux 核心的 linked list Linux 核心使用的 linked list 是通过 Intrusive linked lists 搭配 contain_of 宏，来实现自定义的 linked list node，具有强大的灵活性。 非递归的快速排序中 if (L != R \u0026\u0026 \u0026begin[i]-\u003elist != head) { 其中的 \u0026begin[i]-\u003elist != head 条件判断用于空链表情况，数组版本中使用的是下标比较 L \u003c R 来判断，但是链表中使用 L != R 不足以完全表示 L \u003c R 这个条件，还需要 \u0026begin[i]-\u003elist != head 来判断链表是否为空。 WRITE_ONCE 的原理简单来说是，通过 union 产生两个引用同一地址的引用 (即 __val 和 __c)，然后因为对同一地址有多个引用，所以编译器进行最佳化时不会过于激进的重排序，从而达到顺序执行效果。 Source Intrusive linked lists 这篇文章对于 Intrusive linked list 说明的非常好，解释了其在 memory allocations 和 cache thrashing 的优势，还搭配 Linux kernel 讲解了场景应用。 Linux 核心原始程式碼巨集: container_of sysprog21/linux-list 这个仓库将 Linux kernel 中 linked list 部分抽离出来，并改写为 user mode 的实作。本人对该仓库进行了一些改写，对 insert sort 和 quick sort 增加了 makefile 支持。 Optimized QuickSort: C Implementation (Non-Recursive) 这篇文章介绍了 non-recursion 的 quick sort 在 array 上的实作，参考该文章完成 linked list 上的 non-recursion 的 quick sort 实作。 ","date":"2024-02-03","objectID":"/posts/c-linked-list/:4:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: linked list 和非连续内存","uri":"/posts/c-linked-list/"},{"categories":["Linux Kernel Internals"],"content":"Linux 核心的 list_sort 实作 linux/list_sort.c 先将双向循环链表转换成单向链表，然后利用链表节点的 prev 来挂载 pending list (因为单向链表中 prev 没有作用，但是链表节点仍然存在 prev 字段，所以进行充分利用)。 假设 count 对应的 bits 第 k 个 bit 值为 0 且 $\u003e k$ 的 bits 都为 0，$\u003c k$ 的 bits 都为 1，则 $\u003c k $ 的这些 1 可以表示 pending list 中分别有 $2^{k-1}, 2^{k-2}, …, 2^0$ 大小的 list 各一个。 如果第 k 个 bit 值为 0 且 $\u003e k$ 的 bits 中存在值为 1 的 bit，$\u003c k$ 的 bits 均为 1，则只有 $\u003c k$ 的 bits 可以表示 pending list 中分别有 $2^{k-1}, 2^{k-2}, …, 2^0$ 大小的 list 各一个，\u003e k 的 1 表示需要进行 merge 以获得对应大小的 list。 这样也刚好能使得 merge 时是 $2: 1$ 的长度比例，因为 2 的指数之间的比例是 $2: 1$。 信息 List, HList, and Hash Table hash table What is the strict aliasing rule? [Stack Overflow] Unions and type-punning [Stack Overflow] Nine ways to break your systems code using volatile [Stack Overflow] WRITE_ONCE in linux kernel lists [Stack Overflow] lib/list_sort: Optimize number of calls to comparison function ","date":"2024-02-03","objectID":"/posts/c-linked-list/:4:1","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: linked list 和非连续内存","uri":"/posts/c-linked-list/"},{"categories":["Linux Kernel Internals"],"content":"Fisher–Yates shuffle","date":"2024-02-03","objectID":"/posts/c-linked-list/:5:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: linked list 和非连续内存","uri":"/posts/c-linked-list/"},{"categories":["Rust"],"content":" In this second Crust of Rust video, we cover declarative macros, macro_rules!, by re-implementing the vec! macro from the standard library. As part of that, we cover not only how to write these, but some of the gotchas and tricks you’ll run into, and some common use-cases. 整理自 John Gjengset 的影片 ","date":"2024-01-31","objectID":"/posts/declarative-macros/:0:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"影片注解 ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"regex macro 可以使用以下 3 种分隔符来传入参数 (注意花括号 {} 的需要与 macro 名之间进行空格，末尾不需要分号，这是因为 {} 会被编译器视为一个 statement，无需使用 ; 来进行分隔): macro_rules! avec { () =\u003e {}; ... } avec!(); avec![]; avec! {} macro 定义内的 () 和 {} 也都可以使用 (), [], {} 之间的任意一种，并不影响调研 macro 的分隔符的使用（都是 3 任选 1 即可），不过推荐在 macro 定义内使用 () 和 {} 搭配。 如果需要在 macro 传入的 synatx 中使用正则表达式 (regex)，则需要在外面使用 $() 进行包装: ($($elem:expr),* $(,)?) =\u003e {{ let mut v = Vec::new(); $(v.push($elem);)* v }}; 同样的，可以在 macro 体内使用 regex 对参数进行解包装，语法是相同的： $(...)[delimiter](+|*|?) 其中分隔符 (delimiter) 是可选的。它会根据内部所包含的参数 $(...) (本例中是 $(elem)) 来进行自动解包装，生成对应次数的 statement，如果有分隔符 (delimiter) 也会生成对应的符号。 ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:1","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"cargo expand cargo-expand 可以将宏展开，对于宏的除错非常方便，可以以下命令来安装: $ cargo install cargo-expand 然后可以通过以下命令对 macro 进行展开: $ cargo expand 使用以下命令可以将 unit tests 与 cargo expand 结合起来，即展开的是 unit tests 之后的完整代码: $ cargo expand --lib tests ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:2","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"scope 由于 Rust 中 macro 和 normal code 的作用域不一致，所以像 C 语言那种在 macro 中定义变量或在 macro 中直接修改已有变量是不可行的，操作这种 lvalue 的情况需要使用 macro 参数进行传入，否则无法通过编译。 // cannot compile macro_rules! avec { () =\u003e { let x = 1; } } // cannot compile macro_rules! avec { () =\u003e { x = 42; } } // can compile macro_rules! avec { ($x: ident) =\u003e { $x += 1; } } ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:3","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"statements 在 Rust macro 中，如果需要将传入的 syntax 转换成多个 statements，需要使用 {} 进行包装: () =\u003e {{ ... }} 其中第一对 {} 是 macro 语法所要求的的，第二对 {} 则是用于包装 statements 的 {}，使用 cargo expand 进行查看会更直观。 ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:4","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"delimiter 注意 macro 中传入的 syntax，其使用的类似于 =\u003e 的分隔符是有限的，例如不能使用 -\u003e 作为分隔符，具体可以查阅手册。 ($arg1:ty =\u003e $arg2:ident) =\u003e { type $arg2 = $arg1; }; 技巧 当 declarative macros 变得复杂时，它的可读性会变得很差，这时候需要使用 procedural macros。但是 procedural macros 需要多花费一些编译周期 (compilition cycle)，因为需要先对 procedural macros 进行编译，再编译 lib/bin 对应的源文件。 ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:5","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"calculating 编写 macro 时传入的参数如果是 expression，需要先对其进行计算，然后使用 clone 方法来对该计算结果进行拷贝，这样能最大限度的避免打破 Rust 所有权制度的限制。 ($elem:expr; $count:expr) =\u003e {{ let mut v = Vec::new(); let x = $elem; for _ in 0..$count { v.push(x.clone()); } v }}; 这样传入 y.take().unwrap() 作为宏的 elem 参数就不会产生 panic。 技巧 对于会导致 compile fail 的 unit test，无法使用通常的 unit test 来测试，但是有一个技巧：可以使用 Doc-tests 的方式来构建（需要标记 compile_fail，如果不标记则默认该测试需要 compile success） /// ```compile_fail /// let v: Vec\u003cu32\u003e = vecmac::avec![42; \"foo\"]; /// ``` #[allow(dead_code)] struct CompileFailTest; ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:6","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"trait Rust 中的 macro 无法限制传入参数的 Trait，例如不能限制参数必须实现 Clone 这个 Trait。 ::std::iter 带有前置双冒号 :: 的语法，是在没有显式引入 use std::iter 模块的情况下访问该模块的方式。在这种情况下，::std::iter 表示全局命名空间 (global namespace) 中的 std::iter 模块，即标准库中的 iter 模块。由于 macro 需要进行 export 建议编写 macro 时尽量使用 :: 这类语法。 技巧 计算 vector 的元素个数时使用 () 引用 [()] 进行计数是一个常见技巧，因为 () 是 zero size 的，所以并不会占用栈空间。其他的元素计数方法可以参考 The Little Book of Rust Macros 的 2.5.2 Counting 一节。 ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:7","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"Homework 信息 实作说明: 尝试使用 declarative macro 来实现 HashMap 的初始化语法 (Github: My Implementation) 尝试阅读 vec macro 在 std 库的实现 Macro std::vec 参考资料: Struct std::collections::HashMap ","date":"2024-01-31","objectID":"/posts/declarative-macros/:2:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"Documentations 这里列举视频中一些概念相关的 documentation 学习的一手资料是官方文档，请务必自主学会阅读规格书之类的资料 ","date":"2024-01-31","objectID":"/posts/declarative-macros/:3:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"Crate std 可以使用这里提供的搜素栏进行搜索 (BTW 不要浪费时间在 Google 搜寻上！) Macro std::vec Struct std::vec::Vec Method std::vec::Vec::with_capacity method std::vec::Vec::extend method std::vec::Vec::resize Module std::iter Function std::iter::repeat method std::iter::Iterator::take method std::option::Option::take ","date":"2024-01-31","objectID":"/posts/declarative-macros/:4:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"References 原版的 The Little Book of Rust Macros 在 Rust 更新新版本后没有持续更新，另一位大牛对这本小册子进行了相应的更新: The Little Book of Rust Macros Rust语言中文社区也翻译了该小册子: Rust 宏小册 ","date":"2024-01-31","objectID":"/posts/declarative-macros/:5:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":" We’re going to investigate a case where you need multiple explicit lifetime annotations. We explore why they are needed, and why we need more than one in this particular case. We also talk about some of the differences between the string types and introduce generics over a self-defined trait in the process. 整理自 John Gjengset 的影片 ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:0:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"C 语言中的 lifetime Rust 中的 lifetime 一向是一个难点，为了更好地理解这一难点的本质，建议阅读 C 语言规格书关于 lifetime 的部分，相信你会对 Rust 的 lifetime 有不同的看法。 C11 [6.2.4] Storage durations of objects An object has a storage duration that determines its lifetime. There are four storage durations: static, thread, automatic, and allocated. ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:1:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"影片注解 cargo check 可以给出更简洁的提示，例如相对于编译器给出的错误信息，它会整合相同的错误信息，从而提供简洁切要的提示信息。而且它是一个静态分析工具，不需要进行编译即可给出提示，所以速度会比编译快很多，在大型项目上尤为明显。 影片大概 49 分时提到了 if let Some(ref mut remainder) = self.remainder {...} ref 的作用配合 if let 语句体的逻辑可以体会到 pointer of pointer 的美妙之处。 因为在 pattern match 中形如 \u0026mut 这类也是用于 pattern match 的，不能用于获取 reference，这也是为什么需要使用 ref mut 这类语法来获取 reference 的原因。 影片大概 56 分时提到了 let remainder = self.remainder.as_mut()?; 为什么使用之前所提的 let remainder = \u0026mut self.remainder?; 这是因为使用 ? 运算符返回的是内部值的 copy，所以这种情况 remainder 里是 self.remainder? 返回的值 (是原有 self.remainder 内部值的 copy) 的 reference 影片大概 1:03 时提到了 str 与 String 的区别，个人觉得讲的很好： str -\u003e [char] \u0026str -\u003e \u0026[char] // fat pointer (address and size) String -\u003e Vec\u003cchar\u003e String -\u003e \u0026str (cheap -- AsRef) \u0026str -\u003e String (expensive -- memcpy) 可以将结构体的 lifetime 的第一个 (一般为 'a) 视为实例的 lifetime，其它的可以表示与实例 lifetime 无关的 lifetime。由于 compiler 不够智能，所以它会将实例化时传入参数的 lifetime 中相关联的最小 lifetime 视为实例的 lifetime 约束 (即实例的 lifetime 包含于该 lifetime 内)。 对于 String 使用 \u0026* 可以保证将其转换成 \u0026str，因为 * 会先将 String 转换成 str。当然对于函数参数的 \u0026str，只需传入 \u0026String 即可自动转换类型。 ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:2:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"Documentations 这里列举视频中一些概念相关的 documentation 学习的一手资料是官方文档，请务必自主学会阅读规格书之类的资料 ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:3:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"Crate std 可以使用这里提供的搜素栏进行搜索 (BTW 不要浪费时间在 Google 搜寻上！) Keywords Keyword SelfTy Keyword ref Trait std::iter::Iterator method std::iter::Iterator::eq method std::iter::Iterator::collect method std::iter::Iterator::position method std::iter::Iterator::find Enum std::option::Option method std::option::Option::take method std::option::Option::as_mut method std::option::Option::expect Primitive Type str method str::find method str::char_indices Trait std::ops::Try Macro std::try method char::len_utf8 ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:4:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Linux Distribution"],"content":"记录一下折腾 Deepin 20.9 的物理机的过程与相关的配置。 ","date":"2024-01-24","objectID":"/posts/deepin20.9/:0:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"安装与配置 新手教学影片： 深度操作系统deepin下载安装 (附双系统安装及分区指引) [bilibili] 安装完deepin之后该做的事情 [bilibili] ","date":"2024-01-24","objectID":"/posts/deepin20.9/:1:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"网络代理 新手教学文档: Ubuntu 22.04LTS 相关配置 在境内可以使用 gitclone.com 来加速 clone 的速度。 ","date":"2024-01-24","objectID":"/posts/deepin20.9/:2:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"编辑器: VS Code 新手教学文档: 编辑器: Visual Studio Code [HackMD] 本人的一些注解: GNU/Linux 开发工具 这里列举一下本人配置的插件： Even Better TOML CodeLLDB 用于调试 Rust Git History Native Debug 用于调试 C/C++ rust-analyzer Tokyo Night 挺好看的一个主题 Vim VSCode Great Icons 文件图标主题 ","date":"2024-01-24","objectID":"/posts/deepin20.9/:3:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"终端和 Vim 新手教学文档: 終端機和 Vim 設定 [HackMD] 本人的一些注解: GNU/Linux 开发工具 本人的终端提示符配置: \\u@\\h\\W 本人使用 Minimalist Vim Plugin Manager 来管理 Vim 插件，配置如下: \" Specify a directory for plugins (for Neovim: ~/.local/share/nvim/plugged) call plug#begin('~/.vim/plugged') Plug 'Shougo/neocomplcache' Plug 'scrooloose/nerdtree' map \u003cF5\u003e :NERDTreeToggle\u003cCR\u003e call plug#end() let g:neocomplcache_enable_at_startup = 1 let g:neocomplcache_enable_smart_case = 1 inoremap \u003cexpr\u003e\u003cTAB\u003e pumvisible()?\"\\\u003cC-n\u003e\" : \"\\\u003cTAB\u003e\" syntax on set number set cursorline colorscheme default set bg=dark set tabstop=4 set expandtab set shiftwidth=4 set ai set hlsearch set smartindent map \u003cF4\u003e : set nu!\u003cBAR\u003eset nonu?\u003cCR\u003e \" autocomplete dropdown list colorscheme hi Pmenu ctermfg=0 ctermbg=7 hi PmenuSel ctermfg=7 ctermbg=4 ","date":"2024-01-24","objectID":"/posts/deepin20.9/:4:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"系统语言: Rust 安装教程: Installation [The book] 安装 Rust [Rust course] Channels [The rustup book] # install rust $ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh # install nightly toolchain $ rustup toolchain install nightly # change to nightly toolchain $ rustup default nightly # list installed toolchain $ rustup toolchain list # update installed toolchain $ rustup update 个人偏向于使用 nightly toolchain ","date":"2024-01-24","objectID":"/posts/deepin20.9/:5:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"效果展示 Deepin Terminial Vim Deepin DDE Desktop ","date":"2024-01-24","objectID":"/posts/deepin20.9/:6:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"FAQ 问题 重启后可能会出现，输入密码无法进入图形界面重新返回登录界面，这一循环状况。这个是 deepin 的默认 shell 是 dash 造成的，只需将默认的 shell 改为 bash 即可解决问题： $ ls -l /bin/sh lrwxrwxrwx 1 root root 9 xx月 xx xx:xx /bin/sh -\u003e /bin/dash $ sudo rm /bin/sh $ sudo ln -s /bin/bash /bin/sh 如果你已经处于无限登录界面循环这一状况，可以通过 Ctrl + Alt + \u003cF2\u003e 进入 tty2 界面进行修改： # 先查看问题日志，判断是不是 shell 导致的问题 $ cat .xsession-errors # 如果是，则重复上面的操作即可 ","date":"2024-01-24","objectID":"/posts/deepin20.9/:7:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"在 deepin 20.9 上根据 DragonOS 构建文档 的 bootstrap.sh 的方式来构建 DragonOS 时，如果没有事先安装 Qemu 会出现 KVM 相关的依赖问题。本文记录解决这一问题的过程。 如果事先没有安装 Qemu，在使用 bootstrap.sh 时会出现如下报错： $ bash bootstrap.sh ... 下列软件包有未满足的依赖关系： qemu-kvm : 依赖: qemu-system-x86 E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。 查询 deepin 论坛上的相关内容：qemu-kvm无法安装，可以得知是因为 qemu-kvm 在 debian 发行版上只是一个虚包，所以对于 x86 架构的机器可以直接安装 qemu-systerm-x86 Debian qemu-kvm https://packages.debian.org/search?keywords=qemu-kvm 安装 qemu-systerm-x86: $ sudo apt install qemu-systerm-x86 $ $ qemu-system-x86_64 --version QEMU emulator version 5.2.0 (Debian 1:5.2+dfsg-11+deb11u1) Copyright (c) 2003-2020 Fabrice Bellard and the QEMU Project developers 安装的 qemu 版本看起来有点低，但是先使用 bootstrap.sh 快速安装其它依赖项，然后尝试编译运行一下 DragonOS: $ bash bootstrap.sh ... |-----------Congratulations!---------------| | | | 你成功安装了DragonOS所需的依赖项! | | | | 请关闭当前终端, 并重新打开一个终端 | | 然后通过以下命令运行: | | | | make run | | | |------------------------------------------| 新开一个终端或刷新一下 ~/.bashrc: $ cd DragonOS $ make run 运行 DragonOS Ok 可以成功运行 注意 如果需要使用 RISC-V 的 Qemu 模拟器，安装 qemu-system-misc 即可： $ sudo apt install qemu-system-misc ","date":"2024-01-22","objectID":"/posts/deepin-dragonos/:0:0","tags":["Deepin","Linux","DragonOS"],"title":"在 Deepin 20.9 上构建 DragonOS","uri":"/posts/deepin-dragonos/"},{"categories":["Mathematics"],"content":"随机变量 (Random Variable) 是概率 (Probability) 和统计 (Statistics) 的“灵魂”，从数学上讲，Random Variable 是连接 Probability 和 Statistics 的桥梁；从实际上讲，Random Variable 表示我们所关心、期望的东西。例如一批产品的硬度，每个产品的硬度显然是不同的、是随机的，尽管硬度是随机的，但产品的硬度遵循一定的概率规律，这种随机、但却遵循一定概率规律的东西，就是 Random Value。 学习一门课，要学习其“精神”，而不是学习其方法。 ","date":"2024-01-20","objectID":"/posts/nycu-statistics/:0:0","tags":["Mathematics","Statistics","Probility","Random Variable"],"title":"交大统计学 重点提示","uri":"/posts/nycu-statistics/"},{"categories":["Mathematics"],"content":"Concepts 引用 Sample space $S$: Set of possible outcomes of a random experiment. Every subset of $S$ is an event. Random experiment 是一种特殊的实验。物理实验、化学实验在相同的条件下所产生的结果是相同的，但 Random experiment 不同，在相同的条件下，每次实验的结果是随机的。但 Random experiment 结果的情况是有限的，所有实验结果的集合就称为 Sample space。 引用 Probability set function $P$ on subset of $S$ satisfies: $P(A) \\geq 0$ $P(S) = 1$ $P(\\bigcup\\limits_{k=1}^{\\infty} A_k) = \\sum\\limits_{k=1}^{\\infty} A_k\\ \\ \\ if A_i \\bigcap A_j = \\emptyset\\ for\\ all\\ i \\neq j$ A random variable $X$ is a real-valued function define on $S$. $$ X:\\ S \\rightarrow R\\ \\ \\ or \\ \\ \\ S \\xrightarrow{X} R $$ set function 是对 set 进行映射的 function，所以 $P$ 是 subset of $S$ 到实数的映射关系，通过 $P$ 可以计算 event 对应的概率值。 Probability set function $P$ 有 3 个符合直觉的基本准则，我们可以从这 3 个准则可以推导出其它符合直觉的性质: $$ \\forall A \\subset S \\implies \\begin{cases} P(\\emptyset) \u0026= 0 \\\\ P(A^{C}) \u0026= 1 - p \\end{cases} $$ Proof. $$ \\begin{split} \u0026 \\mathrm{since}\\ \\emptyset \\cap S = \\emptyset \\\\ \u0026 \\mathrm{then}\\ P(S) = P(\\emptyset \\cap S) = P(\\emptyset) + P(S) \\\\ \u0026 \\mathrm{and}\\ P(S) = 1 \\\\ \u0026 \\mathrm{thus}\\ P(\\emptyset) = P(S) - P(S) = 0 \\\\ \u0026 Q.D.E. \\\\ \u0026 \\\\ \u0026 \\mathrm{since}\\ A^{C} \\cap A = \\emptyset \\\\ \u0026 \\mathrm{then}\\ P(S) = P(A^{C} \\cup A) = P(A^{C}) + P(A) \\\\ \u0026 \\mathrm{and}\\ P(S) = 1 \\\\ \u0026 \\mathrm{thus}\\ P(A^{C}) = P(S) - P(A) = 1 - p \\\\ \u0026 Q.D.E. \\end{split} $$ Random variable $X$ 是将 sample space $S$ 映射到实数域 $R$ 的映射关系，即 $S$ 是定义域 (domain)，$R$ 是值域 (co-domain)。由于 $S$ 和 $R$ 在计数上并不相同，所以 $r.v.\\ X$ 只是单射，并不是满射。 为什么需要这样的映射关系？因为对于实数，可以使用微积分这类数学工具对概率的性质进行研究，而微积分这类数学工具对于 sample space 显然是无法使用的。 但是注意，根据 Probability set function 的定义，对于映射后实数域上的集合，我们是无法直接求得对应的概率值，所以需要一个类似反函数的映射关系 $X^{-1}:\\ R \\rightarrow S$ 来将 $R$ 映射回 $S$，从而计算对应的概率值。 为什么是类似反函数的映射？原因如上面所说的，$S$ 和 $R$ 在计数上并不相等，所以 $R$ 到 $S$ 的映射有可能不满足单射。 引用 Our interest of Probability: Given $B \\subset R$, what $P(x \\in B) =\\ ?$ $$ (X \\in B) = X^{-1}(B) = \\{s \\in S: X(s) \\in B\\} \\subset S \\\\ \\implies P(x \\in B) = P(\\{s \\in S: X(s) \\in B\\}) $$ Distribution function (df) of a r.v. $X$ is $$ F(x) = P(X \\leq x),\\ x \\in R $$ 如果我们需要对实数域上的集合 $B$ 求其概率值，则如我们之前所说的，需要使用 $X^{-1}$ 将 $R$ 映射回 $S$。由于可能是非单射的映射关系，所以我们使用集合 $\\{s \\in S: X(s) \\in B\\}$ 来表示映射结果，所以 $(x \\in B)$ 也可以表示 event。 这样我们就可以对实数域上的集合求其概率值了，也即此时我们拥有一个 $subset\\ of\\ R$ 到 $R$ 的映射关系。 但是这样仍然无法在二维坐标轴上进行直观表示，也无法对该关系使用微积分等工具进行研究，我们需要 $R \\rightarrow R$ 的映射关系。 Distribution function (df) 就是我们所期望的 $R \\rightarrow R$ 的映射关系，对于 $R$ 上的每一个 $x$ 映射到 $P(X \\leq x)$。 注意 $X \\leq x$ 只是一个数学表示，并不具备数学意义，因为 $X$ 作为一个 real-valued function 和实数 $x$ 进行关系运算显然是没有意义的。 $X \\leq x$ 表示在 r.v. $X$ 的映射关系下，集合 $y \\in (-\\infty, x]$ 即 $\\{s \\in S: X(s) \\in (-\\infty, x]\\}$，所以 $$ P(X \\leq x) = P(\\{s \\in S: X(s) \\in (-\\infty, x]\\}) $$ 有了 df 我们就可以将概率的性质通过二维坐标轴进行直观显示，并且可以使用微积分这类工具进行进一步研究。 接下来以一些常见的概率分布来对之前所提的概念进行实作： 引用 Some Distributions: Bernoulli distribution and Binomial distribution. A experiment with two possible outcomes is called a Bernoulli experiment. We denote the sample space by $$S = \\{S, F\\},\\ S = Success,\\ F = Failure$$ Probability set function: $$P(\\{S\\}) = p,\\ P(\\{F\\}) = 1-p,\\ 0 \\le p \\le 1$$ We define r.v. $X$ on $S = \\{S, F\\}$ by $$ X(S) = 1, X(F) = 0 \\\\ \\implies \\{S, F\\} \\xrightarrow{X} \\{0, 1\\} $$ The Probability are $$ P(X = 1) = P(X^{-1}\\{1\\}) = P(\\{S\\}) = p $$ 我们可以从这个 Bernoulli distribution 的例子中提炼统计的一般思路: 从 Random experiment 中构建 Sample space $S$ 通过 Probability set function 计算 event 对应的概率值 定义 Random variable $X$ 实现 $S$ 到 $R$ 的映射关系 对 Distribution function (df) 进一步分析 ","date":"2024-01-20","objectID":"/posts/nycu-statistics/:1:0","tags":["Mathematics","Statistics","Probility","Random Variable"],"title":"交大统计学 重点提示","uri":"/posts/nycu-statistics/"},{"categories":["Mathematics"],"content":"References List of LaTeX mathematical symbols ","date":"2024-01-20","objectID":"/posts/nycu-statistics/:2:0","tags":["Mathematics","Statistics","Probility","Random Variable"],"title":"交大统计学 重点提示","uri":"/posts/nycu-statistics/"},{"categories":["Linux Kernel Internals"],"content":"大型开源项目的规模十分庞大，例如使用 Rust 编写的 Servo 浏览器，这个项目有近十万行代码。在开发规模如此庞大的项目时，了解如何通过正确的方式进行调试非常重要，因为这样可以帮助开发者快速地找到瓶颈。 原文地址 | 教学视频 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:0:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"GDB 调试 观看教学视频 拯救資工系學生的基本素養—使用 GDB 除錯基本教學 和搭配博文 ==[How to debug Rust/C/C++ via GDB][debug-gdb]==，学习 GDB 的基本操作和熟悉使用 GDB 调试 Rust/C/C++ 程序。 掌握 run/r, break/b, print/p, continue/c, step/s info/i, delete/d, backtrace/bt, frame/f, up/down, exit/q 等命令的用法。以及 GBD 的一些特性，例如 GDB 会将空白行的断点自动下移到下一代码行；使用 break 命令时可以输入源文件路径，也可以只输入源文件名称。 相关的测试文件： test.c hello_cargo/ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:1:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"GDB 基本介绍 引用 “GDB, the GNU Project debugger, allows you to see what is going on ‘inside’ another program while it executes — or what another program was doing at the moment it crashed.” — from gnu.org 安装 GDB: $ sudo apt install gdb 启动 GDB 时可以加入 -q 参数 (quite)，表示减少或不输出一些提示或信息。 LLDB 与 GDB 的命令类似，本文也可用于 LLDB 的入门学习。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:2:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"GDB 调试 C/C++ 要使用 GDB 来调试 C/C++，需要在编译时加上 -g 参数（必需），也可以使用 -Og 参数来对 debug 进行优化（但使用 -Og 后 compiler 可能会把一些东西移除掉，所以 debug 时可能不会符合预期），例如： $ gcc test.c -Og -g -o test $ gdb -q ./test Source ","date":"2024-01-16","objectID":"/posts/debug-gdb/:3:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"GDB 调试 Rust 在使用 build 命令构建 debug 目标文件（即位于 target/debug 目录下的目标文件，与 package 同名）后，就可以通过 gdb 来进行调试： $ cargo build $ gdb -q ./target/debug/\u003cpackage name\u003e 但是如果是使用 cargo build --release 构建的 release 目标文件（即位于 target/release 目录下的目标文件），则无法使用 GDB 进行调试，因为 release 目标未包含任何调试信息，类似于未使用 -g 参数编译 C/C++ 源代码。 Source ","date":"2024-01-16","objectID":"/posts/debug-gdb/:4:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"GDB 基本命令 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"run run (r) 命令用于从程序的执行起始点开始执行，直到遇到下一个断点或者程序结束。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:1","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"continue continue (c) 命令用于从当前停止的断点位置处继续执行程序，直到遇到下一个断点或者程序结束。 注意 run 和 continue 的区别在于 run 是将程序从头开始执行。例如如果未设置任何断点，使用 run 可以反复执行程序，而如果使用 continue 则会提示 The program is not being run。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:2","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"step step (s) 命令用于 逐行 执行程序，在遇到函数调用时进入对应函数，并在函数内部的第一行暂停。step 命令以 单步方式 执行程序的每一行代码，并跟踪函数调用的进入和退出。 (gdb) step 6 bar += 3; (gdb) step 7 printf(\"bar = %d\\n\", bar); 注意 step 命令与 continue 命令相同，只能在程序处于运行态（即停留在断点处）时才能使用。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:3","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"next next (n) 命令用于执行当前行并移动到 下一行，它用于逐行执行程序，但不会进入函数调用。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:4","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"break break (b) 命令用于在可执行问卷对应的源程序中加入断点，可以在程序处于 未运行态/运行态 时加入断点（运行态是指程序停留在断点处但未执行完毕的姿态）。 可以通过指定 源文件对应的 行数/函数名 来加入断点（源文件名可以省略）： (gdb) break test.c:7 (gdb) break test.c:foo 如果可执行文件由多个源文件编译链接得到，可以通过指定 源文件名字 的方式来加入断点，无需源文件路径，但如果不同路径有重名源文件，则需要指定路径来区分： (gdb) break test1.c:7 (gdb) break test2.c:main ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:5","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"print print (p) 命令用于在调试过程中打印 变量的值或 表达式 的结果，帮助开发者检查程序状态并查看特定变量的当前值。 # Assume x: 3, y: 4 (gdb) print x $1 = 3 (gdb) print x + y $2 = 7 使用 p 命令打印变量值时，会在左侧显示一个 $\u003cnumber\u003e，这个可以理解成临时变量，后续也可以通过这个标志来复用这些值。例如在上面的例子中： (gdb) print $1 $3 = 3 (gdb) print $1 + $3 $4 = 4 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:6","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"backtrace backtrace (bt) 命令用于打印当前调用栈的信息，也称为堆栈回溯 (backtrace)。它显示了程序在执行过程中经过的函数调用序列，以及每个函数调用的位置和参数，即可以获取以下信息： 函数调用序列：显示程序当前的函数调用序列，以及每个函数的名称和所在的源代码文件。 栈帧信息：对于每个函数调用，显示该函数的栈帧信息，包括栈帧的地址和栈帧的大小。 (gdb) backtrace (gdb) backtrace #0 foo () at test.c:7 #1 0x00005555555551d2 in main () at test.c:14 技巧 backtrace 命令对于跟踪程序的执行路径、检查函数调用的顺序以及定位错误非常有用。在实际中，一般会搭配其他GDB命令（如 up、down 和 frame）结合使用，以查看特定栈帧的更多详细信息或切换到不同的栈帧。在上面的例子中，#0 和 #1 表示栈帧的编号，可以通过 frame 配合这些编号来切换栈帧。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:7","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"where where 和 backtrace 命令都用于显示程序的调用栈信息。backtrace 提供更详细的调用栈信息，包括函数名称、文件名、行号、参数和局部变量的值。而 where 命令可以理解为 backtrace 的一个简化版本，它提供的是较为紧凑的调用栈信息，通常只包含函数名称、文件名和行号。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:8","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"frame frame (f) 命令用于选择特定的栈帧 (stack frame)，从而切换到不同的函数调用上下文，每个栈帧对应于程序中的一个函数调用。 接着上一个例子，切换到 main 函数所在的栈帧： (gdb) frame 1 #1 0x00005555555551d2 in main () at test.c:14 14 int result = foo(); ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:9","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"up/down up 和 down 命令用于在调试过程中在不同的栈帧之间进行切换： up 用于在调用栈中向上移动到较高的栈帧，即进入调用当前函数的函数。每次执行 up 命令，GDB 将切换到上一个（更高层次）的栈帧。这可以用于查看调用当前函数的上层函数的执行上下文。 down 用于在调用栈中向下移动到较低的栈帧，即返回到当前函数调用的函数。每次执行 down 命令，GDB 将切换到下一个（较低层次）的栈帧。这可以用于返回到调用当前函数的函数的执行上下文。 这两个命令需要开发者对应函数调用堆栈的布局有一定程度的了解。 接着上一个例子： (gdb) up #1 0x00005555555551d2 in main () at test.c:14 14 int result = foo(); (gdb) down #0 foo () at test.c:7 7 printf(\"bar = %d\\n\", bar); ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:10","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"info info (i) 命令用于获取程序状态和调试环境的相关信息，该命令后面可以跟随不同的子命令，用于获取特定类型的信息。 一些常用的 info 子命令： info breakpoints 显示已设置的所有断点 (breakpoint) 信息，包括断点编号、断点类型、断点位置等。 info watchpoints 显示已设置的所有监视点 (watchpoint) 信息，包括监视点编号、监视点类型、监视的表达式等。 info locals 显示当前函数的局部变量的值和名称。 info args 显示当前函数的参数的值和名称。 info registers 显示当前 CPU 寄存器的值。 info threads 显示当前正在调试的所有线程 (thread) 信息，包括线程编号、线程状态等。 info frame 显示当前栈帧 (stack frame) 的信息，包括函数名称、参数、局部变量等。 info program 显示被调试程序的相关信息，例如程序入口地址、程序的加载地址等。 (gdb) info breakpoints # or simply: i b Num Type Disp Enb Address What 1 breakpoint keep y 0x000055555555518f in foo at test.c:7 2 breakpoint keep y 0x0000555555555175 in foo at test.c:4 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:11","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"delete delete (d) 命令用于删除断点 (breakpoint) 或观察点 (watchpoint)。断点是在程序执行期间暂停执行的特定位置，而观察点是在特定条件满足时暂停执行的位置。 可以通过指定 断点 / 观察点 的编号或使用 delete 命令相关的参数，来删除已设置的断点 / 观察点。断点 / 观察点编号可以在使用 info breakpoints / info watchpoints 命令时获得。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:12","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"quit quit (q) 命令用于退出 GDB，返回终端页面。 (gdb) quit $ # Now, in the terminial ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:13","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"list list 命令用于显示当前位置的代码片段，默认情况下，它会显示当前位置的前后10行代码。 list 命令也可以显示指定范围的代码，使用 list \u003cstart\u003e,\u003cend\u003e 命令将显示从 start 行到 end 行的源代码。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:14","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"whatis whatis 命令用于获取给定标识符（如变量、函数或类型）的类型信息。 // in source code int calendar[12][31]; // in gdb (gdb) whatis calendar type = int [12][31] ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:15","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"x x 命令用于查看内存中的数据，使用 x 命令搭配不同的格式来显示内存中的数据，也可以搭配 / 后跟数字来指定要显示的内存单元数量。例如，x/4 \u003caddress\u003e 表示显示地址 address 开始的连续 4 个内存单元的内容。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:16","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"其他 如果被调试程序正处于运行态（即已经通过 run 命令来运行程序），此时可以通过 Ctrl+C 来中断 GDB，程序将被立即中断，并在中断时所运行到的地方暂停。这种方式被称为 手动断点，手动断点可以理解为一个临时断点，只会在该处暂停一次。 GDB 会将空白行的断点自动下移到下一非空的代码行。 set print pretty 命令可以以更易读和格式化的方式显示结构化数据，以更友好的方式输出结构体、类、数组等复杂类型的数据，更易于阅读和理解。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:17","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":" 「指针」 扮演 「记忆体」 和 「物件」 之间的桥梁 原文地址 ","date":"2024-01-14","objectID":"/posts/c-pointer/:0:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"前言杂谈 Let’s learn programming by inventing it [CppCon 2018] ✅ 在 K\u0026R 一书中，直到 93 页才开始谈论 pointer，而全书总计 185 页，所以大概是在全书 $50.27\\%$ 的位置才开始讲 pointer。所以即使不学 pointer，你还是能够掌握 $~50\\%$ 的 C 语言的内容，但是 C 语言的核心正是 pointer，所以 Good Luck 🤣 godbolt 可以直接在网页上看到，源代码由各类 compiler 生成的 Assembly Code How to read this prototype? [Stack Overflow] ✅ Note 这个问题是关于 signal 系统调用的函数原型解读，里面的回答页给出了很多对于指针，特别是 函数指针 的说明，下面节选一些特别有意思的回答： The whole thing declares a function called signal: signal takes an int and a function pointer this function pointer takes an int and returns void signal returns a function pointer this function pointer takes an intand returns avoid` That’s where the last int comes in. You can use the spiral rule to make sense of such declarations, or the program cdecl(1). 这里面提到了 the spiral rule 这是一个用于解析 C 语言中声明 (declaration) 的方法；另外还提到了 cdecl 这一程序，它也有类似的作用，可以使用英文进行声明或者解释。 Find the leftmost identifier and work your way out, remembering that [] and () bind before *; IOW, *a[] is an array of pointers, (*a)[] is a pointer to an array, *f() is a function returning a pointer, and (*f)() is a pointer to a function. Thus, void ( *signal(int sig, void (*handler)(int)) ) (int); breaks down as signal -- signal signal( ) -- is a function signal( sig ) -- with a parameter named sig signal(int sig, ) -- of type int signal(int sig, handler ) -- and a parameter named handler signal(int sig, *handler ) -- which is a pointer signal(int sig, (*handler)( )) ) -- to a function signal(int sig, (*handler)(int)) ) -- taking an int parameter signal(int sig, void (*handler)(int)) ) -- and returning void *signal(int sig, void (*handler)(int)) ) -- returning a pointer ( *signal(int sig, void (*handler)(int)) )( ) -- to a function ( *signal(int sig, void (*handler)(int)) )(int) -- taking an int parameter void ( *signal(int sig, void (*handler)(int)) )(int); -- and returning void 这一回答强调了 * 和 []、() 优先级的关系，这在判断数组指针、函数指针时是个非常好用的技巧。 Rob Pike 于 2009/10/30 的 Golang Talk [PDF] David Brailsford 教授解说影片 Essentials: Pointer Power! - Computerphile [YouTube] ","date":"2024-01-14","objectID":"/posts/c-pointer/:1:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"阅读 C 语言规格书 一手资料的重要性毋庸置疑，对于 C 语言中的核心概念 指针，借助官方规格书清晰概念是非常重要的。 C99 [6.2.5] Types An array type of unknown size is an incomplete type. It is completed, for an identifier of that type, by specifying the size in a later declaration (with internal or external linkage). A structure or union type of unknown content is an incomplete type. It is completed, for all declarations of that type, by declaring the same structure or union tag with its defining content later in the same scope. incomplete type 和 linkage 配合可以进行 forward declaration，如果搭配 pointer 则可以进一步，在无需知道 object 内部细节即可进行程序开发。 Array, function, and pointer types are collectively called derived declarator types. A declarator type derivation from a type T is the construction of a derived declarator type from T by the application of an array-type, a function-type, or a pointer-type derivation to T. 注意 derived declarator types 表示衍生的声明类型，因为 array, function, pointer 本质都是地址，而它们的类型都是由其它类型衍生而来的，所以可以使用这些所谓的 derived declarator types 来提前声明 object，表示在某个地址会存储一个 object，这也是为什么这些类型被规格书定义为 derived declarator types。 lvalue: Locator value 危险 C 语言里只有 call by value ","date":"2024-01-14","objectID":"/posts/c-pointer/:2:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"void \u0026 void * C89 之前，函数如果没有标注返回类型，则默认返回类型 int，返回值 0。但由于这样既可以表示返回值不重要，也可以表示返回值为 0，这会造成歧义，所以引进了 void。 void * 只能表示地址，而不能对所指向的地址区域的内容进行操作。因为通过 void * 无法知道所指向区域的 size，所以无法对区域的内容进行操作，必须对 void * 进行 显示转换 才能操作指向的内容。（除此之外，针对于 GCC，对于指针本身的操作，void * 与 char * 是等价的，即对于 +/- 1 这类的操作，二者的偏移量是一致的；对于其它的编译器，建议将 void * 转换成 char * 再进行指针的加减运算） ","date":"2024-01-14","objectID":"/posts/c-pointer/:3:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"Alignment 这部分原文描述不是很清晰，2-byte aligned 图示如下： Alignment 如果是 2-byte aligned 且是 little-endian 的处理器，对于左边，可以直接使用 *(uint16_t *) ptr，但对于右边就无法这样（不符合 alignment）： /* may receive wrong value if ptr is not 2-byte aligned */ uint16_t value = *(uint16_t *) ptr; /* portable way of reading a little-endian value */ uint16_t value = *(uint8_t *) ptr | ((*(uint8_t *) (ptr + 1)) \u003c\u003c 8); 因为内存寻址的最小粒度是 Byte，所以使用 (uint_8 *) 不需要担心 alignment 的问题。原文并没有给出 32-bit aligned 的 portable way，我们来写一下： /* may receive wrong value if ptr is not 2-byte aligned */ uint32_t value = *(uint32_t *) ptr; /* portable way of reading a little-endian value */ uint32_t value = *(uint8_t *) ptr | ((*(uint8_t *) (ptr + 1)) \u003c\u003c 8) | ((*(uint8_t *) (ptr + 2)) \u003c\u003c 16) | ((*(uint8_t *) (ptr + 3)) \u003c\u003c 24); 信息 The Lost Art of Structure Packing ","date":"2024-01-14","objectID":"/posts/c-pointer/:3:1","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"规格书中的 Pointer C99 [6.3.2.3] Pointers A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. Ifaconverted pointer is used to call a function whose type is not compatible with the pointed-to type, the behavior is undefined. C11 [6.3.2.3] Pointers A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. If a converted pointer is used to call a function whose type is not compatible with the referenced type, the behavior is undefined. C99 和 C11 都不保证 pointers (whose type is not compatible with the pointed-to / referenced type) 之间的转换是正确的。 导致这个的原因正是之前所提的 Alignment，转换后的指针类型不一定满足原有类型的 Alignment 要求，这种情况下进行 dereference 会导致异常。例如将一个 char * 指针转换成 int * 指针，然后进行 deference 有可能会产生异常。 ","date":"2024-01-14","objectID":"/posts/c-pointer/:3:2","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"Pointers vs. Arrays C99 6.3.2.1 Except when it is the operand of the sizeof operator or the unary \u0026 operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. Array 只有在表示其自身为数组时才不会被 converted to Pointer，例如 // case 1: extern declaration of array extern char a[]; // case 2: defintion of array char a[10]; // case 3: size of array sizeof(a); // case 4: address of array \u0026a 在其他情况则会倍 converted to Pointer，这时 Array 可以和 Pointer 互换进行表示或操作，例如 // case 1: function parameter void func(char a[]); void func(char *a); // case 2: operation in expression char c = a[2]; char c = *(a + 2); 这也是为什么对于一个 Array a，\u0026a 和 \u0026a[0] 值虽然相同，但 \u0026a + 1 和 \u0026a[0] + 1 的结果大部分时候是大不相同的，这件事乍一看是非常惊人的，但其实不然，在了解 Array 和 Pointer 之后，也就那么一回事 🤣 ","date":"2024-01-14","objectID":"/posts/c-pointer/:4:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"GDB 实作 char a[10]; int main() { return 0; }; 我们以上面这个例子，通过 GDB 来对 Array 和 Pointer 进行深入研究： (gdb) print \u0026a $1 = (char (*)[10]) 0x555555558018 \u003ca\u003e (gdb) print \u0026a[0] $2 = 0x555555558018 \u003ca\u003e \"\" 符合预期，\u0026a 和 \u0026a[0] 得到的值是相同的，虽然类型看起来不同，但是现在先放到一边。 (gdb) print \u0026a + 1 $3 = (char (*)[10]) 0x555555558022 (gdb) print \u0026a[0] + 1 $4 = 0x555555558019 \u003ca+1\u003e \"\" (gdb) print a + 1 $5 = 0x555555558019 \u003ca+1\u003e \"\" Oh! 正如我们之前所说的 \u0026a + 1 与 \u0026a[0] + 1 结果并不相同（而 \u0026a[0] + 1 和 a + 1 结果相同正是我们所提到的 Array 退化为 Pointer），虽然如此，GDB 所给的信息提示我们可能是二者 Pointer 类型不相同导致的。 (gdb) whatis \u0026a type = char (*)[10] (gdb) whatis \u0026a[0] type = char * Great! 果然是 Pointer 类型不同导致的，我们可以看到 \u0026a 的类型是 char (*)[10] 一个指向 Array 的指针，\u0026a[0] 则是 char *。所以这两个 Pointer 在进行 +/- 运算时的偏移量是不同的，\u0026a[0] 的偏移量为 sizeof(a[0]) 即一个 char 的宽度 ($0x18 + 1 = 0x19$)，而 \u0026a 的偏移量为 sizeof(a) 即 10 个 char 的宽度 ($0x18 + 10 = 0x22$)。 警告 在 GDB 中使用 memcpy 后直接打印可能会出现以下错误： (gdb) p memcpy(calendar, b, sizeof(b[0])) 'memcpy' has unknown return type; cast the call to its declared return type 只需加入 void * 进行类型转换即可解决该问题： (gdb) p (void *) memcpy(calendar, b, sizeof(b[0])) ... 技巧 遇到陌生的函数，可以使用 man 来快速查阅手册，例如 man strcpy, man strcat，手册可以让我们快速查询函数的一些信息，从而进入实作。 ","date":"2024-01-14","objectID":"/posts/c-pointer/:4:1","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"Runtime Environment 根据 Zero size arrays in C ，原文中的 char (*argv)[0] 在函数参数传递时会被转换成 char **argv。而为什么在查看地址 ((char **) argv)[0] 开始的连续 4 个 char * 内容时，会打印出 envp 中的内容，可以参考以下的进入 main 函数时的栈布局： argv 和 envp 所指的字符串区域是相连的，所以在越过 argv 字符串区域的边界后，会继续打印 envp 区域的字符串。这也是为什么打印出的字符串之间地址增长于其长度相匹配。所以从地址 (char **) argv 开始的区域只是一个 char * 数组，使用 x/4s 对这部分进行字符串格式打印显然是看不懂的。 注意 argv 和 envp 都是在 shell 进行 exec 系统调用之前进行传递（事实上是以 arguments 的形式传递给 exec） man 2 execve int execve(const char *pathname, char *const argv[], char *const envp[]); execve 实际上在内部调用了 fork，所以 argv 和 envp 的传递是在 fork 之前。（设想如果是在 fork 之后传递，可能会出现 fork 后 child process 先执行，这种情况 child process 显然无法获得这些被传递的信息） 注意到 execve 只传递了 argv 而没有传递 argc，这也很容易理解，argc 是 argv 的计数，只需 argv 即可推导出 argc。 ","date":"2024-01-14","objectID":"/posts/c-pointer/:4:2","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"Function Pointer 危险 与 Array 类似，Function 只有在表示自身时不会被 converted to Function Pointer (即除 sizeof 和 \u0026 运算之外)，其它情况、运算时都会被 convert to Function Pointer 理解 C 语言中的 Function 以及 Function Pointer 的核心在于理解 Function Designator 这个概念，函数名字必然是 Function Designator，其它的 designator 则是根据以下两条规则进行推导得来。 C99 [ 6.3.2.1 ] A function designator is an expression that has function type. Except when it is the operand of the sizeof operator or the unary \u0026 operator, a function designator with type ‘‘function returning type’’ is converted to an expression that has type ‘‘pointer to function returning type’’. C99 [6.5.3.2-4] The unary * operator denotes indirection. If the operand points to a function, the result is a function designator. ","date":"2024-01-14","objectID":"/posts/c-pointer/:5:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"指针的修饰符 指针 p 自身不能变更，既不能改变 p 自身所存储的地址。const 在 * 之后： char * const p; 指针 p 所指向的内容不能变更，即不能通过 p 来更改所指向的内容。const 在 * 之前： const char * p; char const * p; 指针 p 自身于所指向的内容都不能变更： const char * const p; char const * const p; ","date":"2024-01-14","objectID":"/posts/c-pointer/:6:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"字符串 对于函数内部的 char *p = \"hello\"; char p[] = \"hello\"; 这两个是不一样的，因为 string literals 是必须放在 “static storage” 中，而 char p[] 则表示将资料分配在 stack 內，所以这会造成编译器隐式地生成额外代码，在执行时 (runtime) 将 string literals 从 static storage 拷贝到 stack 中，所以此时 return p 会造成 UB。而 char *p 的情形不同，此时 p 只是一个指向 static storage 的指针，进行 return p 是合法的。 在大部分情况下，null pointer 并不是一个有效的字符串，所以在 glibc 中字符相关的大部分函数也不会对 null pointer 进行特判 (特判会增加分支，从而影响程序效能)，所以在调用这些函数时需要用户自己判断是否为 null pointer，否则会造成 UB。 ","date":"2024-01-14","objectID":"/posts/c-pointer/:7:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"Linus 的“教导” Linus 親自教你 C 語言 array argument 的使用 because array arguments in C don’t actually exist. Sadly, compilers accept it for various bad historical reasons, and silently turn it into just a pointer argument. There are arguments for them, but they are from weak minds. The “array as function argument” syntax is occasionally useful (particularly for the multi-dimensional array case), so I very much understand why it exists, I just think that in the kernel we’d be better off with the rule that it’s against our coding practices. array argument 应该只用于多维数组 (multi-dimensional arrays) 的情形，这样可以保证使用下标表示时 offset 是正确的，但对于一维数组则不应该使用数组表示作为函数参数，因为这会对函数体内的 sizeof 用法误解 (以为会获得数组的 size，实际上获得的只是指针的 size)。 技巧 一个常用于计算数组中元素个数的宏： #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0])) 这个宏非常有用，xv6 中使用到了这个宏。 但是需要注意，使用时必须保证 x 是一个数组，而不是函数参数中由数组退化而来的指针，以及保证数组必须至少拥有一个元素的长度 (这个很容易满足，毕竟 x[0] 编译器会抛出警告)。 ","date":"2024-01-14","objectID":"/posts/c-pointer/:8:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"Lvalue \u0026 Rvalue Lvalue: locator value Rvalue: Read-only value C99 6.3.2.1 footnote The name “lvalue” comes originally from the assignment expression E1 = E2, in which the left operand E1 is required to be a (modifiable) lvalue. It is perhaps better considered as representing an object “locator value”. What is sometimes called “rvalue” is in this International Standard described as the “value of an expression”. An obvious example of an lvalue is an identifier of an object. As a further example, if E is a unary expression that is a pointer to an object, *E is an lvalue that designates the object to which E points. 即在 C 语言中 lvalue 是必须能在内存 (memory) 中可以定位 (locator) 的东西，因为可以定位 (locator) 所以才可以在表达式左边从而修改值。想像一下，在 C 语言中修改一个常数的值显然是不可能的，因为常数无法在内存 (memory) 定位 (locator) 所以常数在 C 语言中不是 lvalue。C 语言中除了 lvalue 之外的 value 都是 rvalue (这与 C++ 有些不同，C++ 的 lvalue 和 rvalue 的定义请参考 C++ 的规格书)。 ","date":"2024-01-14","objectID":"/posts/c-pointer/:9:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Network"],"content":"之前学校的计网理论课学得云里雾里，对于物理层和数据链路层并没有清晰的逻辑框架，而这学期的计网课设内容为数据链路层和网络层的相关内容，写起来还是云里雾里。虽然最终艰难地把课设水过去了，但是个人认为网络对于 CSer 非常重要，特别是在互联网行业，网络知识是必不可少的。 所以决定寒假重学计网，于是在 HackMD 上冲浪寻找相关资料。然后发现了这篇笔记 110-1 計算機網路 (清大開放式課程)，里面提到清大计网主要介绍 L2 ~ L4 一些著名的协议和算法，这完美符合个人的需求，而且该笔记还补充了一些额外的内容，例如 IPv6，所以当即决定搭配这篇笔记来学习清大的计算机网络概论。 ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:0:0","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"清大计算机网络概论 本課程將介紹計算機網路的基本運作原理與標準的網路七層結構,由淺入深,可以讓我們對於計算機網路的運作有最基本的認識,本課程還會介紹全球建置最多的有線網路──IEEE 802.3 Ethernet 的基本運作原理, 還有全球建置最多的無線區域網路──IEEE 802.11 Wireless LAN 的基本運作原理, 想知道網路交換機(switches) 是如何運作的嗎 ? 想知道網際網路最重要也最關鍵的通訊協議 ── TCP/IP 是如何運作的嗎 ? 想知道網際網路最重要的路由器 (Routers) 是如何運作的嗎 ? 在本課程裡您都可以學到這些重要的基本知識。 开课学校 课程主页 课程资料 课程影片 國立清華大學 計算機網路概論 課程講義與練習題 Youtube ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:1:0","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"L1 Foundation 重点提示与练习 Outline: Applications Network Connectivity Network Architecture Network Performance ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:0","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Applications Foundation - 5 进行 1 次 URL request 需要进行 17 次的讯息交换： 6 次讯息交换用于查询 URL 对应的 IP Address 3 次讯息交换用于建立 TCP 连接（TCP 的 3 次握手） 4 次讯息交换用于 HTTP 协议的请求和回复 4 次讯息交换用于关闭 TCP 连接（TCP 的 4 次握手） ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:1","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Network Connectivity Foundation - 8 交换机 (Switches) 可以分为很多层级，即可以有不同层级的交换机，例如 L2 层的交换机，L3 层的交换机以及 L4 层的交换机。如何判断交换机是哪个层级？很简单，只需要根据交换机所处理的讯息，L2 层交换机处理的是 MAC Address，L3 层交换机处理的是 IP Address，而 L4 层交换机处理的是 TCP 或者 UDP 相关的讯息。 交换机 (Switches) 用于网络 (Network) 内部的连接，路由 (Router) 用于连接不同的网络 (Network)，从而形成 Internetwork。 地址 (Address)，对于网卡来说是指 MAC Address，对于主机来说是指 IP Address。Host-to-Host connectivity 是指不同网络 (Network) 的主机，即位于 Internetwork 的不同主机之间，进行连接。 ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:2","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Network Architecture Foundation - 22 Physical Layer: 如何将原始资料在 link 上传输，例如不同介质、信息编码。(P25) Data Link Layer: 在 Physical Layer 基础上，如何将 frame 传给直接相连的主机或设备，核心是通过 Media Access Control Protocol 解决 Multiple access 产生的碰撞问题。这一层交换的数据被称为 frame。(P26) Network Layer: 在 Data Link Layer 基础上，如何将 packet 通过 Internet 送给目的地主机。核心是通过 Routing Protocols 动态转发 packet。这一层交换的数据被称为 packet。(P27) Transport Layer: 在 Network Layer 基础上，提供不同主机 processes 之间的资料传送。由于 Networkd Layer 是主机间进行资料传送，所以在 Transport Layer 不论是可靠还是不可靠的传输协议，都必须要实现最基本的机制：主机与 process 之间数据的复用和分解。这一层交换的数据被称为 message。(P28) 注意 Switch 一般处于 L2 Layer，Router 一般处于 L3 Layer。L4 Layer 及以上的 layers 通常只存在于 hosts，switches 和 routers 内部一般不具有这些 layers。(P29) Internet Architecture 的层级并不是严格的，Host 可以略过 Application Layer 而直接使用 Transport Layer、Network Layer 中的协议。(P30) Internet Architecture 的核心是 IP 协议，它作为沙漏形状的中心位置，为处于其上层的协议与处于其下层协议之间提供了一个映射关系。(P31) ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:3","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Network Performance Foundation - 36 Foundation - 37 Bandwidth: Number of bits per second (P34) Delay 可以近似理解为 Propagation time。有效利用 network 的标志是在接收对方的回应之前，发送方传送的资料充满了 pipe，即发送了 Delay $\\times$ Bandwitdh bits 的资料量。(P39) Foundation - 40 RTT 可以近似理解为 2 $\\times$ Propagation time，因为一个来回需要从 sender 到 reciever，再从 reciever 到 sender。 ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:4","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Homework Redis 作者 Salvatore Sanfilippo 的聊天室项目: smallchat，通过该项目可以入门学习网络编程 (Network Programming)，请复现该项目。 Salvatore Sanfilippo 在 YouTube 上对 smallchat 的讲解： Smallchat intro smallchat client \u0026 raw line input GitHub 上也有使用 Go 和 Rust 实现该项目的仓库，如果你对 Go 或 Rust 的网络编程 (Network Programming) 感兴趣，可以参考这个仓库。 ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:5","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"L2 IEEE 802.3 Ethernet Outline: Introduction Ethernet Topologies Ethernet Frame Format Ethernet MAC Protocol – CSMA/CD 802.3 Ethernet Standards Summary: MAC Protocol – CSMA/CD Connection less, unreliable transmission Topology from Bus to Star (switches) Half-duplex transmission in Bus topology Work best under lightly loaded conditions Too much collision under heavy load Full-duplex transmission in Switch topology (point-to-point) No more collisions !! Excellent performance (wired speed) ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:3:0","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Introduction Ethernet - 03 Ethernet 发展过程: 传输速度从 10Mb 发展到 100Gb (P4) Ethernet 的特点: Unreliable, Connectionless, CSMA/CD (P5) ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:3:1","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Ethernet Topologies Ethernet - 07 Ethernet - 18 10Base5: 10Mbps, segment up to 500m (P8) 10Base2: 10Mbps, segment up to 200m (P8) 10BaseT: 10Mbps, Twisted pair, segment up to 100m (P16) Repeater, Hub 都是 physical layer 的设备，只负责 转发信号，无法防止 collision (P12, P16) Switch 则是 data-link layer 的设备，内置芯片进行 数据转发，可以防止 collision (P19) Manchester Encoding (P11): Ethernet 下层的 physical layer 使用的编码方式是 Manchester Encoding: 在一个时钟周期内，信号从低到高表示 1，从高到低表示 0 注意 Manchester Encoding 发送方在进行数据传输之前需要发送一些 bits 来进行时钟同步 (例如 P22 的 Preamble 部分)，接收方完成时钟同步后，可以对一个时钟周期进行两次采样：一次前半段，一次后半段，然后可以通过两次取样电位信号的变化来获取对应的 bit (低到高表示 1，高到低表示 0)。 有些读者可能会疑惑，既然都进行时钟同步了，为什么不直接使用高电位信号表示 1，低电位信号表示 0 这样直观的编码方式？这是因为如果采取这种编码方式，那么在一个时钟周期内信号不会有变化，如果接收的是一系列的 1 或 0，信号也不会变化。这样可能会导致漏采样，或者编码出错却无法及时侦测。而采用 Manchester Encoding 接收方每个时钟周期内信号都会变化，如果接收方在一次时钟周期内的两次采样，信号没有发生变化，那么可以立即侦测到出错了 (要么是漏采样了，要么是编码出错了)。 ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:3:2","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Ethernet Frame Format Ethernet - 23 除开 Preamble, SFD 之外，一个 Frame 的大小为 $64 \\sim 1518$ bytes。因为 DA, SA, TYPE, FCS 占据了 $6 + 6 + 2 + 4 = 18$ bytes，所以 Data 部分的大小为 $48 ~\\sim 1500$ bytes (P43) MAC Address 是 unique 并且是与 Adaptor 相关的，所以一个主机可能没有 MAC Address (没有 Adaptor)，可能有两个 MAC Address (有两个 Adaptor)。MAC Address 是由 Adaptor 的生产商来决定的。(P24) unicast address, broadcast address, multicast address (P26) ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:3:3","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"CSMA/CD Ethernet - 46 Ethernet - 41 Ethernet - 45 Ethernet - 49 关于 CSMA/CD 的详细介绍可以查看 P34 ~ P38 关于 Ethernet Frame 的大小限制设计可以查看 P39 ~ P43 关于 CSMA/CD Collision Handling 的策略机制可以查看 P44 ~ P45, P47 ~ P48 注意 Host 在 detect collision 之后进行 backoff random delay，delay 结束后按照 1-persistent protocol (P35) 继续等待到 busy channel goes idle 后立刻进行传输。 ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:3:4","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Homework","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:3:5","tags":["Network"],"title":"清大计算机网络 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["C"],"content":"C 语言规格书 Chapter 6 - Language 阅读记录。 ","date":"2024-01-11","objectID":"/posts/c-spec-ch6/:0:0","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-spec-ch6/"},{"categories":["C"],"content":"6.2 Concepts ","date":"2024-01-11","objectID":"/posts/c-spec-ch6/:1:0","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-spec-ch6/"},{"categories":["C"],"content":"6.2.2 Linkages of identifiers linkage: external internal none 一个拥有 file scope 并且关于 object 或 function 的 identifier 声明，如果使用 static 修饰，则该 identifer 有 internal linkage，e.g. // file scope static int a; static void f(); int main() {} 一个 scope 内使用 static 修饰的 identifier 声明，如果在同一 scope 内已存在该 identifier 声明，则该 identifier 的 linkage 取决于先前的 identifier 声明。如果该 identifier 不存在先前声明或者先前声明 no linkage，则该 identifier 是 external linkage，e.g. // Example 1 static int a; // a is internal linkage extern int a; // linkage is the same as prior // Example 2 extern int b; // no prior, a is external linkage extern int b; // linkage is the same as prior 如果一个 function identifier 声明没有 storage-class 修饰符，则其 linkage 等价于加上 extern 修饰的声明的 linkage，e.g. int func(int a, int b); // equal to `extern int func(int a. int b);` // and then no prior, it is external linkage 如果一个 object identifier 声明没有 storage-class 修饰符，且拥有 file scope，则其拥有 external linkage，e.g. // file scope int a; // external linkage int main() {} ","date":"2024-01-11","objectID":"/posts/c-spec-ch6/:1:1","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-spec-ch6/"},{"categories":["C"],"content":"6.5 Expressions ","date":"2024-01-11","objectID":"/posts/c-spec-ch6/:2:0","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-spec-ch6/"},{"categories":["C"],"content":"6.5.3 Unary operators 注意 C99 [6.2.5] Types There are three real floating types, designated as float, double, and long double. The real floating and complex types are collectively called the floating types. The integer and real floating types are collectively called real types. Integer and floating types are collectively called arithmetic types. A function type describes a function with specified return type. A function type is characterized by its return type and the number and types of its parameters. A function type is said to be derived from its return type, and if its return type is T, the function type is sometimes called ‘‘function returning T’’. The construction of a function type from a return type is called ‘‘function type derivation’’. Arithmetic types and pointer types are collectively called scalar types. C99 [6.3.2.1] Lvalues, arrays, and function designators A function designator is an expression that has function type. Except when it is the operand of the sizeof operator or the unary \u0026 operator, a function designator with type ‘‘function returning type’’ is converted to an expression that has type ‘‘pointer to function returning type’’. 6.5.3.1 Prefix increment and decrement operators Constraints 前缀自增或自减运算符的操作数，必须为实数 (real types) 类型（即不能是复数）或者是指针类型，并且其值是可变的。 Semantics ++E 等价于 (E+=1) --E 等价于 (E-=1) 6.5.3.2 Address and indirection operators Constraints \u0026 运算符的操作数必须为 function designator，[] 或 * 的运算结果，或者是一个不是 bit-field 和 register 修饰的左值。 * 运算符的操作数必须为指针类型。 Semantics \u0026*E 等价于 E，即 \u0026 和 * 被直接忽略，但是它们的 constraints 仍然起作用。所以 (\u0026*(void *)0) 并不会报错。 \u0026a[i] 等价于 a + i，即忽略了 \u0026 以及 * (由 [] 隐式指代)。 其它情况 \u0026 运算的结果为一个指向 object 或 function 的指针。 如果 * 运算符的操作数是一个指向 function 的指针，则结果为对应的 function designator。 如果 * 运算符的操作数是一个指向 object 的指针，则结果为指示该 obejct 的左值。 如果 * 运算符的操作数为非法值的指针，则对该指针进行 * 运算的行为三未定义的。 6.5.3.3 Unary arithmetic operators Constraints 单目 + 或 - 运算符的操作数必须为算数类型 (arithmetic type)，~ 运算符的操作数必须为整数类型 (integer type)，! 运算符的操作数必须为常数类型 (scalar type)。 Semantics 在进行单目 +、-、~ 运算之前，会对操作数进行整数提升 (integer promotions)，结果的类型与操作数进行整数提升后的类型一致。 !E 等价于 (E==0)，结果为 int 类型。 ","date":"2024-01-11","objectID":"/posts/c-spec-ch6/:2:1","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-spec-ch6/"},{"categories":["C"],"content":"6.5.6 Additive operators 介绍加减法运算，其中包括了指针的运算，务必阅读这部分关于指针运算的标准说明。 ","date":"2024-01-11","objectID":"/posts/c-spec-ch6/:2:2","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-spec-ch6/"},{"categories":["C"],"content":"6.5.7 Bitwise shift operators Constraints 位运算的操作数都必须为整数类型。 Semantics 在进行位运算之前会先对操作数进行整数提升 (integer promotion)，位运算结果类型与整数提升后的左操作数一致。如果右运算数是负数，或者大于等于整数提升后的左运算数的类型的宽度，那么这个位运算行为是未定义的。 假设运算结果的类型为 T $E1 \u003c\u003c E2$ 如果 E1 是无符号，则结果为 $E1 \\times 2^{E2} \\bmod (\\max[T] + 1)$。 如果 E1 是有符号，E1 不是负数，并且 T 可以表示 $E1 \\times 2^{E2}$，则结果为 $E1 \\times 2^{E2}$。 除了以上两种行为外，其他均是未定义行为。 $E1 \u003e\u003e E2$ 如果 E1 是无符号，或者 E1 是有符号并且是非负数，则结果为 $E1 / 2^{E2}$。 如果 E1 是有符号并且是负数，则结果由具体实现决定 (implementation-defined)。 ","date":"2024-01-11","objectID":"/posts/c-spec-ch6/:2:3","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-spec-ch6/"},{"categories":["C"],"content":"C 语言规格书 Chapter 7 - Library 阅读记录。 ","date":"2024-01-11","objectID":"/posts/c-spec-ch7/:0:0","tags":["C","Sysprog"],"title":"C 规格第 7 章 Library","uri":"/posts/c-spec-ch7/"},{"categories":["C"],"content":"7.18 Integer types \u003cstdint.h\u003e 描述了头文件 stdint.h 必须定义和实现的整数类型，以及相应的宏。 ","date":"2024-01-11","objectID":"/posts/c-spec-ch7/:1:0","tags":["C","Sysprog"],"title":"C 规格第 7 章 Library","uri":"/posts/c-spec-ch7/"},{"categories":["C"],"content":"7.18.1 Integer types 7.18.1.1 Exact-width integer types 二补数编码，固定长度 N 的整数类型： 有符号数：intN_t 无符号数：uintN_t 7.18.1.2 Minimum-width integer types 至少拥有长度 N 的整数类型： 有符号数：int_leastN_t 无符号数：uint_leastN_t 7.18.1.3 Fastest minimum-width integer types 至少拥有长度 N，且操作速度最快的整数类型： 有符号数：int_fastN_t 无符号数：uint_fastN_t 7.18.1.4 Integer types capable of holding object pointers 可以将指向 void 的有效指针转换成该整数类型，也可以将该整数类型转换回指向 void 的指针类型，并且转换结果与之前的指针值保持一致： 有符号数：intptr_t 无符号数：uintptr_t 7.18.1.5 Greatest-width integer types 可以表示任意整数类型所表示的值的整数类型，即具有最大长度的整数类型： 有符号数：intmax_t 无符号数：uintmax_t ","date":"2024-01-11","objectID":"/posts/c-spec-ch7/:1:1","tags":["C","Sysprog"],"title":"C 规格第 7 章 Library","uri":"/posts/c-spec-ch7/"},{"categories":["C","Linux Kernel Internals"],"content":"C 语言规格书阅读学习记录。 规格书版本为 n1256，对应 C99 标准，对应的 PDF 下载地址。 也配合 C11 标准来阅读，版本 n1570，对应的 PDF 下载地址。 阅读规格书需要一定的体系结构、编译原理的相关知识，但不需要很高的程度。请善用检索工具，在阅读规格书时遇到术语时，请先在规格书中进行检索，因为极大可能是规格书自己定义的术语。 ","date":"2024-01-06","objectID":"/posts/c-specification/:0:0","tags":["C","Sysprog"],"title":"C 语言规格书 阅读记录","uri":"/posts/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"6. Language 详见 阅读记录 6. Language。 ","date":"2024-01-06","objectID":"/posts/c-specification/:1:0","tags":["C","Sysprog"],"title":"C 语言规格书 阅读记录","uri":"/posts/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"7. Library 详见 阅读记录 7. Library。 ","date":"2024-01-06","objectID":"/posts/c-specification/:2:0","tags":["C","Sysprog"],"title":"C 语言规格书 阅读记录","uri":"/posts/c-specification/"},{"categories":["Git"],"content":"Git 中文教学 新手入门推荐，对于 Git 的入门操作讲解十分友好。 视频地址 学习记录 ","date":"2024-01-04","objectID":"/posts/git/:1:0","tags":["Git/GitHub"],"title":"Git/GitHub 资源与问题汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"Git 常见问题及解决 ","date":"2024-01-04","objectID":"/posts/git/:2:0","tags":["Git/GitHub"],"title":"Git/GitHub 资源与问题汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"git pull/push 遇到 Port 22 connect timeout 网络问题导致 22 端口被禁止，无法正常使用 ssh。切换成 443 端口并且编写配置文件即可： $ vim ~/.ssh/config # In ~/.ssh/config Host github.com HostName ssh.github.com Port 443 ","date":"2024-01-04","objectID":"/posts/git/:2:1","tags":["Git/GitHub"],"title":"Git/GitHub 资源与问题汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"References Git 基本原理 Learn Git Branching ugit 动手学习GIT - 最好学习GIT的方式是从零开始做一个 ","date":"2024-01-04","objectID":"/posts/git/:3:0","tags":["Git/GitHub"],"title":"Git/GitHub 资源与问题汇总","uri":"/posts/git/"},{"categories":["Network"],"content":"整理一些计算机网络相关的资源 ","date":"2024-01-02","objectID":"/posts/network/:0:0","tags":["Network"],"title":"计算机网络学习指引","uri":"/posts/network/"},{"categories":["Network"],"content":"Referenecs 110-1 計算機網路 (清大開放式課程) 小菜学网络 NUDT 高级计算机网络实验: 基于UDP的可靠传输 可靠 UDP 的实现 (KCP over UDP) 基于UDP的可靠传输 [bilibili] 实现基于UDP的网络文件传输器，程序员的经验大礼包项目 [bilibili] ping命令但是用来通信，学习计算机网络好项目，也可能是校园网福利 [bilibili] Implementing TCP in Rust [YouTube] Let’s code a TCP/IP stack ","date":"2024-01-02","objectID":"/posts/network/:1:0","tags":["Network"],"title":"计算机网络学习指引","uri":"/posts/network/"},{"categories":["Linux Kernel Internals"],"content":" 人们对数学的加减运算可轻易在脑中辨识符号并理解其结果，但电脑做任何事都受限于实体资料储存及操作方式，换言之，电脑硬体实际只认得 0 和 1，却不知道符号 + 和 - 在数学及应用场域的意义，於是工程人员引入「补数」以便在二进位系统中，表达人们认知上的正负数。但您有没有想过，为何「二补数」(2’s complement) 被电脑广泛采用呢？背後的设计考量又是什麽？本文尝试从数学观点去解读编码背後的原理，并佐以资讯安全及程式码最佳化的考量，探讨二补数这样的编码对于程式设计有何关键影响。 原文地址：解讀計算機編碼 ","date":"2023-12-31","objectID":"/posts/binary-representation/:0:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"一补数 (Ones’ complement) ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"9 的补数 科普短片: Not just counting, but saving lives: Curta ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"运算原理 注意 以一补数编码形式表示的运算子，在参与运算后，运算结果符合一补数的编码： $$ [X]_{一补数} + [Y]_{一补数} = [X+Y]_{一补数} $$ 接下来进行分类讨论，以 32-bit 正数 $X$, $Y$ 为例： $X + Y = X + Y$ 显然运算子和运算结果都满足一补数编码。 $X - Y = X + (2^{32} - 1 - Y)$ 如果 $X \u003e Y$，则运算结果应为 $X - Y$ 且为正数，其一补数编码为 $X - Y$。而此时 $$ 2^{32} - 1 + X - Y $$ 显然会溢出，为了使运算结果对应一补数编码，所以此时循环进位对应 $+\\ (1 - 2_{32})$。 如果 $X \u003c Y$，则运算结果应为 $X - Y$ 且为负数，其一补数编码为 $$ 2^{32} - 1 - （Y - X） = 2_{32} - 1 - X - Y $$ 而此时 $2^{32} - 1 + X - Y$ 并不会溢出，并且满足运算结果的一补数编码，所以无需进行循环进位。 如果 $X = Y$，显然 $$ X - Y = X + 2^{32} - 1 - Y = 2^{32} - 1 $$ 为 0 成立。 $-X - Y = (2^{32} - 1 - X) + (2^{32} - 1 - Y)$，显然会导致溢出。而 $-X - Y$ 的一补数编码为 $$ 2^{32} - 1 - (X + Y) = 2^{32} - 1 - X - Y $$ 所以需要在溢出时循环进位 $+\\ (1 - 2^{32})$ 来消除运算结果中的一个 $2^{32} - 1$。 ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:2","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"二补数 (Two’s complement) ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"正负数编码表示 假设有 n-bit 的二补数编码 $A$，$-A$ 的推导如下： 格式一： $$ \\begin{align*} A + \\neg A \u0026= 2^n - 1 \\\\ A + \\neg A + 1 \u0026\\equiv 0 \\equiv 2^n \\ (\\bmod 2^n) \\\\ -A \u0026= \\neg A + 1 \\\\ \\end{align*} $$ 格式二： $$ \\begin{align*} A + \\neg A \u0026= 2^n - 1 \\\\ A + \\neg A - 1 \u0026= 2^n - 2 \\\\ A - 1 \u0026= 2^n - 1 - (\\neg A + 1) \\\\ \\neg (A - 1) \u0026= \\neg A + 1 \\\\ \\neg (A - 1) \u0026= -A \\\\ \\end{align*} $$ 也可以通过一补数和二补数，在时钟表上的对称轴偏差，来理解上述两种方式是等价的。 Twos’ complement ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"加 / 减法器设计 科普短片: See How Computers Add Numbers In One Lesson ✅ 了解晶体管的原理 了解基本逻辑门元件，例如 OR, AND 逻辑门的设计 了解加法器的原理和工作流程。 ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:2","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"阿贝尔群及对称性 技巧 群论的最大用途是关于「对称性」的研究；所有具有对称性质，群论都可派上用场。只要发生变换后仍有什么东西还维持不变，那符合对称的性质。 一个圆左右翻转后还是圆，它在这种变换下是对称的，而这刚好与群的 封闭性 (Closure) 对应。 一个时钟的时刻，从 0 时刻开始，两边的时刻相加模 12 的结果均为 0，这与群的 单位元 (Identity element) 和 逆元 (Inverse element) 对应。 上述两个例子反映了群论的性质，对于对称性研究的重要性和原理依据。 科普影片: 从五次方程到伽罗瓦理论 ","date":"2023-12-31","objectID":"/posts/binary-representation/:3:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"旁路攻击 观看科普视频: 我听得到你打了什么字 ✅ 阅读相关论文 Keyboard Acoustic Emanations 体验使用相关工具 kbd-audio 借由 Wikipedia 了解旁路攻击 (Side-channel attack) 和时序攻击 (Timing attack) 的基本概念 ✅ Black-box testing Row hammer Cold boot attack Rubber-hose cryptanalysis 延伸阅读 The password guessing bug in Tenex Side Channel Attack By Using Hidden Markov Model One\u0026Done: A Single-Decryption EM-Based Attack on OpenSSL’s Constant-Time Blinded RSA ","date":"2023-12-31","objectID":"/posts/binary-representation/:4:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"Constant-Time Functions 比较常见的常数时间实作方法是，消除分支。因为不同分支的执行时间可能会不同，这会被利用进行时序攻击。这个方法需要对 C 语言中的编码和位运算有一定的了解。 C99 STandard - 7.18.1.1 Exact-width integer types 阅读记录 C99 Standard - 6.5.7.5 Bitwise shift operators 阅读记录 Source Branchless abs 方法一，原理为 $-A = \\neg (A - 1)$: #include \u003cstdint.h\u003e int32_t abs(int32_t x) { int32_t mask = (x \u003e\u003e 31); return (x + mask) ^ mask; } 方法二，原理为 $-A = \\neg A + 1$: #include \u003cstdint.h\u003e int32_t abs(int32_t x) { int32_t mask = (x \u003e\u003e 31); return (x ^ mask) - mask; } Branchless min/max Min: #include \u003cstdint.h\u003e int32_t min(int32_t a, int32_t b) { int32_t diff = (a - b); return b + (diff \u0026 (diff \u003e\u003e 31)); } 如果 diff \u003e 0 即 b 小，那么 (diff \u003e\u003e 31) == 0，则 b + (diff \u0026 (diff \u003e\u003e 31)) == b 如果 diff \u003c 0 即 a 小，那么 (diff \u003e\u003e 31) == -1，则 b + (diff \u0026 (diff \u003e\u003e 31)) == b + (a - b) == a Max: #include \u003cstdint.h\u003e int32_t max(int32_t a, int32_t b) { int32_t diff = (b - a); return b - (diff \u0026 (diff \u003e\u003e 31)); } 如果 diff \u003e 0 即 b 大, 那么 (diff \u003e\u003e 31) == 0，则 b - (diff \u0026 (diff \u003e\u003e 31)) == b 如果 diff \u003c 0 即 a 大，那么 (diff \u003e\u003e 31) == -1，则 b - (diff \u0026 (diff \u003e\u003e 31)) == b - (b - a) == a 信息 基于 C 语言标准研究与系统程序安全议题 这篇文章是第二周的课程内容，学有余力可以先行阅读。 ","date":"2023-12-31","objectID":"/posts/binary-representation/:4:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Rust in 100 Seconds 观看短片: Rust in 100 Seconds ✅ 了解 Rust，初步了解其安全性原理 所有权 (ownership) 借用 (borrow) 警告 0:55 This is wrong, value mutability doesn’t have anything to do with the value being stored on the stack or the heap (and the example let mut hello = \"hi mom\" will be stored on the stack since it’s type is \u0026'static str), it depends on the type of the value (if it’s Sized or not). ","date":"2023-12-28","objectID":"/posts/rust-introduction/:1:0","tags":["Rust","Sysprog"],"title":"Rust: 进行中的未来","uri":"/posts/rust-introduction/"},{"categories":["Linux Kernel Internals","Rust"],"content":"The adoption of Rust in Business (2022) 阅读报告: The adoption of Rust in Business (2022) ✅ Rust 目前蓬勃发展，预测未来是很难的，但是 Rust 已经是进行时的未来了 🤣 ","date":"2023-12-28","objectID":"/posts/rust-introduction/:2:0","tags":["Rust","Sysprog"],"title":"Rust: 进行中的未来","uri":"/posts/rust-introduction/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Visualizing memory layout of Rust’s data types YouTube: Visualizing memory layout of Rust’s data types 影片的中文翻译： 可视化 Rust 各数据结构的内存布局 [bilibili] 可搭配阅读相关的文档： [2022-05-04] 可视化 Rust 各数据类型的内存布局 ","date":"2023-12-28","objectID":"/posts/rust-introduction/:3:0","tags":["Rust","Sysprog"],"title":"Rust: 进行中的未来","uri":"/posts/rust-introduction/"},{"categories":["Git","Linux Kernel Internals"],"content":"教学影片：Git 中文教学 ","date":"2023-12-27","objectID":"/posts/git-learn/:0:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"安装与设定 注意 ✅ 观看影片 Git 教学系列 - 安装与配置，完成常用的 Git 设置。 设置 Git 的编辑器为 vim，主要用于 commit 时的编辑： $ git config --global core.editor vim 设置 Git 的合并解决冲突工具为 vimdiff： $ git config --global merge.tool vimdiff 启用 Git 命令行界面的颜色显示： $ git config --global color.ui true 设置常用命令的别名： $ git config --global alias.st status $ git config --global alias.ch checkout $ git config --global alias.rst reset HEAD 效果为：命令 git st 等价于 git status，其余的类似。 设置 Windows 和 Mac/Linux 的换行符同步： # In Windows $ git config --global core.autocrlf true # In Mac/Linux $ git config --global core.autocrlf input 效果为：在 Windows 提交时自动将 CRLF 转为 LF，检出代码时将 LF 转换成 CRLF。在 Mac/Linux 提交时将 CRLF转为 LF，检出代码时不转换。这是因为 Windows 的换行符为 \\r\\n，而 Mac/Linux 的换行符仅为 \\n。 ","date":"2023-12-27","objectID":"/posts/git-learn/:1:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Add 和 Commit ","date":"2023-12-27","objectID":"/posts/git-learn/:2:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"指定 Commit 注意 ✅ 观看影片 Git 教学系列 - 指定 Commit，掌握 git log、git show、git diff 的常用方法。理解 Hash Value 和 commit 对于 Git 版本控制的核心作用。 只要 commit 了，资料基本不可能丢失，即使误操作了也是可以补救回来的（除非把 .git/ 文件夹也删除了）。 ","date":"2023-12-27","objectID":"/posts/git-learn/:3:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Hash Value Every commit has a unique hash value. Calculate by SHA1 Hash value can indicate a commit absolutely. ","date":"2023-12-27","objectID":"/posts/git-learn/:3:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Indicate Commit git manage references to commit HEAD Branch Tag Remote Also, We can indicate commit by ^, ~ 通俗地将，不论是 HEAD、Branch、Tag、Remote，其本质都是使用 Hash Value 进行索引的 commit，所以 ~ 和 ^ 也可以作用于它们。 可以通过 git log 来查看 commit 以及对应的 Hash 值。事实上，这个命令十分灵活，举个例子： git log 4a6ebc -n1 这个命令的效果是从 Hash 值为 4a6bc 的 commit 开始打印 1 条 commit 记录（没错，对应的是 -n1），因为 Git 十分聪明，所以 commit 对应的 Hash 值只需前 6 位即可（因为这样已经几乎不会发生 Hash 冲突）。 Examples 打印 master 分支的最新一个 commit： git log master -n1 打印 master 分支的最新一个 commit（仅使用一行打印 commit 信息）： git log master -n1 --oneline 打印 HEAD 所指向的 commit： git log HEAD -n1 --oneline 打印 HEAD 所指向的 commit 的前一个 commit： git log HEAD^ -n1 --oneline ^ 可以持续使用，比如 HEAD^^ 表示 HEAD 所指向的 commit 的前两个 commit。当 ^ 数量过多时，可以使用 ~ 搭配数字来达到相同效果。例如： git log HEAD^^^^^ -n1 --oneline git log HEAD~5 -n1 --oneline 一般来说，使用 ^ 就已经足够了，几乎不会遇到使用 ~ 的场景，因为这种场景一般会去找图形化界面吧。🤣 打印与文件 README.md 相关的 commits（仅使用一行显示）： git log --oneline README.md 打印与文件 README.md 相关的 commits（显示详细信息，包括文件内容的增减统计）： git log --stat README.md 打印与文件 README.md 相关的 commits（显示详细信息，包括文件内容的增减细节）： git log --patch README.md 在打印的 commit 信息中抓取与 README 符合的信息（可以与 --stat 或 --patch 配合使用）： git log -S README ","date":"2023-12-27","objectID":"/posts/git-learn/:3:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"View History git log \u003cpath\u003e|\u003ccommit\u003e -n: limit number --oneline: view hash and commit summary --stat: view files change --patch: view lines change -S or --grep: find modification ","date":"2023-12-27","objectID":"/posts/git-learn/:3:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"View Commit git show \u003ccommit\u003e Equal to log -n1 ","date":"2023-12-27","objectID":"/posts/git-learn/:3:4","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"See Difference 查看当前的修改，可以查看已经修改但没有 staged 文件的变化： git diff 查看当前的修改，可以查看已经修改且 staged 文件的变化： git diff --staged 查看当前与指定的 commit 的差异： git diff \u003ccommit\u003e # e.g. git diff master^ 查两个指定的 commit 之间的差异： git diff \u003ccommit\u003e \u003ccommit\u003e # e.g. git diff master^ master^^ ","date":"2023-12-27","objectID":"/posts/git-learn/:3:5","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Path Add and Amend 注意 ✅ 观看影片 Git 教学系列 - Patch Add and Amend，掌握 git add -p、git checkout -p、git add ---amend 的用法，使用 add 和 checkout 时强烈建议使用 -p，掌握修改 commit 的两种方法。 ","date":"2023-12-27","objectID":"/posts/git-learn/:4:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Only Add Related git add -p 推荐尽量使用这个 git add -p 而不是单纯的 git add。 使用 git add -p 后，Git 会帮我们把涉及的修改分成 section，然后我们就可以对每一个 section 涉及的修改进行 review，选择 y(yes) 表示采纳该 sction 对应的修改，选择 n(no) 表示不采纳。 如果觉得 section 切割的粒度太大了，可以选择 s(split) 来进行更细粒度的划分。如果这样仍然觉得粒度不够，可以选择 e(edit) 对 section 涉及的修改，进行以行为粒度的 review，具体操作可以查阅此时给出的提示。 还有一些其它的选项，比如 j、J、k、K，这些是类似 vim，用于切换进行 review 的 section，不太常用。q(quit) 表示退出。 由于可以针对一个文件的不同 section 进行 review，所以在进行 git add -p 之后，使用 git status 可以发现同一个文件会同时处于两种状态。 ","date":"2023-12-27","objectID":"/posts/git-learn/:4:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Checkout Also git checkout -p 这个操作比较危险，因为这个操作的效果与 git add -p 相反，如果选择 y 的话，文件涉及的修改就会消失，如果涉及的修改没有 commit 的话，那么涉及的修改是无法救回的。但是怎么说，这个操作还是比直接使用 git checkout 稍微保险一点，因为会先进入 review 界面，而不是直接撤销修改。所以，请一定要使用 git checkout -p！ ","date":"2023-12-27","objectID":"/posts/git-learn/:4:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Modify Commit 有两种方式来修改最新的 commit： # 1. Use git commit --amend git commit --amend # 2. Use reset HEAD^ then re-commit git reset HEAD^ git add -p git commit git commit --amend 并不是直接替换原有的 commit，而是创建了一个新的 commit 并重新设置了 HEAD 的指向。所以，新旧两个 commit 的 Hash Value 并不相同，事实上，如果你拥有旧 commit 的 Hash Value，是可以通过 git checkout \u003ccommit\u003e 切换到那个 commit 的。其原理如下图： 但是注意，git reset HEAD^ 是会撤销原先的 commit（仅限于本地 Git 存储库）。 ","date":"2023-12-27","objectID":"/posts/git-learn/:4:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Branch and Merge 注意 ✅ 观看影片 Git 教学系列 - Branch and Merge，掌握创建、删除、切换分支的用法，掌握合并分支、解决冲突的方法。 git checkout \u003ccommit\u003e git branch \u003cname\u003e git branch \u003cname\u003e \u003ccommit\u003e git branch [-d|-D] \u003cname\u003e git merge \u003cname\u003e --no-ff ","date":"2023-12-27","objectID":"/posts/git-learn/:5:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Move and Create Branch Checkout: move HEAD git checkout \u003ccommit\u003e: Move HEAD to commit git checkout \u003cpath\u003e: WARNING: discard change 可以将路径上的文件复原到之前 commit 的状态。 Branch: git branch: List branch git branch \u003cname\u003e: Create branch Or just: git checkout -b Examples 修改一个文件并恢复： # modify file load.cpp git status git checkout load.cpp git status 删除一个文件并恢复： rm load.cpp git status git checkout load.cpp git status 正如上一节所说的，git checkout 尽量带上 -p 参数，因为如果一不小心输入了 git checkout .，那就前功尽弃了。 显示分支： # only show name git branch # show more infomation git branch -v 切换分支： # switch to branch 'main' git checkout main 创建分支： # 1. using `git branch` git branch cload # 2. using `git checkout -b` git checkout -b asmload # 3. create a new branch in \u003ccommit\u003e git branch cload \u003ccommit\u003e 切换到任一 commit： git checkout \u003ccommit\u003e 直接 checkout 到任一 commit 会有警告，这是因为，当你以该 commit 为基点进行一系列的 commit，这些新的 commit 会在你切换分支后消失，因为没有 branch 来引用它们。之前可以被引用是因为 HEAD 引用，切换分支后 HEAD 不再引用这些 commit，所以就会消失。在这种情况，Git 会在发出警告的同时建议我们使用 git branch 来创建分支进行引用。 ","date":"2023-12-27","objectID":"/posts/git-learn/:5:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"View Branch 列出仓库的所有分支： git branch 也可以通过 log 来查看分支： git log --decorate: 在 log 的首行显示所有的 references（可能需要通过 git config log.decorate auto 来开启） --graph: 以图形化的方式显示 branch 的关系（主要是 commit 的引用） ","date":"2023-12-27","objectID":"/posts/git-learn/:5:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Delete Branch 删除分支： git branch -d \u003cname\u003e 对于有没有 merge 的 commit 的分支，Git 会警告，需要使用 -D 来强制删除： git branch -D \u003cname\u003e for no-merge commit WARNING: Discard Commit Git 会发出警告的原因同样是 no-merge commit 在删除分支后就无法被引用，所以会发出警告。 ","date":"2023-12-27","objectID":"/posts/git-learn/:5:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Merge 合并分支。默认使用 fast-forward，即如果没有冲突，直接将要合并的分支提前到被合并分支的 commit 处，而不会另外生成一个 merge commit。但这样会使得被合并的分支在合并后，没有历史痕迹。可以通过 --no-ff (no fast forward) 来强制生成 merge commit。推荐使用 merge 时加上 --no-ff 这个参数。 git merge \u003cbranch\u003e 通常是 main/master 这类主分支合并其它分支： git checkout main/master git merge \u003cbranch\u003e ","date":"2023-12-27","objectID":"/posts/git-learn/:5:4","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Resolve Conflict Manually resolve: Check every codes between \u003c\u003c\u003c\u003c\u003c\u003c\u003c, \u003e\u003e\u003e\u003e\u003e\u003e\u003e Edit code to what it should be Use mergetool like vimdiff: It shows: local, base, remote, file to be edited Edit “file ro be edited” to what is should be Add and Commit # 1. 合并分支 git merge \u003cbranch\u003e # 2. 检查状态，查看 unmerged 的文件 git status # 3. 编辑 unmerged 文件，编辑冲突区域代码即可 vim \u003cfile\u003e # 4. 添加解决完冲突的文件 git add \u003cfile\u003e # 5. 进行 merge commit git commit 冲突区域就是 \u003c\u003c\u003c\u003c\u003c\u003c\u003c 和 \u003e\u003e\u003e\u003e\u003e\u003e\u003e 内的区域，在 merge 操作后，Git 已经帮我们把 unmerged 文件修改为待解决冲突的状态，直接编辑文件即可。在编辑完成后，需要手动进行 add 和 commit，此次 commit 的信息 Git 已经帮我们写好了，一般不需要修改。 如果使用的是 mergetool，以 vimdiff 为例，只需将第 3 步的 vim \u003cfile\u003e 改为 git mergetool 即可。vimdiff 会提供 4 个视窗：底部视窗是我们的编辑区，顶部左边是当前合并分支的状态，顶部中间是 base (合并分支和被合并的共同父节点) 的状态，顶部右边是 remote 的状态，按需要选择、编辑。 vimdiff 在编辑完后会保留 *.orig 的文件，这个文件是待解决冲突的文件副本。 ","date":"2023-12-27","objectID":"/posts/git-learn/:5:5","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Merge Conflict Prevent very long development branch. Split source code clearly. ","date":"2023-12-27","objectID":"/posts/git-learn/:5:6","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Rebase 注意 ✅ 观看影片 Git 教学系列 - Branch and Merge，掌握 TODO 的方法。git rebase 是 Git 的精华，可以让我们实现更细粒度的操作，可以说学会了 rebase 才算真正入门了 Git。 这个视频讲得比较乱，所以推荐配合视频给出的参考文章 Git-rebase 小笔记 来学习。 ","date":"2023-12-27","objectID":"/posts/git-learn/:6:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Linux Distribution"],"content":"网络代理 根据项目 clash-for-linux-backup 来配置 Ubuntu 的网络代理。 $ git clone https://github.com/Elegybackup/clash-for-linux-backup.git clash-for-linux 过程当中可能需要安装 curl 和 net-tools，根据提示进行安装即可： sudo apt install curl sudo apt install net-tools 安装并启动完成后，可以通过 localhost:9090/ui 来访问 Dashboard。 启动代理： $ cd clash-for-linux $ sudo bash start.sh $ source /etc/profile.d/clash.sh $ proxy_on 关闭代理： $ cd clash-for-linux $ sudo bash shutdown.sh $ proxy_off ","date":"2023-12-27","objectID":"/posts/ubuntu22.04lts/:1:0","tags":["Linux","Ubuntu"],"title":"Ubuntu 22.04LTS 相关配置","uri":"/posts/ubuntu22.04lts/"},{"categories":["Linux Distribution"],"content":"搜狗输入法 根据 搜狗输入法 Linux 安装指导 来安装搜狗输入法。 无需卸载系统 ibus 输入法框架。 通过 Ctrl + space 唤醒搜狗输入法。 ","date":"2023-12-27","objectID":"/posts/ubuntu22.04lts/:2:0","tags":["Linux","Ubuntu"],"title":"Ubuntu 22.04LTS 相关配置","uri":"/posts/ubuntu22.04lts/"},{"categories":["Linux Distribution"],"content":"快捷键 新建终端： Ctrl + Alt + T 锁屏： Super + L：锁定屏幕并熄屏。 显示桌面： Super + d 或者 Ctrl + Alt + d 最小化所有运行的窗口并显示桌面，再次键入则重新打开之前的窗口。 显示所有的应用程序： Super + a 可以通过 ESC 来退出该显示。 显示当前运行的所有应用程序： Super 移动窗口位置： Super + 左箭头：当前窗口移动到屏幕左半边区域 Super + 右箭头：当前窗口移动到屏幕右半边区域 Super + 上箭头：当前窗口最大化 Super + 下箭头：当前窗口恢复正常 隐藏当前窗口到任务栏： Super + h 切换当前的应用程序： Super + Tab：以应用程序为粒度显示切换选项 Alt + Tab：以窗口为粒度显示切换选项 切换虚拟桌面/工作区： Ctrl + Alt + 左/右方向键 自定义键盘快捷键： Settings -\u003e Keyboard -\u003e Keyboard Shortcus | View and Customize Shortcuts -\u003e Custom Shortcuts ","date":"2023-12-27","objectID":"/posts/ubuntu22.04lts/:3:0","tags":["Linux","Ubuntu"],"title":"Ubuntu 22.04LTS 相关配置","uri":"/posts/ubuntu22.04lts/"},{"categories":["Linux Kernel Internals"],"content":" 摘要 GNU/Linux 开发工具，几乎从硬件到软件，Linux 平台能够自下而上提供各类触及“灵魂”的学习案例，让所有课程从纸上谈兵转变成沙场实战，会极大地提升工程实践的效率和技能。 原文地址 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:0:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"安装 Windows / Ubuntu 双系统 因为有些操作必须在物理硬件上才能执行。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:1:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Markdown 与 LaTeX 速览 LaTeX 语法示例一节，作为工具书册，在需要使用时知道如何查询。 速览 Markdown 语法示例一节，作为工具书册，在需要使用时知道如何查询。 注意 编写 Markdown 文本以及 LaTeX 语法表示的数学式可以通过： Hugo + FixIt ✅ VS Code + Markdown Preview Enhanced ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:2:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Git 和 Github 阅读 SSH key 产生方法一节，配置好 Git 和 Github 的 SSH key。同时也可作为工具书册，在需要使用时知道如何查询。 推荐通过 LearnGitBranching 来熟悉 Git 命令！！！ 以下资源作为自学资源，用于补充自己不熟悉的操作，或者作为以上资料的补充工具手册。 Git 中文教学 - YouTube (学习记录) 30 天精通 Git 版本控制 - GitHub 警告 原文档中的将公钥复制到 clipboard 中使用了 clip 命令，但是这个命令在 Ubuntu 中并没有对应的命令。可以使用 xclip + alias 达到近似效果。 $ sudo apt install xclip # using alias to implement clip, you can add this to bashrc $ alias clip='xclip -sel c' $ clip \u003c ~/.ssh/id_rsa.pub ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:3:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"编辑器: Visual Studio Code 认真阅读，跟随教学文档进行安装、设置。重点阅读 设定、除错（调试） 这两部分。更新 VS Code 部分作为手册，在需要时进行参考。 以下资源作为自学资源，用于补充自己不熟悉的操作，或者作为以上资料的补充工具手册。 开开心心学 Vistual Studio Code 完成 SSH key 的生成。 完成 VS Code 的设置。 安装 Git History 插件。 安装 Native Debug 插件，并进行 Debug (test-stopwatch.c) 操作。 安装 VSCode Great Icons 文件图标主题，另外推荐两款颜色主题：One Dark Pro, Learn with Sumit。 VS Code 控制台使用说明： 可以在面板的输出，点击 GIT 选项显示 VS Code 背后执行的 git 命令。 可以使用 ctrl + shift + P 呼出命令区，然后通过输入 Git branch 和 Git checkout 等并选择对应选项，来达到创建分支、切换分支等功能。 技巧 在 VS Code 设置中，需要在设置中打开 Open Default Settings 选项才能在左侧面板观察到预设值。键位绑定同理。 要想进行调试，需要在使用 gcc 生成目标文件时，加入 -g 参数来生产调试信息。 原文档中的 GDB 教学链接-除错程式-gdb 已失效，这是目前的有效链接。也可通过该影片 拯救资工系学生的基本素养-使用 GDB 除错基本教学 来补充学习 GDB 的操作。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:4:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"终端和 Vim 认真阅读，跟随教学影片 快快乐乐学 Vim 和教学文档配置好 终端提示符、Vim。 完成命令行提示符配置 完成 Vim 的设定 安装并使用 Minial Vim Plugin Manager 来管理 Vim 插件 (neocomplcache, nerdtree) 安装并使用 byobu 来管理多个终端视图。 技巧 在 .vimrc 中增加插件后，打开 vim，执行 :PlugInstall 来安装插件，完成后在 vim 执行 :source ~/.vimrc。（可以通过 :PlugStatus 来查看插件安装状态） 使用 F4 键来[显示/不显示][行数/相对行数]。 使用 F5 键来呼入/呼出文件树(nerdtree)，在文件树恻通过 ENTER 键来访问目录/文件。 使用 Ctrl-w-h/Ctrl-w-l 切换到 文件树/编辑区。 自动补全时使用 ENTER 键来选中，使用方向键或 Ctrl-N/Ctrl-U/Ctrl-P 来上下选择。 在 Vim 中可以通过 :set paste，并在 insert 模式下，将粘贴板的内容通过 Ctrl-Shift-V 进行粘贴。 byobu 使用说明： 在终端输入 byobu F2 新增 Terminial 分页。F3, F4 在 Terminial 分页中切换。Ctrl +F6 删除当前 Terminial 分页。 Shift + F2 水平切割 Terminial。Ctrl +F2 垂直切割 Terminial。Shift + 方向键 切换。 在 byobu 中暂时无法使用之前设置的 F4 或 F5 快捷键，但是可以直接通过命令 :set norelative 来关闭相对行数。 推荐观看影片 How to Do 90% of What Plugins Do (With Just Vim) 来扩展 Vim 插件的使用姿势。 以下资源为 Cheat Sheet，需要使用时回来参考即可。 Vim Cheat Sheet Bash terminal Cheat Sheet ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:5:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Makefile 速览教学文档，作为工具书册，在需要使用时知道如何查询。 gcc 的 -MMD 和 -MF 参数对我们编写 Makefile 是一个巨大利器。理解 Makefile 的各种变量定义的原理。 对之前的 test-stopwatch.c 编写了一个 Makefile 来自动化管理。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:6:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Linux 性能分析工具: Perf 认真阅读，复现教学文档中的所有例子，初步体验 perf 在性能分析上的强大。 安装 perf 并将 kernel.perf_event_paranoid 设置为 1。 动手使用 perf_top_example.c，体验 perf 的作用。 搭配影片: Branch Prediction 对照阅读: Fast and slow if-statements: branch prediction in modern processors 编译器提供的辅助机制: Branch Patterns, Using GCC 动手使用 perf_top_while.c，体验 perf top 的作用。 动手使用 perf_stat_cache_miss.c，体验 perf stat 的作用。（原文的结果有些不直观，务必亲自动手验证） 动手使用 perf_record_example.c，体验 perf record 的作用。（原文的操作不是很详细，可以参考下面的 Success） Source 成功 $ perf record -e branch-misses:u,branch-instructions:u ./perf_record_example [ perf record: Woken up 1 times to write data ] [ perf record: Captured and wrote 0.009 MB perf.data (94 samples) ] 输出第一行表示 perf 工具在收集性能数据时被唤醒了 1 次，以将数据写入输出文件。 输出第二行表示 perf 工具已经取样并写入了一个名为 perf.data 的二进制文件，文件大小为 0.009 MB，其中包含了 94 个采样。（可以通过 ls 命令来检查 perf.data 文件是否存在） 接下来通过 perf report 对之前输出的二进制文件 perf.data 进行分析。可以通过方向键选择，并通过 ENTER 进入下一层查看分析结果。 $ perf report Available samples 5 branch-misses:u 89 branch-instructions:u 技巧 perf 需要在 root 下进行性能分析。 perf top 是对于哪个程序是性能瓶颈没有头绪时使用，可以查看哪个程序（以及程序的哪个部分）是热度点。 在 perf top 时可以通过 h 键呼出帮助列表。 可以通过方向键选择需要进一步分析的部分，并通过 a 键来查看指令级别粒度的热点。 perf stat 是对某一个要优化的程序进行性能分析，对该程序涉及的一系列 events 进行取样检查。 perf record 的精度比 perf stat 更高，可以对取样的 events 进行函数粒度的分析。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:7:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Linux 绘图工具: gnuplot 阅读教程，搭配教学影片 轻轻松松学 gnuplot，使用 gnuplot 完成所给例子相应图像的绘制。 使用 runtime.gp 完成 runtime.png 的绘制生成。 使用 statistic.gp 完成降雨量折线图 statistic.png 的绘制生成。 注意 原文所给的 statistic.gp 是使用 Times_New_Roman 来显示中文的，但笔者的 Ubuntu 中并没有这个字体，所以会显示乱码。可以通过 fc-list :lang=zh 命令来查询当前系统中的已安装的中文字体。 Source 安装 gnuplot: $ sudo apt-get install gnuplot gnuplot script 的使用流程： # 创建并编写一个后缀名为 .gp 的文件 $ vim script.gp # 根据 script 内的指令进行绘图 $ gnuplot script.gp # 根据 script 指定的图片保存路径打开图片 $ eog [name of picture] 下面以一个 script 进行常用指令的说明： reset set ylabel 'time(sec)' set style fill solid set title 'performance comparison' set term png enhanced font 'Verdana,10' set output 'runtime.png' plot [:][:0.100]'output.txt' using 2:xtic(1) with histogram title 'original', \\ '' using ($0-0.06):($2+0.001):2 with labels title ' ', \\ '' using 3:xtic(1) with histogram title 'optimized' , \\ '' using 4:xtic(1) with histogram title 'hash' , \\ '' using ($0+0.3):($3+0.0015):3 with labels title ' ', \\ '' using ($0+0.4):($4+0.0015):4 with labels title ' ' reset 指令的作用为，将之前 set 指令设置过的内容全部重置。 set style fill solid 将绘制出的柱形或区域使用实心方式填充。 set term png enhanced font 'Verdana,10' term png 生成的图像以 png 格式进行保存。(term 是 terminial 的缩写) enhanced 启用增强文本模式，允许在标签和注释中使用特殊的文本格式，如上下标、斜体、下划线等。 font 'Verdana,10' 指定所使用的字体为 Verdana，字号为10。可进行自定义设置。 其它指令查询原文或手册即可。 $0 在 gnuplot 中表示伪列，可以简单理解为行号，以下为相应图示： 原始数据集： append() 0.048240 0.040298 0.057908 findName() 0.006495 0.002938 0.000001 （人为）增加了 伪列 表示的数据集（最左边 0, 1 即为伪列）： 0 append() 0.048240 0.040298 0.057908 1 findName() 0.006495 0.002938 0.000001 技巧 gnuplot 在绘制生成图像时是安装指令的顺序进行的，并且和一般的画图软件类似，在最上层进行绘制。所以在编写 script 的指令时需要注意顺序，否则生成图像的部分可能并不像预期一样位于最上层。（思考上面 script 的 3, 4 列的 label 的绘制顺序） gnuplot script 中的字符串可以使用 '' 或者 \"\" 来包裹，同样类似于 Python。 直接在终端输入 gnuplot 会进入交互式的命令界面，也可以使用 gnulpot 指令来绘图（类似与 Python）。在这种交互式界面环境中，如果需要在输入完指令后立即显示图像到新窗口，而不是保存图像再打开，只需输入进行指令： set term wxt ehanced persist raise term wxt 将图形终端类型设置为WXT，这会在新窗口中显示绘图。 ersist 该选项使绘图窗口保持打开状态，即使脚本执行完毕也不会自动关闭。 raise 该选项将绘图窗口置于其他窗口的前面，以确保它在屏幕上的可见性。 一些额外的教程： Youtube - gnuplot Tutorlal 这个教程有五部影片，到发布者的主页搜寻即可。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:8:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Graphviz 官方网站 安装: $ sudo apt install graphviz 第一周的 linked list 专项测验题会大量使用到。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:9:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"其它工具 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:10:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"cloc man 1 cloc NAME cloc - Count, or compute differences of, lines of source code and comments. SYNOPSIS cloc [options] \u003cFILE|DIR\u003e ... DESCRIPTION Count, or compute differences of, physical lines of source code in the given files (may be archives such as compressed tarballs or zip files, or git commit hashes or branch names) and/or recursively below the given directories. It is written entirely in Perl, using only modules from the standard distribution. ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:10:1","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"top man 1 top NAME top - display Linux processes SYNOPSIS top -hv|-bcEeHiOSs1 -d secs -n max -u|U user -p pids -o field -w [cols] The traditional switches `-' and whitespace are optional. DESCRIPTION The top program provides a dynamic real-time view of a running system. It can display system summary information as well as a list of processes or threads currently being managed by the Linux kernel. The types of system summary information shown and the types, order and size of information displayed for processes are all user configurable and that configuration can be made persistent across restarts. The program provides a limited interactive interface for process manipulation as well as a much more extensive interface for personal configuration -- encompassing every aspect of its operation. And while top is referred to throughout this document, you are free to name the program anything you wish. That new name, possibly an alias, will then be reflected on top's display and used when reading and writing a configuration file. ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:10:2","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"htop man 1 htop NAME htop - interactive process viewer SYNOPSIS htop [-dCFhpustvH] DESCRIPTION htop is a cross-platform ncurses-based process viewer. It is similar to top, but allows you to scroll vertically and horizontally, and interact using a pointing device (mouse). You can observe all processes running on the system, along with their command line arguments, as well as view them in a tree format, select multiple processes and act‐ ing on them all at once. Tasks related to processes (killing, renicing) can be done without entering their PIDs. ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:10:3","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Mathematics"],"content":" 中大數學系開放式課程 台大齐震宇 - 数学潜水艇、微积分、分析 台大谢铭伦 - 线性代数 ","date":"2023-12-23","objectID":"/posts/math/:0:0","tags":["Mathematics"],"title":"数学开放式课程学习指引","uri":"/posts/math/"},{"categories":["Mathematics"],"content":"概率统计 阳明交通大学 陈临安老师，开设了两学期的统计课程，分别是上学期的 统计学 和下学期的 高等统计学。 课程名称 英文名称 课程地址 课程视频 统计学 Statistics 课程资讯 YouTube 高等统计学 Advanced Statistics 课程资讯 YouTube 信息 这两个学期课程的作业、习题以及解答都可以在 这里 找到。 ","date":"2023-12-23","objectID":"/posts/math/:1:0","tags":["Mathematics"],"title":"数学开放式课程学习指引","uri":"/posts/math/"},{"categories":["draft"],"content":"博客（英语：Blog）是一种在线日记型式的个人网站，借由张帖子章、图片或视频来记录生活、抒发情感或分享信息。博客上的文章通常根据张贴时间，以倒序方式由新到旧排列。 ","date":"2023-12-23","objectID":"/posts/hello_world/:0:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"数学公式 行内公式：$N(b,d)=(b-1)M$ 公式块： $$ \\int_{a}^{b}x(t)dt = \\dfrac{b - a}{N} \\\\ =\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} $$ $$ \\begin{aligned} \\int_{a}^{b}x(t)dt \u0026= \\dfrac{b - a}{N} \\\\ \u0026=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} \\\\ \\end{aligned} $$ $$ \\mathrm{Integrals\\ are\\ numerically\\ approximated\\ as\\ finite\\ series}:\\\\ \\begin{split} \\int_{a}^{b}x(t)dt \u0026= \\dfrac{b - a}{N} \\\\ \u0026=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} \\end{split} \\\\ where\\ t_k = a + (b-a)\\cdot k/N $$ $$ \\begin{align*} p(x) = 3x^6 + 14x^5y \u0026+ 590x^4y^2 + 19x^3y^3 \\\\ \u0026- 12x^2y^4 - 12xy^5 + 2y^6 - a^3b^3 - a^2b - ab + c^5d^3 + c^4d^3 - cd \\end{align*} $$ $$ \\begin{split} \u0026(X \\in B) = X^{-1}(B) = {s \\in S: X(s) \\in B} \\subset S \\\\ \u0026\\Rightarrow P(x \\in B) = P({s \\in S: X(s) \\in B}) \\end{split} $$ ","date":"2023-12-23","objectID":"/posts/hello_world/:1:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"代码块 let i: i32 = 13; let v = vec![1, 2, 3, 4, 5, 65]; for x in v.iter() { println!(\"{}\", x); } typedef struct Block_t { int head; int data; } Block_t; ","date":"2023-12-23","objectID":"/posts/hello_world/:2:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"Admonition 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 ","date":"2023-12-23","objectID":"/posts/hello_world/:3:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"References FixIt 快速上手 使用 Hugo + Github 搭建个人博客 Emoji 支持 扩展 Shortcodes 概述 URL management ","date":"2023-12-23","objectID":"/posts/hello_world/:4:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"}]