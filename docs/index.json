<<<<<<< HEAD
[{"categories":["Linux Kernel Internals"],"content":"\r摘要\r大型开源项目的规模十分庞大，例如使用 Rust 编写的 Servo 浏览器，这个项目有近十万行代码。在开发规模如此庞大的项目时，了解如何通过正确的方式进行调试非常重要，因为这样可以帮助开发者快速地找到瓶颈。\r原文地址 | 教学视频 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:0:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rGDB 调试观看教学视频 拯救資工系學生的基本素養—使用 GDB 除錯基本教學 和搭配博文 ==[How to debug Rust/C/C++ via GDB][debug-gdb]==，学习 GDB 的基本操作和熟悉使用 GDB 调试 Rust/C/C++ 程序。 掌握 run/r, break/b, print/p, continue/c, step/s info/i, delete/d, backtrace/bt, frame/f, up/down, exit/q 等命令的用法。以及 GBD 的一些特性，例如 GDB 会将空白行的断点自动下移到下一代码行；使用 break 命令时可以输入源文件路径，也可以只输入源文件名称。 相关的测试文件： test.c hello_cargo/ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:1:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rGDB 基本介绍\r引用\r“GDB, the GNU Project debugger, allows you to see what is going on ‘inside’ another program while it executes — or what another program was doing at the moment it crashed.” — from gnu.org\r安装 GDB: $ sudo apt install gdb LLDB 与 GDB 的命令类似，本文也可用于 LLDB 的入门学习。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:2:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rGDB 调试 C/C++要使用 GDB 来调试 C/C++，需要在编译时加上 -g 参数，例如： $ gcc test.c -g -o test $ gdb ./test Source ","date":"2024-01-16","objectID":"/posts/debug-gdb/:3:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rGDB 调试 Rust在使用 build 命令构建 debug 目标文件（即位于 target/debug 目录下的目标文件，与 package 同名）后，就可以通过 gdb 来进行调试： $ cargo build $ gdb ./target/debug/\u003cpackage name\u003e 但是如果是使用 cargo build --release 构建的 release 目标文件（即位于 target/release 目录下的目标文件），则无法使用 GDB 进行调试，因为 release 目标未包含任何调试信息，类似于未使用 -g 参数编译 C/C++ 源代码。 Source ","date":"2024-01-16","objectID":"/posts/debug-gdb/:4:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rGDB 基本命令","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rrunrun (r) 命令用于从程序的执行起始点开始执行，直到遇到下一个断点或者程序结束。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:1","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rcontinuecontinue (c) 命令用于从当前停止的断点位置处继续执行程序，直到遇到下一个断点或者程序结束。 注意\rrun 和 continue 的区别在于 run 是将程序从头开始执行。例如如果未设置任何断点，使用 run 可以反复执行程序，而如果使用 continue 则会提示 The program is not being run。\r","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:2","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rstepstep (s) 命令用于 逐行 执行程序，在遇到函数调用时进入对应函数，并在函数内部的第一行暂停。step 命令以 单步方式 执行程序的每一行代码，并跟踪函数调用的进入和退出。 (gdb) step 6 bar += 3; (gdb) step 7 printf(\"bar = %d\\n\", bar); 注意\rstep 命令与 continue 命令相同，只能在程序处于运行态（即停留在断点处）时才能使用。\r","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:3","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rbreakbreak (b) 命令用于在可执行问卷对应的源程序中加入断点，可以在程序处于 未运行态/运行态 时加入断点（运行态是指程序停留在断点处但未执行完毕的姿态）。 可以通过指定源文件对应的 行数/函数名 来加入断点： (gdb) break test.c:7 (gdb) break test.c:foo 如果可执行文件由多个源文件编译链接得到，可以通过指定 源文件名字 的方式来加入断点，无需源文件路径，但如果不同路径有重名源文件，则需要指定路径来区分： (gdb) break test1.c:7 (gdb) break test2.c:main ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:4","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rprintprint (p) 命令用于在调试过程中打印 变量的值或 表达式 的结果，帮助开发者检查程序状态并查看特定变量的当前值。 # Assume x: 3, y: 4 (gdb) print x $1 = 3 (gdb) print x + y $2 = 7 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:5","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rbacktracebacktrace (bt) 命令用于打印当前调用栈的信息，也称为堆栈回溯 (backtrace)。它显示了程序在执行过程中经过的函数调用序列，以及每个函数调用的位置和参数，即可以获取以下信息： 函数调用序列：显示程序当前的函数调用序列，以及每个函数的名称和所在的源代码文件。 栈帧信息：对于每个函数调用，显示该函数的栈帧信息，包括栈帧的地址和栈帧的大小。 (gdb) backtrace (gdb) backtrace #0 foo () at test.c:7 #1 0x00005555555551d2 in main () at test.c:14 技巧\rbacktrace 命令对于跟踪程序的执行路径、检查函数调用的顺序以及定位错误非常有用。在实际中，一般会搭配其他GDB命令（如 up、down 和 frame）结合使用，以查看特定栈帧的更多详细信息或切换到不同的栈帧。在上面的例子中，#0 和 #1 表示栈帧的编号，可以通过 frame 配合这些编号来切换栈帧。\r","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:6","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rframeframe (f) 命令用于选择特定的栈帧 (stack frame)，从而切换到不同的函数调用上下文，每个栈帧对应于程序中的一个函数调用。 接着上一个例子，切换到 main 函数所在的栈帧： (gdb) frame 1 #1 0x00005555555551d2 in main () at test.c:14 14 int result = foo(); ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:7","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rup/downup 和 down 命令用于在调试过程中在不同的栈帧之间进行切换： up 用于在调用栈中向上移动到较高的栈帧，即进入调用当前函数的函数。每次执行 up 命令，GDB 将切换到上一个（更高层次）的栈帧。这可以用于查看调用当前函数的上层函数的执行上下文。 down 用于在调用栈中向下移动到较低的栈帧，即返回到当前函数调用的函数。每次执行 down 命令，GDB 将切换到下一个（较低层次）的栈帧。这可以用于返回到调用当前函数的函数的执行上下文。 这两个命令需要开发者对应函数调用堆栈的布局有一定程度的了解。 接着上一个例子： (gdb) up #1 0x00005555555551d2 in main () at test.c:14 14 int result = foo(); (gdb) down #0 foo () at test.c:7 7 printf(\"bar = %d\\n\", bar); ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:8","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rinfoinfo (i) 命令用于获取程序状态和调试环境的相关信息，该命令后面可以跟随不同的子命令，用于获取特定类型的信息。 一些常用的 info 子命令： info breakpoints 显示已设置的所有断点 (breakpoint) 信息，包括断点编号、断点类型、断点位置等。 info watchpoints 显示已设置的所有监视点 (watchpoint) 信息，包括监视点编号、监视点类型、监视的表达式等。 info locals 显示当前函数的局部变量的值和名称。 info args 显示当前函数的参数的值和名称。 info registers 显示当前 CPU 寄存器的值。 info threads 显示当前正在调试的所有线程 (thread) 信息，包括线程编号、线程状态等。 info frame 显示当前栈帧 (stack frame) 的信息，包括函数名称、参数、局部变量等。 info program 显示被调试程序的相关信息，例如程序入口地址、程序的加载地址等。 (gdb) info breakpoints # or simply: i b Num Type Disp Enb Address What 1 breakpoint keep y 0x000055555555518f in foo at test.c:7 2 breakpoint keep y 0x0000555555555175 in foo at test.c:4 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:9","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rdeletedelete (d) 命令用于删除断点 (breakpoint) 或观察点 (watchpoint)。断点是在程序执行期间暂停执行的特定位置，而观察点是在特定条件满足时暂停执行的位置。 可以通过指定 断点 / 观察点 的编号或使用 delete 命令相关的参数，来删除已设置的断点 / 观察点。断点 / 观察点编号可以在使用 info breakpoints / info watchpoints 命令时获得。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:10","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\rquitquit (q) 命令用于退出 GDB，返回终端页面。 (gdb) quit $ # Now, in the terminial ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:11","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\r其他如果被调试程序正处于运行态（即已经通过 run 命令来运行程序），此时可以通过 Ctrl+C 来中断 GDB，程序将被立即中断，并在中断时所运行到的地方暂停。这种方式被称为 手动断点，手动断点可以理解为一个临时断点，只会在该处暂停一次。 GDB 会将空白行的断点自动下移到下一非空的代码行。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:12","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"\r引用\r「指针」 扮演 「记忆体」 和 「物件」 之间的桥梁\r原文地址 直播录影(上) 直播录影(下) ","date":"2024-01-14","objectID":"/posts/c-pointer/:0:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"\r前言杂谈Let’s learn programming by inventing it [CppCon 2018] ✅ 注意\r在 K\u0026R 一书中，直到 93 页才开始谈论 pointer，而全书总计 185 页，所以大概是在全书 $50.27\\%$ 的位置才开始讲 pointer。所以即使不学 pointer，你还是能够掌握 $~50\\%$ 的 C 语言的内容，但是 C 语言的核心正是 pointer，所以 Good Luck 🤣\rgodbolt 可以直接在网页上看到，源代码由各类 compiler 生成的 Assembly Code How to read this prototype? [Stack Overflow] ✅ 注意\r这个问题是关于 signal 系统调用的函数原型解读，里面的回答页给出了很多对于指针，特别是 函数指针 的说明，下面节选一些特别有意思的回答： The whole thing declares a function called signal: signal takes an int and a function pointer this function pointer takes an int and returns void signal returns a function pointer this function pointer takes an intand returns avoid` That’s where the last int comes in. You can use the spiral rule to make sense of such declarations, or the program cdecl(1). 这里面提到了 the spiral rule 这是一个用于解析 C 语言中声明 (declaration) 的方法；另外还提到了 cdecl 这一程序，它也有类似的作用，可以使用英文进行声明或者解释。 Find the leftmost identifier and work your way out, remembering that [] and () bind before *; IOW, *a[] is an array of pointers, (*a)[] is a pointer to an array, *f() is a function returning a pointer, and (*f)() is a pointer to a function. Thus, void ( *signal(int sig, void (*handler)(int)) ) (int); breaks down as signal -- signal signal( ) -- is a function signal( sig ) -- with a parameter named sig signal(int sig, ) -- of type int signal(int sig, handler ) -- and a parameter named handler signal(int sig, *handler ) -- which is a pointer signal(int sig, (*handler)( )) ) -- to a function signal(int sig, (*handler)(int)) ) -- taking an int parameter signal(int sig, void (*handler)(int)) ) -- and returning void *signal(int sig, void (*handler)(int)) ) -- returning a pointer ( *signal(int sig, void (*handler)(int)) )( ) -- to a function ( *signal(int sig, void (*handler)(int)) )(int) -- taking an int parameter void ( *signal(int sig, void (*handler)(int)) )(int); -- and returning void 这一回答强调了 * 和 []、() 优先级的关系，这在判断数组指针、函数指针时是个非常好用的技巧。 Rob Pike 于 2009/10/30 的 Golang Talk [PDF] David Brailsford 教授解说影片 Essentials: Pointer Power! - Computerphile [YouTube] ","date":"2024-01-14","objectID":"/posts/c-pointer/:1:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"\r阅读 C 语言规格书一手资料的重要性毋庸置疑，对于 C 语言中的核心概念 指针，借助官方规格书清晰概念是非常重要的。 C99 [6.2.5] Types Array, function, and pointer types are collectively called derived declarator types. A declarator type derivation from a type T is the construction of a derived declarator type from T by the application of an array-type, a function-type, or a pointer-type derivation to T. derived declarator types 表示衍生的声明类型，因为 array, function, pointer 本质都是地址，所以可以使用这些所谓的 derived declarator types 来提前声明 object，表示在某个地址会存储一个 object，这也是为什么这些类型被规格书定义为 derived declarator types。 lvalue: Location value rvalue: Read value 危险\rC 语言里只有 call by value\r","date":"2024-01-14","objectID":"/posts/c-pointer/:2:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"\rvoid \u0026 void *C89 之前，函数如果没有标注返回类型，则默认返回类型 int，返回值 0。但由于这样既可以表示返回值不重要，也可以表示返回值为 0，这会造成歧义，所以引进了 void。 void * 只能表示地址，而不能对所指向的地址区域的内容进行操作。因为通过 void * 无法知道所指向区域的 size，所以无法对区域的内容进行操作，必须对 void * 进行 显示转换 才能操作指向的内容。（除此之外，对于指针本身的操作，void * 与 char * 是等价的） Alignment 原文描述不是很清晰，2-byte aligned 图示如下： 如果是 2-byte aligned 且是 little-endian 的处理器，对于左边，可以直接使用 *(uint16_t *) ptr，但对于右边就无法这样（不符合 alignment）： /* may receive wrong value if ptr is not 2-byte aligned */ uint16_t value = *(uint16_t *) ptr; /* portable way of reading a little-endian value */ uint16_t value = *(uint8_t *) ptr | ((*(uint8_t *) (ptr + 1)) \u003c\u003c 8); 因为内存寻址的最小粒度是 Byte，所以使用 (uint_8 *) 不需要担心 alignment 的问题。原文并没有给出 32-bit aligned 的 portable way，我们来写一下： /* may receive wrong value if ptr is not 2-byte aligned */ uint32_t value = *(uint32_t *) ptr; /* portable way of reading a little-endian value */ uint32_t value = *(uint8_t *) ptr | ((*(uint8_t *) (ptr + 1)) \u003c\u003c 8) | ((*(uint8_t *) (ptr + 2)) \u003c\u003c 16) | ((*(uint8_t *) (ptr + 3)) \u003c\u003c 24); 信息\rThe Lost Art of Structure Packing ","date":"2024-01-14","objectID":"/posts/c-pointer/:3:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["C"],"content":"C 语言规格书 Chapter 6 - Language 阅读记录。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:0:0","tags":["C","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"\r6.2 Concepts","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:1:0","tags":["C","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"\r6.2.2 Linkages of identifierslinkage: external internal none 一个拥有 file scope 并且关于 object 或 function 的 identifier 声明，如果使用 static 修饰，则该 identifer 有 internal linkage，e.g. // file scope static int a; static void f(); int main() {} 一个 scope 内使用 static 修饰的 identifier 声明，如果在同一 scope 内已存在该 identifier 声明，则该 identifier 的 linkage 取决于先前的 identifier 声明。如果该 identifier 不存在先前声明或者先前声明 no linkage，则该 identifier 是 external linkage，e.g. // Example 1 static int a; // a is internal linkage extern int a; // linkage is the same as prior // Example 2 extern int b; // no prior, a is external linkage extern int b; // linkage is the same as prior 如果一个 function identifier 声明没有 storage-class 修饰符，则其 linkage 等价于加上 extern 修饰的声明的 linkage，e.g. int func(int a, int b); // equal to `extern int func(int a. int b);` // and then no prior, it is external linkage 如果一个 object identifier 声明没有 storage-class 修饰符，且拥有 file scope，则其拥有 external linkage，e.g. // file scope int a; // external linkage int main() {} ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:1:1","tags":["C","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"\r6.5 ExpressionsSyntax unary-exprssion: postfix-exprssion ++ unary-expression -- unary-expression unary-operator cast-exprssion sizeof unary-expression sizeof ( type-name ) unary-operator: one of \u0026 * + - ~ ! ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:2:0","tags":["C","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"\r6.5.3 Unary operators\r注意\rC99 [6.2.5] Types There are three real floating types, designated as float, double, and long double. The real floating and complex types are collectively called the floating types. The integer and real floating types are collectively called real types. Integer and floating types are collectively called arithmetic types. A function type describes a function with specified return type. A function type is characterized by its return type and the number and types of its parameters. A function type is said to be derived from its return type, and if its return type is T, the function type is sometimes called ‘‘function returning T’’. The construction of a function type from a return type is called ‘‘function type derivation’’. Arithmetic types and pointer types are collectively called scalar types. C99 [6.3.2.1] Lvalues, arrays, and function designators A function designator is an expression that has function type. Except when it is the operand of the sizeof operator or the unary \u0026 operator, a function designator with type ‘‘function returning type’’ is converted to an expression that has type ‘‘pointer to function returning type’’. 6.5.3.1 Prefix increment and decrement operatorsConstraints 前缀自增或自减运算符的操作数，必须为实数 (real types) 类型（即不能是复数）或者是指针类型，并且其值是可变的。 Semantics ++E 等价于 (E+=1) --E 等价于 (E-=1) 6.5.3.2 Address and indirection operatorsConstraints \u0026 运算符的操作数必须为 function designator，[] 或 * 的运算结果，或者是一个不是 bit-field 和 register 修饰的左值。 * 运算符的操作数必须为指针类型。 Semantics \u0026*E 等价于 E，即 \u0026 和 * 被直接忽略，但是它们的 constraints 仍然起作用。所以 (\u0026*(void *)0) 并不会报错。 \u0026a[i] 等价于 a + i，即忽略了 \u0026 以及 * (由 [] 隐式指代)。 其它情况 \u0026 运算的结果为一个指向 object 或 function 的指针。 如果 * 运算符的操作数是一个指向 function 的指针，则结果为对应的 function designator。 如果 * 运算符的操作数是一个指向 object 的指针，则结果为指示该 obejct 的左值。 如果 * 运算符的操作数为非法值的指针，则对该指针进行 * 运算的行为三未定义的。 6.5.3.3 Unary arithmetic operatorsConstraints 单目 + 或 - 运算符的操作数必须为算数类型 (arithmetic type)，~ 运算符的操作数必须为整数类型 (integer type)，! 运算符的操作数必须为常数类型 (scalar type)。 Semantics 在进行单目 +、-、~ 运算之前，会对操作数进行整数提升 (integer promotions)，结果的类型与操作数进行整数提升后的类型一致。 !E 等价于 (E==0)，结果为 int 类型。 6.5.3.4待补充 ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:2:1","tags":["C","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"\r6.5.7 Bitwise shift operatorsSyntax shift-expression: additive-exprssion shift-exprssion \u003e\u003e additive-expression shift-exprssion \u003c\u003ccadditive-expression Constraints 位运算的操作数都必须为整数类型。 Semantics 在进行位运算之前会先对操作数进行整数提升 (integer promotion)，位运算结果类型与整数提升后的左操作数一致。如果右运算数是负数，或者大于等于整数提升后的左运算数的类型的宽度，那么这个位运算行为是未定义的。 假设运算结果的类型为 T $E1 \u003c\u003c E2$ 如果 E1 是无符号，则结果为 $E1 \\times 2^{E2} \\bmod (\\max[T] + 1)$。 如果 E1 是有符号，E1 不是负数，并且 T 可以表示 $E1 \\times 2^{E2}$，则结果为 $E1 \\times 2^{E2}$。 除了以上两种行为外，其他均是未定义行为。 $E1 \u003e\u003e E2$ 如果 E1 是无符号，或者 E1 是有符号并且是非负数，则结果为 $E1 / 2^{E2}$。 如果 E1 是有符号并且是负数，则结果由具体实现决定 (implementation-defined)。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:2:2","tags":["C","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"C 语言规格书 Chapter 7 - Library 阅读记录。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch7/:0:0","tags":["C","Sysprog"],"title":"C 规格第 7 章阅读记录","uri":"/posts/c-specification/ch7/"},{"categories":["C"],"content":"\r7.18 Integer types \u003cstdint.h\u003e描述了头文件 stdint.h 必须定义和实现的整数类型，以及相应的宏。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch7/:1:0","tags":["C","Sysprog"],"title":"C 规格第 7 章阅读记录","uri":"/posts/c-specification/ch7/"},{"categories":["C"],"content":"\r7.18.1 Integer types\r7.18.1.1 Exact-width integer types二补数编码，固定长度 N 的整数类型： 有符号数：intN_t 无符号数：uintN_t 7.18.1.2 Minimum-width integer types至少拥有长度 N 的整数类型： 有符号数：int_leastN_t 无符号数：uint_leastN_t 7.18.1.3 Fastest minimum-width integer types至少拥有长度 N，且操作速度最快的整数类型： 有符号数：int_fastN_t 无符号数：uint_fastN_t 7.18.1.4 Integer types capable of holding object pointers可以将指向 void 的有效指针转换成该整数类型，也可以将该整数类型转换回指向 void 的指针类型，并且转换结果与之前的指针值保持一致： 有符号数：intptr_t 无符号数：uintptr_t 7.18.1.5 Greatest-width integer types可以表示任意整数类型所表示的值的整数类型，即具有最大长度的整数类型： 有符号数：intmax_t 无符号数：uintmax_t ","date":"2024-01-11","objectID":"/posts/c-specification/ch7/:1:1","tags":["C","Sysprog"],"title":"C 规格第 7 章阅读记录","uri":"/posts/c-specification/ch7/"},{"categories":["C","Linux Kernel Internals"],"content":"C 语言规格书阅读学习记录。 规格书版本为 n1256，对应 C99 标准，对应的 PDF 下载地址。 也配合 C11 标准来阅读，版本 n1570，对应的 PDF 下载地址。 阅读规格书需要一定的体系结构、编译原理的相关知识，但不需要很高的程度。请善用检索工具，在阅读规格书时遇到术语时，请先在规格书中进行检索，因为极大可能是规格书自己定义的术语。 ","date":"2024-01-06","objectID":"/posts/c-specification/c-specification/:0:0","tags":["C","Sysprog"],"title":"C 语言规格书阅读记录","uri":"/posts/c-specification/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"\r6. Language详见 阅读记录 6. Language。 ","date":"2024-01-06","objectID":"/posts/c-specification/c-specification/:1:0","tags":["C","Sysprog"],"title":"C 语言规格书阅读记录","uri":"/posts/c-specification/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"\r7. Library详见 阅读记录 7. Library。 ","date":"2024-01-06","objectID":"/posts/c-specification/c-specification/:2:0","tags":["C","Sysprog"],"title":"C 语言规格书阅读记录","uri":"/posts/c-specification/c-specification/"},{"categories":["Git"],"content":"\rGit 中文教学新手入门推荐，对于 Git 的入门操作讲解十分友好。 视频地址 学习记录 ","date":"2024-01-04","objectID":"/posts/git/:1:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习指引","uri":"/posts/git/"},{"categories":["Git"],"content":"\rGit 常见问题及解决","date":"2024-01-04","objectID":"/posts/git/:2:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习指引","uri":"/posts/git/"},{"categories":["Git"],"content":"\rgit pull/push 遇到 Port 22 connect timeout网络问题导致 22 端口被禁止，无法正常使用 ssh。切换成 443 端口并且编写配置文件即可： $ vim ~/.ssh/config # In ~/.ssh/config Host github.com HostName ssh.github.com POrt 443 ","date":"2024-01-04","objectID":"/posts/git/:2:1","tags":["Git/GitHub"],"title":"Git/GitHub 学习指引","uri":"/posts/git/"},{"categories":["Git"],"content":"\rReferences Git 基本原理 Learn Git Branching ugit 动手学习GIT - 最好学习GIT的方式是从零开始做一个 ","date":"2024-01-04","objectID":"/posts/git/:3:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习指引","uri":"/posts/git/"},{"categories":["Network"],"content":"\r清大开放式课程 - 计算机网络 课程主页 课程资料 课程视频 ","date":"2024-01-02","objectID":"/posts/network/:1:0","tags":["Network"],"title":"计算机网络学习指引","uri":"/posts/network/"},{"categories":["Network"],"content":"\rReferenecs 110-1 計算機網路 (清大開放式課程) ","date":"2024-01-02","objectID":"/posts/network/:2:0","tags":["Network"],"title":"计算机网络学习指引","uri":"/posts/network/"},{"categories":["Linux Kernel Internals"],"content":"\r摘要\r人们对数学的加减运算可轻易在脑中辨识符号并理解其结果，但电脑做任何事都受限于实体资料储存及操作方式，换言之，电脑硬体实际只认得 0 和 1，却不知道符号 + 和 - 在数学及应用场域的意义，於是工程人员引入「补数」以便在二进位系统中，表达人们认知上的正负数。但您有没有想过，为何「二补数」(2’s complement) 被电脑广泛采用呢？背後的设计考量又是什麽？本文尝试从数学观点去解读编码背後的原理，并佐以资讯安全及程式码最佳化的考量，探讨二补数这样的编码对于程式设计有何关键影响。\r原文地址：解讀計算機編碼 ","date":"2023-12-31","objectID":"/posts/binary-representation/:0:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r一补数 (Ones’ complement)","date":"2023-12-31","objectID":"/posts/binary-representation/:1:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r9 的补数✅ 科普短片: Not just counting, but saving lives: Curta ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r运算原理\r注意\r以一补数编码形式表示的运算子，在参与运算后，运算结果符合一补数的编码： $$\r[X]_{一补数} + [Y]_{一补数} = [X+Y]_{一补数}\r$$\r接下来进行分类讨论，以 32-bit 正数 $X$, $Y$ 为例： $X + Y = X + Y$ 显然运算子和运算结果都满足一补数编码。 $X - Y = X + (2^{32} - 1 - Y)$ 如果 $X \u003e Y$，则运算结果应为 $X - Y$ 且为正数，其一补数编码为 $X - Y$。而此时 $$ 2^{32} - 1 + X - Y $$ 显然会溢出，为了使运算结果对应一补数编码，所以此时循环进位对应 $+\\ (1 - 2_{32})$。 如果 $X \u003c Y$，则运算结果应为 $X - Y$ 且为负数，其一补数编码为 $$ 2^{32} - 1 - （Y - X） = 2_{32} - 1 - X - Y $$ 而此时 $2^{32} - 1 + X - Y$ 并不会溢出，并且满足运算结果的一补数编码，所以无需进行循环进位。 如果 $X = Y$，显然 $$ X - Y = X + 2^{32} - 1 - Y = 2^{32} - 1 $$ 为 0 成立。 $-X - Y = (2^{32} - 1 - X) + (2^{32} - 1 - Y)$，显然会导致溢出。而 $-X - Y$ 的一补数编码为 $$ 2^{32} - 1 - (X + Y) = 2^{32} - 1 - X - Y $$ 所以需要在溢出时循环进位 $+\\ (1 - 2^{32})$ 来消除运算结果中的一个 $2^{32} - 1$。 ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:2","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r二补数 (Two’s complement)","date":"2023-12-31","objectID":"/posts/binary-representation/:2:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r正负数编码表示假设有 n-bit 的二补数编码 $A$，$-A$ 的推导如下： 格式一： $$\r\\begin{align*}\rA + \\neg A \u0026= 2^n - 1 \\\\\rA + \\neg A + 1 \u0026\\equiv 0 \\equiv 2^n \\ (\\bmod 2^n) \\\\\r-A \u0026= \\neg A + 1 \\\\ \\end{align*}\r$$\r格式二： $$\r\\begin{align*}\rA + \\neg A \u0026= 2^n - 1 \\\\\rA + \\neg A - 1 \u0026= 2^n - 2 \\\\\rA - 1 \u0026= 2^n - 1 - (\\neg A + 1) \\\\ \\neg (A - 1) \u0026= \\neg A + 1 \\\\\r\\neg (A - 1) \u0026= -A \\\\\r\\end{align*}\r$$\r也可以通过一补数和二补数，在时钟表上的对称轴偏差，来理解上述两种方式是等价的。 ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r加 / 减法器设计✅ 科普短片: See How Computers Add Numbers In One Lesson 了解晶体管的原理 了解基本逻辑门元件，例如 OR, AND 逻辑门的设计 了解加法器的原理和工作流程。 ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:2","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r阿贝尔群及对称性\r技巧\r群论的最大用途是关于「对称性」的研究；所有具有对称性质，群论都可派上用场。只要发生变换后仍有什么东西还维持不变，那符合对称的性质。 一个圆左右翻转后还是圆，它在这种变换下是对称的，而这刚好与群的 封闭性 (Closure) 对应。 一个时钟的时刻，从 0 时刻开始，两边的时刻相加模 12 的结果均为 0，这与群的 单位元 (Identity element) 和 逆元 (Inverse element) 对应。 上述两个例子反映了群论的性质，对于对称性研究的重要性和原理依据。 科普影片：从五次方程到伽罗瓦理论 阿贝尔和伽罗瓦的悲惨世界 ","date":"2023-12-31","objectID":"/posts/binary-representation/:3:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r旁路攻击✅ 观看科普视频: 我听得到你打了什么字 阅读相关论文 Keyboard Acoustic Emanations 体验使用相关工具 kbd-audio ✅ 借由 Wikipedia 了解旁路攻击 (Side-channel attack) 和时序攻击 (Timing attack) 的基本概念。 Black-box testing Row hammer Cold boot attack Rubber-hose cryptanalysis 延伸阅读\rThe password guessing bug in Tenex Side Channel Attack By Using Hidden Markov Model One\u0026Done: A Single-Decryption EM-Based Attack on OpenSSL’s Constant-Time Blinded RSA ","date":"2023-12-31","objectID":"/posts/binary-representation/:4:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\rConstant-Time Functions比较常见的常数时间实作方法是，消除分支。因为不同分支的执行时间可能会不同，这会被利用进行时序攻击。这个方法需要对 C 语言中的编码和位运算有一定的了解。 C99 STandard - 7.18.1.1 Exact-width integer types 阅读记录 C99 Standard - 6.5.7.5 Bitwise shift operators 阅读记录 Branchless abs方法一，原理为 $-A = \\neg (A - 1)$: #include \u003cstdint.h\u003e int32_t abs(int32_t x) { int32_t mask = (x \u003e\u003e 31); return (x + mask) ^ mask; } 方法二，原理为 $-A = \\neg A + 1$: #include \u003cstdint.h\u003e int32_t abs(int32_t x) { int32_t mask = (x \u003e\u003e 31); return (x ^ mask) - mask; } Branchless min/maxMin: #include \u003cstdint.h\u003e int32_t min(int32_t a, int32_t b) { int32_t diff = (a - b); return b + (diff \u0026 (diff \u003e\u003e 31)); } 如果 diff \u003e 0 即 b 小，那么 (diff \u003e\u003e 31) == 0，则 b + (diff \u0026 (diff \u003e\u003e 31)) == b 如果 diff \u003c 0 即 a 小，那么 (diff \u003e\u003e 31) == -1，则 b + (diff \u0026 (diff \u003e\u003e 31)) == b + (a - b) == a Max: #include \u003cstdint.h\u003e int32_t max(int32_t a, int32_t b) { int32_t diff = (b - a); return b - (diff \u0026 (diff \u003e\u003e 31)); } 如果 diff \u003e 0 即 b 大, 那么 (diff \u003e\u003e 31) == 0，则 b - (diff \u0026 (diff \u003e\u003e 31)) == b 如果 diff \u003c 0 即 a 大，那么 (diff \u003e\u003e 31) == -1，则 b - (diff \u0026 (diff \u003e\u003e 31)) == b - (b - a) == a 延伸阅读\r❌ 基于 C 语言标准研究与系统程序安全议题\r","date":"2023-12-31","objectID":"/posts/binary-representation/:4:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\rRust in 100 Seconds✅ 观看短片：Rust in 100 Seconds 了解 Rust，初步了解其安全性原理 所有权 (ownership) 借用 (borrow) 警告\r0:55 This is wrong, value mutability doesn’t have anything to do with the value being stored on the stack or the heap (and the example let mut hello = \"hi mom\" will be stored on the stack since it’s type is \u0026'static str), it depends on the type of the value (if it’s Sized or not).\r","date":"2023-12-28","objectID":"/posts/rust-introduction/:1:0","tags":["Rust","Sysprog"],"title":"Rust - 进行中的未来","uri":"/posts/rust-introduction/"},{"categories":["Linux Kernel Internals"],"content":"\rThe adoption of Rust in Business (2022)❌ 阅读报告 The adoption of Rust in Business (2022)。 ","date":"2023-12-28","objectID":"/posts/rust-introduction/:2:0","tags":["Rust","Sysprog"],"title":"Rust - 进行中的未来","uri":"/posts/rust-introduction/"},{"categories":["Git","Linux Kernel Internals"],"content":"教学影片：Git 中文教学 ","date":"2023-12-27","objectID":"/posts/git-learn/:0:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\r安装与设定\r注意\r✅ 观看影片 Git 教学系列 - 安装与配置，完成常用的 Git 设置。\r设置 Git 的编辑器为 vim，主要用于 commit 时的编辑： $ git config --global core.editor vim 设置 Git 的合并解决冲突工具为 vimdiff： $ git config --global merge.tool vimdiff 启用 Git 命令行界面的颜色显示： $ git config --global color.ui true 设置常用命令的别名： $ git config --global alias.st status $ git config --global alias.ch checkout $ git config --global alias.rst reset HEAD 效果为：命令 git st 等价于 git status，其余的类似。 设置 Windows 和 Mac/Linux 的换行符同步： # In Windows $ git config --global core.autocrlf true # In Mac/Linux $ git config --global core.autocrlf input 效果为：在 Windows 提交时自动将 CRLF 转为 LF，检出代码时将 LF 转换成 CRLF。在 Mac/Linux 提交时将 CRLF转为 LF，检出代码时不转换。这是因为 Windows 的换行符为 \\r\\n，而 Mac/Linux 的换行符仅为 \\n。 ","date":"2023-12-27","objectID":"/posts/git-learn/:1:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rAdd 和 Commit","date":"2023-12-27","objectID":"/posts/git-learn/:2:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\r指定 Commit\r注意\r✅ 观看影片 Git 教学系列 - 指定 Commit，掌握 git log、git show、git diff 的常用方法。理解 Hash Value 和 commit 对于 Git 版本控制的核心作用。\r只要 commit 了，资料基本不可能丢失，即使误操作了也是可以补救回来的（除非把 .git/ 文件夹也删除了）。\r","date":"2023-12-27","objectID":"/posts/git-learn/:3:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rHash Value Every commit has a unique hash value. Calculate by SHA1 Hash value can indicate a commit absolutely. ","date":"2023-12-27","objectID":"/posts/git-learn/:3:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rIndicate Commit git manage references to commit HEAD Branch Tag Remote Also, We can indicate commit by ^, ~ 通俗地将，不论是 HEAD、Branch、Tag、Remote，其本质都是使用 Hash Value 进行索引的 commit，所以 ~ 和 ^ 也可以作用于它们。 可以通过 git log 来查看 commit 以及对应的 Hash 值。事实上，这个命令十分灵活，举个例子： git log 4a6ebc -n1 这个命令的效果是从 Hash 值为 4a6bc 的 commit 开始打印 1 条 commit 记录（没错，对应的是 -n1），因为 Git 十分聪明，所以 commit 对应的 Hash 值只需前 6 位即可（因为这样已经几乎不会发生 Hash 冲突）。 Examples\r打印 master 分支的最新一个 commit： git log master -n1 打印 master 分支的最新一个 commit（仅使用一行打印 commit 信息）： git log master -n1 --oneline 打印 HEAD 所指向的 commit： git log HEAD -n1 --oneline 打印 HEAD 所指向的 commit 的前一个 commit： git log HEAD^ -n1 --oneline ^ 可以持续使用，比如 HEAD^^ 表示 HEAD 所指向的 commit 的前两个 commit。当 ^ 数量过多时，可以使用 ~ 搭配数字来达到相同效果。例如： git log HEAD^^^^^ -n1 --oneline git log HEAD~5 -n1 --oneline 一般来说，使用 ^ 就已经足够了，几乎不会遇到使用 ~ 的场景，因为这种场景一般会去找图形化界面吧。🤣 打印与文件 README.md 相关的 commits（仅使用一行显示）： git log --oneline README.md 打印与文件 README.md 相关的 commits（显示详细信息，包括文件内容的增减统计）： git log --stat README.md 打印与文件 README.md 相关的 commits（显示详细信息，包括文件内容的增减细节）： git log --patch README.md 在打印的 commit 信息中抓取与 README 符合的信息（可以与 --stat 或 --patch 配合使用）： git log -S README ","date":"2023-12-27","objectID":"/posts/git-learn/:3:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rView History git log \u003cpath\u003e|\u003ccommit\u003e -n: limit number --oneline: view hash and commit summary --stat: view files change --patch: view lines change -S or --grep: find modification ","date":"2023-12-27","objectID":"/posts/git-learn/:3:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rView Commit git show \u003ccommit\u003e Equal to log -n1 ","date":"2023-12-27","objectID":"/posts/git-learn/:3:4","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rSee Difference查看当前的修改，可以查看已经修改但没有 staged 文件的变化： git diff 查看当前的修改，可以查看已经修改且 staged 文件的变化： git diff --staged 查看当前与指定的 commit 的差异： git diff \u003ccommit\u003e # e.g. git diff master^ 查两个指定的 commit 之间的差异： git diff \u003ccommit\u003e \u003ccommit\u003e # e.g. git diff master^ master^^ ","date":"2023-12-27","objectID":"/posts/git-learn/:3:5","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rPath Add and Amend\r注意\r✅ 观看影片 Git 教学系列 - Patch Add and Amend，掌握 git add -p、git checkout -p、git add ---amend 的用法，使用 add 和 checkout 时强烈建议使用 -p，掌握修改 commit 的两种方法。\r","date":"2023-12-27","objectID":"/posts/git-learn/:4:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rOnly Add Related git add -p 推荐尽量使用这个 git add -p 而不是单纯的 git add。 使用 git add -p 后，Git 会帮我们把涉及的修改分成 section，然后我们就可以对每一个 section 涉及的修改进行 review，选择 y(yes) 表示采纳该 sction 对应的修改，选择 n(no) 表示不采纳。 如果觉得 section 切割的粒度太大了，可以选择 s(split) 来进行更细粒度的划分。如果这样仍然觉得粒度不够，可以选择 e(edit) 对 section 涉及的修改，进行以行为粒度的 review，具体操作可以查阅此时给出的提示。 还有一些其它的选项，比如 j、J、k、K，这些是类似 vim，用于切换进行 review 的 section，不太常用。q(quit) 表示退出。 由于可以针对一个文件的不同 section 进行 review，所以在进行 git add -p 之后，使用 git status 可以发现同一个文件会同时处于两种状态。 ","date":"2023-12-27","objectID":"/posts/git-learn/:4:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rCheckout Also git checkout -p 这个操作比较危险，因为这个操作的效果与 git add -p 相反，如果选择 y 的话，文件涉及的修改就会消失，如果涉及的修改没有 commit 的话，那么涉及的修改是无法救回的。但是怎么说，这个操作还是比直接使用 git checkout 稍微保险一点，因为会先进入 review 界面，而不是直接撤销修改。所以，请一定要使用 git checkout -p！ ","date":"2023-12-27","objectID":"/posts/git-learn/:4:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rModify Commit有两种方式来修改最新的 commit： # 1. Use git commit --amend git commit --amend # 2. Use reset HEAD^ then re-commit git reset HEAD^ git add -p git commit git commit --amend 并不是直接替换原有的 commit，而是创建了一个新的 commit 并重新设置了 HEAD 的指向。所以，新旧两个 commit 的 Hash Value 并不相同，事实上，如果你拥有旧 commit 的 Hash Value，是可以通过 git checkout \u003ccommit\u003e 切换到那个 commit 的。其原理如下图： 但是注意，git reset HEAD^ 是会撤销原先的 commit（仅限于本地 Git 存储库）。 ","date":"2023-12-27","objectID":"/posts/git-learn/:4:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rBranch and Merge\r注意\r✅ 观看影片 Git 教学系列 - Branch and Merge，掌握创建、删除、切换分支的用法，掌握合并分支、解决冲突的方法。 git checkout \u003ccommit\u003e git branch \u003cname\u003e git branch \u003cname\u003e \u003ccommit\u003e git branch [-d|-D] \u003cname\u003e git merge \u003cname\u003e --no-ff ","date":"2023-12-27","objectID":"/posts/git-learn/:5:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rMove and Create BranchCheckout: move HEAD git checkout \u003ccommit\u003e: Move HEAD to commit git checkout \u003cpath\u003e: WARNING: discard change 可以将路径上的文件复原到之前 commit 的状态。 Branch: git branch: List branch git branch \u003cname\u003e: Create branch Or just: git checkout -b Examples\r修改一个文件并恢复： # modify file load.cpp git status git checkout load.cpp git status 删除一个文件并恢复： rm load.cpp git status git checkout load.cpp git status 正如上一节所说的，git checkout 尽量带上 -p 参数，因为如果一不小心输入了 git checkout .，那就前功尽弃了。 显示分支： # only show name git branch # show more infomation git branch -v 切换分支： # switch to branch 'main' git checkout main 创建分支： # 1. using `git branch` git branch cload # 2. using `git checkout -b` git checkout -b asmload # 3. create a new branch in \u003ccommit\u003e git branch cload \u003ccommit\u003e 切换到任一 commit： git checkout \u003ccommit\u003e 直接 checkout 到任一 commit 会有警告，这是因为，当你以该 commit 为基点进行一系列的 commit，这些新的 commit 会在你切换分支后消失，因为没有 branch 来引用它们。之前可以被引用是因为 HEAD 引用，切换分支后 HEAD 不再引用这些 commit，所以就会消失。在这种情况，Git 会在发出警告的同时建议我们使用 git branch 来创建分支进行引用。 ","date":"2023-12-27","objectID":"/posts/git-learn/:5:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rView Branch列出仓库的所有分支： git branch 也可以通过 log 来查看分支： git log --decorate: 在 log 的首行显示所有的 references（可能需要通过 git config log.decorate auto 来开启） --graph: 以图形化的方式显示 branch 的关系（主要是 commit 的引用） ","date":"2023-12-27","objectID":"/posts/git-learn/:5:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rDelete Branch删除分支： git branch -d \u003cname\u003e 对于有没有 merge 的 commit 的分支，Git 会警告，需要使用 -D 来强制删除： git branch -D \u003cname\u003e for no-merge commit WARNING: Discard Commit Git 会发出警告的原因同样是 no-merge commit 在删除分支后就无法被引用，所以会发出警告。 ","date":"2023-12-27","objectID":"/posts/git-learn/:5:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rMerge合并分支。默认使用 fast-forward，即如果没有冲突，直接将要合并的分支提前到被合并分支的 commit 处，而不会另外生成一个 merge commit。但这样会使得被合并的分支在合并后，没有历史痕迹。可以通过 --no-ff (no fast forward) 来强制生成 merge commit。推荐使用 merge 时加上 --no-ff 这个参数。 git merge \u003cbranch\u003e 通常是 main/master 这类主分支合并其它分支： git checkout main/master git merge \u003cbranch\u003e ","date":"2023-12-27","objectID":"/posts/git-learn/:5:4","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rResolve ConflictManually resolve: Check every codes between \u003c\u003c\u003c\u003c\u003c\u003c\u003c, \u003e\u003e\u003e\u003e\u003e\u003e\u003e Edit code to what it should be Use mergetool like vimdiff: It shows: local, base, remote, file to be edited Edit “file ro be edited” to what is should be Add and Commit # 1. 合并分支 git merge \u003cbranch\u003e # 2. 检查状态，查看 unmerged 的文件 git status # 3. 编辑 unmerged 文件，编辑冲突区域代码即可 vim \u003cfile\u003e # 4. 添加解决完冲突的文件 git add \u003cfile\u003e # 5. 进行 merge commit git commit 冲突区域就是 \u003c\u003c\u003c\u003c\u003c\u003c\u003c 和 \u003e\u003e\u003e\u003e\u003e\u003e\u003e 内的区域，在 merge 操作后，Git 已经帮我们把 unmerged 文件修改为待解决冲突的状态，直接编辑文件即可。在编辑完成后，需要手动进行 add 和 commit，此次 commit 的信息 Git 已经帮我们写好了，一般不需要修改。\r如果使用的是 mergetool，以 vimdiff 为例，只需将第 3 步的 vim \u003cfile\u003e 改为 git mergetool 即可。vimdiff 会提供 4 个视窗：底部视窗是我们的编辑区，顶部左边是当前合并分支的状态，顶部中间是 base (合并分支和被合并的共同父节点) 的状态，顶部右边是 remote 的状态，按需要选择、编辑。 vimdiff 在编辑完后会保留 *.orig 的文件，这个文件是待解决冲突的文件副本。 ","date":"2023-12-27","objectID":"/posts/git-learn/:5:5","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rMerge Conflict Prevent very long development branch. Split source code clearly. ","date":"2023-12-27","objectID":"/posts/git-learn/:5:6","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rRebase\r注意\r✅ 观看影片 Git 教学系列 - Branch and Merge，掌握 TODO 的方法。git rebase 是 Git 的精华，可以让我们实现更细粒度的操作，可以说学会了 rebase 才算真正入门了 Git。 这个视频讲得比较乱，所以推荐配合视频给出的参考文章 Git-rebase 小笔记 来学习。 ","date":"2023-12-27","objectID":"/posts/git-learn/:6:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Linux"],"content":"\r网络代理根据项目 clash-for-linux-backup 来配置 Ubuntu 的网络代理。 $ git clone https://github.com/Elegybackup/clash-for-linux-backup.git clash-for-linux 过程当中可能需要安装 curl 和 net-tools，根据提示进行安装即可： sudo apt install curl sudo apt install net-tools 安装并启动完成后，可以通过 localhost:9090/ui 来访问 Dashboard。 启动代理： $ cd clash-for-linux $ sudo bash start.sh $ source /etc/profile.d/clash.sh $ proxy_on 关闭代理： $ cd clash-for-linux $ sudo bash shutdown.sh $ proxy_off ","date":"2023-12-27","objectID":"/posts/ubuntu/:1:0","tags":["Linux"],"title":"Ubuntu 22.04 配置","uri":"/posts/ubuntu/"},{"categories":["Linux"],"content":"\r搜狗输入法根据 搜狗输入法 Linux 安装指导 来安装搜狗输入法。 无需卸载系统 ibus 输入法框架。 通过 Ctrl + space 唤醒搜狗输入法。 ","date":"2023-12-27","objectID":"/posts/ubuntu/:2:0","tags":["Linux"],"title":"Ubuntu 22.04 配置","uri":"/posts/ubuntu/"},{"categories":["Linux"],"content":"\r快捷键新建终端： Ctrl + Alt + T 锁屏： Super + L：锁定屏幕并熄屏。 显示桌面： Super + d 或者 Ctrl + Alt + d 最小化所有运行的窗口并显示桌面，再次键入则重新打开之前的窗口。 显示所有的应用程序： Super + a 可以通过 ESC 来退出该显示。 显示当前运行的所有应用程序： Super 移动窗口位置： Super + 左箭头：当前窗口移动到屏幕左半边区域 Super + 右箭头：当前窗口移动到屏幕右半边区域 Super + 上箭头：当前窗口最大化 Super + 下箭头：当前窗口恢复正常 隐藏当前窗口到任务栏： Super + h 切换当前的应用程序： Super + Tab：以应用程序为粒度显示切换选项 Alt + Tab：以窗口为粒度显示切换选项 切换虚拟桌面/工作区： Ctrl + Alt + 左/右方向键 自定义键盘快捷键： Settings -\u003e Keyboard -\u003e Keyboard Shortcus | View and Customize Shortcuts -\u003e Custom Shortcuts ","date":"2023-12-27","objectID":"/posts/ubuntu/:3:0","tags":["Linux"],"title":"Ubuntu 22.04 配置","uri":"/posts/ubuntu/"},{"categories":["Linux Kernel Internals"],"content":"\r摘要\rGNU/Linux 开发工具，几乎从硬件到软件，Linux 平台能够自下而上提供各类触及“灵魂”的学习案例，让所有课程从纸上谈兵转变成沙场实战，会极大地提升工程实践的效率和技能。\r原文地址 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:0:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\r安装 Windows / Ubuntu 双系统因为有些操作必须在物理硬件上才能执行。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:1:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\rMarkdown 与 LaTeX速览 LaTeX 语法示例一节，作为工具书册，在需要使用时知道如何查询。 速览 Markdown 语法示例一节，作为工具书册，在需要使用时知道如何查询。 注意\r编写 Markdown 文本以及 LaTeX 语法表示的数学式可以通过： Hugo + FixIt ✅ VS Code + Markdown Preview Enhanced ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:2:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\rGit 和 Github阅读 SSH key 产生方法一节，配置好 Git 和 Github 的 SSH key。同时也可作为工具书册，在需要使用时知道如何查询。 推荐通过 LearnGitBranching 来熟悉 Git 命令！！！ 以下资源作为自学资源，用于补充自己不熟悉的操作，或者作为以上资料的补充工具手册。 Git 中文教学 - YouTube (学习记录) 30 天精通 Git 版本控制 - GitHub 警告\r原文档中的将公钥复制到 clipboard 中使用了 clip 命令，但是这个命令在 Ubuntu 中并没有对应的命令。可以使用 xclip + alias 达到近似效果。 $ sudo apt install xclip # using alias to implement clip, you can add this to bashrc $ alias='xclip -sel c' ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:3:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\r编辑器: Visual Studio Code认真阅读，跟随教学文档进行安装、设置。重点阅读 设定、除错（调试） 这两部分。更新 VS Code 部分作为手册，在需要时进行参考。 以下资源作为自学资源，用于补充自己不熟悉的操作，或者作为以上资料的补充工具手册。 开开心心学 Vistual Studio Code 完成 SSH key 的生成。 完成 VS Code 的设置。 安装 Git History 插件。 安装 Native Debug 插件，并进行 Debug (test-stopwatch.c) 操作。 安装 VSCode Great Icons 文件图标主题，另外推荐两款颜色主题：One Dark Pro, Learn with Sumit。 VS Code 控制台使用说明： 可以在面板的输出，点击 GIT 选项显示 VS Code 背后执行的 git 命令。 可以使用 ctrl + shift + P 呼出命令区，然后通过输入 Git branch 和 Git checkout 等并选择对应选项，来达到创建分支、切换分支等功能。 技巧\r在 VS Code 设置中，需要在设置中打开 Open Default Settings 选项才能在左侧面板观察到预设值。键位绑定同理。 要想进行调试，需要在使用 gcc 生成目标文件时，加入 -g 参数来生产调试信息。 原文档中的 GDB 教学链接-除错程式-gdb 已失效，这是目前的有效链接。也可通过该影片 拯救资工系学生的基本素养-使用 GDB 除错基本教学 来补充学习 GDB 的操作。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:4:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\r终端和 Vim认真阅读，跟随教学影片 快快乐乐学 Vim 和教学文档配置好 终端提示符、Vim。 完成命令行提示符配置 完成 Vim 的设定 安装并使用 Minial Vim Plugin Manager 来管理 Vim 插件 (neocomplcache, nerdtree) 安装并使用 byobu 来管理多个终端视图。 技巧\r在 .vimrc 中增加插件后，打开 vim，执行 :PlugInstall 来安装插件，完成后在 vim 执行 :source ~/.vimrc。（可以通过 :PlugStatus 来查看插件安装状态） 使用 F4 键来[显示/不显示][行数/相对行数]。 使用 F5 键来呼入/呼出文件树(nerdtree)，在文件树恻通过 ENTER 键来访问目录/文件。 使用 Ctrl-w-h/Ctrl-w-l 切换到 文件树/编辑区。 自动补全时使用 ENTER 键来选中，使用方向键或 Ctrl-N/Ctrl-U/Ctrl-P 来上下选择。 在 Vim 中可以通过 :set paste，并在 insert 模式下，将粘贴板的内容通过 Ctrl-Shift-V 进行粘贴。 byobu 使用说明： 在终端输入 byobu F2 新增 Terminial 分页。F3, F4 在 Terminial 分页中切换。Ctrl +F6 删除当前 Terminial 分页。 Shift + F2 水平切割 Terminial。Ctrl +F2 垂直切割 Terminial。Shift + 方向键 切换。 在 byobu 中暂时无法使用之前设置的 F4 或 F5 快捷键，但是可以直接通过命令 :set norelative 来关闭相对行数。 推荐观看影片 How to Do 90% of What Plugins Do (With Just Vim) 来扩展 Vim 插件的使用姿势。 以下资源为 Cheat Sheet，需要使用时回来参考即可。 Vim Cheat Sheet Bash terminal Cheat Sheet ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:5:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\rMakefile速览教学文档，作为工具书册，在需要使用时知道如何查询。 gcc 的 -MMD 和 -MF 参数对我们编写 Makefile 是一个巨大利器。理解 Makefile 的各种变量定义的原理。 对之前的 test-stopwatch.c 编写了一个 Makefile 来自动化管理。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:6:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\rLinux 性能分析工具: Perf认真阅读，复现教学文档中的所有例子，初步体验 perf 在性能分析上的强大。 安装 perf 并将 kernel.perf_event_paranoid 设置为 1。 动手使用 perf_top_example.c，体验 perf 的作用。 搭配影片: Branch Prediction 对照阅读: Fast and slow if-statements: branch prediction in modern processors 编译器提供的辅助机制: Branch Patterns, Using GCC 动手使用 perf_top_while.c，体验 perf top 的作用。 动手使用 perf_stat_cache_miss.c，体验 perf stat 的作用。（原文的结果有些不直观，务必亲自动手验证） 动手使用 perf_record_example.c，体验 perf record 的作用。（原文的操作不是很详细，可以参考下面的 Success） Source 成功\r$ perf record -e branch-misses:u,branch-instructions:u ./perf_record_example [ perf record: Woken up 1 times to write data ] [ perf record: Captured and wrote 0.009 MB perf.data (94 samples) ] 输出第一行表示 perf 工具在收集性能数据时被唤醒了 1 次，以将数据写入输出文件。 输出第二行表示 perf 工具已经取样并写入了一个名为 perf.data 的二进制文件，文件大小为 0.009 MB，其中包含了 94 个采样。（可以通过 ls 命令来检查 perf.data 文件是否存在） 接下来通过 perf report 对之前输出的二进制文件 perf.data 进行分析。可以通过方向键选择，并通过 ENTER 进入下一层查看分析结果。 $ perf report Available samples 5 branch-misses:u 89 branch-instructions:u 技巧\rperf 需要在 root 下进行性能分析。 perf top 是对于哪个程序是性能瓶颈没有头绪时使用，可以查看哪个程序（以及程序的哪个部分）是热度点。 在 perf top 时可以通过 h 键呼出帮助列表。 可以通过方向键选择需要进一步分析的部分，并通过 a 键来查看指令级别粒度的热点。 perf stat 是对某一个要优化的程序进行性能分析，对该程序涉及的一系列 events 进行取样检查。 perf record 的精度比 perf stat 更高，可以对取样的 events 进行函数粒度的分析。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:7:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\rLinux 绘图工具: gnuplot阅读教程，搭配教学影片 轻轻松松学 gnuplot，使用 gnuplot 完成所给例子相应图像的绘制。 使用 runtime.gp 完成 runtime.png 的绘制生成。 使用 statistic.gp 完成降雨量折线图 statistic.png 的绘制生成。 注意\r原文所给的 statistic.gp 是使用 Times_New_Roman 来显示中文的，但笔者的 Ubuntu 中并没有这个字体，所以会显示乱码。可以通过 fc-list :lang=zh 命令来查询当前系统中的已安装的中文字体。\rSource 安装 gnuplot: $ sudo apt-get install gnuplot gnuplot script 的使用流程： # 创建并编写一个后缀名为 .gp 的文件 $ vim script.gp # 根据 script 内的指令进行绘图 $ gnuplot script.gp # 根据 script 指定的图片保存路径打开图片 $ eog [name of picture] 下面以一个 script 进行常用指令的说明： reset set ylabel 'time(sec)' set style fill solid set title 'performance comparison' set term png enhanced font 'Verdana,10' set output 'runtime.png' plot [:][:0.100]'output.txt' using 2:xtic(1) with histogram title 'original', \\ '' using ($0-0.06):($2+0.001):2 with labels title ' ', \\ '' using 3:xtic(1) with histogram title 'optimized' , \\ '' using 4:xtic(1) with histogram title 'hash' , \\ '' using ($0+0.3):($3+0.0015):3 with labels title ' ', \\ '' using ($0+0.4):($4+0.0015):4 with labels title ' ' reset 指令的作用为，将之前 set 指令设置过的内容全部重置。 set style fill solid 将绘制出的柱形或区域使用实心方式填充。 set term png enhanced font 'Verdana,10' term png 生成的图像以 png 格式进行保存。(term 是 terminial 的缩写) enhanced 启用增强文本模式，允许在标签和注释中使用特殊的文本格式，如上下标、斜体、下划线等。 font 'Verdana,10' 指定所使用的字体为 Verdana，字号为10。可进行自定义设置。 其它指令查询原文或手册即可。 $0 在 gnuplot 中表示伪列，可以简单理解为行号，以下为相应图示： 原始数据集： append() 0.048240 0.040298 0.057908 findName() 0.006495 0.002938 0.000001 （人为）增加了 伪列 表示的数据集（最左边 0, 1 即为伪列）： 0 append() 0.048240 0.040298 0.057908 1 findName() 0.006495 0.002938 0.000001 技巧\rgnuplot 在绘制生成图像时是安装指令的顺序进行的，并且和一般的画图软件类似，在最上层进行绘制。所以在编写 script 的指令时需要注意顺序，否则生成图像的部分可能并不像预期一样位于最上层。（思考上面 script 的 3, 4 列的 label 的绘制顺序） gnuplot script 中的字符串可以使用 '' 或者 \"\" 来包裹，同样类似于 Python。 直接在终端输入 gnuplot 会进入交互式的命令界面，也可以使用 gnulpot 指令来绘图（类似与 Python）。在这种交互式界面环境中，如果需要在输入完指令后立即显示图像到新窗口，而不是保存图像再打开，只需输入进行指令： set term wxt ehanced persist raise term wxt 将图形终端类型设置为WXT，这会在新窗口中显示绘图。 ersist 该选项使绘图窗口保持打开状态，即使脚本执行完毕也不会自动关闭。 raise 该选项将绘图窗口置于其他窗口的前面，以确保它在屏幕上的可见性。 一些额外的教程： Youtube - gnuplot Tutorlal 这个教程有五部影片，到发布者的主页搜寻即可。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:8:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Mathematics"],"content":" 中大數學系開放式課程 台大齐震宇 - 数学潜水艇、微积分、分析 台大谢铭伦 - 线性代数 ","date":"2023-12-23","objectID":"/posts/math/:0:0","tags":["Math"],"title":"数学开放式课程学习指引","uri":"/posts/math/"},{"categories":["Mathematics"],"content":"\r概率统计阳明交通大学 陈临安老师，开设了两学期的统计课程，分别是上学期的 统计学 和下学期的 高等统计学。 课程名称 英文名称 课程地址 课程视频 统计学 Statistics 课程资讯 YouTube 高等统计学 Advanced Statistics 课程资讯 YouTube 信息\r这两个学期课程的作业、习题以及解答都可以在 这里 找到。\r","date":"2023-12-23","objectID":"/posts/math/:1:0","tags":["Math"],"title":"数学开放式课程学习指引","uri":"/posts/math/"},{"categories":["draft"],"content":"博客（英语：Blog）是一种在线日记型式的个人网站，借由张帖子章、图片或视频来记录生活、抒发情感或分享信息。博客上的文章通常根据张贴时间，以倒序方式由新到旧排列。 ","date":"2023-12-23","objectID":"/posts/hello_world/:0:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"\r数学公式行内公式：$N(b,d)=(b-1)M$ 公式块： $$\r\\int_{a}^{b}x(t)dt =\r\\dfrac{b - a}{N} \\\\\r=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N}\r$$\r$$\r\\begin{aligned}\r\\int_{a}^{b}x(t)dt \u0026=\r\\dfrac{b - a}{N} \\\\\r\u0026=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} \\\\\r\\end{aligned}\r$$\r$$\r\\mathrm{Integrals\\ are\\ numerically\\ approximated\\ as\\ finite\\ series}:\\\\ \\begin{split}\r\\int_{a}^{b}x(t)dt \u0026=\r\\dfrac{b - a}{N} \\\\\r\u0026=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N}\r\\end{split} \\\\ where\\ t_k = a + (b-a)\\cdot k/N\r$$\r$$\r\\begin{align*}\rp(x) = 3x^6 + 14x^5y \u0026+ 590x^4y^2 + 19x^3y^3 \\\\\r\u0026- 12x^2y^4 - 12xy^5 + 2y^6 - a^3b^3 - a^2b - ab + c^5d^3 + c^4d^3 - cd\r\\end{align*}\r$$\r","date":"2023-12-23","objectID":"/posts/hello_world/:1:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"\r代码块 let i: i32 = 13; let v = vec![1, 2, 3, 4, 5, 65]; for x in v.iter() { println!(\"{}\", x); } typedef struct Block_t { int head; int data; } Block_t; ","date":"2023-12-23","objectID":"/posts/hello_world/:2:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"\rAdmonition\r注意\r一个 注意 横幅\r摘要\r一个 摘要 横幅\r信息\r一个 信息 横幅\r技巧\r一个 技巧 横幅\r成功\r一个 成功 横幅\r问题\r一个 问题 横幅\r警告\r一个 警告 横幅\r失败\r一个 失败 横幅\r危险\r一个 危险 横幅\rBug\r一个 Bug 横幅\r示例\r一个 示例 横幅\r引用\r一个 引用 横幅\r","date":"2023-12-23","objectID":"/posts/hello_world/:3:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"\rReferences FixIt 快速上手 使用 Hugo + Github 搭建个人博客 Emoji 支持 扩展 Shortcodes 概述 URL management ","date":"2023-12-23","objectID":"/posts/hello_world/:4:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"}]
=======
[{"categories":["Network"],"content":"\r摘要\r之前学校的计网理论课学得云里雾里，对于物理层和数据链路层并没有清晰的逻辑框架，而这学期的计网课设内容为数据链路层和网络层的相关内容，写起来还是云里雾里。虽然最终艰难地把课设水过去了，但是个人认为网络对于 CSer 非常重要，特别是在互联网行业，网络知识是必不可少的。 所以决定寒假重学计网，于是在 HackMD 上冲浪寻找相关资料。然后发现了这篇笔记 110-1 計算機網路 (清大開放式課程)，里面提到清大计网主要介绍 L2 ~ L4 一些著名的协议和算法，这完美符合个人的需求，而且该篇该笔还补充了一些额外的内容，例如 IPv6，所以当即准备搭配这篇笔记来学习清大的计算机网络概论。\r","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:0:0","tags":["Network"],"title":"清大计算机网络重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"\r清大计算机网络概论 本課程將介紹計算機網路的基本運作原理與標準的網路七層結構,由淺入深,可以讓我們對於計算機網路的運作有最基本的認識,本課程還會介紹全球建置最多的有線網路──IEEE 802.3 Ethernet 的基本運作原理, 還有全球建置最多的無線區域網路──IEEE 802.11 Wireless LAN 的基本運作原理, 想知道網路交換機(switches) 是如何運作的嗎 ? 想知道網際網路最重要也最關鍵的通訊協議 ── TCP/IP 是如何運作的嗎 ? 想知道網際網路最重要的路由器 (Routers) 是如何運作的嗎 ? 在本課程裡您都可以學到這些重要的基本知識。 开课学校 课程主页 课程资料 课程影片 國立清華大學 計算機網路概論 課程講義與練習題 Youtube ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:1:0","tags":["Network"],"title":"清大计算机网络重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"\rL1 Foundation 重点提示与练习","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:0","tags":["Network"],"title":"清大计算机网络重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"\rApplicationsFoundation - 5\r进行 1 次 URL request 需要进行 17 次的讯息交换： 6 次讯息交换用于查询 URL 对应的 IP Address 3 次讯息交换用于建立 TCP 连接（TCP 的 3 次握手） 4 次讯息交换用于 HTTP 协议的请求和回复 4 次讯息交换用于关闭 TCP 连接（TCP 的 4 次握手） ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:1","tags":["Network"],"title":"清大计算机网络重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"\rNetwork ConnectivityFoundation - 8\r交换机 (Switches) 可以分为很多层级，即可以有不同层级的交换机，例如 L2 层的交换机，L3 层的交换机以及 L4 层的交换机。如何判断交换机是哪个层级？很简单，只需要根据交换机所处理的讯息，L2 层交换机处理的是 MAC Address，L3 层交换机处理的是 IP Address，而 L4 层交换机处理的是 TCP 或者 UDP 相关的讯息。 交换机 (Switches) 用于网络 (Network) 内部的连接，路由 (Router) 用于连接不同的网络 (Network)，从而形成 Internetwork。 地址 (Address)，对于网卡来说是指 MAC Address，对于主机来说是指 IP Address。Host-to-Host connectivity 是指不同网络 (Network) 的主机，即位于 Internetwork 的不同主机之间，进行连接。 ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:2","tags":["Network"],"title":"清大计算机网络重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"\rNetwork ArchitectureFoundation - 22\rPhysical Layer: 如何将原始资料在 link 上传输，例如不同介质、信息编码。(P25) Data Link Layer: 在 Physical Layer 基础上，如何将 frame 传给直接相连的主机或设备，核心是通过 Media Access Control Protocol 解决 Multiple access 产生的碰撞问题。这一层交换的数据被称为 frame。(P26) Network Layer: 在 Data Link Layer 基础上，如何将 packet 通过 Internet 送给目的地主机。核心是通过 Routing Protocols 动态转发 packet。这一层交换的数据被称为 packet。(P27) Transport Layer: 在 Network Layer 基础上，提供不同主机 processes 之间的资料传送。由于 Networkd Layer 是主机间进行资料传送，所以在 Transport Layer 不论是可靠还是不可靠的传输协议，都必须要实现最基本的机制：主机与 process 之间数据的复用和分解。这一层交换的数据被称为 message。(P28) 注意\rSwitch 一般处于 L2 Layer，Router 一般处于 L3 Layer。L4 Layer 及以上的 layers 通常只存在于 hosts，switches 和 routers 内部一般不具有这些 layers。(P29) Internet Architecture 的层级并不是严格的，Host 可以略过 Application Layer 而直接使用 Transport Layer、Network Layer 中的协议。(P30) Internet Architecture 的核心是 IP 协议，它作为沙漏形状的中心位置，为处于其上层的协议与处于其下层协议之间提供了一个映射关系。(P31) ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:3","tags":["Network"],"title":"清大计算机网络重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"\rNetwork PerformanceFoundation - 36\rFoundation - 37\rBandwidth: Number of bits per second (P34) Delay 可以近似理解为 Propagation time。有效利用 network 的标志是在接收对方的回应之前，发送方传送的资料充满了 pipe，即发送了 Delay $\\times$ Bandwitdh bits 的资料量。(P39) Foundation - 40\rRTT 可以近似理解为 2 $\\times$ Propagation time，因为一个来回需要从 sender 到 reciever，再从 reciever 到 sender。 ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:4","tags":["Network"],"title":"清大计算机网络重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["C"],"content":"C 语言规格书 Chapter 6 - Language 阅读记录。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:0:0","tags":["C/C++","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"\r6.5 ExpressionsSyntax unary-exprssion: postfix-exprssion ++ unary-expression -- unary-expression unary-operator cast-exprssion sizeof unary-expression sizeof ( type-name ) unary-operator: one of \u0026 * + - ~ ! ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:1:0","tags":["C/C++","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"\r6.5.3 Unary operators\r信息\rC99 [6.2.5] Types There are three real floating types, designated as float, double, and long double. The real floating and complex types are collectively called the floating types. The integer and real floating types are collectively called real types. Integer and floating types are collectively called arithmetic types. A function type describes a function with specified return type. A function type is characterized by its return type and the number and types of its parameters. A function type is said to be derived from its return type, and if its return type is T, the function type is sometimes called ‘‘function returning T’’. Arithmetic types and pointer types are collectively called scalar types. C99 [6.3.2.1] Lvalues, arrays, and function designators A function designator is an expression that has function type. Except when it is the operand of the sizeof operator or the unary \u0026 operator,afunction designator with type ‘‘function returning type’’ is converted to an expression that has type ‘‘pointer to function returning type’’. 6.5.3.1 Prefix increment and decrement operatorsConstraints 前缀自增或自减运算符的操作数，必须为实数 (real types) 类型（即不能是复数）或者是指针类型，并且其值是可变的。 Semantics ++E 等价于 (E+=1) --E 等价于 (E-=1) 6.5.3.2 Address and indirection operatorsConstraints \u0026 运算符的操作数必须为 function designator，[] 或 * 的运算结果，或者是一个不是 bit-field 和 register 修饰的左值。 * 运算符的操作数必须为指针类型。 Semantics \u0026*E 等价于 E，即 \u0026 和 * 被直接忽略，但是它们的 constraints 仍然起作用。所以 (\u0026*(void *)0) 并不会报错。 \u0026a[i] 等价于 a + i，即忽略了 \u0026 以及 * (由 [] 隐式指代)。 其它情况 \u0026 运算的结果为一个指向 object 或 function 的指针。 如果 * 运算符的操作数是一个指向 function 的指针，则结果为对应的 function designator。 如果 * 运算符的操作数是一个指向 object 的指针，则结果为指示该 obejct 的左值。 如果 * 运算符的操作数为非法值的指针，则对该指针进行 * 运算的行为三未定义的。 6.5.3.3 Unary arithmetic operatorsConstraints 单目 + 或 - 运算符的操作数必须为算数类型 (arithmetic type)，~ 运算符的操作数必须为整数类型 (integer type)，! 运算符的操作数必须为常数类型 (scalar type)。 Semantics 在进行单目 +、-、~ 运算之前，会对操作数进行整数提升 (integer promotions)，结果的类型与操作数进行整数提升后的类型一致。 !E 等价于 (E==0)，结果为 int 类型。 6.5.3.4待补充 ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:1:1","tags":["C/C++","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"\r6.5.7 Bitwise shift operatorsSyntax shift-expression: additive-exprssion shift-exprssion \u003e\u003e additive-expression shift-exprssion \u003c\u003ccadditive-expression Constraints 位运算的操作数都必须为整数类型。 Semantics 在进行位运算之前会先对操作数进行整数提升 (integer promotion)，位运算结果类型与整数提升后的左操作数一致。如果右运算数是负数，或者大于等于整数提升后的左运算数的类型的宽度，那么这个位运算行为是未定义的。 假设运算结果的类型为 T $E1 \u003c\u003c E2$ 如果 E1 是无符号，则结果为 $E1 \\times 2^{E2} \\bmod (\\max[T] + 1)$。 如果 E1 是有符号，E1 不是负数，并且 T 可以表示 $E1 \\times 2^{E2}$，则结果为 $E1 \\times 2^{E2}$。 除了以上两种行为外，其他均是未定义行为。 $E1 \u003e\u003e E2$ 如果 E1 是无符号，或者 E1 是有符号并且是非负数，则结果为 $E1 / 2^{E2}$。 如果 E1 是有符号并且是负数，则结果由具体实现决定 (implementation-defined)。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:1:2","tags":["C/C++","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"C 语言规格书 Chapter 7 - Library 阅读记录。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch7/:0:0","tags":["C/C++","Sysprog"],"title":"C 规格第 7 章阅读记录","uri":"/posts/c-specification/ch7/"},{"categories":["C"],"content":"\r7.18 Integer types \u003cstdint.h\u003e描述了头文件 stdint.h 必须定义和实现的整数类型，以及相应的宏。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch7/:1:0","tags":["C/C++","Sysprog"],"title":"C 规格第 7 章阅读记录","uri":"/posts/c-specification/ch7/"},{"categories":["C"],"content":"\r7.18.1 Integer types\r7.18.1.1 Exact-width integer types二补数编码，固定长度 N 的整数类型： 有符号数：intN_t 无符号数：uintN_t 7.18.1.2 Minimum-width integer types至少拥有长度 N 的整数类型： 有符号数：int_leastN_t 无符号数：uint_leastN_t 7.18.1.3 Fastest minimum-width integer types至少拥有长度 N，且操作速度最快的整数类型： 有符号数：int_fastN_t 无符号数：uint_fastN_t 7.18.1.4 Integer types capable of holding object pointers可以将指向 void 的有效指针转换成该整数类型，也可以将该整数类型转换回指向 void 的指针类型，并且转换结果与之前的指针值保持一致： 有符号数：intptr_t 无符号数：uintptr_t 7.18.1.5 Greatest-width integer types可以表示任意整数类型所表示的值的整数类型，即具有最大长度的整数类型： 有符号数：intmax_t 无符号数：uintmax_t ","date":"2024-01-11","objectID":"/posts/c-specification/ch7/:1:1","tags":["C/C++","Sysprog"],"title":"C 规格第 7 章阅读记录","uri":"/posts/c-specification/ch7/"},{"categories":["C"],"content":"C 语言规格书阅读学习记录。 规格书版本为 n1256，对应 C99 标准，对应的 PDF 下载地址。 也配合 C11 标准来阅读，版本 n1570，对应的 PDF 下载地址。 阅读规格书需要一定的体系结构、编译原理的相关知识，但不需要很高的程度。请善用检索工具，在阅读规格书时遇到术语时，请先在规格书中进行检索，因为极大可能是规格书自己定义的术语。 ","date":"2024-01-06","objectID":"/posts/c-specification/c-specification/:0:0","tags":["C/C++","Sysprog"],"title":"C 语言规格书阅读记录","uri":"/posts/c-specification/c-specification/"},{"categories":["C"],"content":"\r6. Language详见 阅读记录 6. Language。 ","date":"2024-01-06","objectID":"/posts/c-specification/c-specification/:1:0","tags":["C/C++","Sysprog"],"title":"C 语言规格书阅读记录","uri":"/posts/c-specification/c-specification/"},{"categories":["C"],"content":"\r7. Library详见 阅读记录 7. Library。 ","date":"2024-01-06","objectID":"/posts/c-specification/c-specification/:2:0","tags":["C/C++","Sysprog"],"title":"C 语言规格书阅读记录","uri":"/posts/c-specification/c-specification/"},{"categories":["Git"],"content":"\rGit 中文教学新手入门推荐，对于 Git 的入门操作讲解十分友好。 视频地址 学习记录 ","date":"2024-01-04","objectID":"/posts/git/:1:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习指引","uri":"/posts/git/"},{"categories":["Git"],"content":"\rGit 基本原理对 Git 原理介绍比较准确，UP 主其它关于 GitHub 的合集也比较推荐。 视频地址 学习记录 ","date":"2024-01-04","objectID":"/posts/git/:2:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习指引","uri":"/posts/git/"},{"categories":["Git"],"content":"\rLearn Git Branching交互性学习 Git 的网站，可以边玩边学 Git 操作，趣味性 MAX（来自 THUer 的推荐）。 网站地址 学习记录 ","date":"2024-01-04","objectID":"/posts/git/:3:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习指引","uri":"/posts/git/"},{"categories":["Git"],"content":"\rugit动手造一个 Mini Git，锻炼代码能力和加深原理理解。建议初步理解 Git 原理后再来挑战这个轮子。 仓库地址 教程地址 ","date":"2024-01-04","objectID":"/posts/git/:4:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习指引","uri":"/posts/git/"},{"categories":["Git"],"content":"\rReferences 知乎: 动手学习GIT - 最好学习GIT的方式是从零开始做一个 ","date":"2024-01-04","objectID":"/posts/git/:5:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习指引","uri":"/posts/git/"},{"categories":["Network"],"content":"整理一些计算机网络相关的资源 ","date":"2024-01-02","objectID":"/posts/network/:0:0","tags":["Network"],"title":"计算机网络学习指引","uri":"/posts/network/"},{"categories":["Network"],"content":"\rReferenecs 110-1 計算機網路 (清大開放式課程) 小菜学网络 NUDT 高级计算机网络实验: 基于UDP的可靠传输 可靠 UDP 的实现 (KCP over UDP) 基于UDP的可靠传输 [bilibili] 实现基于UDP的网络文件传输器，程序员的经验大礼包项目 [bilibili] ping命令但是用来通信，学习计算机网络好项目，也可能是校园网福利 [bilibili] Implementing TCP in Rust [YouTube] Let’s code a TCP/IP stack ","date":"2024-01-02","objectID":"/posts/network/:1:0","tags":["Network"],"title":"计算机网络学习指引","uri":"/posts/network/"},{"categories":["Linux Kernel Internals"],"content":"\r摘要\r人们对数学的加减运算可轻易在脑中辨识符号并理解其结果，但电脑做任何事都受限于实体资料储存及操作方式，换言之，电脑硬体实际只认得 0 和 1，却不知道符号 + 和 - 在数学及应用场域的意义，於是工程人员引入「补数」以便在二进位系统中，表达人们认知上的正负数。但您有没有想过，为何「二补数」(2’s complement) 被电脑广泛采用呢？背後的设计考量又是什麽？本文尝试从数学观点去解读编码背後的原理，并佐以资讯安全及程式码最佳化的考量，探讨二补数这样的编码对于程式设计有何关键影响。\r原文地址：解讀計算機編碼 ","date":"2023-12-31","objectID":"/posts/binary-representation/:0:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r一补数 (Ones’ complement)","date":"2023-12-31","objectID":"/posts/binary-representation/:1:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r9 的补数✅ 科普短片: Not just counting, but saving lives: Curta ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r运算原理\r注意\r以一补数编码形式表示的运算子，在参与运算后，运算结果符合一补数的编码： $$\r[X]_{一补数} + [Y]_{一补数} = [X+Y]_{一补数}\r$$\r接下来进行分类讨论，以 32-bit 正数 $X$, $Y$ 为例： $X + Y = X + Y$ 显然运算子和运算结果都满足一补数编码。 $X - Y = X + (2^{32} - 1 - Y)$ 如果 $X \u003e Y$，则运算结果应为 $X - Y$ 且为正数，其一补数编码为 $X - Y$。而此时 $$ 2^{32} - 1 + X - Y $$ 显然会溢出，为了使运算结果对应一补数编码，所以此时循环进位对应 $+\\ (1 - 2_{32})$。 如果 $X \u003c Y$，则运算结果应为 $X - Y$ 且为负数，其一补数编码为 $$ 2^{32} - 1 - （Y - X） = 2_{32} - 1 - X - Y $$ 而此时 $2^{32} - 1 + X - Y$ 并不会溢出，并且满足运算结果的一补数编码，所以无需进行循环进位。 如果 $X = Y$，显然 $$ X - Y = X + 2^{32} - 1 - Y = 2^{32} - 1 $$ 为 0 成立。 $-X - Y = (2^{32} - 1 - X) + (2^{32} - 1 - Y)$，显然会导致溢出。而 $-X - Y$ 的一补数编码为 $$ 2^{32} - 1 - (X + Y) = 2^{32} - 1 - X - Y $$ 所以需要在溢出时循环进位 $+\\ (1 - 2^{32})$ 来消除运算结果中的一个 $2^{32} - 1$。 ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:2","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r二补数 (Two’s complement)","date":"2023-12-31","objectID":"/posts/binary-representation/:2:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r正负数编码表示假设有 n-bit 的二补数编码 $A$，$-A$ 的推导如下： 格式一： $$\r\\begin{align*}\rA + \\neg A \u0026= 2^n - 1 \\\\\rA + \\neg A + 1 \u0026\\equiv 0 \\equiv 2^n \\ (\\bmod 2^n) \\\\\r-A \u0026= \\neg A + 1 \\\\ \\end{align*}\r$$\r格式二： $$\r\\begin{align*}\rA + \\neg A \u0026= 2^n - 1 \\\\\rA + \\neg A - 1 \u0026= 2^n - 2 \\\\\rA - 1 \u0026= 2^n - 1 - (\\neg A + 1) \\\\ \\neg (A - 1) \u0026= \\neg A + 1 \\\\\r\\neg (A - 1) \u0026= -A \\\\\r\\end{align*}\r$$\r也可以通过一补数和二补数，在时钟表上的对称轴偏差，来理解上述两种方式是等价的。 ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r加 / 减法器设计✅ 科普短片: See How Computers Add Numbers In One Lesson 了解晶体管的原理 了解基本逻辑门元件，例如 OR, AND 逻辑门的设计 了解加法器的原理和工作流程。 ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:2","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r阿贝尔群及对称性\r技巧\r群论的最大用途是关于「对称性」的研究；所有具有对称性质，群论都可派上用场。只要发生变换后仍有什么东西还维持不变，那符合对称的性质。 一个圆左右翻转后还是圆，它在这种变换下是对称的，而这刚好与群的 封闭性 (Closure) 对应。 一个时钟的时刻，从 0 时刻开始，两边的时刻相加模 12 的结果均为 0，这与群的 单位元 (Identity element) 和 逆元 (Inverse element) 对应。 上述两个例子反映了群论的性质，对于对称性研究的重要性和原理依据。 科普影片：从五次方程到伽罗瓦理论 阿贝尔和伽罗瓦的悲惨世界 ","date":"2023-12-31","objectID":"/posts/binary-representation/:3:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\r旁路攻击✅ 观看科普视频: 我听得到你打了什么字 阅读相关论文 Keyboard Acoustic Emanations 体验使用相关工具 kbd-audio ✅ 借由 Wikipedia 了解旁路攻击 (Side-channel attack) 和时序攻击 (Timing attack) 的基本概念。 Black-box testing Row hammer Cold boot attack Rubber-hose cryptanalysis 延伸阅读\rThe password guessing bug in Tenex Side Channel Attack By Using Hidden Markov Model One\u0026Done: A Single-Decryption EM-Based Attack on OpenSSL’s Constant-Time Blinded RSA ","date":"2023-12-31","objectID":"/posts/binary-representation/:4:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\rConstant-Time Functions比较常见的常数时间实作方法是，消除分支。因为不同分支的执行时间可能会不同，这会被利用进行时序攻击。这个方法需要对 C 语言中的编码和位运算有一定的了解。 C99 STandard - 7.18.1.1 Exact-width integer types 阅读记录 C99 Standard - 6.5.7.5 Bitwise shift operators 阅读记录 Branchless abs方法一，原理为 $-A = \\neg (A - 1)$: #include \u003cstdint.h\u003e int32_t abs(int32_t x) { int32_t mask = (x \u003e\u003e 31); return (x + mask) ^ mask; } 方法二，原理为 $-A = \\neg A + 1$: #include \u003cstdint.h\u003e int32_t abs(int32_t x) { int32_t mask = (x \u003e\u003e 31); return (x ^ mask) - mask; } Branchless min/maxMin: #include \u003cstdint.h\u003e int32_t min(int32_t a, int32_t b) { int32_t diff = (a - b); return b + (diff \u0026 (diff \u003e\u003e 31)); } 如果 diff \u003e 0 即 b 小，那么 (diff \u003e\u003e 31) == 0，则 b + (diff \u0026 (diff \u003e\u003e 31)) == b 如果 diff \u003c 0 即 a 小，那么 (diff \u003e\u003e 31) == -1，则 b + (diff \u0026 (diff \u003e\u003e 31)) == b + (a - b) == a Max: #include \u003cstdint.h\u003e int32_t max(int32_t a, int32_t b) { int32_t diff = (b - a); return b - (diff \u0026 (diff \u003e\u003e 31)); } 如果 diff \u003e 0 即 b 大, 那么 (diff \u003e\u003e 31) == 0，则 b - (diff \u0026 (diff \u003e\u003e 31)) == b 如果 diff \u003c 0 即 a 大，那么 (diff \u003e\u003e 31) == -1，则 b - (diff \u0026 (diff \u003e\u003e 31)) == b - (b - a) == a 延伸阅读\r❌ 基于 C 语言标准研究与系统程序安全议题\r","date":"2023-12-31","objectID":"/posts/binary-representation/:4:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"\rRust in 100 Seconds✅ 观看短片：Rust in 100 Seconds 了解 Rust，初步了解其安全性原理 所有权 (ownership) 借用 (borrow) 警告\r0:55 This is wrong, value mutability doesn’t have anything to do with the value being stored on the stack or the heap (and the example let mut hello = \"hi mom\" will be stored on the stack since it’s type is \u0026'static str), it depends on the type of the value (if it’s Sized or not).\r","date":"2023-12-28","objectID":"/posts/rust-introduction/:1:0","tags":["Rust","Sysprog"],"title":"Rust - 进行中的未来","uri":"/posts/rust-introduction/"},{"categories":["Linux Kernel Internals"],"content":"\rThe adoption of Rust in Business (2022)❌ 阅读报告 The adoption of Rust in Business (2022)。 ","date":"2023-12-28","objectID":"/posts/rust-introduction/:2:0","tags":["Rust","Sysprog"],"title":"Rust - 进行中的未来","uri":"/posts/rust-introduction/"},{"categories":["Git","Linux Kernel Internals"],"content":"教学影片：Git 中文教学 ","date":"2023-12-27","objectID":"/posts/git-learn/:0:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\r安装与设定\r注意\r✅ 观看影片 Git 教学系列 - 安装与配置，完成常用的 Git 设置。\r设置 Git 的编辑器为 vim，主要用于 commit 时的编辑： $ git config --global core.editor vim 设置 Git 的合并解决冲突工具为 vimdiff： $ git config --global merge.tool vimdiff 启用 Git 命令行界面的颜色显示： $ git config --global color.ui true 设置常用命令的别名： $ git config --global alias.st status $ git config --global alias.ch checkout $ git config --global alias.rst reset HEAD 效果为：命令 git st 等价于 git status，其余的类似。 设置 Windows 和 Mac/Linux 的换行符同步： # In Windows $ git config --global core.autocrlf true # In Mac/Linux $ git config --global core.autocrlf input 效果为：在 Windows 提交时自动将 CRLF 转为 LF，检出代码时将 LF 转换成 CRLF。在 Mac/Linux 提交时将 CRLF转为 LF，检出代码时不转换。这是因为 Windows 的换行符为 \\r\\n，而 Mac/Linux 的换行符仅为 \\n。 ","date":"2023-12-27","objectID":"/posts/git-learn/:1:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rAdd 和 Commit","date":"2023-12-27","objectID":"/posts/git-learn/:2:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\r指定 Commit\r注意\r✅ 观看影片 Git 教学系列 - 指定 Commit，掌握 git log、git show、git diff 的常用方法。理解 Hash Value 和 commit 对于 Git 版本控制的核心作用。\r只要 commit 了，资料基本不可能丢失，即使误操作了也是可以补救回来的（除非把 .git/ 文件夹也删除了）。\r","date":"2023-12-27","objectID":"/posts/git-learn/:3:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rHash Value Every commit has a unique hash value. Calculate by SHA1 Hash value can indicate a commit absolutely. ","date":"2023-12-27","objectID":"/posts/git-learn/:3:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rIndicate Commit git manage references to commit HEAD Branch Tag Remote Also, We can indicate commit by ^, ~ 通俗地将，不论是 HEAD、Branch、Tag、Remote，其本质都是使用 Hash Value 进行索引的 commit，所以 ~ 和 ^ 也可以作用于它们。 可以通过 git log 来查看 commit 以及对应的 Hash 值。事实上，这个命令十分灵活，举个例子： git log 4a6ebc -n1 这个命令的效果是从 Hash 值为 4a6bc 的 commit 开始打印 1 条 commit 记录（没错，对应的是 -n1），因为 Git 十分聪明，所以 commit 对应的 Hash 值只需前 6 位即可（因为这样已经几乎不会发生 Hash 冲突）。 Examples\r打印 master 分支的最新一个 commit： git log master -n1 打印 master 分支的最新一个 commit（仅使用一行打印 commit 信息）： git log master -n1 --oneline 打印 HEAD 所指向的 commit： git log HEAD -n1 --oneline 打印 HEAD 所指向的 commit 的前一个 commit： git log HEAD^ -n1 --oneline ^ 可以持续使用，比如 HEAD^^ 表示 HEAD 所指向的 commit 的前两个 commit。当 ^ 数量过多时，可以使用 ~ 搭配数字来达到相同效果。例如： git log HEAD^^^^^ -n1 --oneline git log HEAD~5 -n1 --oneline 一般来说，使用 ^ 就已经足够了，几乎不会遇到使用 ~ 的场景，因为这种场景一般会去找图形化界面吧。🤣 打印与文件 README.md 相关的 commits（仅使用一行显示）： git log --oneline README.md 打印与文件 README.md 相关的 commits（显示详细信息，包括文件内容的增减统计）： git log --stat README.md 打印与文件 README.md 相关的 commits（显示详细信息，包括文件内容的增减细节）： git log --patch README.md 在打印的 commit 信息中抓取与 README 符合的信息（可以与 --stat 或 --patch 配合使用）： git log -S README ","date":"2023-12-27","objectID":"/posts/git-learn/:3:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rView History git log \u003cpath\u003e|\u003ccommit\u003e -n: limit number --oneline: view hash and commit summary --stat: view files change --patch: view lines change -S or --grep: find modification ","date":"2023-12-27","objectID":"/posts/git-learn/:3:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rView Commit git show \u003ccommit\u003e Equal to log -n1 ","date":"2023-12-27","objectID":"/posts/git-learn/:3:4","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rSee Difference查看当前的修改，可以查看已经修改但没有 staged 文件的变化： git diff 查看当前的修改，可以查看已经修改且 staged 文件的变化： git diff --staged 查看当前与指定的 commit 的差异： git diff \u003ccommit\u003e # e.g. git diff master^ 查两个指定的 commit 之间的差异： git diff \u003ccommit\u003e \u003ccommit\u003e # e.g. git diff master^ master^^ ","date":"2023-12-27","objectID":"/posts/git-learn/:3:5","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rPath Add and Amend\r注意\r✅ 观看影片 Git 教学系列 - Patch Add and Amend，掌握 git add -p、git checkout -p、git add ---amend 的用法，使用 add 和 checkout 时强烈建议使用 -p，掌握修改 commit 的两种方法。\r","date":"2023-12-27","objectID":"/posts/git-learn/:4:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rOnly Add Related git add -p 推荐尽量使用这个 git add -p 而不是单纯的 git add。 使用 git add -p 后，Git 会帮我们把涉及的修改分成 section，然后我们就可以对每一个 section 涉及的修改进行 review，选择 y(yes) 表示采纳该 sction 对应的修改，选择 n(no) 表示不采纳。 如果觉得 section 切割的粒度太大了，可以选择 s(split) 来进行更细粒度的划分。如果这样仍然觉得粒度不够，可以选择 e(edit) 对 section 涉及的修改，进行以行为粒度的 review，具体操作可以查阅此时给出的提示。 还有一些其它的选项，比如 j、J、k、K，这些是类似 vim，用于切换进行 review 的 section，不太常用。q(quit) 表示退出。 由于可以针对一个文件的不同 section 进行 review，所以在进行 git add -p 之后，使用 git status 可以发现同一个文件会同时处于两种状态。 ","date":"2023-12-27","objectID":"/posts/git-learn/:4:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rCheckout Also git checkout -p 这个操作比较危险，因为这个操作的效果与 git add -p 相反，如果选择 y 的话，文件涉及的修改就会消失，如果涉及的修改没有 commit 的话，那么涉及的修改是无法救回的。但是怎么说，这个操作还是比直接使用 git checkout 稍微保险一点，因为会先进入 review 界面，而不是直接撤销修改。所以，请一定要使用 git checkout -p！ ","date":"2023-12-27","objectID":"/posts/git-learn/:4:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rModify Commit有两种方式来修改最新的 commit： # 1. Use git commit --amend git commit --amend # 2. Use reset HEAD^ then re-commit git reset HEAD^ git add -p git commit git commit --amend 并不是直接替换原有的 commit，而是创建了一个新的 commit 并重新设置了 HEAD 的指向。所以，新旧两个 commit 的 Hash Value 并不相同，事实上，如果你拥有旧 commit 的 Hash Value，是可以通过 git checkout \u003ccommit\u003e 切换到那个 commit 的。其原理如下图： 但是注意，git reset HEAD^ 是会撤销原先的 commit（仅限于本地 Git 存储库）。 ","date":"2023-12-27","objectID":"/posts/git-learn/:4:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rBranch and Merge\r注意\r✅ 观看影片 Git 教学系列 - Branch and Merge，掌握创建、删除、切换分支的用法，掌握合并分支、解决冲突的方法。 git checkout \u003ccommit\u003e git branch \u003cname\u003e git branch \u003cname\u003e \u003ccommit\u003e git branch [-d|-D] \u003cname\u003e git merge \u003cname\u003e --no-ff ","date":"2023-12-27","objectID":"/posts/git-learn/:5:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rMove and Create BranchCheckout: move HEAD git checkout \u003ccommit\u003e: Move HEAD to commit git checkout \u003cpath\u003e: WARNING: discard change 可以将路径上的文件复原到之前 commit 的状态。 Branch: git branch: List branch git branch \u003cname\u003e: Create branch Or just: git checkout -b Examples\r修改一个文件并恢复： # modify file load.cpp git status git checkout load.cpp git status 删除一个文件并恢复： rm load.cpp git status git checkout load.cpp git status 正如上一节所说的，git checkout 尽量带上 -p 参数，因为如果一不小心输入了 git checkout .，那就前功尽弃了。 显示分支： # only show name git branch # show more infomation git branch -v 切换分支： # switch to branch 'main' git checkout main 创建分支： # 1. using `git branch` git branch cload # 2. using `git checkout -b` git checkout -b asmload # 3. create a new branch in \u003ccommit\u003e git branch cload \u003ccommit\u003e 切换到任一 commit： git checkout \u003ccommit\u003e 直接 checkout 到任一 commit 会有警告，这是因为，当你以该 commit 为基点进行一系列的 commit，这些新的 commit 会在你切换分支后消失，因为没有 branch 来引用它们。之前可以被引用是因为 HEAD 引用，切换分支后 HEAD 不再引用这些 commit，所以就会消失。在这种情况，Git 会在发出警告的同时建议我们使用 git branch 来创建分支进行引用。 ","date":"2023-12-27","objectID":"/posts/git-learn/:5:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rView Branch列出仓库的所有分支： git branch 也可以通过 log 来查看分支： git log --decorate: 在 log 的首行显示所有的 references（可能需要通过 git config log.decorate auto 来开启） --graph: 以图形化的方式显示 branch 的关系（主要是 commit 的引用） ","date":"2023-12-27","objectID":"/posts/git-learn/:5:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rDelete Branch删除分支： git branch -d \u003cname\u003e 对于有没有 merge 的 commit 的分支，Git 会警告，需要使用 -D 来强制删除： git branch -D \u003cname\u003e for no-merge commit WARNING: Discard Commit Git 会发出警告的原因同样是 no-merge commit 在删除分支后就无法被引用，所以会发出警告。 ","date":"2023-12-27","objectID":"/posts/git-learn/:5:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rMerge合并分支。默认使用 fast-forward，即如果没有冲突，直接将要合并的分支提前到被合并分支的 commit 处，而不会另外生成一个 merge commit。但这样会使得被合并的分支在合并后，没有历史痕迹。可以通过 --no-ff (no fast forward) 来强制生成 merge commit。推荐使用 merge 时加上 --no-ff 这个参数。 git merge \u003cbranch\u003e 通常是 main/master 这类主分支合并其它分支： git checkout main/master git merge \u003cbranch\u003e ","date":"2023-12-27","objectID":"/posts/git-learn/:5:4","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rResolve ConflictManually resolve: Check every codes between \u003c\u003c\u003c\u003c\u003c\u003c\u003c, \u003e\u003e\u003e\u003e\u003e\u003e\u003e Edit code to what it should be Use mergetool like vimdiff: It shows: local, base, remote, file to be edited Edit “file ro be edited” to what is should be Add and Commit # 1. 合并分支 git merge \u003cbranch\u003e # 2. 检查状态，查看 unmerged 的文件 git status # 3. 编辑 unmerged 文件，编辑冲突区域代码即可 vim \u003cfile\u003e # 4. 添加解决完冲突的文件 git add \u003cfile\u003e # 5. 进行 merge commit git commit 冲突区域就是 \u003c\u003c\u003c\u003c\u003c\u003c\u003c 和 \u003e\u003e\u003e\u003e\u003e\u003e\u003e 内的区域，在 merge 操作后，Git 已经帮我们把 unmerged 文件修改为待解决冲突的状态，直接编辑文件即可。在编辑完成后，需要手动进行 add 和 commit，此次 commit 的信息 Git 已经帮我们写好了，一般不需要修改。\r如果使用的是 mergetool，以 vimdiff 为例，只需将第 3 步的 vim \u003cfile\u003e 改为 git mergetool 即可。vimdiff 会提供 4 个视窗：底部视窗是我们的编辑区，顶部左边是当前合并分支的状态，顶部中间是 base (合并分支和被合并的共同父节点) 的状态，顶部右边是 remote 的状态，按需要选择、编辑。 vimdiff 在编辑完后会保留 *.orig 的文件，这个文件是待解决冲突的文件副本。 ","date":"2023-12-27","objectID":"/posts/git-learn/:5:5","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rMerge Conflict Prevent very long development branch. Split source code clearly. ","date":"2023-12-27","objectID":"/posts/git-learn/:5:6","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"\rRebase\r注意\r✅ 观看影片 Git 教学系列 - Branch and Merge，掌握 TODO 的方法。git rebase 是 Git 的精华，可以让我们实现更细粒度的操作，可以说学会了 rebase 才算真正入门了 Git。 这个视频讲得比较乱，所以推荐配合视频给出的参考文章 Git-rebase 小笔记 来学习。 ","date":"2023-12-27","objectID":"/posts/git-learn/:6:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Linux"],"content":"\r网络代理根据项目 clash-for-linux-backup 来配置 Ubuntu 的网络代理。 $ git clone https://github.com/Elegybackup/clash-for-linux-backup.git clash-for-linux 过程当中可能需要安装 curl 和 net-tools，根据提示进行安装即可： sudo apt install curl sudo apt install net-tools 安装并启动完成后，可以通过 localhost:9090/ui 来访问 Dashboard。 启动代理： $ cd clash-for-linux $ sudo bash start.sh $ source /etc/profile.d/clash.sh $ proxy_on 关闭代理： $ cd clash-for-linux $ sudo bash shutdown.sh $ proxy_off ","date":"2023-12-27","objectID":"/posts/ubuntu/:1:0","tags":["Linux"],"title":"Ubuntu 22.04 配置","uri":"/posts/ubuntu/"},{"categories":["Linux"],"content":"\r搜狗输入法根据 搜狗输入法 Linux 安装指导 来安装搜狗输入法。 无需卸载系统 ibus 输入法框架。 通过 Ctrl + space 唤醒搜狗输入法。 ","date":"2023-12-27","objectID":"/posts/ubuntu/:2:0","tags":["Linux"],"title":"Ubuntu 22.04 配置","uri":"/posts/ubuntu/"},{"categories":["Linux"],"content":"\r快捷键新建终端： Ctrl + Alt + T 锁屏： Super + L：锁定屏幕并熄屏。 显示桌面： Super + d 或者 Ctrl + Alt + d 最小化所有运行的窗口并显示桌面，再次键入则重新打开之前的窗口。 显示所有的应用程序： Super + a 可以通过 ESC 来退出该显示。 显示当前运行的所有应用程序： Super 移动窗口位置： Super + 左箭头：当前窗口移动到屏幕左半边区域 Super + 右箭头：当前窗口移动到屏幕右半边区域 Super + 上箭头：当前窗口最大化 Super + 下箭头：当前窗口恢复正常 隐藏当前窗口到任务栏： Super + h 切换当前的应用程序： Super + Tab：以应用程序为粒度显示切换选项 Alt + Tab：以窗口为粒度显示切换选项 切换虚拟桌面/工作区： Ctrl + Alt + 左/右方向键 自定义键盘快捷键： Settings -\u003e Keyboard -\u003e Keyboard Shortcus | View and Customize Shortcuts -\u003e Custom Shortcuts ","date":"2023-12-27","objectID":"/posts/ubuntu/:3:0","tags":["Linux"],"title":"Ubuntu 22.04 配置","uri":"/posts/ubuntu/"},{"categories":["Linux Kernel Internals"],"content":"\r摘要\rGNU/Linux 开发工具，几乎从硬件到软件，Linux 平台能够自下而上提供各类触及“灵魂”的学习案例，让所有课程从纸上谈兵转变成沙场实战，会极大地提升工程实践的效率和技能。\r原文地址：GNU/Linux 开发工具 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:0:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\r安装 Windows / Ubuntu 双系统因为有些操作必须在物理硬件上才能执行。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:1:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\rMarkdown 与 LaTeX速览 LaTeX 语法示例一节，作为工具书册，在需要使用时知道如何查询。 速览 Markdown 语法示例一节，作为工具书册，在需要使用时知道如何查询。 注意\r编写 Markdown 文本以及 LaTeX 语法表示的数学式可以通过： Hugo + FixIt ✅ VS Code + Markdown Preview Enhanced ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:2:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\rGit 和 Github阅读 SSH key 产生方法一节，配置好 Git 和 Github 的 SSH key。同时也可作为工具书册，在需要使用时知道如何查询。 推荐通过 LearnGitBranching 来熟悉 Git 命令！！！ 以下资源作为自学资源，用于补充自己不熟悉的操作，或者作为以上资料的补充工具手册。 Git 中文教学（视频） 学习记录 30 天精通 Git 版本控制（文本） 警告\r原文档中的将公钥复制到 clipboard 中使用了 clip 命令，但是这个命令在 Ubuntu 中并没有对应的命令。可以使用 xclip + alias 达到近似效果。 $ sudo apt install xclip # using alias to implement clip, you can add this to bashrc $ alias='xclip -sel c' ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:3:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\r编辑器: Visual Studio Code认真阅读，跟随教学文档进行安装、设置。重点阅读 设定、除错（调试） 这两部分。更新 VS Code 部分作为手册，在需要时进行参考。 以下资源作为自学资源，用于补充自己不熟悉的操作，或者作为以上资料的补充工具手册。 开开心心学 Vistual Studio Code 完成 SSH key 的生成。 完成 VS Code 的设置。 安装 Git History 插件。 安装 Native Debug 插件，并进行 Debug (test-stopwatch.c) 操作。 安装 VSCode Great Icons 文件图标主题，另外推荐两款颜色主题：One Dark Pro, Learn with Sumit。 VS Code 控制台使用说明： 可以在面板的输出，点击 GIT 选项显示 VS Code 背后执行的 git 命令。 可以使用 ctrl + shift + P 呼出命令区，然后通过输入 Git branch 和 Git checkout 等并选择对应选项，来达到创建分支、切换分支等功能。 技巧\r在 VS Code 设置中，需要在设置中打开 Open Default Settings 选项才能在左侧面板观察到预设值。键位绑定同理。 要想进行调试，需要在使用 gcc 生成目标文件时，加入 -g 参数来生产调试信息。 原文档中的 GDB 教学链接-除错程式-gdb 已失效，这是目前的有效链接。也可通过该影片 拯救资工系学生的基本素养-使用 GDB 除错基本教学 来补充学习 GDB 的操作。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:4:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\r终端和 Vim认真阅读，跟随教学影片 快快乐乐学 Vim 和教学文档配置好 终端提示符、Vim。 完成命令行提示符配置 完成 Vim 的设定 安装并使用 Minial Vim Plugin Manager 来管理 Vim 插件 (neocomplcache, nerdtree) 安装并使用 byobu 来管理多个终端视图。 技巧\r在 .vimrc 中增加插件后，打开 vim，执行 :PlugInstall 来安装插件，完成后在 vim 执行 :source ~/.vimrc。（可以通过 :PlugStatus 来查看插件安装状态） 使用 F4 键来[显示/不显示][行数/相对行数]。 使用 F5 键来呼入/呼出文件树(nerdtree)，在文件树恻通过 ENTER 键来访问目录/文件。 使用 Ctrl-w-h/Ctrl-w-l 切换到 文件树/编辑区。 自动补全时使用 ENTER 键来选中，使用方向键或 Ctrl-N/Ctrl-U/Ctrl-P 来上下选择。 在 Vim 中可以通过 :set paste，并在 insert 模式下，将粘贴板的内容通过 Ctrl-Shift-V 进行粘贴。 推荐观看影片 How to Do 90% of What Plugins Do (With Just Vim) 来扩展 Vim 插件的使用姿势。 以下资源为 Cheat Sheet，需要使用时回来参考即可。 Vim Cheat Sheet Bash terminal Cheat Sheet ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:5:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\rMakefile速览教学文档，作为工具书册，在需要使用时知道如何查询。 gcc 的 -MMD 和 -MF 参数对我们编写 Makefile 是一个巨大利器。理解 Makefile 的各种变量定义的原理。 对之前的 test-stopwatch.c 编写了一个 Makefile 来自动化管理。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:6:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\rLinux 性能分析工具: Perf认真阅读，复现教学文档中的所有例子，初步体验 perf 在性能分析上的强大。 安装 perf 并将 kernel.perf_event_paranoid 设置为 1。 动手使用 perf_top_example.c，体验 perf 的作用。 搭配影片: Branch Prediction 对照阅读: Fast and slow if-statements: branch prediction in modern processors 编译器提供的辅助机制: Branch Patterns, Using GCC 动手使用 perf_top_while.c，体验 perf top 的作用。 动手使用 perf_stat_cache_miss.c，体验 perf stat 的作用。（原文的结果有些不直观，务必亲自动手验证） 动手使用 perf_record_example.c，体验 perf record 的作用。（原文的操作不是很详细，可以参考下面的 Success） 源程序地址 成功\r$ perf record -e branch-misses:u,branch-instructions:u ./perf_record_example [ perf record: Woken up 1 times to write data ] [ perf record: Captured and wrote 0.009 MB perf.data (94 samples) ] 输出第一行表示 perf 工具在收集性能数据时被唤醒了 1 次，以将数据写入输出文件。 输出第二行表示 perf 工具已经取样并写入了一个名为 perf.data 的二进制文件，文件大小为 0.009 MB，其中包含了 94 个采样。（可以通过 ls 命令来检查 perf.data 文件是否存在） 接下来通过 perf report 对之前输出的二进制文件 perf.data 进行分析。可以通过方向键选择，并通过 ENTER 进入下一层查看分析结果。 $ perf report Available samples 5 branch-misses:u 89 branch-instructions:u 技巧\rperf 需要在 root 下进行性能分析。 perf top 是对于哪个程序是性能瓶颈没有头绪时使用，可以查看哪个程序（以及程序的哪个部分）是热度点。 在 perf top 时可以通过 h 键呼出帮助列表。 可以通过方向键选择需要进一步分析的部分，并通过 a 键来查看指令级别粒度的热点。 perf stat 是对某一个要优化的程序进行性能分析，对该程序涉及的一系列 events 进行取样检查。 perf record 的精度比 perf stat 更高，可以对取样的 events 进行函数粒度的分析。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:7:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\rLinux 绘图工具: gnuplot安装 gnuplot: $ sudo apt-get install gnuplot ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:8:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\r学习记录","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:9:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"\rGDB 调试观看教学视频 拯救資工系學生的基本素養—使用 GDB 除錯基本教學 和搭配博文 ==How to debug Rust/C/C++ via GDB==，学习 GDB 的基本操作和熟悉使用 GDB 调试 Rust/C/C++ 程序。 掌握 run/r, break/b, print/p, continue/c, step/s info/i, delete/d, backtrace/bt, frame/f, up/down, exit/q 等命令的用法。以及 GBD 的一些特性，例如 GDB 会将空白行的断点自动下移到下一代码行；使用 break 命令时可以输入源文件路径，也可以只输入源文件名称。 相关的测试文件： test.c hello_cargo/ ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:9:1","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Mathematics"],"content":" 中大數學系開放式課程 台大齐震宇 - 数学潜水艇、微积分、分析 台大谢铭伦 - 线性代数 ","date":"2023-12-23","objectID":"/posts/math/:0:0","tags":["Math"],"title":"数学开放式课程学习指引","uri":"/posts/math/"},{"categories":["Mathematics"],"content":"\r概率统计阳明交通大学 陈临安老师，开设了两学期的统计课程，分别是上学期的 统计学 和下学期的 高等统计学。 课程名称 英文名称 课程地址 课程视频 统计学 Statistics 课程资讯 YouTube 高等统计学 Advanced Statistics 课程资讯 YouTube 信息\r这两个学期课程的作业、习题以及解答都可以在 这里 找到。\r","date":"2023-12-23","objectID":"/posts/math/:1:0","tags":["Math"],"title":"数学开放式课程学习指引","uri":"/posts/math/"},{"categories":["draft"],"content":"博客（英语：Blog）是一种在线日记型式的个人网站，借由张帖子章、图片或视频来记录生活、抒发情感或分享信息。博客上的文章通常根据张贴时间，以倒序方式由新到旧排列。 ","date":"2023-12-23","objectID":"/posts/hello_world/:0:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"\r数学公式行内公式：$N(b,d)=(b-1)M$ 公式块： $$\r\\int_{a}^{b}x(t)dt =\r\\dfrac{b - a}{N} \\\\\r=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N}\r$$\r$$\r\\begin{aligned}\r\\int_{a}^{b}x(t)dt \u0026=\r\\dfrac{b - a}{N} \\\\\r\u0026=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} \\\\\r\\end{aligned}\r$$\r$$\r\\mathrm{Integrals\\ are\\ numerically\\ approximated\\ as\\ finite\\ series}:\\\\ \\begin{split}\r\\int_{a}^{b}x(t)dt \u0026=\r\\dfrac{b - a}{N} \\\\\r\u0026=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N}\r\\end{split} \\\\ where\\ t_k = a + (b-a)\\cdot k/N\r$$\r$$\r\\begin{align*}\rp(x) = 3x^6 + 14x^5y \u0026+ 590x^4y^2 + 19x^3y^3 \\\\\r\u0026- 12x^2y^4 - 12xy^5 + 2y^6 - a^3b^3 - a^2b - ab + c^5d^3 + c^4d^3 - cd\r\\end{align*}\r$$\r","date":"2023-12-23","objectID":"/posts/hello_world/:1:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"\r代码块 let i: i32 = 13; let v = vec![1, 2, 3, 4, 5, 65]; for x in v.iter() { println!(\"{}\", x); } typedef struct Block_t { int head; int data; } Block_t; ","date":"2023-12-23","objectID":"/posts/hello_world/:2:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"\rAdmonition\r注意\r一个 注意 横幅\r摘要\r一个 摘要 横幅\r信息\r一个 信息 横幅\r技巧\r一个 技巧 横幅\r成功\r一个 成功 横幅\r问题\r一个 问题 横幅\r警告\r一个 警告 横幅\r失败\r一个 失败 横幅\r危险\r一个 危险 横幅\rBug\r一个 Bug 横幅\r示例\r一个 示例 横幅\r引用\r一个 引用 横幅\r","date":"2023-12-23","objectID":"/posts/hello_world/:3:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"\rReferences FixIt 快速上手 使用 Hugo + Github 搭建个人博客 Emoji 支持 扩展 Shortcodes 概述 URL management ","date":"2023-12-23","objectID":"/posts/hello_world/:4:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"}]
>>>>>>> network
