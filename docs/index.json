[{"categories":["C"],"content":"C 语言规格书 Chapter 6 - Language 阅读记录。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:0:0","tags":["C/C++","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"6.5 Expressions ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:1:0","tags":["C/C++","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"6.5.7 Bitwise shift operators 位运算的操作数都必须为整数类型。 在进行位运算之前会先对操作数进行整数提升 (integer promotion)，位运算结果类型与整数提升后的左操作数一致。如果右运算数是负数，或者大于等于整数提升后的左运算数的类型的宽度，那么这个位运算行为是未定义的。 假设运算结果的类型为 T $E1 \u003c\u003c E2$ 如果 E1 是无符号，则结果为 $E1 \\times 2^{E2} \\bmod (\\max[T] + 1)$。 如果 E1 是有符号，E1 不是负数，并且 T 可以表示 $E1 \\times 2^{E2}$，则结果为 $E1 \\times 2^{E2}$。 除了以上两种行为外，其他均是未定义行为。 $E1 \u003e\u003e E2$ 如果 E1 是无符号，或者 E1 是有符号并且是非负数，则结果为 $E1 / 2^{E2}$。 如果 E1 是有符号并且是负数，则结果由具体实现决定 (implementation-defined)。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:1:1","tags":["C/C++","Sysprog"],"title":"C 规格第 6 章阅读记录","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"C 语言规格书 Chapter 7 - Library 阅读记录。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch7/:0:0","tags":["C/C++","Sysprog"],"title":"C 规格第 7 章阅读记录","uri":"/posts/c-specification/ch7/"},{"categories":["C"],"content":"7.18 Integer types \u003cstdint.h\u003e 描述了头文件 stdint.h 必须定义和实现的整数类型，以及相应的宏。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch7/:1:0","tags":["C/C++","Sysprog"],"title":"C 规格第 7 章阅读记录","uri":"/posts/c-specification/ch7/"},{"categories":["C"],"content":"7.18.1 Integer types 7.18.1.1 Exact-width integer types 二补数编码，固定长度 N 的整数类型： 有符号数：intN_t 无符号数：uintN_t 7.18.1.2 Minimum-width integer types 至少拥有长度 N 的整数类型： 有符号数：int_leastN_t 无符号数：uint_leastN_t 7.18.1.3 Fastest minimum-width integer types 至少拥有长度 N，且操作速度最快的整数类型： 有符号数：int_fastN_t 无符号数：uint_fastN_t 7.18.1.4 Integer types capable of holding object pointers 可以将指向 void 的有效指针转换成该整数类型，也可以将该整数类型转换回指向 void 的指针类型，并且转换结果与之前的指针值保持一致： 有符号数：intptr_t 无符号数：uintptr_t 7.18.1.5 Greatest-width integer types 可以表示任意整数类型所表示的值的整数类型，即具有最大长度的整数类型： 有符号数：intmax_t 无符号数：uintmax_t ","date":"2024-01-11","objectID":"/posts/c-specification/ch7/:1:1","tags":["C/C++","Sysprog"],"title":"C 规格第 7 章阅读记录","uri":"/posts/c-specification/ch7/"},{"categories":["C"],"content":"C 语言规格书阅读学习记录。 阅读的规格书版本为 n1256，对应的下载地址为 C 语言规格书。 ","date":"2024-01-06","objectID":"/posts/c-specification/c-specification/:0:0","tags":["C/C++","Sysprog"],"title":"C 语言规格书阅读记录","uri":"/posts/c-specification/c-specification/"},{"categories":["C"],"content":"6. Language 详见 阅读记录 6. Language。 ","date":"2024-01-06","objectID":"/posts/c-specification/c-specification/:1:0","tags":["C/C++","Sysprog"],"title":"C 语言规格书阅读记录","uri":"/posts/c-specification/c-specification/"},{"categories":["C"],"content":"7. Library 详见 阅读记录 7. Library。 ","date":"2024-01-06","objectID":"/posts/c-specification/c-specification/:2:0","tags":["C/C++","Sysprog"],"title":"C 语言规格书阅读记录","uri":"/posts/c-specification/c-specification/"},{"categories":["Git"],"content":"Git 中文教学 新手入门推荐，对于 Git 的入门操作讲解十分友好。 视频地址 学习记录 ","date":"2024-01-04","objectID":"/posts/git/git/:1:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习导航","uri":"/posts/git/git/"},{"categories":["Git"],"content":"Git 基本原理 对 Git 原理介绍比较准确，UP 主其它关于 GitHub 的合集也比较推荐。 视频地址 学习记录 ","date":"2024-01-04","objectID":"/posts/git/git/:2:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习导航","uri":"/posts/git/git/"},{"categories":["Git"],"content":"Learn Git Branching 交互性学习 Git 的网站，可以边玩边学 Git 操作，趣味性 MAX（来自 THUer 的推荐）。 网站地址 学习记录 ","date":"2024-01-04","objectID":"/posts/git/git/:3:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习导航","uri":"/posts/git/git/"},{"categories":["Git"],"content":"ugit 动手造一个 Mini Git，锻炼代码能力和加深原理理解。建议初步理解 Git 原理后再来挑战这个轮子。 仓库地址 教程地址 ","date":"2024-01-04","objectID":"/posts/git/git/:4:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习导航","uri":"/posts/git/git/"},{"categories":["Git"],"content":"References 知乎: 动手学习GIT - 最好学习GIT的方式是从零开始做一个 ","date":"2024-01-04","objectID":"/posts/git/git/:5:0","tags":["Git/GitHub"],"title":"Git/GitHub 学习导航","uri":"/posts/git/git/"},{"categories":["Network"],"content":"清大开放式课程 - 计算机网络 课程主页 课程资料 课程视频 ","date":"2024-01-02","objectID":"/posts/network/network/:1:0","tags":["Network"],"title":"计算机网络学习指引","uri":"/posts/network/network/"},{"categories":["Network"],"content":"Referenecs 110-1 計算機網路 (清大開放式課程) ","date":"2024-01-02","objectID":"/posts/network/network/:2:0","tags":["Network"],"title":"计算机网络学习指引","uri":"/posts/network/network/"},{"categories":["Linux Kernel Internals"],"content":" 摘要 人们对数学的加减运算可轻易在脑中辨识符号并理解其结果，但电脑做任何事都受限于实体资料储存及操作方式，换言之，电脑硬体实际只认得 0 和 1，却不知道符号 + 和 - 在数学及应用场域的意义，於是工程人员引入「补数」以便在二进位系统中，表达人们认知上的正负数。但您有没有想过，为何「二补数」(2’s complement) 被电脑广泛采用呢？背後的设计考量又是什麽？本文尝试从数学观点去解读编码背後的原理，并佐以资讯安全及程式码最佳化的考量，探讨二补数这样的编码对于程式设计有何关键影响。 原文地址：解讀計算機編碼 ","date":"2023-12-31","objectID":"/posts/sysprog/binary-representation/:0:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/sysprog/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"一补数 (Ones’ complement) ","date":"2023-12-31","objectID":"/posts/sysprog/binary-representation/:1:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/sysprog/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"9 的补数 ✅ 科普短片: Not just counting, but saving lives: Curta ","date":"2023-12-31","objectID":"/posts/sysprog/binary-representation/:1:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/sysprog/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"运算原理 注意 以一补数编码形式表示的运算子，在参与运算后，运算结果符合一补数的编码： $$ [X]_{一补数} + [Y]_{一补数} = [X+Y]_{一补数} $$ 接下来进行分类讨论，以 32-bit 正数 $X$, $Y$ 为例： $X + Y = X + Y$ 显然运算子和运算结果都满足一补数编码。 $X - Y = X + (2^{32} - 1 - Y)$ 如果 $X \u003e Y$，则运算结果应为 $X - Y$ 且为正数，其一补数编码为 $X - Y$。而此时 $$ 2^{32} - 1 + X - Y $$ 显然会溢出，为了使运算结果对应一补数编码，所以此时循环进位对应 $+\\ (1 - 2_{32})$。 如果 $X \u003c Y$，则运算结果应为 $X - Y$ 且为负数，其一补数编码为 $$ 2^{32} - 1 - （Y - X） = 2_{32} - 1 - X - Y $$ 而此时 $2^{32} - 1 + X - Y$ 并不会溢出，并且满足运算结果的一补数编码，所以无需进行循环进位。 如果 $X = Y$，显然 $$ X - Y = X + 2^{32} - 1 - Y = 2^{32} - 1 $$ 为 0 成立。 $-X - Y = (2^{32} - 1 - X) + (2^{32} - 1 - Y)$，显然会导致溢出。而 $-X - Y$ 的一补数编码为 $$ 2^{32} - 1 - (X + Y) = 2^{32} - 1 - X - Y $$ 所以需要在溢出时循环进位 $+\\ (1 - 2^{32})$ 来消除运算结果中的一个 $2^{32} - 1$。 ","date":"2023-12-31","objectID":"/posts/sysprog/binary-representation/:1:2","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/sysprog/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"二补数 (Two’s complement) ","date":"2023-12-31","objectID":"/posts/sysprog/binary-representation/:2:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/sysprog/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"正负数编码表示 假设有 n-bit 的二补数编码 $A$，$-A$ 的推导如下： 格式一： $$ \\begin{align*} A + \\neg A \u0026= 2^n - 1 \\\\ A + \\neg A + 1 \u0026\\equiv 0 \\equiv 2^n \\ (\\bmod 2^n) \\\\ -A \u0026= \\neg A + 1 \\\\ \\end{align*} $$ 格式二： $$ \\begin{align*} A + \\neg A \u0026= 2^n - 1 \\\\ A + \\neg A - 1 \u0026= 2^n - 2 \\\\ A - 1 \u0026= 2^n - 1 - (\\neg A + 1) \\\\ \\neg (A - 1) \u0026= \\neg A + 1 \\\\ \\neg (A - 1) \u0026= -A \\\\ \\end{align*} $$ 也可以通过一补数和二补数，在时钟表上的对称轴偏差，来理解上述两种方式是等价的。 ","date":"2023-12-31","objectID":"/posts/sysprog/binary-representation/:2:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/sysprog/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"加 / 减法器设计 ✅ 科普短片: See How Computers Add Numbers In One Lesson 了解晶体管的原理 了解基本逻辑门元件，例如 OR, AND 逻辑门的设计 了解加法器的原理和工作流程。 ","date":"2023-12-31","objectID":"/posts/sysprog/binary-representation/:2:2","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/sysprog/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"阿贝尔群及对称性 技巧 群论的最大用途是关于「对称性」的研究；所有具有对称性质，群论都可派上用场。只要发生变换后仍有什么东西还维持不变，那符合对称的性质。 一个圆左右翻转后还是圆，它在这种变换下是对称的，而这刚好与群的 封闭性 (Closure) 对应。 一个时钟的时刻，从 0 时刻开始，两边的时刻相加模 12 的结果均为 0，这与群的 单位元 (Identity element) 和 逆元 (Inverse element) 对应。 上述两个例子反映了群论的性质，对于对称性研究的重要性和原理依据。 科普影片：从五次方程到伽罗瓦理论 阿贝尔和伽罗瓦的悲惨世界 ","date":"2023-12-31","objectID":"/posts/sysprog/binary-representation/:3:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/sysprog/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"旁路攻击 ✅ 观看科普视频: 我听得到你打了什么字 阅读相关论文 Keyboard Acoustic Emanations 体验使用相关工具 kbd-audio ✅ 借由 Wikipedia 了解旁路攻击 (Side-channel attack) 和时序攻击 (Timing attack) 的基本概念。 Black-box testing Row hammer Cold boot attack Rubber-hose cryptanalysis 延伸阅读 The password guessing bug in Tenex Side Channel Attack By Using Hidden Markov Model One\u0026Done: A Single-Decryption EM-Based Attack on OpenSSL’s Constant-Time Blinded RSA ","date":"2023-12-31","objectID":"/posts/sysprog/binary-representation/:4:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/sysprog/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"Constant-Time Functions 比较常见的常数时间实作方法是，消除分支。因为不同分支的执行时间可能会不同，这会被利用进行时序攻击。这个方法需要对 C 语言中的编码和位运算有一定的了解。 C99 STandard - 7.18.1.1 Exact-width integer types 阅读记录 C99 Standard - 6.5.7.5 Bitwise shift operators 阅读记录 Branchless abs 方法一，原理为 $-A = \\neg (A - 1)$: #include \u003cstdint.h\u003e int32_t abs(int32_t x) { int32_t mask = (x \u003e\u003e 31); return (x + mask) ^ mask; } 方法二，原理为 $-A = \\neg A + 1$: #include \u003cstdint.h\u003e int32_t abs(int32_t x) { int32_t mask = (x \u003e\u003e 31); return (x ^ mask) - mask; } Branchless min/max Min: #include \u003cstdint.h\u003e int32_t min(int32_t a, int32_t b) { int32_t diff = (a - b); return b + (diff \u0026 (diff \u003e\u003e 31)); } 如果 diff \u003e 0 即 b 小，那么 (diff \u003e\u003e 31) == 0，则 b + (diff \u0026 (diff \u003e\u003e 31)) == b 如果 diff \u003c 0 即 a 小，那么 (diff \u003e\u003e 31) == -1，则 b + (diff \u0026 (diff \u003e\u003e 31)) == b + (a - b) == a Max: #include \u003cstdint.h\u003e int32_t max(int32_t a, int32_t b) { int32_t diff = (b - a); return b - (diff \u0026 (diff \u003e\u003e 31)); } 如果 diff \u003e 0 即 b 大, 那么 (diff \u003e\u003e 31) == 0，则 b - (diff \u0026 (diff \u003e\u003e 31)) == b 如果 diff \u003c 0 即 a 大，那么 (diff \u003e\u003e 31) == -1，则 b - (diff \u0026 (diff \u003e\u003e 31)) == b - (b - a) == a 延伸阅读 ❌ 基于 C 语言标准研究与系统程序安全议题 ","date":"2023-12-31","objectID":"/posts/sysprog/binary-representation/:4:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/sysprog/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"Rust in 100 Seconds ✅ 观看短片：Rust in 100 Seconds 了解 Rust，初步了解其安全性原理 所有权 (ownership) 借用 (borrow) 警告 0:55 This is wrong, value mutability doesn’t have anything to do with the value being stored on the stack or the heap (and the example let mut hello = \"hi mom\" will be stored on the stack since it’s type is \u0026'static str), it depends on the type of the value (if it’s Sized or not). ","date":"2023-12-28","objectID":"/posts/sysprog/rust-introduction/:1:0","tags":["Rust","Sysprog"],"title":"Rust - 进行中的未来","uri":"/posts/sysprog/rust-introduction/"},{"categories":["Linux Kernel Internals"],"content":"The adoption of Rust in Business (2022) ❌ 阅读报告 The adoption of Rust in Business (2022)。 ","date":"2023-12-28","objectID":"/posts/sysprog/rust-introduction/:2:0","tags":["Rust","Sysprog"],"title":"Rust - 进行中的未来","uri":"/posts/sysprog/rust-introduction/"},{"categories":["Git","Linux Kernel Internals"],"content":"教学影片：Git 中文教学 ","date":"2023-12-27","objectID":"/posts/git/git-learn/:0:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"安装与设定 注意 ✅ 观看影片 Git 教学系列 - 安装与配置，完成常用的 Git 设置。 设置 Git 的编辑器为 vim，主要用于 commit 时的编辑： $ git config --global core.editor vim 设置 Git 的合并解决冲突工具为 vimdiff： $ git config --global merge.tool vimdiff 启用 Git 命令行界面的颜色显示： $ git config --global color.ui true 设置常用命令的别名： $ git config --global alias.st status $ git config --global alias.ch checkout $ git config --global alias.rst reset HEAD 效果为：命令 git st 等价于 git status，其余的类似。 设置 Windows 和 Mac/Linux 的换行符同步： # In Windows $ git config --global core.autocrlf true # In Mac/Linux $ git config --global core.autocrlf input 效果为：在 Windows 提交时自动将 CRLF 转为 LF，检出代码时将 LF 转换成 CRLF。在 Mac/Linux 提交时将 CRLF转为 LF，检出代码时不转换。这是因为 Windows 的换行符为 \\r\\n，而 Mac/Linux 的换行符仅为 \\n。 ","date":"2023-12-27","objectID":"/posts/git/git-learn/:1:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Add 和 Commit ","date":"2023-12-27","objectID":"/posts/git/git-learn/:2:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"指定 Commit 注意 ✅ 观看影片 Git 教学系列 - 指定 Commit，掌握 git log、git show、git diff 的常用方法。理解 Hash Value 和 commit 对于 Git 版本控制的核心作用。 只要 commit 了，资料基本不可能丢失，即使误操作了也是可以补救回来的（除非把 .git/ 文件夹也删除了）。 ","date":"2023-12-27","objectID":"/posts/git/git-learn/:3:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Hash Value Every commit has a unique hash value. Calculate by SHA1 Hash value can indicate a commit absolutely. ","date":"2023-12-27","objectID":"/posts/git/git-learn/:3:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Indicate Commit git manage references to commit HEAD Branch Tag Remote Also, We can indicate commit by ^, ~ 通俗地将，不论是 HEAD、Branch、Tag、Remote，其本质都是使用 Hash Value 进行索引的 commit，所以 ~ 和 ^ 也可以作用于它们。 可以通过 git log 来查看 commit 以及对应的 Hash 值。事实上，这个命令十分灵活，举个例子： git log 4a6ebc -n1 这个命令的效果是从 Hash 值为 4a6bc 的 commit 开始打印 1 条 commit 记录（没错，对应的是 -n1），因为 Git 十分聪明，所以 commit 对应的 Hash 值只需前 6 位即可（因为这样已经几乎不会发生 Hash 冲突）。 Examples 打印 master 分支的最新一个 commit： git log master -n1 打印 master 分支的最新一个 commit（仅使用一行打印 commit 信息）： git log master -n1 --oneline 打印 HEAD 所指向的 commit： git log HEAD -n1 --oneline 打印 HEAD 所指向的 commit 的前一个 commit： git log HEAD^ -n1 --oneline ^ 可以持续使用，比如 HEAD^^ 表示 HEAD 所指向的 commit 的前两个 commit。当 ^ 数量过多时，可以使用 ~ 搭配数字来达到相同效果。例如： git log HEAD^^^^^ -n1 --oneline git log HEAD~5 -n1 --oneline 一般来说，使用 ^ 就已经足够了，几乎不会遇到使用 ~ 的场景，因为这种场景一般会去找图形化界面吧。🤣 打印与文件 README.md 相关的 commits（仅使用一行显示）： git log --oneline README.md 打印与文件 README.md 相关的 commits（显示详细信息，包括文件内容的增减统计）： git log --stat README.md 打印与文件 README.md 相关的 commits（显示详细信息，包括文件内容的增减细节）： git log --patch README.md 在打印的 commit 信息中抓取与 README 符合的信息（可以与 --stat 或 --patch 配合使用）： git log -S README ","date":"2023-12-27","objectID":"/posts/git/git-learn/:3:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"View History git log \u003cpath\u003e|\u003ccommit\u003e -n: limit number --oneline: view hash and commit summary --stat: view files change --patch: view lines change -S or --grep: find modification ","date":"2023-12-27","objectID":"/posts/git/git-learn/:3:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"View Commit git show \u003ccommit\u003e Equal to log -n1 ","date":"2023-12-27","objectID":"/posts/git/git-learn/:3:4","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"See Difference 查看当前的修改，可以查看已经修改但没有 staged 文件的变化： git diff 查看当前的修改，可以查看已经修改且 staged 文件的变化： git diff --staged 查看当前与指定的 commit 的差异： git diff \u003ccommit\u003e # e.g. git diff master^ 查两个指定的 commit 之间的差异： git diff \u003ccommit\u003e \u003ccommit\u003e # e.g. git diff master^ master^^ ","date":"2023-12-27","objectID":"/posts/git/git-learn/:3:5","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Path Add and Amend 注意 ✅ 观看影片 Git 教学系列 - Patch Add and Amend，掌握 git add -p、git checkout -p、git add ---amend 的用法，使用 add 和 checkout 时强烈建议使用 -p，掌握修改 commit 的两种方法。 ","date":"2023-12-27","objectID":"/posts/git/git-learn/:4:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Only Add Related git add -p 推荐尽量使用这个 git add -p 而不是单纯的 git add。 使用 git add -p 后，Git 会帮我们把涉及的修改分成 section，然后我们就可以对每一个 section 涉及的修改进行 review，选择 y(yes) 表示采纳该 sction 对应的修改，选择 n(no) 表示不采纳。 如果觉得 section 切割的粒度太大了，可以选择 s(split) 来进行更细粒度的划分。如果这样仍然觉得粒度不够，可以选择 e(edit) 对 section 涉及的修改，进行以行为粒度的 review，具体操作可以查阅此时给出的提示。 还有一些其它的选项，比如 j、J、k、K，这些是类似 vim，用于切换进行 review 的 section，不太常用。q(quit) 表示退出。 由于可以针对一个文件的不同 section 进行 review，所以在进行 git add -p 之后，使用 git status 可以发现同一个文件会同时处于两种状态。 ","date":"2023-12-27","objectID":"/posts/git/git-learn/:4:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Checkout Also git checkout -p 这个操作比较危险，因为这个操作的效果与 git add -p 相反，如果选择 y 的话，文件涉及的修改就会消失，如果涉及的修改没有 commit 的话，那么涉及的修改是无法救回的。但是怎么说，这个操作还是比直接使用 git checkout 稍微保险一点，因为会先进入 review 界面，而不是直接撤销修改。所以，请一定要使用 git checkout -p！ ","date":"2023-12-27","objectID":"/posts/git/git-learn/:4:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Modify Commit 有两种方式来修改最新的 commit： # 1. Use git commit --amend git commit --amend # 2. Use reset HEAD^ then re-commit git reset HEAD^ git add -p git commit git commit --amend 并不是直接替换原有的 commit，而是创建了一个新的 commit 并重新设置了 HEAD 的指向。所以，新旧两个 commit 的 Hash Value 并不相同，事实上，如果你拥有旧 commit 的 Hash Value，是可以通过 git checkout \u003ccommit\u003e 切换到那个 commit 的。其原理如下图： 但是注意，git reset HEAD^ 是会撤销原先的 commit（仅限于本地 Git 存储库）。 ","date":"2023-12-27","objectID":"/posts/git/git-learn/:4:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Branch and Merge 注意 ✅ 观看影片 Git 教学系列 - Branch and Merge，掌握创建、删除、切换分支的用法，掌握合并分支、解决冲突的方法。 git checkout \u003ccommit\u003e git branch \u003cname\u003e git branch \u003cname\u003e \u003ccommit\u003e git branch [-d|-D] \u003cname\u003e git merge \u003cname\u003e --no-ff ","date":"2023-12-27","objectID":"/posts/git/git-learn/:5:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Move and Create Branch Checkout: move HEAD git checkout \u003ccommit\u003e: Move HEAD to commit git checkout \u003cpath\u003e: WARNING: discard change 可以将路径上的文件复原到之前 commit 的状态。 Branch: git branch: List branch git branch \u003cname\u003e: Create branch Or just: git checkout -b Examples 修改一个文件并恢复： # modify file load.cpp git status git checkout load.cpp git status 删除一个文件并恢复： rm load.cpp git status git checkout load.cpp git status 正如上一节所说的，git checkout 尽量带上 -p 参数，因为如果一不小心输入了 git checkout .，那就前功尽弃了。 显示分支： # only show name git branch # show more infomation git branch -v 切换分支： # switch to branch 'main' git checkout main 创建分支： # 1. using `git branch` git branch cload # 2. using `git checkout -b` git checkout -b asmload # 3. create a new branch in \u003ccommit\u003e git branch cload \u003ccommit\u003e 切换到任一 commit： git checkout \u003ccommit\u003e 直接 checkout 到任一 commit 会有警告，这是因为，当你以该 commit 为基点进行一系列的 commit，这些新的 commit 会在你切换分支后消失，因为没有 branch 来引用它们。之前可以被引用是因为 HEAD 引用，切换分支后 HEAD 不再引用这些 commit，所以就会消失。在这种情况，Git 会在发出警告的同时建议我们使用 git branch 来创建分支进行引用。 ","date":"2023-12-27","objectID":"/posts/git/git-learn/:5:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"View Branch 列出仓库的所有分支： git branch 也可以通过 log 来查看分支： git log --decorate: 在 log 的首行显示所有的 references（可能需要通过 git config log.decorate auto 来开启） --graph: 以图形化的方式显示 branch 的关系（主要是 commit 的引用） ","date":"2023-12-27","objectID":"/posts/git/git-learn/:5:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Delete Branch 删除分支： git branch -d \u003cname\u003e 对于有没有 merge 的 commit 的分支，Git 会警告，需要使用 -D 来强制删除： git branch -D \u003cname\u003e for no-merge commit WARNING: Discard Commit Git 会发出警告的原因同样是 no-merge commit 在删除分支后就无法被引用，所以会发出警告。 ","date":"2023-12-27","objectID":"/posts/git/git-learn/:5:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Merge 合并分支。默认使用 fast-forward，即如果没有冲突，直接将要合并的分支提前到被合并分支的 commit 处，而不会另外生成一个 merge commit。但这样会使得被合并的分支在合并后，没有历史痕迹。可以通过 --no-ff (no fast forward) 来强制生成 merge commit。推荐使用 merge 时加上 --no-ff 这个参数。 git merge \u003cbranch\u003e 通常是 main/master 这类主分支合并其它分支： git checkout main/master git merge \u003cbranch\u003e ","date":"2023-12-27","objectID":"/posts/git/git-learn/:5:4","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Resolve Conflict Manually resolve: Check every codes between \u003c\u003c\u003c\u003c\u003c\u003c\u003c, \u003e\u003e\u003e\u003e\u003e\u003e\u003e Edit code to what it should be Use mergetool like vimdiff: It shows: local, base, remote, file to be edited Edit “file ro be edited” to what is should be Add and Commit # 1. 合并分支 git merge \u003cbranch\u003e # 2. 检查状态，查看 unmerged 的文件 git status # 3. 编辑 unmerged 文件，编辑冲突区域代码即可 vim \u003cfile\u003e # 4. 添加解决完冲突的文件 git add \u003cfile\u003e # 5. 进行 merge commit git commit 冲突区域就是 \u003c\u003c\u003c\u003c\u003c\u003c\u003c 和 \u003e\u003e\u003e\u003e\u003e\u003e\u003e 内的区域，在 merge 操作后，Git 已经帮我们把 unmerged 文件修改为待解决冲突的状态，直接编辑文件即可。在编辑完成后，需要手动进行 add 和 commit，此次 commit 的信息 Git 已经帮我们写好了，一般不需要修改。 如果使用的是 mergetool，以 vimdiff 为例，只需将第 3 步的 vim \u003cfile\u003e 改为 git mergetool 即可。vimdiff 会提供 4 个视窗：底部视窗是我们的编辑区，顶部左边是当前合并分支的状态，顶部中间是 base (合并分支和被合并的共同父节点) 的状态，顶部右边是 remote 的状态，按需要选择、编辑。 vimdiff 在编辑完后会保留 *.orig 的文件，这个文件是待解决冲突的文件副本。 ","date":"2023-12-27","objectID":"/posts/git/git-learn/:5:5","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Merge Conflict Prevent very long development branch. Split source code clearly. ","date":"2023-12-27","objectID":"/posts/git/git-learn/:5:6","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Rebase 注意 ✅ 观看影片 Git 教学系列 - Branch and Merge，掌握 TODO 的方法。git rebase 是 Git 的精华，可以让我们实现更细粒度的操作，可以说学会了 rebase 才算真正入门了 Git。 这个视频讲得比较乱，所以推荐配合视频给出的参考文章 Git-rebase 小笔记 来学习。 ","date":"2023-12-27","objectID":"/posts/git/git-learn/:6:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git/git-learn/"},{"categories":["Linux"],"content":"网络代理 根据项目 clash-for-linux-backup 来配置 Ubuntu 的网络代理。 $ git clone https://github.com/Elegybackup/clash-for-linux-backup.git clash-for-linux 过程当中可能需要安装 curl 和 net-tools，根据提示进行安装即可： sudo apt install curl sudo apt install net-tools 安装并启动完成后，可以通过 localhost:9090/ui 来访问 Dashboard。 启动代理： $ cd clash-for-linux $ sudo bash start.sh $ source /etc/profile.d/clash.sh $ proxy_on 关闭代理： $ cd clash-for-linux $ sudo bash shutdown.sh $ proxy_off ","date":"2023-12-27","objectID":"/posts/ubuntu/:1:0","tags":["Linux"],"title":"Ubuntu 22.04 配置","uri":"/posts/ubuntu/"},{"categories":["Linux"],"content":"搜狗输入法 根据 搜狗输入法 Linux 安装指导 来安装搜狗输入法。 无需卸载系统 ibus 输入法框架。 通过 Ctrl + space 唤醒搜狗输入法。 ","date":"2023-12-27","objectID":"/posts/ubuntu/:2:0","tags":["Linux"],"title":"Ubuntu 22.04 配置","uri":"/posts/ubuntu/"},{"categories":["Linux"],"content":"快捷键 新建终端： Ctrl + Alt + T 锁屏： Super + L：锁定屏幕并熄屏。 显示桌面： Super + d 或者 Ctrl + Alt + d 最小化所有运行的窗口并显示桌面，再次键入则重新打开之前的窗口。 显示所有的应用程序： Super + a 可以通过 ESC 来退出该显示。 显示当前运行的所有应用程序： Super 移动窗口位置： Super + 左箭头：当前窗口移动到屏幕左半边区域 Super + 右箭头：当前窗口移动到屏幕右半边区域 Super + 上箭头：当前窗口最大化 Super + 下箭头：当前窗口恢复正常 隐藏当前窗口到任务栏： Super + h 切换当前的应用程序： Super + Tab：以应用程序为粒度显示切换选项 Alt + Tab：以窗口为粒度显示切换选项 切换虚拟桌面/工作区： Ctrl + Alt + 左/右方向键 自定义键盘快捷键： Settings -\u003e Keyboard -\u003e Keyboard Shortcus | View and Customize Shortcuts -\u003e Custom Shortcuts ","date":"2023-12-27","objectID":"/posts/ubuntu/:3:0","tags":["Linux"],"title":"Ubuntu 22.04 配置","uri":"/posts/ubuntu/"},{"categories":["Linux Kernel Internals"],"content":" 摘要 GNU/Linux 开发工具，几乎从硬件到软件，Linux 平台能够自下而上提供各类触及“灵魂”的学习案例，让所有课程从纸上谈兵转变成沙场实战，会极大地提升工程实践的效率和技能。 原文地址：GNU/Linux 开发工具 ","date":"2023-12-25","objectID":"/posts/sysprog/gnu-linux-dev/:0:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/sysprog/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"安装 Windows / Ubuntu 双系统 因为有些操作必须在物理硬件上才能执行。 ","date":"2023-12-25","objectID":"/posts/sysprog/gnu-linux-dev/:1:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/sysprog/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Markdown 与 LaTeX 速览 LaTeX 语法示例一节，作为工具书册，在需要使用时知道如何查询。 速览 Markdown 语法示例一节，作为工具书册，在需要使用时知道如何查询。 注意 编写 Markdown 文本以及 LaTeX 语法表示的数学式可以通过： Hugo + FixIt ✅ VS Code + Markdown Preview Enhanced ","date":"2023-12-25","objectID":"/posts/sysprog/gnu-linux-dev/:2:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/sysprog/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Git 和 Github 阅读 SSH key 产生方法一节，配置好 Git 和 Github 的 SSH key。同时也可作为工具书册，在需要使用时知道如何查询。 推荐通过 LearnGitBranching 来熟悉 Git 命令！！！ 以下资源作为自学资源，用于补充自己不熟悉的操作，或者作为以上资料的补充工具手册。 Git 中文教学（视频） 学习记录 30 天精通 Git 版本控制（文本） 警告 原文档中的将公钥复制到 clipboard 中使用了 clip 命令，但是这个命令在 Ubuntu 中并没有对应的命令。可以使用 xclip + alias 达到近似效果。 $ sudo apt install xclip # using alias to implement clip, you can add this to bashrc $ alias='xclip -sel c' ","date":"2023-12-25","objectID":"/posts/sysprog/gnu-linux-dev/:3:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/sysprog/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"编辑器: Visual Studio Code 认真阅读，跟随教学文档进行安装、设置。重点阅读 设定、除错（调试） 这两部分。更新 VS Code 部分作为手册，在需要时进行参考。 以下资源作为自学资源，用于补充自己不熟悉的操作，或者作为以上资料的补充工具手册。 开开心心学 Vistual Studio Code 完成 SSH key 的生成。 完成 VS Code 的设置。 安装 Git History 插件。 安装 Native Debug 插件，并进行 Debug (test-stopwatch.c) 操作。 安装 VSCode Great Icons 文件图标主题，另外推荐两款颜色主题：One Dark Pro, Learn with Sumit。 VS Code 控制台使用说明： 可以在面板的输出，点击 GIT 选项显示 VS Code 背后执行的 git 命令。 可以使用 ctrl + shift + P 呼出命令区，然后通过输入 Git branch 和 Git checkout 等并选择对应选项，来达到创建分支、切换分支等功能。 技巧 在 VS Code 设置中，需要在设置中打开 Open Default Settings 选项才能在左侧面板观察到预设值。键位绑定同理。 要想进行调试，需要在使用 gcc 生成目标文件时，加入 -g 参数来生产调试信息。 原文档中的 GDB 教学链接-除错程式-gdb 已失效，这是目前的有效链接。也可通过该影片 拯救资工系学生的基本素养-使用 GDB 除错基本教学 来补充学习 GDB 的操作。 ","date":"2023-12-25","objectID":"/posts/sysprog/gnu-linux-dev/:4:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/sysprog/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"终端和 Vim 认真阅读，跟随教学影片 快快乐乐学 Vim 和教学文档配置好 终端提示符、Vim。 完成命令行提示符配置 完成 Vim 的设定 安装并使用 Minial Vim Plugin Manager 来管理 Vim 插件 (neocomplcache, nerdtree) 安装并使用 byobu 来管理多个终端视图。 技巧 在 .vimrc 中增加插件后，打开 vim，执行 :PlugInstall 来安装插件，完成后在 vim 执行 :source ~/.vimrc。（可以通过 :PlugStatus 来查看插件安装状态） 使用 F4 键来[显示/不显示][行数/相对行数]。 使用 F5 键来呼入/呼出文件树(nerdtree)，在文件树恻通过 ENTER 键来访问目录/文件。 使用 Ctrl-w-h/Ctrl-w-l 切换到 文件树/编辑区。 自动补全时使用 ENTER 键来选中，使用方向键或 Ctrl-N/Ctrl-U/Ctrl-P 来上下选择。 在 Vim 中可以通过 :set paste，并在 insert 模式下，将粘贴板的内容通过 Ctrl-Shift-V 进行粘贴。 推荐观看影片 How to Do 90% of What Plugins Do (With Just Vim) 来扩展 Vim 插件的使用姿势。 以下资源为 Cheat Sheet，需要使用时回来参考即可。 Vim Cheat Sheet Bash terminal Cheat Sheet ","date":"2023-12-25","objectID":"/posts/sysprog/gnu-linux-dev/:5:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/sysprog/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Makefile 速览教学文档，作为工具书册，在需要使用时知道如何查询。 gcc 的 -MMD 和 -MF 参数对我们编写 Makefile 是一个巨大利器。理解 Makefile 的各种变量定义的原理。 对之前的 test-stopwatch.c 编写了一个 Makefile 来自动化管理。 ","date":"2023-12-25","objectID":"/posts/sysprog/gnu-linux-dev/:6:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/sysprog/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Linux 性能分析工具: Perf 认真阅读，复现教学文档中的所有例子，初步体验 perf 在性能分析上的强大。 安装 perf 并将 kernel.perf_event_paranoid 设置为 1。 动手使用 perf_top_example.c，体验 perf 的作用。 搭配影片: Branch Prediction 对照阅读: Fast and slow if-statements: branch prediction in modern processors 编译器提供的辅助机制: Branch Patterns, Using GCC 动手使用 perf_top_while.c，体验 perf top 的作用。 动手使用 perf_stat_cache_miss.c，体验 perf stat 的作用。（原文的结果有些不直观，务必亲自动手验证） 动手使用 perf_record_example.c，体验 perf record 的作用。（原文的操作不是很详细，可以参考下面的 Success） 源程序地址 成功 $ perf record -e branch-misses:u,branch-instructions:u ./perf_record_example [ perf record: Woken up 1 times to write data ] [ perf record: Captured and wrote 0.009 MB perf.data (94 samples) ] 输出第一行表示 perf 工具在收集性能数据时被唤醒了 1 次，以将数据写入输出文件。 输出第二行表示 perf 工具已经取样并写入了一个名为 perf.data 的二进制文件，文件大小为 0.009 MB，其中包含了 94 个采样。（可以通过 ls 命令来检查 perf.data 文件是否存在） 接下来通过 perf report 对之前输出的二进制文件 perf.data 进行分析。可以通过方向键选择，并通过 ENTER 进入下一层查看分析结果。 $ perf report Available samples 5 branch-misses:u 89 branch-instructions:u 技巧 perf 需要在 root 下进行性能分析。 perf top 是对于哪个程序是性能瓶颈没有头绪时使用，可以查看哪个程序（以及程序的哪个部分）是热度点。 在 perf top 时可以通过 h 键呼出帮助列表。 可以通过方向键选择需要进一步分析的部分，并通过 a 键来查看指令级别粒度的热点。 perf stat 是对某一个要优化的程序进行性能分析，对该程序涉及的一系列 events 进行取样检查。 perf record 的精度比 perf stat 更高，可以对取样的 events 进行函数粒度的分析。 ","date":"2023-12-25","objectID":"/posts/sysprog/gnu-linux-dev/:7:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/sysprog/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Linux 绘图工具: gnuplot 安装 gnuplot: $ sudo apt-get install gnuplot ","date":"2023-12-25","objectID":"/posts/sysprog/gnu-linux-dev/:8:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/sysprog/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"学习记录 ","date":"2023-12-25","objectID":"/posts/sysprog/gnu-linux-dev/:9:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/sysprog/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"GDB 调试 观看教学视频 拯救資工系學生的基本素養—使用 GDB 除錯基本教學 和搭配博文 ==How to debug Rust/C/C++ via GDB==，学习 GDB 的基本操作和熟悉使用 GDB 调试 Rust/C/C++ 程序。 掌握 run/r, break/b, print/p, continue/c, step/s info/i, delete/d, backtrace/bt, frame/f, up/down, exit/q 等命令的用法。以及 GBD 的一些特性，例如 GDB 会将空白行的断点自动下移到下一代码行；使用 break 命令时可以输入源文件路径，也可以只输入源文件名称。 相关的测试文件： test.c hello_cargo/ ","date":"2023-12-25","objectID":"/posts/sysprog/gnu-linux-dev/:9:1","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/sysprog/gnu-linux-dev/"},{"categories":["Mathematics"],"content":" 中大數學系開放式課程 台大齐震宇 - 数学潜水艇、微积分、分析 台大谢铭伦 - 线性代数 ","date":"2023-12-23","objectID":"/posts/math/math/:0:0","tags":["Math"],"title":"数学开放式课程学习导航","uri":"/posts/math/math/"},{"categories":["Mathematics"],"content":"概率统计 阳明交通大学 陈临安老师，开设了两学期的统计课程，分别是上学期的 统计学 和下学期的 高等统计学。 课程名称 英文名称 课程地址 课程视频 统计学 Statistics 课程资讯 YouTube 高等统计学 Advanced Statistics 课程资讯 YouTube 信息 这两个学期课程的作业、习题以及解答都可以在 这里 找到。 ","date":"2023-12-23","objectID":"/posts/math/math/:1:0","tags":["Math"],"title":"数学开放式课程学习导航","uri":"/posts/math/math/"},{"categories":["draft"],"content":"博客（英语：Blog）是一种在线日记型式的个人网站，借由张帖子章、图片或视频来记录生活、抒发情感或分享信息。博客上的文章通常根据张贴时间，以倒序方式由新到旧排列。 ","date":"2023-12-23","objectID":"/posts/hello_world/:0:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"数学公式 行内公式：$N(b,d)=(b-1)M$ 公式块： $$ \\int_{a}^{b}x(t)dt = \\dfrac{b - a}{N} \\\\ =\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} $$ $$ \\begin{aligned} \\int_{a}^{b}x(t)dt \u0026= \\dfrac{b - a}{N} \\\\ \u0026=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} \\\\ \\end{aligned} $$ $$ \\mathrm{Integrals\\ are\\ numerically\\ approximated\\ as\\ finite\\ series}:\\\\ \\begin{split} \\int_{a}^{b}x(t)dt \u0026= \\dfrac{b - a}{N} \\\\ \u0026=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} \\end{split} \\\\ where\\ t_k = a + (b-a)\\cdot k/N $$ $$ \\begin{align*} p(x) = 3x^6 + 14x^5y \u0026+ 590x^4y^2 + 19x^3y^3 \\\\ \u0026- 12x^2y^4 - 12xy^5 + 2y^6 - a^3b^3 - a^2b - ab + c^5d^3 + c^4d^3 - cd \\end{align*} $$ ","date":"2023-12-23","objectID":"/posts/hello_world/:1:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"代码块 let i: i32 = 13; let v = vec![1, 2, 3, 4, 5, 65]; for x in v.iter() { println!(\"{}\", x); } typedef struct Block_t { int head; int data; } Block_t; ","date":"2023-12-23","objectID":"/posts/hello_world/:2:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"Admonition 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 ","date":"2023-12-23","objectID":"/posts/hello_world/:3:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"References FixIt 快速上手 使用 Hugo + Github 搭建个人博客 Emoji 支持 扩展 Shortcodes 概述 URL management ","date":"2023-12-23","objectID":"/posts/hello_world/:4:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"}]