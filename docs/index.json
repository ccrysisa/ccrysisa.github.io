[{"categories":["Rust"],"content":"整理自 John Gjengset 的影片 ","date":"2024-01-31","objectID":"/posts/declarative-macros/:0:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"影片注解 macro 可以使用以下 3 种分隔符来传入参数 (注意花括号 {} 的需要与 macro 名之间进行空格，末尾不需要分号，这是因为 {} 会被编译器视为一个 statement，无需使用 ; 来进行分隔): macro_rules! avec { () =\u003e {}; ... } avec!(); avec![]; avec! {} macro 定义内的 () 和 {} 也都可以使用 (), [], {} 之间的任意一种，并不影响调研 macro 的分隔符的使用（都是 3 任选 1 即可），不过推荐在 macro 定义内使用 () 和 {} 搭配。 cargo-expand 可以将宏展开，对于宏的除错非常方便，可以以下命令来安装: $ cargo install cargo-expand 然后可以提供==通过以下命令对 macro 进行展开: $ cargo expand 使用以下命令可以将 unit tests 与 cargo expand 结合起来，即展开的是 unit tests 之后的完整代码: $ cargo expand --lib tests 由于 Rust 中 macro 和 normal code 的作用域不一致，所以像 C 语言那种在 macro 中定义变量或在 macro 中直接修改已有变量是不可行的，操作这种 lvalue 的情况需要使用 macro 参数进行传入，否则无法通过编译。 // cannot compile macro_rules! avec { () =\u003e { let x = 1; } } // cannot compile macro_rules! avec { () =\u003e { x = 42; } } // can compile macro_rules! avec { ($x: ident) =\u003e { $x += 1; } } 在 Rust macro 中，如果需要将传入的 syntax 转换成多个 statements，需要使用 {} 进行包装: () =\u003e {{ ... }} 其中第一对 {} 是 macro 语法所要求的的，第二对 {} 则是用于包装 statements 的 {}，使用 cargo expand 进行查看会更直观。 注意 macro 中传入的 syntax，其使用的类似于 =\u003e 的分隔符是有限的，例如不能使用 -\u003e 作为分隔符，具体可以查阅手册。 ($arg1:ty =\u003e $arg2:ident) =\u003e { type $arg2 = $arg1; }; 如果需要在 macro 传入的 synatx 中使用正则表达式 (regex)，则需要在外面使用 $() 进行包装: ($($elem:expr),* $(,)?) =\u003e {{ let mut v = Vec::new(); $(v.push($elem);)* v }}; 同样的，可以在 macro 体内使用 $()* 进行解包装，其中 * 也可以选择 + 来替代，并没有差异。$(...)* 会根据内部所包含的参数 $(...) (本例中是 $(elem)) 来进行自动解包装，生成对应次数的 statement。 当 declarative macros 变得复杂时，它的可读性会变得很差，这时候需要使用 procedural macros。但是 procedural macros 需要多花费一些编译周期 (compilition cycle)，因为需要先对 procedural macros 进行编译，再编译 lib/bin 对应的源文件。 ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"Documentations 这里列举视频中一些概念相关的 documentation 学习的一手资料是官方文档，请务必自主学会阅读规格书之类的资料 ","date":"2024-01-31","objectID":"/posts/declarative-macros/:2:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"Crate std 可以使用这里提供的搜素栏进行搜索 (BTW 不要浪费时间在 Google 搜寻上！) Struct std::vec::Vec method std::option::Option::take ","date":"2024-01-31","objectID":"/posts/declarative-macros/:3:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"References 原版的 The Little Book of Rust Macros 在 Rust 更新新版本后没有持续更新，另一位大牛对这本小册子进行了相应的更新: The Little Book of Rust Macros Rust语言中文社区也翻译了该小册子: Rust 宏小册 ","date":"2024-01-31","objectID":"/posts/declarative-macros/:4:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"整理自 John Gjengset 的影片 ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:0:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"C 语言中的 lifetime Rust 中的 lifetime 一向是一个难点，为了更好地理解这一难点的本质，建议阅读 C 语言规格书关于 lifetime 的部分，相信你会对 Rust 的 lifetime 有不同的看法。 C11 [6.2.4] Storage durations of objects An object has a storage duration that determines its lifetime. There are four storage durations: static, thread, automatic, and allocated. ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:1:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"影片注解 cargo check 可以给出更简洁的提示，例如相对于编译器给出的错误信息，它会整合相同的错误信息，从而提供简洁切要的提示信息。而且它是一个静态分析工具，不需要进行编译即可给出提示，所以速度会比编译快很多，在大型项目上尤为明显。 影片大概 49 分时提到了 if let Some(ref mut remainder) = self.remainder {...} ref 的作用配合 if let 语句体的逻辑可以体会到 pointer of pointer 的美妙之处。 因为在 pattern match 中形如 \u0026mut 这类也是用于 pattern match 的，不能用于获取 reference，这也是为什么需要使用 ref mut 这类语法来获取 reference 的原因。 影片大概 56 分时提到了 let remainder = self.remainder.as_mut()?; 为什么使用之前所提的 let remainder = \u0026mut self.remainder?; 这是因为使用 ? 运算符返回的是内部值的 copy，所以这种情况 remainder 里是 self.remainder? 返回的值 (是原有 self.remainder 内部值的 copy) 的 reference 影片大概 1:03 时提到了 str 与 String 的区别，个人觉得讲的很好： str -\u003e [char] \u0026str -\u003e \u0026[char] // fat pointer (address and size) String -\u003e Vec\u003cchar\u003e String -\u003e \u0026str (cheap -- AsRef) \u0026str -\u003e String (expensive -- memcpy) 可以将结构体的 lifetime 的第一个 (一般为 'a) 视为实例的 lifetime，其它的可以表示与实例 lifetime 无关的 lifetime。由于 compiler 不够智能，所以它会将实例化时传入参数的 lifetime 中相关联的最小 lifetime 视为实例的 lifetime 约束 (即实例的 lifetime 包含于该 lifetime 内)。 对于 String 使用 \u0026* 可以保证将其转换成 \u0026str，因为 * 会先将 String 转换成 str。当然对于函数参数的 \u0026str，只需传入 \u0026String 即可自动转换类型。 ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:2:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"Documentations 这里列举视频中一些概念相关的 documentation 学习的一手资料是官方文档，请务必自主学会阅读规格书之类的资料 ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:3:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"Crate std 可以使用这里提供的搜素栏进行搜索 (BTW 不要浪费时间在 Google 搜寻上！) Keywords Keyword SelfTy Keyword ref Trait std::iter::Iterator method std::iter::Iterator::eq method std::iter::Iterator::collect method std::iter::Iterator::position method std::iter::Iterator::find Enum std::option::Option method std::option::Option::take method std::option::Option::as_mut method std::option::Option::expect Primitive Type str method str::find method str::char_indices Trait std::ops::Try Macro std::try method char::len_utf8 ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:4:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Linux Distribution"],"content":"记录一下折腾 Deepin 20.9 的物理机的过程与相关的配置。 ","date":"2024-01-24","objectID":"/posts/deepin20.9/:0:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"安装与配置 新手教学影片： 深度操作系统deepin下载安装 (附双系统安装及分区指引) [bilibili] 安装完deepin之后该做的事情 [bilibili] ","date":"2024-01-24","objectID":"/posts/deepin20.9/:1:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"网络代理 新手教学文档: Ubuntu 22.04LTS 相关配置 在境内可以使用 gitclone.com 来加速 clone 的速度。 ","date":"2024-01-24","objectID":"/posts/deepin20.9/:2:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"编辑器: VS Code 新手教学文档: 编辑器: Visual Studio Code [HackMD] 本人的一些注解: GNU/Linux 开发工具 这里列举一下本人配置的插件： Even Better TOML CodeLLDB 用于调试 Rust Git History Native Debug 用于调试 C/C++ rust-analyzer Tokyo Night 挺好看的一个主题 Vim VSCode Great Icons 文件图标主题 ","date":"2024-01-24","objectID":"/posts/deepin20.9/:3:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"终端和 Vim 新手教学文档: 終端機和 Vim 設定 [HackMD] 本人的一些注解: GNU/Linux 开发工具 本人的终端提示符配置: \\u@\\h\\W 本人使用 Minimalist Vim Plugin Manager 来管理 Vim 插件，配置如下: \" Specify a directory for plugins (for Neovim: ~/.local/share/nvim/plugged) call plug#begin('~/.vim/plugged') Plug 'Shougo/neocomplcache' Plug 'scrooloose/nerdtree' map \u003cF5\u003e :NERDTreeToggle\u003cCR\u003e call plug#end() let g:neocomplcache_enable_at_startup = 1 let g:neocomplcache_enable_smart_case = 1 inoremap \u003cexpr\u003e\u003cTAB\u003e pumvisible()?\"\\\u003cC-n\u003e\" : \"\\\u003cTAB\u003e\" syntax on set number set cursorline colorscheme default set bg=dark set tabstop=4 set expandtab set shiftwidth=4 set ai set hlsearch set smartindent map \u003cF4\u003e : set nu!\u003cBAR\u003eset nonu?\u003cCR\u003e \" autocomplete dropdown list colorscheme hi Pmenu ctermfg=0 ctermbg=7 hi PmenuSel ctermfg=7 ctermbg=4 ","date":"2024-01-24","objectID":"/posts/deepin20.9/:4:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"系统语言: Rust 安装教程: Installation [The book] 安装 Rust [Rust course] Channels [The rustup book] # install rust $ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh # install nightly toolchain $ rustup toolchain install nightly # change to nightly toolchain $ rustup default nightly # list installed toolchain $ rustup toolchain list # update installed toolchain $ rustup update 个人偏向于使用 nightly toolchain ","date":"2024-01-24","objectID":"/posts/deepin20.9/:5:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"效果展示 Deepin Terminial Vim Deepin DDE Desktop ","date":"2024-01-24","objectID":"/posts/deepin20.9/:6:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"FAQ 问题 重启后可能会出现，输入密码无法进入图形界面重新返回登录界面，这一循环状况。这个是 deepin 的默认 shell 是 dash 造成的，只需将默认的 shell 改为 bash 即可解决问题： $ ls -l /bin/sh lrwxrwxrwx 1 root root 9 xx月 xx xx:xx /bin/sh -\u003e /bin/dash $ sudo rm /bin/sh $ sudo ln -s /bin/bash /bin/sh 如果你已经处于无限登录界面循环这一状况，可以通过 Ctrl + Alt + \u003cF2\u003e 进入 tty2 界面进行修改： # 先查看问题日志，判断是不是 shell 导致的问题 $ cat .xsession-errors # 如果是，则重复上面的操作即可 ","date":"2024-01-24","objectID":"/posts/deepin20.9/:7:0","tags":["Linux","Deepin"],"title":"深度操作系统 Deepin 20.9 安装配置","uri":"/posts/deepin20.9/"},{"categories":["Linux Distribution"],"content":"在 deepin 20.9 上根据 DragonOS 构建文档 的 bootstrap.sh 的方式来构建 DragonOS 时，如果没有事先安装 Qemu 会出现 KVM 相关的依赖问题。本文记录解决这一问题的过程。 如果事先没有安装 Qemu，在使用 bootstrap.sh 时会出现如下报错： $ bash bootstrap.sh ... 下列软件包有未满足的依赖关系： qemu-kvm : 依赖: qemu-system-x86 E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。 查询 deepin 论坛上的相关内容：qemu-kvm无法安装，可以得知是因为 qemu-kvm 在 debian 发行版上只是一个虚包，所以对于 x86 架构的机器可以直接安装 qemu-systerm-x86 Debian qemu-kvm https://packages.debian.org/search?keywords=qemu-kvm 安装 qemu-systerm-x86: $ sudo apt install qemu-systerm-x86 $ $ qemu-system-x86_64 --version QEMU emulator version 5.2.0 (Debian 1:5.2+dfsg-11+deb11u1) Copyright (c) 2003-2020 Fabrice Bellard and the QEMU Project developers 安装的 qemu 版本看起来有点低，但是先使用 bootstrap.sh 快速安装其它依赖项，然后尝试编译运行一下 DragonOS: $ bash bootstrap.sh ... |-----------Congratulations!---------------| | | | 你成功安装了DragonOS所需的依赖项! | | | | 请关闭当前终端, 并重新打开一个终端 | | 然后通过以下命令运行: | | | | make run | | | |------------------------------------------| 新开一个终端或刷新一下 ~/.bashrc: $ cd DragonOS $ make run 运行 DragonOS Ok 可以成功运行 注意 如果需要使用 RISC-V 的 Qemu 模拟器，安装 qemu-system-misc 即可： $ sudo apt install qemu-system-misc ","date":"2024-01-22","objectID":"/posts/deepin-dragonos/:0:0","tags":["Deepin","Linux","DragonOS"],"title":"在 Deepin 20.9 上构建 DragonOS","uri":"/posts/deepin-dragonos/"},{"categories":["Mathematics"],"content":"随机变量 (Random Variable) 是概率 (Probability) 和统计 (Statistics) 的“灵魂”，从数学上讲，Random Variable 是连接 Probability 和 Statistics 的桥梁；从实际上讲，Random Variable 表示我们所关心、期望的东西。例如一批产品的硬度，每个产品的硬度显然是不同的、是随机的，尽管硬度是随机的，但产品的硬度遵循一定的概率规律，这种随机、但却遵循一定概率规律的东西，就是 Random Value。 学习一门课，要学习其“精神”，而不是学习其方法。 ","date":"2024-01-20","objectID":"/posts/nycu-statistics/:0:0","tags":["Mathematics","Statistics","Probility","Random Variable"],"title":"\u003c交大统计学\u003e 重点提示","uri":"/posts/nycu-statistics/"},{"categories":["Mathematics"],"content":"Concepts 引用 Sample space $S$: Set of possible outcomes of a random experiment. Every subset of $S$ is an event. Random experiment 是一种特殊的实验。物理实验、化学实验在相同的条件下所产生的结果是相同的，但 Random experiment 不同，在相同的条件下，每次实验的结果是随机的。但 Random experiment 结果的情况是有限的，所有实验结果的集合就称为 Sample space。 引用 Probability set function $P$ on subset of $S$ satisfies: $P(A) \\geq 0$ $P(S) = 1$ $P(\\bigcup\\limits_{k=1}^{\\infty} A_k) = \\sum\\limits_{k=1}^{\\infty} A_k\\ \\ \\ if A_i \\bigcap A_j = \\emptyset\\ for\\ all\\ i \\neq j$ A random variable $X$ is a real-valued function define on $S$. $$ X:\\ S \\rightarrow R\\ \\ \\ or \\ \\ \\ S \\xrightarrow{X} R $$ set function 是对 set 进行映射的 function，所以 $P$ 是 subset of $S$ 到实数的映射关系，通过 $P$ 可以计算 event 对应的概率值。 Probability set function $P$ 有 3 个符合直觉的基本准则，我们可以从这 3 个准则可以推导出其它符合直觉的性质: $$ \\forall A \\subset S \\implies \\begin{cases} P(\\emptyset) \u0026= 0 \\\\ P(A^{C}) \u0026= 1 - p \\end{cases} $$ Proof. $$ \\begin{split} \u0026 \\mathrm{since}\\ \\emptyset \\cap S = \\emptyset \\\\ \u0026 \\mathrm{then}\\ P(S) = P(\\emptyset \\cap S) = P(\\emptyset) + P(S) \\\\ \u0026 \\mathrm{and}\\ P(S) = 1 \\\\ \u0026 \\mathrm{thus}\\ P(\\emptyset) = P(S) - P(S) = 0 \\\\ \u0026 Q.D.E. \\\\ \u0026 \\\\ \u0026 \\mathrm{since}\\ A^{C} \\cap A = \\emptyset \\\\ \u0026 \\mathrm{then}\\ P(S) = P(A^{C} \\cup A) = P(A^{C}) + P(A) \\\\ \u0026 \\mathrm{and}\\ P(S) = 1 \\\\ \u0026 \\mathrm{thus}\\ P(A^{C}) = P(S) - P(A) = 1 - p \\\\ \u0026 Q.D.E. \\end{split} $$ Random variable $X$ 是将 sample space $S$ 映射到实数域 $R$ 的映射关系，即 $S$ 是定义域 (domain)，$R$ 是值域 (co-domain)。由于 $S$ 和 $R$ 在计数上并不相同，所以 $r.v.\\ X$ 只是单射，并不是满射。 为什么需要这样的映射关系？因为对于实数，可以使用微积分这类数学工具对概率的性质进行研究，而微积分这类数学工具对于 sample space 显然是无法使用的。 但是注意，根据 Probability set function 的定义，对于映射后实数域上的集合，我们是无法直接求得对应的概率值，所以需要一个类似反函数的映射关系 $X^{-1}:\\ R \\rightarrow S$ 来将 $R$ 映射回 $S$，从而计算对应的概率值。 为什么是类似反函数的映射？原因如上面所说的，$S$ 和 $R$ 在计数上并不相等，所以 $R$ 到 $S$ 的映射有可能不满足单射。 引用 Our interest of Probability: Given $B \\subset R$, what $P(x \\in B) =\\ ?$ $$ (X \\in B) = X^{-1}(B) = \\{s \\in S: X(s) \\in B\\} \\subset S \\\\ \\implies P(x \\in B) = P(\\{s \\in S: X(s) \\in B\\}) $$ Distribution function (df) of a r.v. $X$ is $$ F(x) = P(X \\leq x),\\ x \\in R $$ 如果我们需要对实数域上的集合 $B$ 求其概率值，则如我们之前所说的，需要使用 $X^{-1}$ 将 $R$ 映射回 $S$。由于可能是非单射的映射关系，所以我们使用集合 $\\{s \\in S: X(s) \\in B\\}$ 来表示映射结果，所以 $(x \\in B)$ 也可以表示 event。 这样我们就可以对实数域上的集合求其概率值了，也即此时我们拥有一个 $subset\\ of\\ R$ 到 $R$ 的映射关系。 但是这样仍然无法在二维坐标轴上进行直观表示，也无法对该关系使用微积分等工具进行研究，我们需要 $R \\rightarrow R$ 的映射关系。 Distribution function (df) 就是我们所期望的 $R \\rightarrow R$ 的映射关系，对于 $R$ 上的每一个 $x$ 映射到 $P(X \\leq x)$。 注意 $X \\leq x$ 只是一个数学表示，并不具备数学意义，因为 $X$ 作为一个 real-valued function 和实数 $x$ 进行关系运算显然是没有意义的。 $X \\leq x$ 表示在 r.v. $X$ 的映射关系下，集合 $y \\in (-\\infty, x]$ 即 $\\{s \\in S: X(s) \\in (-\\infty, x]\\}$，所以 $$ P(X \\leq x) = P(\\{s \\in S: X(s) \\in (-\\infty, x]\\}) $$ 有了 df 我们就可以将概率的性质通过二维坐标轴进行直观显示，并且可以使用微积分这类工具进行进一步研究。 接下来以一些常见的概率分布来对之前所提的概念进行实作： 引用 Some Distributions: Bernoulli distribution and Binomial distribution. A experiment with two possible outcomes is called a Bernoulli experiment. We denote the sample space by $$S = \\{S, F\\},\\ S = Success,\\ F = Failure$$ Probability set function: $$P(\\{S\\}) = p,\\ P(\\{F\\}) = 1-p,\\ 0 \\le p \\le 1$$ We define r.v. $X$ on $S = \\{S, F\\}$ by $$ X(S) = 1, X(F) = 0 \\\\ \\implies \\{S, F\\} \\xrightarrow{X} \\{0, 1\\} $$ The Probability are $$ P(X = 1) = P(X^{-1}\\{1\\}) = P(\\{S\\}) = p $$ 我们可以从这个 Bernoulli distribution 的例子中提炼统计的一般思路: 从 Random experiment 中构建 Sample space $S$ 通过 Probability set function 计算 event 对应的概率值 定义 Random variable $X$ 实现 $S$ 到 $R$ 的映射关系 对 Distribution function (df) 进一步分析 ","date":"2024-01-20","objectID":"/posts/nycu-statistics/:1:0","tags":["Mathematics","Statistics","Probility","Random Variable"],"title":"\u003c交大统计学\u003e 重点提示","uri":"/posts/nycu-statistics/"},{"categories":["Mathematics"],"content":"References List of LaTeX mathematical symbols ","date":"2024-01-20","objectID":"/posts/nycu-statistics/:2:0","tags":["Mathematics","Statistics","Probility","Random Variable"],"title":"\u003c交大统计学\u003e 重点提示","uri":"/posts/nycu-statistics/"},{"categories":["Linux Kernel Internals"],"content":" 摘要 大型开源项目的规模十分庞大，例如使用 Rust 编写的 Servo 浏览器，这个项目有近十万行代码。在开发规模如此庞大的项目时，了解如何通过正确的方式进行调试非常重要，因为这样可以帮助开发者快速地找到瓶颈。 原文地址 | 教学视频 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:0:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"GDB 调试 观看教学视频 拯救資工系學生的基本素養—使用 GDB 除錯基本教學 和搭配博文 ==[How to debug Rust/C/C++ via GDB][debug-gdb]==，学习 GDB 的基本操作和熟悉使用 GDB 调试 Rust/C/C++ 程序。 掌握 run/r, break/b, print/p, continue/c, step/s info/i, delete/d, backtrace/bt, frame/f, up/down, exit/q 等命令的用法。以及 GBD 的一些特性，例如 GDB 会将空白行的断点自动下移到下一代码行；使用 break 命令时可以输入源文件路径，也可以只输入源文件名称。 相关的测试文件： test.c hello_cargo/ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:1:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"GDB 基本介绍 引用 “GDB, the GNU Project debugger, allows you to see what is going on ‘inside’ another program while it executes — or what another program was doing at the moment it crashed.” — from gnu.org 安装 GDB: $ sudo apt install gdb 启动 GDB 时可以加入 -q 参数 (quite)，表示减少或不输出一些提示或信息。 LLDB 与 GDB 的命令类似，本文也可用于 LLDB 的入门学习。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:2:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"GDB 调试 C/C++ 要使用 GDB 来调试 C/C++，需要在编译时加上 -g 参数（必需），也可以使用 -Og 参数来对 debug 进行优化（但使用 -Og 后 compiler 可能会把一些东西移除掉，所以 debug 时可能不会符合预期），例如： $ gcc test.c -Og -g -o test $ gdb -q ./test Source ","date":"2024-01-16","objectID":"/posts/debug-gdb/:3:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"GDB 调试 Rust 在使用 build 命令构建 debug 目标文件（即位于 target/debug 目录下的目标文件，与 package 同名）后，就可以通过 gdb 来进行调试： $ cargo build $ gdb -q ./target/debug/\u003cpackage name\u003e 但是如果是使用 cargo build --release 构建的 release 目标文件（即位于 target/release 目录下的目标文件），则无法使用 GDB 进行调试，因为 release 目标未包含任何调试信息，类似于未使用 -g 参数编译 C/C++ 源代码。 Source ","date":"2024-01-16","objectID":"/posts/debug-gdb/:4:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"GDB 基本命令 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"run run (r) 命令用于从程序的执行起始点开始执行，直到遇到下一个断点或者程序结束。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:1","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"continue continue (c) 命令用于从当前停止的断点位置处继续执行程序，直到遇到下一个断点或者程序结束。 注意 run 和 continue 的区别在于 run 是将程序从头开始执行。例如如果未设置任何断点，使用 run 可以反复执行程序，而如果使用 continue 则会提示 The program is not being run。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:2","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"step step (s) 命令用于 逐行 执行程序，在遇到函数调用时进入对应函数，并在函数内部的第一行暂停。step 命令以 单步方式 执行程序的每一行代码，并跟踪函数调用的进入和退出。 (gdb) step 6 bar += 3; (gdb) step 7 printf(\"bar = %d\\n\", bar); 注意 step 命令与 continue 命令相同，只能在程序处于运行态（即停留在断点处）时才能使用。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:3","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"next next (n) 命令用于执行当前行并移动到 下一行，它用于逐行执行程序，但不会进入函数调用。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:4","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"break break (b) 命令用于在可执行问卷对应的源程序中加入断点，可以在程序处于 未运行态/运行态 时加入断点（运行态是指程序停留在断点处但未执行完毕的姿态）。 可以通过指定 源文件对应的 行数/函数名 来加入断点（源文件名可以省略）： (gdb) break test.c:7 (gdb) break test.c:foo 如果可执行文件由多个源文件编译链接得到，可以通过指定 源文件名字 的方式来加入断点，无需源文件路径，但如果不同路径有重名源文件，则需要指定路径来区分： (gdb) break test1.c:7 (gdb) break test2.c:main ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:5","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"print print (p) 命令用于在调试过程中打印 变量的值或 表达式 的结果，帮助开发者检查程序状态并查看特定变量的当前值。 # Assume x: 3, y: 4 (gdb) print x $1 = 3 (gdb) print x + y $2 = 7 使用 p 命令打印变量值时，会在左侧显示一个 $\u003cnumber\u003e，这个可以理解成临时变量，后续也可以通过这个标志来复用这些值。例如在上面的例子中： (gdb) print $1 $3 = 3 (gdb) print $1 + $3 $4 = 4 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:6","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"backtrace backtrace (bt) 命令用于打印当前调用栈的信息，也称为堆栈回溯 (backtrace)。它显示了程序在执行过程中经过的函数调用序列，以及每个函数调用的位置和参数，即可以获取以下信息： 函数调用序列：显示程序当前的函数调用序列，以及每个函数的名称和所在的源代码文件。 栈帧信息：对于每个函数调用，显示该函数的栈帧信息，包括栈帧的地址和栈帧的大小。 (gdb) backtrace (gdb) backtrace #0 foo () at test.c:7 #1 0x00005555555551d2 in main () at test.c:14 技巧 backtrace 命令对于跟踪程序的执行路径、检查函数调用的顺序以及定位错误非常有用。在实际中，一般会搭配其他GDB命令（如 up、down 和 frame）结合使用，以查看特定栈帧的更多详细信息或切换到不同的栈帧。在上面的例子中，#0 和 #1 表示栈帧的编号，可以通过 frame 配合这些编号来切换栈帧。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:7","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"where where 和 backtrace 命令都用于显示程序的调用栈信息。backtrace 提供更详细的调用栈信息，包括函数名称、文件名、行号、参数和局部变量的值。而 where 命令可以理解为 backtrace 的一个简化版本，它提供的是较为紧凑的调用栈信息，通常只包含函数名称、文件名和行号。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:8","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"frame frame (f) 命令用于选择特定的栈帧 (stack frame)，从而切换到不同的函数调用上下文，每个栈帧对应于程序中的一个函数调用。 接着上一个例子，切换到 main 函数所在的栈帧： (gdb) frame 1 #1 0x00005555555551d2 in main () at test.c:14 14 int result = foo(); ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:9","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"up/down up 和 down 命令用于在调试过程中在不同的栈帧之间进行切换： up 用于在调用栈中向上移动到较高的栈帧，即进入调用当前函数的函数。每次执行 up 命令，GDB 将切换到上一个（更高层次）的栈帧。这可以用于查看调用当前函数的上层函数的执行上下文。 down 用于在调用栈中向下移动到较低的栈帧，即返回到当前函数调用的函数。每次执行 down 命令，GDB 将切换到下一个（较低层次）的栈帧。这可以用于返回到调用当前函数的函数的执行上下文。 这两个命令需要开发者对应函数调用堆栈的布局有一定程度的了解。 接着上一个例子： (gdb) up #1 0x00005555555551d2 in main () at test.c:14 14 int result = foo(); (gdb) down #0 foo () at test.c:7 7 printf(\"bar = %d\\n\", bar); ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:10","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"info info (i) 命令用于获取程序状态和调试环境的相关信息，该命令后面可以跟随不同的子命令，用于获取特定类型的信息。 一些常用的 info 子命令： info breakpoints 显示已设置的所有断点 (breakpoint) 信息，包括断点编号、断点类型、断点位置等。 info watchpoints 显示已设置的所有监视点 (watchpoint) 信息，包括监视点编号、监视点类型、监视的表达式等。 info locals 显示当前函数的局部变量的值和名称。 info args 显示当前函数的参数的值和名称。 info registers 显示当前 CPU 寄存器的值。 info threads 显示当前正在调试的所有线程 (thread) 信息，包括线程编号、线程状态等。 info frame 显示当前栈帧 (stack frame) 的信息，包括函数名称、参数、局部变量等。 info program 显示被调试程序的相关信息，例如程序入口地址、程序的加载地址等。 (gdb) info breakpoints # or simply: i b Num Type Disp Enb Address What 1 breakpoint keep y 0x000055555555518f in foo at test.c:7 2 breakpoint keep y 0x0000555555555175 in foo at test.c:4 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:11","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"delete delete (d) 命令用于删除断点 (breakpoint) 或观察点 (watchpoint)。断点是在程序执行期间暂停执行的特定位置，而观察点是在特定条件满足时暂停执行的位置。 可以通过指定 断点 / 观察点 的编号或使用 delete 命令相关的参数，来删除已设置的断点 / 观察点。断点 / 观察点编号可以在使用 info breakpoints / info watchpoints 命令时获得。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:12","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"quit quit (q) 命令用于退出 GDB，返回终端页面。 (gdb) quit $ # Now, in the terminial ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:13","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"list list 命令用于显示当前位置的代码片段，默认情况下，它会显示当前位置的前后10行代码。 list 命令也可以显示指定范围的代码，使用 list \u003cstart\u003e,\u003cend\u003e 命令将显示从 start 行到 end 行的源代码。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:14","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"whatis whatis 命令用于获取给定标识符（如变量、函数或类型）的类型信息。 // in source code int calendar[12][31]; // in gdb (gdb) whatis calendar type = int [12][31] ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:15","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"x x 命令用于查看内存中的数据，使用 x 命令搭配不同的格式来显示内存中的数据，也可以搭配 / 后跟数字来指定要显示的内存单元数量。例如，x/4 \u003caddress\u003e 表示显示地址 address 开始的连续 4 个内存单元的内容。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:16","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":"其他 如果被调试程序正处于运行态（即已经通过 run 命令来运行程序），此时可以通过 Ctrl+C 来中断 GDB，程序将被立即中断，并在中断时所运行到的地方暂停。这种方式被称为 手动断点，手动断点可以理解为一个临时断点，只会在该处暂停一次。 GDB 会将空白行的断点自动下移到下一非空的代码行。 set print pretty 命令可以以更易读和格式化的方式显示结构化数据，以更友好的方式输出结构体、类、数组等复杂类型的数据，更易于阅读和理解。 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:17","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"GDB 调试入门","uri":"/posts/debug-gdb/"},{"categories":["Linux Kernel Internals"],"content":" 引用 「指针」 扮演 「记忆体」 和 「物件」 之间的桥梁 原文地址 直播录影(上) 直播录影(下) ","date":"2024-01-14","objectID":"/posts/c-pointer/:0:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"前言杂谈 Let’s learn programming by inventing it [CppCon 2018] ✅ 注意 在 K\u0026R 一书中，直到 93 页才开始谈论 pointer，而全书总计 185 页，所以大概是在全书 $50.27\\%$ 的位置才开始讲 pointer。所以即使不学 pointer，你还是能够掌握 $~50\\%$ 的 C 语言的内容，但是 C 语言的核心正是 pointer，所以 Good Luck 🤣 godbolt 可以直接在网页上看到，源代码由各类 compiler 生成的 Assembly Code How to read this prototype? [Stack Overflow] ✅ 注意 这个问题是关于 signal 系统调用的函数原型解读，里面的回答页给出了很多对于指针，特别是 函数指针 的说明，下面节选一些特别有意思的回答： The whole thing declares a function called signal: signal takes an int and a function pointer this function pointer takes an int and returns void signal returns a function pointer this function pointer takes an intand returns avoid` That’s where the last int comes in. You can use the spiral rule to make sense of such declarations, or the program cdecl(1). 这里面提到了 the spiral rule 这是一个用于解析 C 语言中声明 (declaration) 的方法；另外还提到了 cdecl 这一程序，它也有类似的作用，可以使用英文进行声明或者解释。 Find the leftmost identifier and work your way out, remembering that [] and () bind before *; IOW, *a[] is an array of pointers, (*a)[] is a pointer to an array, *f() is a function returning a pointer, and (*f)() is a pointer to a function. Thus, void ( *signal(int sig, void (*handler)(int)) ) (int); breaks down as signal -- signal signal( ) -- is a function signal( sig ) -- with a parameter named sig signal(int sig, ) -- of type int signal(int sig, handler ) -- and a parameter named handler signal(int sig, *handler ) -- which is a pointer signal(int sig, (*handler)( )) ) -- to a function signal(int sig, (*handler)(int)) ) -- taking an int parameter signal(int sig, void (*handler)(int)) ) -- and returning void *signal(int sig, void (*handler)(int)) ) -- returning a pointer ( *signal(int sig, void (*handler)(int)) )( ) -- to a function ( *signal(int sig, void (*handler)(int)) )(int) -- taking an int parameter void ( *signal(int sig, void (*handler)(int)) )(int); -- and returning void 这一回答强调了 * 和 []、() 优先级的关系，这在判断数组指针、函数指针时是个非常好用的技巧。 Rob Pike 于 2009/10/30 的 Golang Talk [PDF] David Brailsford 教授解说影片 Essentials: Pointer Power! - Computerphile [YouTube] ","date":"2024-01-14","objectID":"/posts/c-pointer/:1:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"阅读 C 语言规格书 一手资料的重要性毋庸置疑，对于 C 语言中的核心概念 指针，借助官方规格书清晰概念是非常重要的。 C99 [6.2.5] Types An array type of unknown size is an incomplete type. It is completed, for an identifier of that type, by specifying the size in a later declaration (with internal or external linkage). A structure or union type of unknown content is an incomplete type. It is completed, for all declarations of that type, by declaring the same structure or union tag with its defining content later in the same scope. incomplete type 和 linkage 配合可以进行 forward declaration，如果搭配 pointer 则可以进一步，在无需知道 object 内部细节即可进行程序开发。 Array, function, and pointer types are collectively called derived declarator types. A declarator type derivation from a type T is the construction of a derived declarator type from T by the application of an array-type, a function-type, or a pointer-type derivation to T. 注意 derived declarator types 表示衍生的声明类型，因为 array, function, pointer 本质都是地址，而它们的类型都是由其它类型衍生而来的，所以可以使用这些所谓的 derived declarator types 来提前声明 object，表示在某个地址会存储一个 object，这也是为什么这些类型被规格书定义为 derived declarator types。 lvalue: Locator value 危险 C 语言里只有 call by value ","date":"2024-01-14","objectID":"/posts/c-pointer/:2:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"void \u0026 void * C89 之前，函数如果没有标注返回类型，则默认返回类型 int，返回值 0。但由于这样既可以表示返回值不重要，也可以表示返回值为 0，这会造成歧义，所以引进了 void。 void * 只能表示地址，而不能对所指向的地址区域的内容进行操作。因为通过 void * 无法知道所指向区域的 size，所以无法对区域的内容进行操作，必须对 void * 进行 显示转换 才能操作指向的内容。（除此之外，对于指针本身的操作，void * 与 char * 是等价的，即对于 +/- 1 这类的操作，二者的偏移量是一致的） ","date":"2024-01-14","objectID":"/posts/c-pointer/:3:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"Alignment 这部分原文描述不是很清晰，2-byte aligned 图示如下： 如果是 2-byte aligned 且是 little-endian 的处理器，对于左边，可以直接使用 *(uint16_t *) ptr，但对于右边就无法这样（不符合 alignment）： /* may receive wrong value if ptr is not 2-byte aligned */ uint16_t value = *(uint16_t *) ptr; /* portable way of reading a little-endian value */ uint16_t value = *(uint8_t *) ptr | ((*(uint8_t *) (ptr + 1)) \u003c\u003c 8); 因为内存寻址的最小粒度是 Byte，所以使用 (uint_8 *) 不需要担心 alignment 的问题。原文并没有给出 32-bit aligned 的 portable way，我们来写一下： /* may receive wrong value if ptr is not 2-byte aligned */ uint32_t value = *(uint32_t *) ptr; /* portable way of reading a little-endian value */ uint32_t value = *(uint8_t *) ptr | ((*(uint8_t *) (ptr + 1)) \u003c\u003c 8) | ((*(uint8_t *) (ptr + 2)) \u003c\u003c 16) | ((*(uint8_t *) (ptr + 3)) \u003c\u003c 24); 信息 The Lost Art of Structure Packing ","date":"2024-01-14","objectID":"/posts/c-pointer/:3:1","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"规格书中的 Pointer C99 [6.3.2.3] Pointers A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. Ifaconverted pointer is used to call a function whose type is not compatible with the pointed-to type, the behavior is undefined. C11 [6.3.2.3] Pointers A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. If a converted pointer is used to call a function whose type is not compatible with the referenced type, the behavior is undefined. C99 和 C11 都不保证 pointers (whose type is not compatible with the pointed-to / referenced type) 之间的转换是正确的。 ","date":"2024-01-14","objectID":"/posts/c-pointer/:3:2","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"Pointers vs. Arrays C99 6.3.2.1 Except when it is the operand of the sizeof operator or the unary \u0026 operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. Array 只有在表示其自身为数组时才不会被 converted to Pointer，例如 // case 1: extern declaration of array extern char a[]; // case 2: defintion of array char a[10]; // case 3: size of array sizeof(a); // case 4: address of array \u0026a 在其他情况则会倍 converted to Pointer，这时 Array 可以和 Pointer 互换进行表示或操作，例如 // case 1: function parameter void func(char a[]); void func(char *a); // case 2: operation in expression char c = a[2]; char c = *(a + 2); 这也是为什么对于一个 Array a，\u0026a 和 \u0026a[0] 值虽然相同，但 \u0026a + 1 和 \u0026a[0] + 1 的结果大部分时候是大不相同的，这件事乍一看是非常惊人的，但其实不然，在了解 Array 和 Pointer 之后，也就那么一回事 🤣 ","date":"2024-01-14","objectID":"/posts/c-pointer/:4:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"GDB 实作 char a[10]; int main() { return 0; }; 我们以上面这个例子，通过 GDB 来对 Array 和 Pointer 进行深入研究： (gdb) print \u0026a $1 = (char (*)[10]) 0x555555558018 \u003ca\u003e (gdb) print \u0026a[0] $2 = 0x555555558018 \u003ca\u003e \"\" 符合预期，\u0026a 和 \u0026a[0] 得到的值是相同的，虽然类型看起来不同，但是现在先放到一边。 (gdb) print \u0026a + 1 $3 = (char (*)[10]) 0x555555558022 (gdb) print \u0026a[0] + 1 $4 = 0x555555558019 \u003ca+1\u003e \"\" (gdb) print a + 1 $5 = 0x555555558019 \u003ca+1\u003e \"\" Oh! 正如我们之前所说的 \u0026a + 1 与 \u0026a[0] + 1 结果并不相同（而 \u0026a[0] + 1 和 a + 1 结果相同正是我们所提到的 Array 退化为 Pointer），虽然如此，GDB 所给的信息提示我们可能是二者 Pointer 类型不相同导致的。 (gdb) whatis \u0026a type = char (*)[10] (gdb) whatis \u0026a[0] type = char * Great! 果然是 Pointer 类型不同导致的，我们可以看到 \u0026a 的类型是 char (*)[10] 一个指向 Array 的指针，\u0026a[0] 则是 char *。所以这两个 Pointer 在进行 +/- 运算时的偏移量是不同的，\u0026a[0] 的偏移量为 sizeof(a[0]) 即一个 char 的宽度 ($0x18 + 1 = 0x19$)，而 \u0026a 的偏移量为 sizeof(a) 即 10 个 char 的宽度 ($0x18 + 10 = 0x22$)。 警告 在 GDB 中使用 memcpy 后直接打印可能会出现以下错误： (gdb) p memcpy(calendar, b, sizeof(b[0])) 'memcpy' has unknown return type; cast the call to its declared return type 只需加入 void * 进行类型转换即可解决该问题： (gdb) p (void *) memcpy(calendar, b, sizeof(b[0])) ... 技巧 遇到陌生的函数，可以使用 man 来快速查阅手册，例如 man strcpy, man strcat，手册可以让我们快速查询函数的一些信息，从而进入实作。 ","date":"2024-01-14","objectID":"/posts/c-pointer/:4:1","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"Runtime Environment 根据 Zero size arrays in C ，原文中的 char (*argv)[0] 在函数参数传递时会被转换成 char **argv。而为什么在查看地址 ((char **) argv)[0] 开始的连续 4 个 char * 内容时，会打印出 envp 中的内容，可以参考以下的进入 main 函数时的栈布局： argv 和 envp 所指的字符串区域是相连的，所以在越过 argv 字符串区域的边界后，会继续打印 envp 区域的字符串。这也是为什么打印出的字符串之间地址增长于其长度相匹配。所以从地址 (char **) argv 开始的区域只是一个 char * 数组，使用 x/4s 对这部分进行字符串格式打印显然是看不懂的。 注意 argv 和 envp 都是在 shell 进行 exec 系统调用之前进行传递（事实上是以 arguments 的形式传递给 exec） man 2 execve int execve(const char *pathname, char *const argv[], char *const envp[]); execve 实际上在内部调用了 fork，所以 argv 和 envp 的传递是在 fork 之前。（设想如果是在 fork 之后传递，可能会出现 fork 后 child process 先执行，这种情况 child process 显然无法获得这些被传递的信息） 注意到 execve 只传递了 argv 而没有传递 argc，这也很容易理解，argc 是 argv 的计数，只需 argv 即可推导出 argc。 ","date":"2024-01-14","objectID":"/posts/c-pointer/:4:2","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"Function Pointer 危险 与 Array 类似，Function 只有在表示自身时不会被 converted to Function Pointer (即除 sizeof 和 \u0026 运算之外)，其它情况、运算时都会被 convert to Function Pointer 理解 C 语言中的 Function 以及 Function Pointer 的核心在于理解 Function Designator 这个概念，函数名字必然是 Function Designator，其它的 designator 则是根据以下两条规则进行推导得来。 C99 [ 6.3.2.1 ] A function designator is an expression that has function type. Except when it is the operand of the sizeof operator or the unary \u0026 operator, a function designator with type ‘‘function returning type’’ is converted to an expression that has type ‘‘pointer to function returning type’’. C99 [6.5.3.2-4] The unary * operator denotes indirection. If the operand points to a function, the result is a function designator. ","date":"2024-01-14","objectID":"/posts/c-pointer/:5:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"指针的修饰符 指针 p 自身不能变更，既不能改变 p 自身所存储的地址。const 在 * 之后： char * const p; 指针 p 所指向的内容不能变更，即不能通过 p 来更改所指向的内容。const 在 * 之前： const char * p; char const * p; 指针 p 自身于所指向的内容都不能变更： const char * const p; char const * const p; ","date":"2024-01-14","objectID":"/posts/c-pointer/:6:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"字符串 对于函数内部的 char *p = \"hello\"; char p[] = \"hello\"; 这两个是不一样的，因为 string literals 是必须放在 “static storage” 中，而 char p[] 则表示将资料分配在 stack 內，所以这会造成编译器隐式地生成额外代码，在执行时 (runtime) 将 string literals 从 static storage 拷贝到 stack 中，所以此时 return p 会造成 UB。而 char *p 的情形不同，此时 p 只是一个指向 static storage 的指针，进行 return p 是合法的。 在大部分情况下，null pointer 并不是一个有效的字符串，所以在 glibc 中字符相关的大部分函数也不会对 null pointer 进行特判 (特判会增加分支，从而影响程序效能)，所以在调用这些函数时需要用户自己判断是否为 null pointer，否则会造成 UB。 ","date":"2024-01-14","objectID":"/posts/c-pointer/:7:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"Linus 的“教导” Linus 親自教你 C 語言 array argument 的使用 because array arguments in C don’t actually exist. Sadly, compilers accept it for various bad historical reasons, and silently turn it into just a pointer argument. There are arguments for them, but they are from weak minds. The “array as function argument” syntax is occasionally useful (particularly for the multi-dimensional array case), so I very much understand why it exists, I just think that in the kernel we’d be better off with the rule that it’s against our coding practices. array argument 应该只用于多维数组 (multi-dimensional arrays) 的情形，这样可以保证使用下标表示时 offset 是正确的，但对于一维数组则不应该使用数组表示作为函数参数，因为这会对函数体内的 sizeof 用法误解 (以为会获得数组的 size，实际上获得的只是指针的 size)。 技巧 一个常用于计算数组中元素个数的宏： #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0])) 这个宏非常有用，xv6 中使用到了这个宏。 但是需要注意，使用时必须保证 x 是一个数组，而不是函数参数中由数组退化而来的指针，以及保证数组必须至少拥有一个元素的长度 (这个很容易满足，毕竟 x[0] 编译器会抛出警告)。 ","date":"2024-01-14","objectID":"/posts/c-pointer/:8:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Linux Kernel Internals"],"content":"Lvalue \u0026 Rvalue Lvalue: locator value Rvalue: Read-only value C99 6.3.2.1 footnote The name “lvalue” comes originally from the assignment expression E1 = E2, in which the left operand E1 is required to be a (modifiable) lvalue. It is perhaps better considered as representing an object “locator value”. What is sometimes called “rvalue” is in this International Standard described as the “value of an expression”. An obvious example of an lvalue is an identifier of an object. As a further example, if E is a unary expression that is a pointer to an object, *E is an lvalue that designates the object to which E points. 即在 C 语言中 lvalue 是必须能在内存 (memory) 中可以定位 (locator) 的东西，因为可以定位 (locator) 所以才可以在表达式左边从而修改值。想像一下，在 C 语言中修改一个常数的值显然是不可能的，因为常数无法在内存 (memory) 定位 (locator) 所以常数在 C 语言中不是 lvalue。C 语言中除了 lvalue 之外的 value 都是 rvalue (这与 C++ 有些不同，C++ 的 lvalue 和 rvalue 的定义请参考 C++ 的规格书)。 ","date":"2024-01-14","objectID":"/posts/c-pointer/:9:0","tags":["Sysprog","C"],"title":"你所不知道的 C 语言: 指针篇","uri":"/posts/c-pointer/"},{"categories":["Network"],"content":" 摘要 之前学校的计网理论课学得云里雾里，对于物理层和数据链路层并没有清晰的逻辑框架，而这学期的计网课设内容为数据链路层和网络层的相关内容，写起来还是云里雾里。虽然最终艰难地把课设水过去了，但是个人认为网络对于 CSer 非常重要，特别是在互联网行业，网络知识是必不可少的。 所以决定寒假重学计网，于是在 HackMD 上冲浪寻找相关资料。然后发现了这篇笔记 110-1 計算機網路 (清大開放式課程)，里面提到清大计网主要介绍 L2 ~ L4 一些著名的协议和算法，这完美符合个人的需求，而且该篇该笔还补充了一些额外的内容，例如 IPv6，所以当即准备搭配这篇笔记来学习清大的计算机网络概论。 ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:0:0","tags":["Network"],"title":"\u003c清大计算机网络\u003e 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"清大计算机网络概论 本課程將介紹計算機網路的基本運作原理與標準的網路七層結構,由淺入深,可以讓我們對於計算機網路的運作有最基本的認識,本課程還會介紹全球建置最多的有線網路──IEEE 802.3 Ethernet 的基本運作原理, 還有全球建置最多的無線區域網路──IEEE 802.11 Wireless LAN 的基本運作原理, 想知道網路交換機(switches) 是如何運作的嗎 ? 想知道網際網路最重要也最關鍵的通訊協議 ── TCP/IP 是如何運作的嗎 ? 想知道網際網路最重要的路由器 (Routers) 是如何運作的嗎 ? 在本課程裡您都可以學到這些重要的基本知識。 开课学校 课程主页 课程资料 课程影片 國立清華大學 計算機網路概論 課程講義與練習題 Youtube ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:1:0","tags":["Network"],"title":"\u003c清大计算机网络\u003e 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"L1 Foundation 重点提示与练习 ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:0","tags":["Network"],"title":"\u003c清大计算机网络\u003e 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Applications Foundation - 5 进行 1 次 URL request 需要进行 17 次的讯息交换： 6 次讯息交换用于查询 URL 对应的 IP Address 3 次讯息交换用于建立 TCP 连接（TCP 的 3 次握手） 4 次讯息交换用于 HTTP 协议的请求和回复 4 次讯息交换用于关闭 TCP 连接（TCP 的 4 次握手） ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:1","tags":["Network"],"title":"\u003c清大计算机网络\u003e 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Network Connectivity Foundation - 8 交换机 (Switches) 可以分为很多层级，即可以有不同层级的交换机，例如 L2 层的交换机，L3 层的交换机以及 L4 层的交换机。如何判断交换机是哪个层级？很简单，只需要根据交换机所处理的讯息，L2 层交换机处理的是 MAC Address，L3 层交换机处理的是 IP Address，而 L4 层交换机处理的是 TCP 或者 UDP 相关的讯息。 交换机 (Switches) 用于网络 (Network) 内部的连接，路由 (Router) 用于连接不同的网络 (Network)，从而形成 Internetwork。 地址 (Address)，对于网卡来说是指 MAC Address，对于主机来说是指 IP Address。Host-to-Host connectivity 是指不同网络 (Network) 的主机，即位于 Internetwork 的不同主机之间，进行连接。 ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:2","tags":["Network"],"title":"\u003c清大计算机网络\u003e 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Network Architecture Foundation - 22 Physical Layer: 如何将原始资料在 link 上传输，例如不同介质、信息编码。(P25) Data Link Layer: 在 Physical Layer 基础上，如何将 frame 传给直接相连的主机或设备，核心是通过 Media Access Control Protocol 解决 Multiple access 产生的碰撞问题。这一层交换的数据被称为 frame。(P26) Network Layer: 在 Data Link Layer 基础上，如何将 packet 通过 Internet 送给目的地主机。核心是通过 Routing Protocols 动态转发 packet。这一层交换的数据被称为 packet。(P27) Transport Layer: 在 Network Layer 基础上，提供不同主机 processes 之间的资料传送。由于 Networkd Layer 是主机间进行资料传送，所以在 Transport Layer 不论是可靠还是不可靠的传输协议，都必须要实现最基本的机制：主机与 process 之间数据的复用和分解。这一层交换的数据被称为 message。(P28) 注意 Switch 一般处于 L2 Layer，Router 一般处于 L3 Layer。L4 Layer 及以上的 layers 通常只存在于 hosts，switches 和 routers 内部一般不具有这些 layers。(P29) Internet Architecture 的层级并不是严格的，Host 可以略过 Application Layer 而直接使用 Transport Layer、Network Layer 中的协议。(P30) Internet Architecture 的核心是 IP 协议，它作为沙漏形状的中心位置，为处于其上层的协议与处于其下层协议之间提供了一个映射关系。(P31) ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:3","tags":["Network"],"title":"\u003c清大计算机网络\u003e 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["Network"],"content":"Network Performance Foundation - 36 Foundation - 37 Bandwidth: Number of bits per second (P34) Delay 可以近似理解为 Propagation time。有效利用 network 的标志是在接收对方的回应之前，发送方传送的资料充满了 pipe，即发送了 Delay $\\times$ Bandwitdh bits 的资料量。(P39) Foundation - 40 RTT 可以近似理解为 2 $\\times$ Propagation time，因为一个来回需要从 sender 到 reciever，再从 reciever 到 sender。 ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:4","tags":["Network"],"title":"\u003c清大计算机网络\u003e 重点提示","uri":"/posts/nthu-computer-network/"},{"categories":["C"],"content":"C 语言规格书 Chapter 6 - Language 阅读记录。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:0:0","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"6.2 Concepts ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:1:0","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"6.2.2 Linkages of identifiers linkage: external internal none 一个拥有 file scope 并且关于 object 或 function 的 identifier 声明，如果使用 static 修饰，则该 identifer 有 internal linkage，e.g. // file scope static int a; static void f(); int main() {} 一个 scope 内使用 static 修饰的 identifier 声明，如果在同一 scope 内已存在该 identifier 声明，则该 identifier 的 linkage 取决于先前的 identifier 声明。如果该 identifier 不存在先前声明或者先前声明 no linkage，则该 identifier 是 external linkage，e.g. // Example 1 static int a; // a is internal linkage extern int a; // linkage is the same as prior // Example 2 extern int b; // no prior, a is external linkage extern int b; // linkage is the same as prior 如果一个 function identifier 声明没有 storage-class 修饰符，则其 linkage 等价于加上 extern 修饰的声明的 linkage，e.g. int func(int a, int b); // equal to `extern int func(int a. int b);` // and then no prior, it is external linkage 如果一个 object identifier 声明没有 storage-class 修饰符，且拥有 file scope，则其拥有 external linkage，e.g. // file scope int a; // external linkage int main() {} ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:1:1","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"6.5 Expressions Syntax unary-exprssion: postfix-exprssion ++ unary-expression -- unary-expression unary-operator cast-exprssion sizeof unary-expression sizeof ( type-name ) unary-operator: one of \u0026 * + - ~ ! ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:2:0","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"6.5.3 Unary operators 注意 C99 [6.2.5] Types There are three real floating types, designated as float, double, and long double. The real floating and complex types are collectively called the floating types. The integer and real floating types are collectively called real types. Integer and floating types are collectively called arithmetic types. A function type describes a function with specified return type. A function type is characterized by its return type and the number and types of its parameters. A function type is said to be derived from its return type, and if its return type is T, the function type is sometimes called ‘‘function returning T’’. The construction of a function type from a return type is called ‘‘function type derivation’’. Arithmetic types and pointer types are collectively called scalar types. C99 [6.3.2.1] Lvalues, arrays, and function designators A function designator is an expression that has function type. Except when it is the operand of the sizeof operator or the unary \u0026 operator, a function designator with type ‘‘function returning type’’ is converted to an expression that has type ‘‘pointer to function returning type’’. 6.5.3.1 Prefix increment and decrement operators Constraints 前缀自增或自减运算符的操作数，必须为实数 (real types) 类型（即不能是复数）或者是指针类型，并且其值是可变的。 Semantics ++E 等价于 (E+=1) --E 等价于 (E-=1) 6.5.3.2 Address and indirection operators Constraints \u0026 运算符的操作数必须为 function designator，[] 或 * 的运算结果，或者是一个不是 bit-field 和 register 修饰的左值。 * 运算符的操作数必须为指针类型。 Semantics \u0026*E 等价于 E，即 \u0026 和 * 被直接忽略，但是它们的 constraints 仍然起作用。所以 (\u0026*(void *)0) 并不会报错。 \u0026a[i] 等价于 a + i，即忽略了 \u0026 以及 * (由 [] 隐式指代)。 其它情况 \u0026 运算的结果为一个指向 object 或 function 的指针。 如果 * 运算符的操作数是一个指向 function 的指针，则结果为对应的 function designator。 如果 * 运算符的操作数是一个指向 object 的指针，则结果为指示该 obejct 的左值。 如果 * 运算符的操作数为非法值的指针，则对该指针进行 * 运算的行为三未定义的。 6.5.3.3 Unary arithmetic operators Constraints 单目 + 或 - 运算符的操作数必须为算数类型 (arithmetic type)，~ 运算符的操作数必须为整数类型 (integer type)，! 运算符的操作数必须为常数类型 (scalar type)。 Semantics 在进行单目 +、-、~ 运算之前，会对操作数进行整数提升 (integer promotions)，结果的类型与操作数进行整数提升后的类型一致。 !E 等价于 (E==0)，结果为 int 类型。 6.5.3.4 待补充 ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:2:1","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"6.5.7 Bitwise shift operators Syntax shift-expression: additive-exprssion shift-exprssion \u003e\u003e additive-expression shift-exprssion \u003c\u003ccadditive-expression Constraints 位运算的操作数都必须为整数类型。 Semantics 在进行位运算之前会先对操作数进行整数提升 (integer promotion)，位运算结果类型与整数提升后的左操作数一致。如果右运算数是负数，或者大于等于整数提升后的左运算数的类型的宽度，那么这个位运算行为是未定义的。 假设运算结果的类型为 T $E1 \u003c\u003c E2$ 如果 E1 是无符号，则结果为 $E1 \\times 2^{E2} \\bmod (\\max[T] + 1)$。 如果 E1 是有符号，E1 不是负数，并且 T 可以表示 $E1 \\times 2^{E2}$，则结果为 $E1 \\times 2^{E2}$。 除了以上两种行为外，其他均是未定义行为。 $E1 \u003e\u003e E2$ 如果 E1 是无符号，或者 E1 是有符号并且是非负数，则结果为 $E1 / 2^{E2}$。 如果 E1 是有符号并且是负数，则结果由具体实现决定 (implementation-defined)。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch6/:2:2","tags":["C","Sysprog"],"title":"C 规格第 6 章 Language","uri":"/posts/c-specification/ch6/"},{"categories":["C"],"content":"C 语言规格书 Chapter 7 - Library 阅读记录。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch7/:0:0","tags":["C","Sysprog"],"title":"C 规格第 7 章 Library","uri":"/posts/c-specification/ch7/"},{"categories":["C"],"content":"7.18 Integer types \u003cstdint.h\u003e 描述了头文件 stdint.h 必须定义和实现的整数类型，以及相应的宏。 ","date":"2024-01-11","objectID":"/posts/c-specification/ch7/:1:0","tags":["C","Sysprog"],"title":"C 规格第 7 章 Library","uri":"/posts/c-specification/ch7/"},{"categories":["C"],"content":"7.18.1 Integer types 7.18.1.1 Exact-width integer types 二补数编码，固定长度 N 的整数类型： 有符号数：intN_t 无符号数：uintN_t 7.18.1.2 Minimum-width integer types 至少拥有长度 N 的整数类型： 有符号数：int_leastN_t 无符号数：uint_leastN_t 7.18.1.3 Fastest minimum-width integer types 至少拥有长度 N，且操作速度最快的整数类型： 有符号数：int_fastN_t 无符号数：uint_fastN_t 7.18.1.4 Integer types capable of holding object pointers 可以将指向 void 的有效指针转换成该整数类型，也可以将该整数类型转换回指向 void 的指针类型，并且转换结果与之前的指针值保持一致： 有符号数：intptr_t 无符号数：uintptr_t 7.18.1.5 Greatest-width integer types 可以表示任意整数类型所表示的值的整数类型，即具有最大长度的整数类型： 有符号数：intmax_t 无符号数：uintmax_t ","date":"2024-01-11","objectID":"/posts/c-specification/ch7/:1:1","tags":["C","Sysprog"],"title":"C 规格第 7 章 Library","uri":"/posts/c-specification/ch7/"},{"categories":["C","Linux Kernel Internals"],"content":"C 语言规格书阅读学习记录。 规格书版本为 n1256，对应 C99 标准，对应的 PDF 下载地址。 也配合 C11 标准来阅读，版本 n1570，对应的 PDF 下载地址。 阅读规格书需要一定的体系结构、编译原理的相关知识，但不需要很高的程度。请善用检索工具，在阅读规格书时遇到术语时，请先在规格书中进行检索，因为极大可能是规格书自己定义的术语。 ","date":"2024-01-06","objectID":"/posts/c-specification/c-specification/:0:0","tags":["C","Sysprog"],"title":"C 语言规格书","uri":"/posts/c-specification/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"6. Language 详见 阅读记录 6. Language。 ","date":"2024-01-06","objectID":"/posts/c-specification/c-specification/:1:0","tags":["C","Sysprog"],"title":"C 语言规格书","uri":"/posts/c-specification/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"7. Library 详见 阅读记录 7. Library。 ","date":"2024-01-06","objectID":"/posts/c-specification/c-specification/:2:0","tags":["C","Sysprog"],"title":"C 语言规格书","uri":"/posts/c-specification/c-specification/"},{"categories":["Git"],"content":"Git 中文教学 新手入门推荐，对于 Git 的入门操作讲解十分友好。 视频地址 学习记录 ","date":"2024-01-04","objectID":"/posts/git/:1:0","tags":["Git/GitHub"],"title":"Git/GitHub 资源与问题汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"Git 常见问题及解决 ","date":"2024-01-04","objectID":"/posts/git/:2:0","tags":["Git/GitHub"],"title":"Git/GitHub 资源与问题汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"git pull/push 遇到 Port 22 connect timeout 网络问题导致 22 端口被禁止，无法正常使用 ssh。切换成 443 端口并且编写配置文件即可： $ vim ~/.ssh/config # In ~/.ssh/config Host github.com HostName ssh.github.com Port 443 ","date":"2024-01-04","objectID":"/posts/git/:2:1","tags":["Git/GitHub"],"title":"Git/GitHub 资源与问题汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"References Git 基本原理 Learn Git Branching ugit 动手学习GIT - 最好学习GIT的方式是从零开始做一个 ","date":"2024-01-04","objectID":"/posts/git/:3:0","tags":["Git/GitHub"],"title":"Git/GitHub 资源与问题汇总","uri":"/posts/git/"},{"categories":["Network"],"content":"整理一些计算机网络相关的资源 ","date":"2024-01-02","objectID":"/posts/network/:0:0","tags":["Network"],"title":"计算机网络学习指引","uri":"/posts/network/"},{"categories":["Network"],"content":"Referenecs 110-1 計算機網路 (清大開放式課程) 小菜学网络 NUDT 高级计算机网络实验: 基于UDP的可靠传输 可靠 UDP 的实现 (KCP over UDP) 基于UDP的可靠传输 [bilibili] 实现基于UDP的网络文件传输器，程序员的经验大礼包项目 [bilibili] ping命令但是用来通信，学习计算机网络好项目，也可能是校园网福利 [bilibili] Implementing TCP in Rust [YouTube] Let’s code a TCP/IP stack ","date":"2024-01-02","objectID":"/posts/network/:1:0","tags":["Network"],"title":"计算机网络学习指引","uri":"/posts/network/"},{"categories":["Linux Kernel Internals"],"content":" 摘要 人们对数学的加减运算可轻易在脑中辨识符号并理解其结果，但电脑做任何事都受限于实体资料储存及操作方式，换言之，电脑硬体实际只认得 0 和 1，却不知道符号 + 和 - 在数学及应用场域的意义，於是工程人员引入「补数」以便在二进位系统中，表达人们认知上的正负数。但您有没有想过，为何「二补数」(2’s complement) 被电脑广泛采用呢？背後的设计考量又是什麽？本文尝试从数学观点去解读编码背後的原理，并佐以资讯安全及程式码最佳化的考量，探讨二补数这样的编码对于程式设计有何关键影响。 原文地址：解讀計算機編碼 ","date":"2023-12-31","objectID":"/posts/binary-representation/:0:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"一补数 (Ones’ complement) ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"9 的补数 ✅ 科普短片: Not just counting, but saving lives: Curta ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"运算原理 注意 以一补数编码形式表示的运算子，在参与运算后，运算结果符合一补数的编码： $$ [X]_{一补数} + [Y]_{一补数} = [X+Y]_{一补数} $$ 接下来进行分类讨论，以 32-bit 正数 $X$, $Y$ 为例： $X + Y = X + Y$ 显然运算子和运算结果都满足一补数编码。 $X - Y = X + (2^{32} - 1 - Y)$ 如果 $X \u003e Y$，则运算结果应为 $X - Y$ 且为正数，其一补数编码为 $X - Y$。而此时 $$ 2^{32} - 1 + X - Y $$ 显然会溢出，为了使运算结果对应一补数编码，所以此时循环进位对应 $+\\ (1 - 2_{32})$。 如果 $X \u003c Y$，则运算结果应为 $X - Y$ 且为负数，其一补数编码为 $$ 2^{32} - 1 - （Y - X） = 2_{32} - 1 - X - Y $$ 而此时 $2^{32} - 1 + X - Y$ 并不会溢出，并且满足运算结果的一补数编码，所以无需进行循环进位。 如果 $X = Y$，显然 $$ X - Y = X + 2^{32} - 1 - Y = 2^{32} - 1 $$ 为 0 成立。 $-X - Y = (2^{32} - 1 - X) + (2^{32} - 1 - Y)$，显然会导致溢出。而 $-X - Y$ 的一补数编码为 $$ 2^{32} - 1 - (X + Y) = 2^{32} - 1 - X - Y $$ 所以需要在溢出时循环进位 $+\\ (1 - 2^{32})$ 来消除运算结果中的一个 $2^{32} - 1$。 ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:2","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"二补数 (Two’s complement) ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"正负数编码表示 假设有 n-bit 的二补数编码 $A$，$-A$ 的推导如下： 格式一： $$ \\begin{align*} A + \\neg A \u0026= 2^n - 1 \\\\ A + \\neg A + 1 \u0026\\equiv 0 \\equiv 2^n \\ (\\bmod 2^n) \\\\ -A \u0026= \\neg A + 1 \\\\ \\end{align*} $$ 格式二： $$ \\begin{align*} A + \\neg A \u0026= 2^n - 1 \\\\ A + \\neg A - 1 \u0026= 2^n - 2 \\\\ A - 1 \u0026= 2^n - 1 - (\\neg A + 1) \\\\ \\neg (A - 1) \u0026= \\neg A + 1 \\\\ \\neg (A - 1) \u0026= -A \\\\ \\end{align*} $$ 也可以通过一补数和二补数，在时钟表上的对称轴偏差，来理解上述两种方式是等价的。 ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"加 / 减法器设计 ✅ 科普短片: See How Computers Add Numbers In One Lesson 了解晶体管的原理 了解基本逻辑门元件，例如 OR, AND 逻辑门的设计 了解加法器的原理和工作流程。 ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:2","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"阿贝尔群及对称性 技巧 群论的最大用途是关于「对称性」的研究；所有具有对称性质，群论都可派上用场。只要发生变换后仍有什么东西还维持不变，那符合对称的性质。 一个圆左右翻转后还是圆，它在这种变换下是对称的，而这刚好与群的 封闭性 (Closure) 对应。 一个时钟的时刻，从 0 时刻开始，两边的时刻相加模 12 的结果均为 0，这与群的 单位元 (Identity element) 和 逆元 (Inverse element) 对应。 上述两个例子反映了群论的性质，对于对称性研究的重要性和原理依据。 科普影片：从五次方程到伽罗瓦理论 阿贝尔和伽罗瓦的悲惨世界 ","date":"2023-12-31","objectID":"/posts/binary-representation/:3:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"旁路攻击 ✅ 观看科普视频: 我听得到你打了什么字 阅读相关论文 Keyboard Acoustic Emanations 体验使用相关工具 kbd-audio ✅ 借由 Wikipedia 了解旁路攻击 (Side-channel attack) 和时序攻击 (Timing attack) 的基本概念。 Black-box testing Row hammer Cold boot attack Rubber-hose cryptanalysis 延伸阅读 The password guessing bug in Tenex Side Channel Attack By Using Hidden Markov Model One\u0026Done: A Single-Decryption EM-Based Attack on OpenSSL’s Constant-Time Blinded RSA ","date":"2023-12-31","objectID":"/posts/binary-representation/:4:0","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"Constant-Time Functions 比较常见的常数时间实作方法是，消除分支。因为不同分支的执行时间可能会不同，这会被利用进行时序攻击。这个方法需要对 C 语言中的编码和位运算有一定的了解。 C99 STandard - 7.18.1.1 Exact-width integer types 阅读记录 C99 Standard - 6.5.7.5 Bitwise shift operators 阅读记录 Branchless abs 方法一，原理为 $-A = \\neg (A - 1)$: #include \u003cstdint.h\u003e int32_t abs(int32_t x) { int32_t mask = (x \u003e\u003e 31); return (x + mask) ^ mask; } 方法二，原理为 $-A = \\neg A + 1$: #include \u003cstdint.h\u003e int32_t abs(int32_t x) { int32_t mask = (x \u003e\u003e 31); return (x ^ mask) - mask; } Branchless min/max Min: #include \u003cstdint.h\u003e int32_t min(int32_t a, int32_t b) { int32_t diff = (a - b); return b + (diff \u0026 (diff \u003e\u003e 31)); } 如果 diff \u003e 0 即 b 小，那么 (diff \u003e\u003e 31) == 0，则 b + (diff \u0026 (diff \u003e\u003e 31)) == b 如果 diff \u003c 0 即 a 小，那么 (diff \u003e\u003e 31) == -1，则 b + (diff \u0026 (diff \u003e\u003e 31)) == b + (a - b) == a Max: #include \u003cstdint.h\u003e int32_t max(int32_t a, int32_t b) { int32_t diff = (b - a); return b - (diff \u0026 (diff \u003e\u003e 31)); } 如果 diff \u003e 0 即 b 大, 那么 (diff \u003e\u003e 31) == 0，则 b - (diff \u0026 (diff \u003e\u003e 31)) == b 如果 diff \u003c 0 即 a 大，那么 (diff \u003e\u003e 31) == -1，则 b - (diff \u0026 (diff \u003e\u003e 31)) == b - (b - a) == a 延伸阅读 ❌ 基于 C 语言标准研究与系统程序安全议题 ","date":"2023-12-31","objectID":"/posts/binary-representation/:4:1","tags":["Sysprog"],"title":"解读计算机编码","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"Rust in 100 Seconds ✅ 观看短片：Rust in 100 Seconds 了解 Rust，初步了解其安全性原理 所有权 (ownership) 借用 (borrow) 警告 0:55 This is wrong, value mutability doesn’t have anything to do with the value being stored on the stack or the heap (and the example let mut hello = \"hi mom\" will be stored on the stack since it’s type is \u0026'static str), it depends on the type of the value (if it’s Sized or not). ","date":"2023-12-28","objectID":"/posts/rust-introduction/:1:0","tags":["Rust","Sysprog"],"title":"Rust - 进行中的未来","uri":"/posts/rust-introduction/"},{"categories":["Linux Kernel Internals"],"content":"The adoption of Rust in Business (2022) ❌ 阅读报告 The adoption of Rust in Business (2022)。 ","date":"2023-12-28","objectID":"/posts/rust-introduction/:2:0","tags":["Rust","Sysprog"],"title":"Rust - 进行中的未来","uri":"/posts/rust-introduction/"},{"categories":["Git","Linux Kernel Internals"],"content":"教学影片：Git 中文教学 ","date":"2023-12-27","objectID":"/posts/git-learn/:0:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"安装与设定 注意 ✅ 观看影片 Git 教学系列 - 安装与配置，完成常用的 Git 设置。 设置 Git 的编辑器为 vim，主要用于 commit 时的编辑： $ git config --global core.editor vim 设置 Git 的合并解决冲突工具为 vimdiff： $ git config --global merge.tool vimdiff 启用 Git 命令行界面的颜色显示： $ git config --global color.ui true 设置常用命令的别名： $ git config --global alias.st status $ git config --global alias.ch checkout $ git config --global alias.rst reset HEAD 效果为：命令 git st 等价于 git status，其余的类似。 设置 Windows 和 Mac/Linux 的换行符同步： # In Windows $ git config --global core.autocrlf true # In Mac/Linux $ git config --global core.autocrlf input 效果为：在 Windows 提交时自动将 CRLF 转为 LF，检出代码时将 LF 转换成 CRLF。在 Mac/Linux 提交时将 CRLF转为 LF，检出代码时不转换。这是因为 Windows 的换行符为 \\r\\n，而 Mac/Linux 的换行符仅为 \\n。 ","date":"2023-12-27","objectID":"/posts/git-learn/:1:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Add 和 Commit ","date":"2023-12-27","objectID":"/posts/git-learn/:2:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"指定 Commit 注意 ✅ 观看影片 Git 教学系列 - 指定 Commit，掌握 git log、git show、git diff 的常用方法。理解 Hash Value 和 commit 对于 Git 版本控制的核心作用。 只要 commit 了，资料基本不可能丢失，即使误操作了也是可以补救回来的（除非把 .git/ 文件夹也删除了）。 ","date":"2023-12-27","objectID":"/posts/git-learn/:3:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Hash Value Every commit has a unique hash value. Calculate by SHA1 Hash value can indicate a commit absolutely. ","date":"2023-12-27","objectID":"/posts/git-learn/:3:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Indicate Commit git manage references to commit HEAD Branch Tag Remote Also, We can indicate commit by ^, ~ 通俗地将，不论是 HEAD、Branch、Tag、Remote，其本质都是使用 Hash Value 进行索引的 commit，所以 ~ 和 ^ 也可以作用于它们。 可以通过 git log 来查看 commit 以及对应的 Hash 值。事实上，这个命令十分灵活，举个例子： git log 4a6ebc -n1 这个命令的效果是从 Hash 值为 4a6bc 的 commit 开始打印 1 条 commit 记录（没错，对应的是 -n1），因为 Git 十分聪明，所以 commit 对应的 Hash 值只需前 6 位即可（因为这样已经几乎不会发生 Hash 冲突）。 Examples 打印 master 分支的最新一个 commit： git log master -n1 打印 master 分支的最新一个 commit（仅使用一行打印 commit 信息）： git log master -n1 --oneline 打印 HEAD 所指向的 commit： git log HEAD -n1 --oneline 打印 HEAD 所指向的 commit 的前一个 commit： git log HEAD^ -n1 --oneline ^ 可以持续使用，比如 HEAD^^ 表示 HEAD 所指向的 commit 的前两个 commit。当 ^ 数量过多时，可以使用 ~ 搭配数字来达到相同效果。例如： git log HEAD^^^^^ -n1 --oneline git log HEAD~5 -n1 --oneline 一般来说，使用 ^ 就已经足够了，几乎不会遇到使用 ~ 的场景，因为这种场景一般会去找图形化界面吧。🤣 打印与文件 README.md 相关的 commits（仅使用一行显示）： git log --oneline README.md 打印与文件 README.md 相关的 commits（显示详细信息，包括文件内容的增减统计）： git log --stat README.md 打印与文件 README.md 相关的 commits（显示详细信息，包括文件内容的增减细节）： git log --patch README.md 在打印的 commit 信息中抓取与 README 符合的信息（可以与 --stat 或 --patch 配合使用）： git log -S README ","date":"2023-12-27","objectID":"/posts/git-learn/:3:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"View History git log \u003cpath\u003e|\u003ccommit\u003e -n: limit number --oneline: view hash and commit summary --stat: view files change --patch: view lines change -S or --grep: find modification ","date":"2023-12-27","objectID":"/posts/git-learn/:3:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"View Commit git show \u003ccommit\u003e Equal to log -n1 ","date":"2023-12-27","objectID":"/posts/git-learn/:3:4","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"See Difference 查看当前的修改，可以查看已经修改但没有 staged 文件的变化： git diff 查看当前的修改，可以查看已经修改且 staged 文件的变化： git diff --staged 查看当前与指定的 commit 的差异： git diff \u003ccommit\u003e # e.g. git diff master^ 查两个指定的 commit 之间的差异： git diff \u003ccommit\u003e \u003ccommit\u003e # e.g. git diff master^ master^^ ","date":"2023-12-27","objectID":"/posts/git-learn/:3:5","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Path Add and Amend 注意 ✅ 观看影片 Git 教学系列 - Patch Add and Amend，掌握 git add -p、git checkout -p、git add ---amend 的用法，使用 add 和 checkout 时强烈建议使用 -p，掌握修改 commit 的两种方法。 ","date":"2023-12-27","objectID":"/posts/git-learn/:4:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Only Add Related git add -p 推荐尽量使用这个 git add -p 而不是单纯的 git add。 使用 git add -p 后，Git 会帮我们把涉及的修改分成 section，然后我们就可以对每一个 section 涉及的修改进行 review，选择 y(yes) 表示采纳该 sction 对应的修改，选择 n(no) 表示不采纳。 如果觉得 section 切割的粒度太大了，可以选择 s(split) 来进行更细粒度的划分。如果这样仍然觉得粒度不够，可以选择 e(edit) 对 section 涉及的修改，进行以行为粒度的 review，具体操作可以查阅此时给出的提示。 还有一些其它的选项，比如 j、J、k、K，这些是类似 vim，用于切换进行 review 的 section，不太常用。q(quit) 表示退出。 由于可以针对一个文件的不同 section 进行 review，所以在进行 git add -p 之后，使用 git status 可以发现同一个文件会同时处于两种状态。 ","date":"2023-12-27","objectID":"/posts/git-learn/:4:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Checkout Also git checkout -p 这个操作比较危险，因为这个操作的效果与 git add -p 相反，如果选择 y 的话，文件涉及的修改就会消失，如果涉及的修改没有 commit 的话，那么涉及的修改是无法救回的。但是怎么说，这个操作还是比直接使用 git checkout 稍微保险一点，因为会先进入 review 界面，而不是直接撤销修改。所以，请一定要使用 git checkout -p！ ","date":"2023-12-27","objectID":"/posts/git-learn/:4:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Modify Commit 有两种方式来修改最新的 commit： # 1. Use git commit --amend git commit --amend # 2. Use reset HEAD^ then re-commit git reset HEAD^ git add -p git commit git commit --amend 并不是直接替换原有的 commit，而是创建了一个新的 commit 并重新设置了 HEAD 的指向。所以，新旧两个 commit 的 Hash Value 并不相同，事实上，如果你拥有旧 commit 的 Hash Value，是可以通过 git checkout \u003ccommit\u003e 切换到那个 commit 的。其原理如下图： 但是注意，git reset HEAD^ 是会撤销原先的 commit（仅限于本地 Git 存储库）。 ","date":"2023-12-27","objectID":"/posts/git-learn/:4:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Branch and Merge 注意 ✅ 观看影片 Git 教学系列 - Branch and Merge，掌握创建、删除、切换分支的用法，掌握合并分支、解决冲突的方法。 git checkout \u003ccommit\u003e git branch \u003cname\u003e git branch \u003cname\u003e \u003ccommit\u003e git branch [-d|-D] \u003cname\u003e git merge \u003cname\u003e --no-ff ","date":"2023-12-27","objectID":"/posts/git-learn/:5:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Move and Create Branch Checkout: move HEAD git checkout \u003ccommit\u003e: Move HEAD to commit git checkout \u003cpath\u003e: WARNING: discard change 可以将路径上的文件复原到之前 commit 的状态。 Branch: git branch: List branch git branch \u003cname\u003e: Create branch Or just: git checkout -b Examples 修改一个文件并恢复： # modify file load.cpp git status git checkout load.cpp git status 删除一个文件并恢复： rm load.cpp git status git checkout load.cpp git status 正如上一节所说的，git checkout 尽量带上 -p 参数，因为如果一不小心输入了 git checkout .，那就前功尽弃了。 显示分支： # only show name git branch # show more infomation git branch -v 切换分支： # switch to branch 'main' git checkout main 创建分支： # 1. using `git branch` git branch cload # 2. using `git checkout -b` git checkout -b asmload # 3. create a new branch in \u003ccommit\u003e git branch cload \u003ccommit\u003e 切换到任一 commit： git checkout \u003ccommit\u003e 直接 checkout 到任一 commit 会有警告，这是因为，当你以该 commit 为基点进行一系列的 commit，这些新的 commit 会在你切换分支后消失，因为没有 branch 来引用它们。之前可以被引用是因为 HEAD 引用，切换分支后 HEAD 不再引用这些 commit，所以就会消失。在这种情况，Git 会在发出警告的同时建议我们使用 git branch 来创建分支进行引用。 ","date":"2023-12-27","objectID":"/posts/git-learn/:5:1","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"View Branch 列出仓库的所有分支： git branch 也可以通过 log 来查看分支： git log --decorate: 在 log 的首行显示所有的 references（可能需要通过 git config log.decorate auto 来开启） --graph: 以图形化的方式显示 branch 的关系（主要是 commit 的引用） ","date":"2023-12-27","objectID":"/posts/git-learn/:5:2","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Delete Branch 删除分支： git branch -d \u003cname\u003e 对于有没有 merge 的 commit 的分支，Git 会警告，需要使用 -D 来强制删除： git branch -D \u003cname\u003e for no-merge commit WARNING: Discard Commit Git 会发出警告的原因同样是 no-merge commit 在删除分支后就无法被引用，所以会发出警告。 ","date":"2023-12-27","objectID":"/posts/git-learn/:5:3","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Merge 合并分支。默认使用 fast-forward，即如果没有冲突，直接将要合并的分支提前到被合并分支的 commit 处，而不会另外生成一个 merge commit。但这样会使得被合并的分支在合并后，没有历史痕迹。可以通过 --no-ff (no fast forward) 来强制生成 merge commit。推荐使用 merge 时加上 --no-ff 这个参数。 git merge \u003cbranch\u003e 通常是 main/master 这类主分支合并其它分支： git checkout main/master git merge \u003cbranch\u003e ","date":"2023-12-27","objectID":"/posts/git-learn/:5:4","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Resolve Conflict Manually resolve: Check every codes between \u003c\u003c\u003c\u003c\u003c\u003c\u003c, \u003e\u003e\u003e\u003e\u003e\u003e\u003e Edit code to what it should be Use mergetool like vimdiff: It shows: local, base, remote, file to be edited Edit “file ro be edited” to what is should be Add and Commit # 1. 合并分支 git merge \u003cbranch\u003e # 2. 检查状态，查看 unmerged 的文件 git status # 3. 编辑 unmerged 文件，编辑冲突区域代码即可 vim \u003cfile\u003e # 4. 添加解决完冲突的文件 git add \u003cfile\u003e # 5. 进行 merge commit git commit 冲突区域就是 \u003c\u003c\u003c\u003c\u003c\u003c\u003c 和 \u003e\u003e\u003e\u003e\u003e\u003e\u003e 内的区域，在 merge 操作后，Git 已经帮我们把 unmerged 文件修改为待解决冲突的状态，直接编辑文件即可。在编辑完成后，需要手动进行 add 和 commit，此次 commit 的信息 Git 已经帮我们写好了，一般不需要修改。 如果使用的是 mergetool，以 vimdiff 为例，只需将第 3 步的 vim \u003cfile\u003e 改为 git mergetool 即可。vimdiff 会提供 4 个视窗：底部视窗是我们的编辑区，顶部左边是当前合并分支的状态，顶部中间是 base (合并分支和被合并的共同父节点) 的状态，顶部右边是 remote 的状态，按需要选择、编辑。 vimdiff 在编辑完后会保留 *.orig 的文件，这个文件是待解决冲突的文件副本。 ","date":"2023-12-27","objectID":"/posts/git-learn/:5:5","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Merge Conflict Prevent very long development branch. Split source code clearly. ","date":"2023-12-27","objectID":"/posts/git-learn/:5:6","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Git","Linux Kernel Internals"],"content":"Rebase 注意 ✅ 观看影片 Git 教学系列 - Branch and Merge，掌握 TODO 的方法。git rebase 是 Git 的精华，可以让我们实现更细粒度的操作，可以说学会了 rebase 才算真正入门了 Git。 这个视频讲得比较乱，所以推荐配合视频给出的参考文章 Git-rebase 小笔记 来学习。 ","date":"2023-12-27","objectID":"/posts/git-learn/:6:0","tags":["Git/GitHub"],"title":"Git 学习记录","uri":"/posts/git-learn/"},{"categories":["Linux Distribution"],"content":"网络代理 根据项目 clash-for-linux-backup 来配置 Ubuntu 的网络代理。 $ git clone https://github.com/Elegybackup/clash-for-linux-backup.git clash-for-linux 过程当中可能需要安装 curl 和 net-tools，根据提示进行安装即可： sudo apt install curl sudo apt install net-tools 安装并启动完成后，可以通过 localhost:9090/ui 来访问 Dashboard。 启动代理： $ cd clash-for-linux $ sudo bash start.sh $ source /etc/profile.d/clash.sh $ proxy_on 关闭代理： $ cd clash-for-linux $ sudo bash shutdown.sh $ proxy_off ","date":"2023-12-27","objectID":"/posts/ubuntu22.04lts/:1:0","tags":["Linux","Ubuntu"],"title":"Ubuntu 22.04LTS 相关配置","uri":"/posts/ubuntu22.04lts/"},{"categories":["Linux Distribution"],"content":"搜狗输入法 根据 搜狗输入法 Linux 安装指导 来安装搜狗输入法。 无需卸载系统 ibus 输入法框架。 通过 Ctrl + space 唤醒搜狗输入法。 ","date":"2023-12-27","objectID":"/posts/ubuntu22.04lts/:2:0","tags":["Linux","Ubuntu"],"title":"Ubuntu 22.04LTS 相关配置","uri":"/posts/ubuntu22.04lts/"},{"categories":["Linux Distribution"],"content":"快捷键 新建终端： Ctrl + Alt + T 锁屏： Super + L：锁定屏幕并熄屏。 显示桌面： Super + d 或者 Ctrl + Alt + d 最小化所有运行的窗口并显示桌面，再次键入则重新打开之前的窗口。 显示所有的应用程序： Super + a 可以通过 ESC 来退出该显示。 显示当前运行的所有应用程序： Super 移动窗口位置： Super + 左箭头：当前窗口移动到屏幕左半边区域 Super + 右箭头：当前窗口移动到屏幕右半边区域 Super + 上箭头：当前窗口最大化 Super + 下箭头：当前窗口恢复正常 隐藏当前窗口到任务栏： Super + h 切换当前的应用程序： Super + Tab：以应用程序为粒度显示切换选项 Alt + Tab：以窗口为粒度显示切换选项 切换虚拟桌面/工作区： Ctrl + Alt + 左/右方向键 自定义键盘快捷键： Settings -\u003e Keyboard -\u003e Keyboard Shortcus | View and Customize Shortcuts -\u003e Custom Shortcuts ","date":"2023-12-27","objectID":"/posts/ubuntu22.04lts/:3:0","tags":["Linux","Ubuntu"],"title":"Ubuntu 22.04LTS 相关配置","uri":"/posts/ubuntu22.04lts/"},{"categories":["Linux Kernel Internals"],"content":" 摘要 GNU/Linux 开发工具，几乎从硬件到软件，Linux 平台能够自下而上提供各类触及“灵魂”的学习案例，让所有课程从纸上谈兵转变成沙场实战，会极大地提升工程实践的效率和技能。 原文地址 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:0:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"安装 Windows / Ubuntu 双系统 因为有些操作必须在物理硬件上才能执行。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:1:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Markdown 与 LaTeX 速览 LaTeX 语法示例一节，作为工具书册，在需要使用时知道如何查询。 速览 Markdown 语法示例一节，作为工具书册，在需要使用时知道如何查询。 注意 编写 Markdown 文本以及 LaTeX 语法表示的数学式可以通过： Hugo + FixIt ✅ VS Code + Markdown Preview Enhanced ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:2:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Git 和 Github 阅读 SSH key 产生方法一节，配置好 Git 和 Github 的 SSH key。同时也可作为工具书册，在需要使用时知道如何查询。 推荐通过 LearnGitBranching 来熟悉 Git 命令！！！ 以下资源作为自学资源，用于补充自己不熟悉的操作，或者作为以上资料的补充工具手册。 Git 中文教学 - YouTube (学习记录) 30 天精通 Git 版本控制 - GitHub 警告 原文档中的将公钥复制到 clipboard 中使用了 clip 命令，但是这个命令在 Ubuntu 中并没有对应的命令。可以使用 xclip + alias 达到近似效果。 $ sudo apt install xclip # using alias to implement clip, you can add this to bashrc $ alias='xclip -sel c' ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:3:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"编辑器: Visual Studio Code 认真阅读，跟随教学文档进行安装、设置。重点阅读 设定、除错（调试） 这两部分。更新 VS Code 部分作为手册，在需要时进行参考。 以下资源作为自学资源，用于补充自己不熟悉的操作，或者作为以上资料的补充工具手册。 开开心心学 Vistual Studio Code 完成 SSH key 的生成。 完成 VS Code 的设置。 安装 Git History 插件。 安装 Native Debug 插件，并进行 Debug (test-stopwatch.c) 操作。 安装 VSCode Great Icons 文件图标主题，另外推荐两款颜色主题：One Dark Pro, Learn with Sumit。 VS Code 控制台使用说明： 可以在面板的输出，点击 GIT 选项显示 VS Code 背后执行的 git 命令。 可以使用 ctrl + shift + P 呼出命令区，然后通过输入 Git branch 和 Git checkout 等并选择对应选项，来达到创建分支、切换分支等功能。 技巧 在 VS Code 设置中，需要在设置中打开 Open Default Settings 选项才能在左侧面板观察到预设值。键位绑定同理。 要想进行调试，需要在使用 gcc 生成目标文件时，加入 -g 参数来生产调试信息。 原文档中的 GDB 教学链接-除错程式-gdb 已失效，这是目前的有效链接。也可通过该影片 拯救资工系学生的基本素养-使用 GDB 除错基本教学 来补充学习 GDB 的操作。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:4:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"终端和 Vim 认真阅读，跟随教学影片 快快乐乐学 Vim 和教学文档配置好 终端提示符、Vim。 完成命令行提示符配置 完成 Vim 的设定 安装并使用 Minial Vim Plugin Manager 来管理 Vim 插件 (neocomplcache, nerdtree) 安装并使用 byobu 来管理多个终端视图。 技巧 在 .vimrc 中增加插件后，打开 vim，执行 :PlugInstall 来安装插件，完成后在 vim 执行 :source ~/.vimrc。（可以通过 :PlugStatus 来查看插件安装状态） 使用 F4 键来[显示/不显示][行数/相对行数]。 使用 F5 键来呼入/呼出文件树(nerdtree)，在文件树恻通过 ENTER 键来访问目录/文件。 使用 Ctrl-w-h/Ctrl-w-l 切换到 文件树/编辑区。 自动补全时使用 ENTER 键来选中，使用方向键或 Ctrl-N/Ctrl-U/Ctrl-P 来上下选择。 在 Vim 中可以通过 :set paste，并在 insert 模式下，将粘贴板的内容通过 Ctrl-Shift-V 进行粘贴。 byobu 使用说明： 在终端输入 byobu F2 新增 Terminial 分页。F3, F4 在 Terminial 分页中切换。Ctrl +F6 删除当前 Terminial 分页。 Shift + F2 水平切割 Terminial。Ctrl +F2 垂直切割 Terminial。Shift + 方向键 切换。 在 byobu 中暂时无法使用之前设置的 F4 或 F5 快捷键，但是可以直接通过命令 :set norelative 来关闭相对行数。 推荐观看影片 How to Do 90% of What Plugins Do (With Just Vim) 来扩展 Vim 插件的使用姿势。 以下资源为 Cheat Sheet，需要使用时回来参考即可。 Vim Cheat Sheet Bash terminal Cheat Sheet ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:5:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Makefile 速览教学文档，作为工具书册，在需要使用时知道如何查询。 gcc 的 -MMD 和 -MF 参数对我们编写 Makefile 是一个巨大利器。理解 Makefile 的各种变量定义的原理。 对之前的 test-stopwatch.c 编写了一个 Makefile 来自动化管理。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:6:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Linux 性能分析工具: Perf 认真阅读，复现教学文档中的所有例子，初步体验 perf 在性能分析上的强大。 安装 perf 并将 kernel.perf_event_paranoid 设置为 1。 动手使用 perf_top_example.c，体验 perf 的作用。 搭配影片: Branch Prediction 对照阅读: Fast and slow if-statements: branch prediction in modern processors 编译器提供的辅助机制: Branch Patterns, Using GCC 动手使用 perf_top_while.c，体验 perf top 的作用。 动手使用 perf_stat_cache_miss.c，体验 perf stat 的作用。（原文的结果有些不直观，务必亲自动手验证） 动手使用 perf_record_example.c，体验 perf record 的作用。（原文的操作不是很详细，可以参考下面的 Success） Source 成功 $ perf record -e branch-misses:u,branch-instructions:u ./perf_record_example [ perf record: Woken up 1 times to write data ] [ perf record: Captured and wrote 0.009 MB perf.data (94 samples) ] 输出第一行表示 perf 工具在收集性能数据时被唤醒了 1 次，以将数据写入输出文件。 输出第二行表示 perf 工具已经取样并写入了一个名为 perf.data 的二进制文件，文件大小为 0.009 MB，其中包含了 94 个采样。（可以通过 ls 命令来检查 perf.data 文件是否存在） 接下来通过 perf report 对之前输出的二进制文件 perf.data 进行分析。可以通过方向键选择，并通过 ENTER 进入下一层查看分析结果。 $ perf report Available samples 5 branch-misses:u 89 branch-instructions:u 技巧 perf 需要在 root 下进行性能分析。 perf top 是对于哪个程序是性能瓶颈没有头绪时使用，可以查看哪个程序（以及程序的哪个部分）是热度点。 在 perf top 时可以通过 h 键呼出帮助列表。 可以通过方向键选择需要进一步分析的部分，并通过 a 键来查看指令级别粒度的热点。 perf stat 是对某一个要优化的程序进行性能分析，对该程序涉及的一系列 events 进行取样检查。 perf record 的精度比 perf stat 更高，可以对取样的 events 进行函数粒度的分析。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:7:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Linux Kernel Internals"],"content":"Linux 绘图工具: gnuplot 阅读教程，搭配教学影片 轻轻松松学 gnuplot，使用 gnuplot 完成所给例子相应图像的绘制。 使用 runtime.gp 完成 runtime.png 的绘制生成。 使用 statistic.gp 完成降雨量折线图 statistic.png 的绘制生成。 注意 原文所给的 statistic.gp 是使用 Times_New_Roman 来显示中文的，但笔者的 Ubuntu 中并没有这个字体，所以会显示乱码。可以通过 fc-list :lang=zh 命令来查询当前系统中的已安装的中文字体。 Source 安装 gnuplot: $ sudo apt-get install gnuplot gnuplot script 的使用流程： # 创建并编写一个后缀名为 .gp 的文件 $ vim script.gp # 根据 script 内的指令进行绘图 $ gnuplot script.gp # 根据 script 指定的图片保存路径打开图片 $ eog [name of picture] 下面以一个 script 进行常用指令的说明： reset set ylabel 'time(sec)' set style fill solid set title 'performance comparison' set term png enhanced font 'Verdana,10' set output 'runtime.png' plot [:][:0.100]'output.txt' using 2:xtic(1) with histogram title 'original', \\ '' using ($0-0.06):($2+0.001):2 with labels title ' ', \\ '' using 3:xtic(1) with histogram title 'optimized' , \\ '' using 4:xtic(1) with histogram title 'hash' , \\ '' using ($0+0.3):($3+0.0015):3 with labels title ' ', \\ '' using ($0+0.4):($4+0.0015):4 with labels title ' ' reset 指令的作用为，将之前 set 指令设置过的内容全部重置。 set style fill solid 将绘制出的柱形或区域使用实心方式填充。 set term png enhanced font 'Verdana,10' term png 生成的图像以 png 格式进行保存。(term 是 terminial 的缩写) enhanced 启用增强文本模式，允许在标签和注释中使用特殊的文本格式，如上下标、斜体、下划线等。 font 'Verdana,10' 指定所使用的字体为 Verdana，字号为10。可进行自定义设置。 其它指令查询原文或手册即可。 $0 在 gnuplot 中表示伪列，可以简单理解为行号，以下为相应图示： 原始数据集： append() 0.048240 0.040298 0.057908 findName() 0.006495 0.002938 0.000001 （人为）增加了 伪列 表示的数据集（最左边 0, 1 即为伪列）： 0 append() 0.048240 0.040298 0.057908 1 findName() 0.006495 0.002938 0.000001 技巧 gnuplot 在绘制生成图像时是安装指令的顺序进行的，并且和一般的画图软件类似，在最上层进行绘制。所以在编写 script 的指令时需要注意顺序，否则生成图像的部分可能并不像预期一样位于最上层。（思考上面 script 的 3, 4 列的 label 的绘制顺序） gnuplot script 中的字符串可以使用 '' 或者 \"\" 来包裹，同样类似于 Python。 直接在终端输入 gnuplot 会进入交互式的命令界面，也可以使用 gnulpot 指令来绘图（类似与 Python）。在这种交互式界面环境中，如果需要在输入完指令后立即显示图像到新窗口，而不是保存图像再打开，只需输入进行指令： set term wxt ehanced persist raise term wxt 将图形终端类型设置为WXT，这会在新窗口中显示绘图。 ersist 该选项使绘图窗口保持打开状态，即使脚本执行完毕也不会自动关闭。 raise 该选项将绘图窗口置于其他窗口的前面，以确保它在屏幕上的可见性。 一些额外的教程： Youtube - gnuplot Tutorlal 这个教程有五部影片，到发布者的主页搜寻即可。 ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:8:0","tags":["Sysprog"],"title":"GNU/Linux 开发工具","uri":"/posts/gnu-linux-dev/"},{"categories":["Mathematics"],"content":" 中大數學系開放式課程 台大齐震宇 - 数学潜水艇、微积分、分析 台大谢铭伦 - 线性代数 ","date":"2023-12-23","objectID":"/posts/math/:0:0","tags":["Mathematics"],"title":"数学开放式课程学习指引","uri":"/posts/math/"},{"categories":["Mathematics"],"content":"概率统计 阳明交通大学 陈临安老师，开设了两学期的统计课程，分别是上学期的 统计学 和下学期的 高等统计学。 课程名称 英文名称 课程地址 课程视频 统计学 Statistics 课程资讯 YouTube 高等统计学 Advanced Statistics 课程资讯 YouTube 信息 这两个学期课程的作业、习题以及解答都可以在 这里 找到。 ","date":"2023-12-23","objectID":"/posts/math/:1:0","tags":["Mathematics"],"title":"数学开放式课程学习指引","uri":"/posts/math/"},{"categories":["draft"],"content":"博客（英语：Blog）是一种在线日记型式的个人网站，借由张帖子章、图片或视频来记录生活、抒发情感或分享信息。博客上的文章通常根据张贴时间，以倒序方式由新到旧排列。 ","date":"2023-12-23","objectID":"/posts/hello_world/:0:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"数学公式 行内公式：$N(b,d)=(b-1)M$ 公式块： $$ \\int_{a}^{b}x(t)dt = \\dfrac{b - a}{N} \\\\ =\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} $$ $$ \\begin{aligned} \\int_{a}^{b}x(t)dt \u0026= \\dfrac{b - a}{N} \\\\ \u0026=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} \\\\ \\end{aligned} $$ $$ \\mathrm{Integrals\\ are\\ numerically\\ approximated\\ as\\ finite\\ series}:\\\\ \\begin{split} \\int_{a}^{b}x(t)dt \u0026= \\dfrac{b - a}{N} \\\\ \u0026=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} \\end{split} \\\\ where\\ t_k = a + (b-a)\\cdot k/N $$ $$ \\begin{align*} p(x) = 3x^6 + 14x^5y \u0026+ 590x^4y^2 + 19x^3y^3 \\\\ \u0026- 12x^2y^4 - 12xy^5 + 2y^6 - a^3b^3 - a^2b - ab + c^5d^3 + c^4d^3 - cd \\end{align*} $$ $$ \\begin{split} \u0026(X \\in B) = X^{-1}(B) = {s \\in S: X(s) \\in B} \\subset S \\\\ \u0026\\Rightarrow P(x \\in B) = P({s \\in S: X(s) \\in B}) \\end{split} $$ ","date":"2023-12-23","objectID":"/posts/hello_world/:1:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"代码块 let i: i32 = 13; let v = vec![1, 2, 3, 4, 5, 65]; for x in v.iter() { println!(\"{}\", x); } typedef struct Block_t { int head; int data; } Block_t; ","date":"2023-12-23","objectID":"/posts/hello_world/:2:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"Admonition 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 ","date":"2023-12-23","objectID":"/posts/hello_world/:3:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"References FixIt 快速上手 使用 Hugo + Github 搭建个人博客 Emoji 支持 扩展 Shortcodes 概述 URL management ","date":"2023-12-23","objectID":"/posts/hello_world/:4:0","tags":["draft"],"title":"Hello, World","uri":"/posts/hello_world/"}]