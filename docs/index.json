[{"categories":["Linux Kernel Internals"],"content":" åœ¨ã€ŒLinux æ ¸å¿ƒè®¾è®¡/å®ä½œã€Spring 2023 è¯¾ç¨‹è¿›åº¦é¡µé¢çš„åŸå§‹æ¡£æ¡ˆçš„åŸºç¡€ä¸Šï¼Œç¨ä½œä¿®æ”¹ä»¥è®°å½•æˆ‘çš„å­¦ä¹ è¿›åº¦ åŸå§‹é¡µé¢ / PDF æˆåŠŸ å¦‚æœä½ å­¦ä¹ æ—¶æ„Ÿåˆ°æŒ«æŠ˜ï¼Œæ„Ÿåˆ°è¿›åº¦æ¨è¿›å¾ˆæ…¢ï¼Œè¿™å¾ˆæ­£å¸¸ï¼Œå› ä¸º Jserv çš„ä¸€ä¸ªè®²åº§ï¼Œéœ€è¦æˆ‘ä»¬èŠ±è´¹ä¸€ä¸ªæ˜ŸæœŸå»æ¶ˆåŒ– ğŸ¤£ å¹¶ä¸” Jserv ä¹Ÿæåˆ°å‰ 6 å‘¨è¯¾ç¨‹çš„å¯†åº¦æ˜¯æ¯”è¾ƒå¤§çš„ æ‰€ä»¥æ²¡å¿…è¦ä¸ºæ­¤ç„¦è™‘ï¼Œå¦‚æœä½ è§‰å¾—æŸä¸ªå†…å®¹ä¸å¤ªç†è§£ï¼Œå¯ä»¥å°è¯•å…ˆå»çœ‹å…¶ä»–è®²åº§ï¼Œå°†åŸå…ˆä¸æ‡‚çš„çŸ¥è¯†äº¤ç»™å¤§è„‘éšå¼æ¶ˆåŒ–ï¼Œè¿‡æ®µæ—¶é—´å†å›æ¥çœ‹ï¼Œä½ çš„ç†è§£ä¼šå¤§æœ‰ä¸åŒã€‚ Instructor: Jim Huang (é»ƒæ•¬ç¾¤) \u003cjserv.tw@gmail.com\u003e å¾€å¹´èª²ç¨‹é€²åº¦ Linux æ ¸å¿ƒè¨­è¨ˆ (ç·šä¸Šè¬›åº§) æ³¨æ„: ä¸‹æ–¹èª²ç¨‹é€²åº¦è¡¨æ¨™è¨»æœ‰ * çš„é …ç›®ï¼Œè¡¨ç¤ºå…§é™„éŒ„å½±çš„æ•™æ æ³¨æ„: æ–°é–‹çš„ã€ŒLinux æ ¸å¿ƒå¯¦ä½œã€èª²ç¨‹å…§å®¹å¹¾ä¹èˆ‡ã€ŒLinux æ ¸å¿ƒè¨­è¨ˆã€ä¸€è‡´ï¼Œæ¡ç·šä¸Šç‚ºä¸»çš„é€²è¡Œæ–¹å¼ ","date":"2024-02-28","objectID":"/posts/linux2023/:0:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡/å®ä½œ (Linux Kernel Internals)","uri":"/posts/linux2023/"},{"categories":["Linux Kernel Internals"],"content":"Linux æ ¸å¿ƒè¨­è¨ˆ/å¯¦ä½œ (Spring 2023) èª²ç¨‹é€²åº¦è¡¨æš¨ç·šä¸Šè³‡æº ","date":"2024-02-28","objectID":"/posts/linux2023/:1:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡/å®ä½œ (Linux Kernel Internals)","uri":"/posts/linux2023/"},{"categories":["Linux Kernel Internals"],"content":"ç¬¬ 1 é€±: èª å¯¦é¢å°è‡ªå·± (Feb 13, 14, 16) æ•™æè§£èªª* (åƒ…æ­¢æ–¼æ¦‚æ³ï¼Œè«‹è©³é–±ä¸‹æ–¹æ•™æåŠå€‹åˆ¥çš„å°æ‡‰è§£èªªéŒ„å½±) èª²ç¨‹ç°¡ä»‹å’Œæ³¨æ„é ˆçŸ¥ / èª²ç¨‹ç°¡ä»‹è§£èªªéŒ„å½±* æ¯é€±å‡å®‰æ’éš¨å ‚æ¸¬é©—ï¼Œæ¡è¨ˆå…¶ä¸­æœ€é«˜åˆ†çš„ 9 æ¬¡ å­¸æœŸè©•åˆ†æ–¹å¼: éš¨å ‚æ¸¬é©— (20%) + å€‹äººä½œæ¥­+å ±å‘ŠåŠå°ˆé¡Œ (30%) + è‡ªæˆ‘è©•åˆ† (50%) æ­·å±†ä¿®èª²å­¸ç”Ÿå¿ƒå¾—: å‘æ™¯äº˜, å¼µå®¶æ¦®, è•­å¥•å‡±, æ–¹éˆºå­¸ åˆ†çµ„å ±å‘Šç¤ºç¯„: ARM-Linux, Xvisor GNU/Linux é–‹ç™¼å·¥å…·å…±ç­†*: å‹™å¿… è‡ªä¸» å­¸ç¿’ Linux æ“ä½œ, Git, HackMD, LaTeX èªæ³• (ç‰¹åˆ¥æ˜¯æ•¸å­¸å¼), GNU make, perf, gnuplot ç¢ºèª Ubuntu Linux 22.04-LTS (æˆ–æ›´æ–°çš„ç‰ˆæœ¬) å·²é †åˆ©å®‰è£åˆ°ä½ çš„é›»è…¦ä¸­ é€é Computer Systems: A Programmerâ€™s Perspective å­¸ç¿’ç³»çµ±è»Ÿé«”*: æœ¬èª²ç¨‹æŒ‡å®šçš„æ•™ç§‘æ›¸ (è«‹åŠæ—©è³¼è²·: å¤©ç“æ›¸åº—) è»Ÿé«”ç¼ºå¤±å°è‡´çš„å±å®³ 1970 å¹´ä»£æ¨å‡ºçš„é¦–æ¬¾å»£é«”æ°‘èˆªå®¢æ©Ÿæ³¢éŸ³ 747 è»Ÿé«”ç”±å¤§ç´„ 40 è¬è¡Œç¨‹å¼ç¢¼æ§‹æˆï¼Œè€Œ 2011 å¹´å¼•é€²çš„æ³¢éŸ³ 787 çš„è»Ÿé«”è¦æ¨¡å‰‡æ˜¯æ³¢éŸ³ 747 çš„ 16 å€ï¼Œç´„ 650 è¬è¡Œç¨‹å¼ç¢¼ã€‚æ›è¨€ä¹‹ï¼Œä½ æˆ‘çš„æ€§å‘½ç·Šç¹«æ–¼ä¸€ç³»åˆ—æ¥µç‚ºè¤‡é›œçš„è»Ÿé«”ç³»çµ±ä¹‹ä¸­ï¼Œèƒ½ä¸èŠ±é»æ™‚é–“äº†è§£å—ï¼Ÿ è»Ÿé«”é–‹ç™¼çš„å®‰å…¨æ€§è¨­è¨ˆå’Œæ¸¬è©¦é©—è­‰æ‡‰ç²å¾—æ›´é«˜çš„é‡è¦– The adoption of Rust in Business (2022) æ­é…è§€çœ‹çŸ­ç‰‡: Rust in 100 Seconds è§£è®€è¨ˆç®—æ©Ÿç·¨ç¢¼ äººå€‘å°æ•¸å­¸çš„åŠ æ¸›é‹ç®—å¯è¼•æ˜“åœ¨è…¦ä¸­è¾¨è­˜ç¬¦è™Ÿä¸¦ç†è§£å…¶çµæœï¼Œä½†é›»è…¦åšä»»ä½•äº‹éƒ½å—é™æ–¼å¯¦é«”è³‡æ–™å„²å­˜åŠæ“ä½œæ–¹å¼ï¼Œæ›è¨€ä¹‹ï¼Œé›»è…¦ç¡¬é«”å¯¦éš›åªèªå¾— 0 å’Œ 1ï¼Œå»ä¸çŸ¥é“ç¬¦è™Ÿ + å’Œ - åœ¨æ•¸å­¸åŠæ‡‰ç”¨å ´åŸŸçš„æ„ç¾©ï¼Œæ–¼æ˜¯å·¥ç¨‹äººå“¡å¼•å…¥ã€Œè£œæ•¸ã€ä»¥è¡¨é”äººå€‘èªçŸ¥ä¸Šçš„æ­£è² æ•¸ æ‚¨æœ‰æ²’æœ‰æƒ³éï¼Œç‚ºä½•ã€ŒäºŒè£œæ•¸ã€(2â€™s complement) è¢«é›»è…¦å»£æ³›æ¡ç”¨å‘¢ï¼ŸèƒŒå¾Œçš„è¨­è¨ˆè€ƒé‡æ˜¯ä»€éº¼ï¼Ÿæœ¬æ–‡å˜—è©¦å¾æ•¸å­¸è§€é»å»è§£è®€ç·¨ç¢¼èƒŒå¾Œçš„åŸç† ä½ æ‰€ä¸çŸ¥é“çš„ C èªè¨€ï¼šæŒ‡æ¨™ç¯‡* linked list å’Œéé€£çºŒè¨˜æ†¶é«”æ“ä½œ* å®‰æ’ linked list ä½œç‚ºç¬¬ä¸€ä»½ä½œæ¥­åŠéš¨å ‚æ¸¬é©—çš„è€ƒé‡é»: æª¢é©—å­¸å“¡å°æ–¼ C èªè¨€æŒ‡æ¨™æ“ä½œçš„ç†Ÿæ‚‰ç¨‹åº¦ (é™„å¸¶æ€è€ƒï¼šå°æ–¼ Java ç¨‹å¼èªè¨€ä¾†èªªï¼Œè©²å¦‚ä½•å¯¦ä½œ linked list å‘¢ï¼Ÿ) linked list æœ¬è³ªä¸Šå°±æ˜¯å°éé€£çºŒè¨˜æ†¶é«”çš„æ“ä½œï¼Œä¹çœ‹åƒ…æ˜¯ä¸€ç¨®å–®ç´”çš„è³‡æ–™çµæ§‹ï¼Œä½†å°æ‡‰çš„æ¼”ç®—æ³•è®ŠåŒ–å¤šç«¯ï¼Œåƒæ˜¯ã€Œå¦‚ä½•åµæ¸¬ linked list æ˜¯å¦å­˜åœ¨ç’°ç‹€çµæ§‹ï¼Ÿã€å’Œã€Œå¦‚ä½•å° linked list æ’åºä¸¦ç¢ºä¿ç©ºé–“è¤‡é›œåº¦ç‚º O(1) å‘¢ï¼Ÿã€ linked list çš„æ“ä½œï¼Œä¾‹å¦‚èµ°è¨ª (traverse) æ‰€æœ‰ç¯€é»ï¼Œåæ˜ å‡º Locality of reference (cache ç”¨èª) çš„è¡¨ç¾å’Œè¨˜æ†¶é«”éšå±¤æ¶æ§‹ (memory hierarchy) é«˜åº¦ç›¸é—œï¼Œå­¸å“¡å¾ˆå®¹æ˜“å¾å¯¦é©—å¾—çŸ¥ç³»çµ±çš„è¡Œç‚ºï¼Œå¾è€Œæ€è€ƒå…¶è¡æ“Šå’Œæ•ˆèƒ½æ”¹é€²æ–¹æ¡ˆ ç„¡è«–æ˜¯ä½œæ¥­ç³»çµ±æ ¸å¿ƒã€C èªè¨€å‡½å¼åº«å…§éƒ¨ã€æ‡‰ç”¨ç¨‹å¼æ¡†æ¶ï¼Œåˆ°æ‡‰ç”¨ç¨‹å¼ï¼Œéƒ½ä¸é›£è¦‹åˆ° linked list çš„èº«å½±ï¼ŒåŒ…å«å¤šç¨®é‡å°æ•ˆèƒ½å’Œå®‰å…¨è­°é¡Œæ‰€åšçš„ linked list è®Šå½¢ï¼Œåˆé‚„è¦è€ƒæ…®åˆ°æ‡‰ç”¨ç¨‹å¼çš„æ³›ç”¨æ€§ (generic programming)ï¼Œæ˜¯å¾ˆå¥½çš„é€²éšé¡Œæ é¡Œç›® 1 + åˆ†æ* é¡Œç›®2 / åƒè€ƒé¡Œè§£1, åƒè€ƒé¡Œè§£2 é¡Œç›®3 / åƒè€ƒé¡Œè§£ é¡Œç›®4 / åƒè€ƒé¡Œè§£ é¡Œç›®5 / åƒè€ƒé¡Œè§£ ä½³å¥å¶å¾—ï¼šã€Œå¤§éƒ¨åˆ†çš„äººä¸€è¼©å­æ´å¯ŸåŠ›ä¸å½°ï¼ŒåŸå› ä¹‹ä¸€æ˜¯æ€•è¬›éŒ¯è¢«ç¬‘ã€‚æƒ³äº†ä¸€é»é»å°±ä¸æ•¢ç¹¼çºŒä¹Ÿæ²’è¨˜éŒ„æˆ–åˆ†äº«ï¼Œæ™‚é–“éƒ½èŠ±åœ¨è®€æ›¸æŸ¥è³‡æ–™çœ‹åˆ¥äººæ€éº¼æƒ³ã€‚çœ‹å®Œå°±çœŸçš„æ²’æœ‰è‡ªå·±çš„æ´å¯Ÿäº†ã€(å‡ºè™•) ä½œæ¥­: æˆªæ­¢ç¹³äº¤æ—¥: Feb 28, 2023 lab0* quiz1 ç¬¬ 1 é€±éš¨å ‚æ¸¬é©—: é¡Œç›® (å…§å«ä½œç­”è¡¨å–®) èª²å ‚å•ç­”ç°¡è¨˜ ","date":"2024-02-28","objectID":"/posts/linux2023/:1:1","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡/å®ä½œ (Linux Kernel Internals)","uri":"/posts/linux2023/"},{"categories":["Linux Kernel Internals"],"content":"ç¬¬ 2 é€±: C èªè¨€ç¨‹å¼è¨­è¨ˆ (Feb 20, 21, 23) æ•™æè§£èªª* (åƒ…æ­¢æ–¼æ¦‚æ³ï¼Œè«‹è©³é–±ä¸‹æ–¹æ•™æåŠå€‹åˆ¥çš„å°æ‡‰è§£èªªéŒ„å½±) Linux v6.2 ç™¼å¸ƒ: æ¥ä¸‹ä¾†æœƒæ˜¯è®“å­¸å“¡çœ¼èŠ±æ’©äº‚çš„ä¸»ç‰ˆè™Ÿ/æ¬¡ç‰ˆè™Ÿçš„é£›å¿«è·³èº / kernel.org Linux: ä½œæ¥­ç³»çµ±è¡“èªåŠæ¦‚å¿µ* ç³»çµ±è»Ÿé«”é–‹ç™¼æ€ç¶­ C èªè¨€: æ•¸å€¼ç³»çµ±* å„˜ç®¡æ•¸å€¼ç³»çµ±ä¸¦é C èªè¨€æ‰€ç‰¹æœ‰ï¼Œä½†åœ¨ Linux æ ¸å¿ƒå¤§é‡å­˜åœ¨ u8/u16/u32/u64 é€™æ¨£é€é typedef æ‰€å®šç¾©çš„å‹æ…‹ï¼Œä¼´éš¨è‘—å„å¼ alignment å­˜å–ï¼Œè‹¥å­¸å“¡å°æ•¸å€¼ç³»çµ±çš„èªçŸ¥ä¸å¤ å……åˆ†ï¼Œå¯èƒ½ç«‹å³å°±è¢«é˜»æ“‹åœ¨æ¢ç´¢ Linux æ ¸å¿ƒä¹‹å¤– â€”â€” ç•¢ç«Ÿä½ å®Œå…¨æä¸æ¸…æ¥šï¼Œç‚ºä½•åœ¨ Linux æ ¸å¿ƒå­˜å–ç‰¹å®šè³‡æ–™éœ€è¦ç¹ä¸€å¤§åœˆã€‚ C èªè¨€: Bitwise æ“ä½œ* Linux æ ¸å¿ƒåŸå§‹ç¨‹å¼ç¢¼å­˜åœ¨å¤§é‡ bit(-wise) operations (ç°¡ç¨± bitops)ï¼Œé —å¤šä¹çœ‹åƒæ˜¯é­”æ³•çš„ C ç¨‹å¼ç¢¼å°±æ˜¯ bitops çš„çµ„åˆ é¡ç¥ç¶“ç¶²è·¯çš„ ReLU åŠå…¶å¸¸æ•¸æ™‚é–“è¤‡é›œåº¦å¯¦ä½œ å¾ âˆš2 çš„å­˜åœ¨è«‡é–‹å¹³æ–¹æ ¹çš„å¿«é€Ÿé‹ç®— Linux æ ¸å¿ƒçš„ hash table å¯¦ä½œ ç‚ºä»€éº¼è¦æ·±å…¥å­¸ç¿’ C èªè¨€ï¼Ÿ* C èªè¨€ç™¼æ˜è€… Dennis M. Ritchie èªªï¼šã€ŒC å¾ˆå½†æ‰­åˆç¼ºé™·é‡é‡ï¼Œå»ç•°å¸¸æˆåŠŸã€‚å›ºç„¶æœ‰æ­·å²çš„å·§åˆæ¨æ³¢åŠ©ç€¾ï¼Œå¯ä¹Ÿçš„ç¢ºæ˜¯å› ç‚ºå®ƒèƒ½æ»¿è¶³æ–¼ç³»çµ±è»Ÿé«”å¯¦ä½œçš„ç¨‹å¼èªè¨€æœŸå¾…ï¼šæ—¢æœ‰ç›¸ç•¶çš„æ•ˆç‡ä¾†å–ä»£çµ„åˆèªè¨€ï¼Œåˆå¯å……åˆ†é”åˆ°æŠ½è±¡ä¸”æµæš¢ï¼Œèƒ½ç”¨æ–¼æè¿°åœ¨å¤šæ¨£ç’°å¢ƒçš„æ¼”ç®—æ³•ã€‚ã€ Linux æ ¸å¿ƒä½œç‚ºä¸–ç•Œä¸Šæœ€æˆåŠŸçš„é–‹æ”¾åŸå§‹ç¢¼è¨ˆç•«ï¼Œä¹Ÿæ˜¯ C èªè¨€åœ¨å·¥ç¨‹é ˜åŸŸçš„ç‘°å¯¶ï¼Œè£¡é ­å……æ–¥å„å¼ã€Œè—è¡“ã€ï¼Œå¾€å¾€æœƒåš‡åˆ°åˆæ¬¡æ¥è§¸çš„äººå€‘ï¼Œä½†ç¸½æ˜¯èƒ½å¤ ç”¨ C èªè¨€æ¨™æº–å’Œé–‹ç™¼å·¥å…·æä¾›çš„æ“´å±• (ä¸»è¦ä¾†è‡ª gcc çš„ GNU extensions) ä¾†è§£é‡‹ã€‚ åŸºæ–¼ C èªè¨€æ¨™æº–ç ”ç©¶èˆ‡ç³»çµ±ç¨‹å¼å®‰å…¨è­°é¡Œ è—‰ç”±ç ”è®€æ¼æ´ç¨‹å¼ç¢¼åŠ C èªè¨€æ¨™æº–ï¼Œè¨è«–ç³»çµ±ç¨‹å¼çš„å®‰å…¨è­°é¡Œ é€éé™¤éŒ¯å™¨è¿½è¹¤ç¨‹å¼ç¢¼å¯¦éš›é‹è¡Œçš„ç‹€æ³ï¼Œäº†è§£å…¶é‹ä½œåŸç†; å–æè‡ª dangling pointer, CWE-416 Use After Free, CVE-2017-16943 ä»¥åŠ integer overflow çš„è­°é¡Œ; C èªè¨€ï¼šè¨˜æ†¶é«”ç®¡ç†ã€å°é½ŠåŠç¡¬é«”ç‰¹æ€§* æ­é…é–±è®€: The Lost Art of Structure Packing å¾è™›æ“¬è¨˜æ†¶é«”è«‡èµ·ï¼Œæ­¸ç´å‡ºç¾ä»£éŠ€è¡Œå’Œè™›æ“¬è¨˜æ†¶é«”å…©è€…é«˜åº¦ç›¸ä¼¼: malloc çµ¦å‡º valid pointer ä¸è¦å¤ªé«˜èˆˆï¼Œç­‰ä½ è¦é–‹å§‹ç”¨çš„æ™‚å€™æä¸å¥½ä½œæ¥­ç³»çµ±çµ¦å€‹ OOM â€”â€”ç°¡å–®ä¾†èªªå°±æ˜¯ä¸€å¼µæ”¯ç¥¨ï¼Œèƒ½ä¸èƒ½æ‹¿ä¾†é–‹ç­‰åˆ°å…Œç¾æ‰çŸ¥é“ã€‚ æ¢è¨ heap (å‹•æ…‹é…ç½®ç”¢ç”Ÿï¼Œç³»çµ±æœƒå­˜æ”¾åœ¨å¦å¤–ä¸€å¡Šç©ºé–“)ã€data alignmentï¼Œå’Œ malloc å¯¦ä½œæ©Ÿåˆ¶ç­‰è­°é¡Œã€‚é€™äº›éƒ½æ˜¯ç†è§£ Linux æ ¸å¿ƒé‹ä½œçš„é—œéµæ¦‚å¿µã€‚ C èªè¨€: bit-field bit field æ˜¯ C èªè¨€ä¸€å€‹å¾ˆè¢«å¿½ç•¥çš„ç‰¹å¾µï¼Œä½†åœ¨ Linux å’Œ gcc é€™é¡ç³»çµ±è»Ÿé«”å¾ˆå¸¸å‡ºç¾ï¼Œä¸åƒ…æ˜¯ç²¾æº–è¦ç¯„æ¯å€‹ bit çš„ä½œç”¨ï¼Œç”šè‡³ç”¨ä¾†ã€Œæ“´å……ã€C èªè¨€ åƒè€ƒé¡Œç›® / åƒè€ƒé¡Œç›®* / åƒè€ƒé¡Œè§£ 1, åƒè€ƒé¡Œè§£ 2, åƒè€ƒé¡Œè§£ 3 ä½œæ¥­: æˆªæ­¢ç¹³äº¤æ—¥ Mar 7 quiz2 ç¬¬ 2 é€±éš¨å ‚æ¸¬é©—: é¡Œç›® (å…§å«ä½œç­”è¡¨å–®) èª²å ‚å•ç­”ç°¡è¨˜ ","date":"2024-02-28","objectID":"/posts/linux2023/:1:2","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡/å®ä½œ (Linux Kernel Internals)","uri":"/posts/linux2023/"},{"categories":["Linux Kernel Internals"],"content":"ç¬¬ 3 é€±: ä¸¦è¡Œå’Œ C èªè¨€ç¨‹å¼è¨­è¨ˆ (Feb 27, 28, Mar 2) æ•™æè§£èªª* (åƒ…æ­¢æ–¼æ¦‚æ³ï¼Œè«‹è©³é–±ä¸‹æ–¹æ•™æåŠå€‹åˆ¥çš„å°æ‡‰è§£èªªéŒ„å½±) å…¬å‘Š 2 æœˆ 28 æ—¥æ²’æœ‰å¯¦é«”èª²ç¨‹ï¼Œä½†å®‰æ’ç·šä¸Šæ¸¬é©— (ã€ŒLinux æ ¸å¿ƒè¨­è¨ˆã€èª²ç¨‹çš„å­¸å“¡å‹™å¿…åƒåŠ )ï¼Œåœ¨ 15:20-23:59 ä¹‹é–“ä¾æ“š Google Calendar é€²è¡Œä½œç­” ç¬¬äºŒæ¬¡ä½œæ¥­å·²æŒ‡æ´¾ï¼Œå¯åœ¨ 2 æœˆ 28 æ—¥æ™šé–“èµ·é–‹å§‹ç¹³äº¤ï¼Œæˆªæ­¢ç¹³äº¤æ—¥ Mar 7 3 æœˆ 1 æ—¥æ™šé–“å®‰æ’ç¬¬ä¸€æ¬¡ä½œæ¥­çš„æª¢è¨ç›´æ’­ (äº‹å¾Œæœ‰éŒ„å½±)ï¼Œè«‹åƒè¦‹ Google Calendar Linux: ç™¼å±•å‹•æ…‹å›é¡§* å¾ Revolution OS çœ‹ä½œæ¥­ç³»çµ±ç”Ÿæ…‹è®ŠåŒ–* ä¸¦è¡Œå’Œå¤šåŸ·è¡Œç·’ç¨‹å¼è¨­è¨ˆ*: æ‡‰æ¶µè“‹ Part 1 åˆ° Part 4 Part 1: æ¦‚å¿µã€æ‰§è¡Œé¡ºåº Part 2: POSIX Thread Part 3 Part 4 C èªè¨€: å‡½å¼å‘¼å«* è‘—é‡åœ¨è¨ˆç®—æ©Ÿæ¶æ§‹å°æ‡‰çš„æ”¯æ´å’Œè¡Œç‚ºåˆ†æ C èªè¨€: éè¿´å‘¼å«* æˆ–è¨±è·Ÿä½ æƒ³åƒä¸­ä¸åŒï¼ŒLinux æ ¸å¿ƒçš„åŸå§‹ç¨‹å¼ç¢¼è£¡é ­ä¹Ÿç”¨åˆ°éè¿´å‡½å¼å‘¼å«ï¼Œç‰¹åˆ¥åœ¨è¼ƒè¤‡é›œçš„å¯¦ä½œï¼Œä¾‹å¦‚æª”æ¡ˆç³»çµ±ï¼Œå–„ç”¨éè¿´å¯å¤§å¹…ç¸®æ¸›ç¨‹å¼ç¢¼ï¼Œä½†é€™ä¹Ÿå°è‡´è¿½è¹¤ç¨‹å¼é‹ä½œçš„é›£åº¦å¤§å¢ C èªè¨€: å‰ç½®è™•ç†å™¨æ‡‰ç”¨* C èªè¨€ä¹‹æ‰€ä»¥ä¸éœ€è¦æ™‚å¸¸ç™¼ä½ˆæ–°çš„èªè¨€ç‰¹å¾µåˆå¯ä»¥ä¿æŒæ´»åŠ›ï¼Œå‰ç½®è™•ç†å™¨ (preprocessor) æ˜¯å¾ˆé‡è¦çš„å› ç´ ï¼Œæœ‰å¿ƒè€…å¯é€•è¡Œã€Œæ“´å……ã€C èªè¨€ C èªè¨€: goto å’Œæµç¨‹æ§åˆ¶* goto åœ¨ C èªè¨€è¢«æŸäº›äººçœ‹åšæ˜¯å¦–é­”èˆ¬çš„å­˜åœ¨ï¼Œä¸éå¯¦åœ¨ä¸ç”¨é€™æ¨£çœ‹å¾…ï¼Œè‡³å°‘åœ¨ Linux æ ¸å¿ƒåŸå§‹ç¨‹å¼ç¢¼ä¸­ï¼Œgoto æ˜¯å¤§é‡å­˜åœ¨ (è·Ÿä½ æƒ³åƒä¸­ä¸åŒå§)ã€‚æœ‰æ™‚ä¸ç”¨ goto æœƒå¯«å‡ºæ›´å¯æ€•çš„ç¨‹å¼ç¢¼ C èªè¨€ç¨‹å¼è¨­è¨ˆæŠ€å·§* ä½œæ¥­: æˆªæ­¢ç¹³äº¤æ—¥: Mar 21 fibdrv* quiz3 review* Week3 éš¨å ‚æ¸¬é©—: é¡Œç›® (å…§å«ä½œç­”è¡¨å–®) ","date":"2024-02-28","objectID":"/posts/linux2023/:1:3","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡/å®ä½œ (Linux Kernel Internals)","uri":"/posts/linux2023/"},{"categories":["Linux Kernel Internals"],"content":"ç¬¬ 4 é€±: æ•¸å€¼ç³»çµ± + ç·¨è­¯å™¨ (Mar 6, 7, 9) æ•™æè§£èªª* (åƒ…æ­¢æ–¼æ¦‚æ³ï¼Œè«‹è©³é–±ä¸‹æ–¹æ•™æåŠå€‹åˆ¥çš„å°æ‡‰è§£èªªéŒ„å½±) å…¬å‘Š: è«‹å¡«å¯« Google è¡¨å–®ï¼Œä»¥åˆ©å¾ŒçºŒè¿½è¹¤ ã€ŠDemystifying the Linux CPU Schedulerã€‹çš„æ›¸ç¨¿å·²å¯„é€çµ¦æˆåŠŸå¤§å­¸çš„é¸èª²å­¸ç”Ÿï¼Œæ—è½çš„å­¸å“¡é è¨ˆåœ¨ 3 æœˆ 13 æ—¥å–å¾— (ç¬¬ 5 é€±é€²åº¦) è²¢ç»ç¨‹å¼ç¢¼åˆ° Linux æ ¸å¿ƒ ç¬¬ä¸€æ¬¡çµ¦ Linux Kernel ç™¼ patch æäº¤ç¬¬ä¸€ä»½ Patch åˆ° Linux Kernel ç¬¬ä¸€æ¬¡ç™¼ patch åˆ° LKML è¿½æ±‚ç¥ä¹å…¶æŠ€çš„ç¨‹å¼è¨­è¨ˆä¹‹é“ ã€Œå¯ä»¥çœ‹å‡ºæŠ„è¥²é¢¨æ°£åœ¨å°ç£ä¸¦ä¸åªæ˜¯å°æ™‚å€™åœ¨å­¸æ ¡æŠ„æŠ„ä½œæ¥­è€Œå·²ï¼›åª’é«”å·¥ä½œè€…åœ¨å ±å°ä¸­ä»»æ„æŠ„è¥²åŠè½‰è¼‰æ˜¯ç¨®ä¸å°Šé‡è‡ªå·±å°ˆæ¥­çš„è¡¨ç¾ï¼Œä¸ä½†éš±å«è‘—ä¸€ç¨®æ‡‰ä»˜äº†äº‹çš„å¿ƒæ…‹ï¼Œæ›´ä»£è¡¨è‘—é€™äº›äººå°æ–¼è‡ªå·±çš„å·¥ä½œæ²’æœ‰ç†±æƒ…ï¼Œæ›´æ²’æœ‰è‘—ä¸€é»å …æŒã€‚å¦‚æœè¦èªªæˆ‘åœ¨ç¾åœ‹çœ‹åˆ°é€™é‚Šå’Œå°ç£æœ‰ä»€éº¼æœ€å¤§çš„ä¸åŒï¼Œæˆ‘æƒ³é—œéµçš„å·®ç•°å°±åœ¨å°è‡ªå·±çš„å·¥ä½œæœ‰æ²’æœ‰ç†±æƒ…å’Œå …æŒè€Œå·²äº†ã€‚ã€ ã€Œç¨‹å¼è—è¡“å®¶ä¹Ÿä¸éæ˜¯åœ¨ã€ç°¡æ½”ã€ã€ã€å½ˆæ€§ã€ã€ã€æ•ˆç‡ã€é€™ä¸‰å¤§ç›®æ¨™ä¸Šé€²è¡Œä¸€é€£ä¸²çš„å–æ¨ (trade-off) å’Œæœ€ä½³åŒ–ã€‚ã€ Linux æ ¸å¿ƒçš„ç´…é»‘æ¨¹ CS:APP ç¬¬ 2 ç« é‡é»æç¤ºå’Œç·´ç¿’* æ ¸å¿ƒé–‹ç™¼è€…ç•¶ç„¶è¦ç†Ÿæ‚‰ç·¨è­¯å™¨è¡Œç‚º Linus Torvalds æ•™ä½ åˆ†æ gcc è¡Œç‚º Pointers are more abstract than you might expect in C / HackerNews è¨è«– C ç·¨è­¯å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æ* C èªè¨€: æœªå®šç¾©è¡Œç‚º*: C èªè¨€æœ€åˆç‚ºäº†é–‹ç™¼ UNIX å’Œç³»çµ±è»Ÿé«”è€Œç”Ÿï¼Œæœ¬è³ªæ˜¯ä½éšçš„ç¨‹å¼èªè¨€ï¼Œåœ¨èªè¨€è¦ç¯„å±¤ç´šå­˜åœ¨ undefined behaviorï¼Œå¯å…è¨±ç·¨è­¯å™¨å¼•å…¥æ›´å¤šæœ€ä½³åŒ– C èªè¨€: ç·¨è­¯å™¨å’Œæœ€ä½³åŒ–åŸç†* ã€ŠDemystifying the Linux CPU Schedulerã€‹ç¬¬ 1 ç«  ä½œæ¥­: æˆªæ­¢ç¹³äº¤æ—¥: Mar 30 quiz4 Week4 éš¨å ‚æ¸¬é©—: é¡Œç›® (å…§å«ä½œç­”è¡¨å–®) èª²å ‚å•ç­”ç°¡è¨˜ ","date":"2024-02-28","objectID":"/posts/linux2023/:1:4","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡/å®ä½œ (Linux Kernel Internals)","uri":"/posts/linux2023/"},{"categories":["Linux Kernel Internals"],"content":"ç¬¬ 5 é€±: Linux CPU scheduler (Mar 13, 14, 16) æ•™æè§£èªª* (åƒ…æ­¢æ–¼æ¦‚æ³ï¼Œè«‹è©³é–±ä¸‹æ–¹æ•™æåŠå€‹åˆ¥çš„å°æ‡‰è§£èªªéŒ„å½±) å…¬å‘Š: æœ¬é€±å°å…¥å®¢è£½åŒ–ä½œæ¥­ï¼Œè®“å­¸å“¡é¸æ“‡æ”¹é€²å‰å››é€±çš„ä½œæ¥­æˆ–è‡ªè¨‚é¡Œç›® (ä¾‹å¦‚è²¢ç»ç¨‹å¼ç¢¼åˆ° Linux æ ¸å¿ƒ)ï¼Œéš¨å¾Œå®‰æ’æˆèª²æ•™å¸«å’Œå­¸å“¡çš„ç·šä¸Šä¸€å°ä¸€è¨è«– æµ®é»æ•¸é‹ç®—*: å·¥ç¨‹é ˜åŸŸå¾€å¾€æ˜¯ä¸€ç³»åˆ—çš„å–æ¨çµæœï¼Œæµ®é»æ•¸æ›´æ˜¯å¦‚æ­¤ï¼Œåœ¨è»Ÿé«”ç™¼é–‹ç™¼æœ‰å¤ªå¤šå¤±èª¤æ¡ˆä¾‹æºè‡ªå·¥ç¨‹äººå“¡å°æµ®é»æ•¸é‹ç®—çš„æŒæ¡ä¸è¶³ï¼Œæœ¬è­°ç¨‹å¸Œæœ›è—‰ç”±æ¢è¨çœŸå¯¦ä¸–ç•Œçš„è¡€æ·‹æ·‹æ¡ˆä¾‹ï¼Œå¸¶è‘—å­¸å“¡æ€è€ƒ IEEE 754 è¦æ ¼å’Œç›¸é—œè»Ÿç¡¬é«”è€ƒé‡é»ï¼Œæœ€å¾Œä¹Ÿæœƒæ¢è¨åœ¨æ·±åº¦å­¸ç¿’é ˜åŸŸç‚ºäº†æ”¹å–„è³‡æ–™è™•ç†æ•ˆç‡ï¼Œè€Œå¼•å…¥çš„ BFloat16 é€™æ¨£çš„æ–°æ¨™æº– float16 vs. bfloat16 è¨˜æ†¶é«”é…ç½®å™¨æ¶‰åŠ bitwise æ“ä½œåŠæµ®é»æ•¸é‹ç®—ã€‚å‚³çµ±çš„å³æ™‚ç³»çµ±å’Œè©²é ˜åŸŸçš„ä½œæ¥­ç³»çµ± (å³ RTOS) ç‚ºäº†è®“ç³»çµ±è¡Œç‚ºæ›´å¯é æ¸¬ï¼Œå¾€å¾€æ¨æ£„å‹•æ…‹è¨˜æ†¶é«”é…ç½®çš„èƒ½åŠ›ï¼Œä½†é€™é¡¯ç„¶è®“ç³»çµ±çš„æ“´å……èƒ½åŠ›å¤§å¹…å—é™ã€‚å¾Œä¾†ç ”ç©¶äººå“¡æå‡º TLSF (Two-Level Segregated Fit) å˜—è©¦è®“å³æ™‚ç³»çµ±ä¹Ÿèƒ½äº«ç”¨å‹•æ…‹è¨˜æ†¶é«”ç®¡ç†ï¼Œå…¶é—œéµè¨´æ±‚æ˜¯ â€œO(1) cost for malloc, free, realloc, aligned_allocâ€ Benchmarking Malloc with Doom 3 tlsf-bsd TLSF: Part 1: Background, Part 2: The floating point Linux æ ¸å¿ƒæ¨¡çµ„é‹ä½œåŸç† Linux: ä¸åªæŒ‘é¸ä»»å‹™çš„æ’ç¨‹å™¨*: æ’ç¨‹å™¨ (scheduler) æ˜¯ä»»ä½•ä¸€å€‹å¤šå·¥ä½œæ¥­ç³»çµ±æ ¸å¿ƒéƒ½å…·å‚™çš„æ©Ÿåˆ¶ï¼Œä½†å½¼æ­¤è½å·®æ¥µå¤§ï¼Œè€ƒé‡é»ä¸åƒ…æ˜¯æ¼”ç®—æ³•ï¼Œé‚„æœ‰ç•¶æ‡‰ç”¨è¦æ¨¡ææ˜‡æ™‚ (æ‰€è¬‚çš„ scalability) å’Œæ¶‰åŠå³æ™‚è™•ç†ä¹‹éš›ï¼Œæœƒæ‹›è‡´ä¸å¯é çŸ¥çš„ç‹€æ³ (non-determinism)ï¼Œä¸åƒ…å³æ™‚ç³»çµ±åœ¨æ„ï¼Œä»»ä½•å»ºæ§‹åœ¨ Linux æ ¸å¿ƒä¹‹ä¸Šçš„å¤§å‹æœå‹™éƒ½æœƒæ·±å—è¡æ“Šã€‚æ˜¯æ­¤ï¼ŒLinux æ ¸å¿ƒçš„æ’ç¨‹å™¨ç¶“æ­·å¤šæ¬¡è®Šé©ï¼Œéœ€è¦ç•™æ„çš„æ˜¯ï¼Œæ’ç¨‹çš„é›£åº¦ä¸åœ¨æ–¼æŒ‘é¸ä¸‹ä¸€å€‹å¯åŸ·è¡Œçš„è¡Œç¨‹ (process)ï¼Œè€Œæ˜¯è®“åŸ·è¡Œå®Œçš„è¡Œç¨‹å¾—ä»¥å®‰æ’åˆ°åˆé©çš„ä½ç½®ï¼Œä½¿å¾— runqueue ä¾ç„¶ä¾æ“šç¬¦åˆé æœŸçš„é †åºã€‚ C èªè¨€: å‹•æ…‹é€£çµå™¨* C èªè¨€: é€£çµå™¨å’ŒåŸ·è¡Œæª”è³‡è¨Š* C èªè¨€: åŸ·è¡Œéšæ®µç¨‹å¼åº« (CRT)* ä½œæ¥­: æˆªæ­¢ç¹³äº¤ Apr 10 assessment Week5 éš¨å ‚æ¸¬é©—: é¡Œç›® (å…§å«ä½œç­”è¡¨å–®) èª²å ‚å•ç­”ç°¡è¨˜ ","date":"2024-02-28","objectID":"/posts/linux2023/:1:5","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡/å®ä½œ (Linux Kernel Internals)","uri":"/posts/linux2023/"},{"categories":["Linux Kernel Internals"],"content":"ç¬¬ 6 é€±: System call + CPU Scheduler (Mar 20, 21, 23) æ•™æè§£èªª* (åƒ…æ­¢æ–¼æ¦‚æ³ï¼Œè«‹è©³é–±ä¸‹æ–¹æ•™æåŠå€‹åˆ¥çš„å°æ‡‰è§£èªªéŒ„å½±) å…¬å‘Š è‡ª 3 æœˆ 22 æ—¥èµ·ï¼Œé–‹æ”¾è®“å­¸å“¡ (é¸èª²çš„å­¸ç”Ÿ + å®Œæˆå‰äºŒæ¬¡ä½œæ¥­éåŠè¦æ±‚çš„æ—è½è€…) è·Ÿæˆèª²æ•™å¸«é ç´„ä¸€å°ä¸€ç·šä¸Šè¨è«–ï¼Œè«‹åƒç…§èª²ç¨‹è¡Œäº‹æ›†è£¡é ­æ¨™æ³¨ â€œOffice hourâ€ çš„æ™‚æ®µï¼Œç™¼è¨Šæ¯åˆ° Facebook ç²‰çµ²å°ˆé ï¼Œç°¡è¿°ä½ çš„å­¸ç¿’ç‹€æ³ä¸¦é¸å®šåå¥½çš„æ™‚æ®µ (å»ºè­°æ˜¯ 30 åˆ†é˜)ã€‚ç•™æ„èª²ç¨‹ç™¼é€çš„å…¬å‘Šä¿¡ä»¶ é¸ä¿®èª²ç¨‹çš„å­¸å“¡åœ¨æœ¬å­¸æœŸè‡³å°‘è¦å®‰æ’ä¸€æ¬¡ä¸€å°ä¸€è¨è«–ï¼Œå¦å‰‡æˆèª²æ•™å¸«é›£ä»¥è©•ä¼°å­¸ç¿’ç‹€æ³ï¼Œå¾è€Œæœƒå½±éŸ¿è©•åˆ†ï¼Œè«‹é‡è¦–è‡ªå·±çš„æ¬Šç›Šã€‚ coroutine Linux: è³¦äºˆæ‡‰ç”¨ç¨‹å¼ç”Ÿå‘½çš„ç³»çµ±å‘¼å« vDSO: å¿«é€Ÿçš„ Linux ç³»çµ±å‘¼å«æ©Ÿåˆ¶ UNIX ä½œæ¥­ç³»çµ± fork/exec ç³»çµ±å‘¼å«çš„å‰ä¸–ä»Šç”Ÿ ã€ŠDemystifying the Linux CPU Schedulerã€‹ 1.2.1 System calls 1.2.2 A different kind of software 1.2.3 User and kernel stacks 1.3 Process management 2.1 Introduction 2.2 Prior to CFS 2.3 Completely Fair Scheduler (CFS) 3.1 Structs and their role ä½œæ¥­: æˆªæ­¢ç¹³äº¤ Apr 17 quiz5, quiz6 Week6 éš¨å ‚æ¸¬é©—: é¡Œç›® (å…§å«ä½œç­”è¡¨å–®) èª²å ‚å•ç­”ç°¡è¨˜ ç¬¬ 7 é€± (Mar 27, 28, 30): Process, ä¸¦è¡Œå’Œå¤šåŸ·è¡Œç·’ æ•™æè§£èªª-1*, æ•™æè§£èªª-2* (åƒ…æ­¢æ–¼æ¦‚æ³ï¼Œè«‹è©³é–±ä¸‹æ–¹æ•™æåŠå€‹åˆ¥çš„å°æ‡‰è§£èªªéŒ„å½±) å…¬å‘Š: ç¬¬ 5 æ¬¡ä½œæ¥­ å’Œ ç¬¬ 6 æ¬¡ä½œæ¥­ ä½œæ¥­å·²æŒ‡æ´¾ æœ¬é€±æ¸¬é©—é †å»¶åˆ° 4 æœˆ 4 æ—¥å’Œ 4 æœˆ 6 æ—¥ï¼Œ3 æœˆ 30 æ—¥æ™šé–“å®‰æ’èª²ç¨‹è¬›è§£ 4 æœˆ 3 æ—¥æ™šé–“ä¾èˆŠè¬›èª² (äº‹å¾Œæœ‰éŒ„å½±)ã€4 æœˆ 4 æ—¥ä¸‹åˆåˆ°æ™šé–“å®‰æ’åœ¨å®¶æ¸¬é©—ï¼Œ4 æœˆ 6 æ—¥æ™šé–“å®‰æ’æ¸¬é©— Linux: ä¸åƒ…æ˜¯å€‹åŸ·è¡Œå–®å…ƒçš„ Process*: Linux æ ¸å¿ƒå°æ–¼ UNIX Process çš„å¯¦ä½œç›¸ç•¶è¤‡é›œï¼Œä¸åƒ…è˜Šå«æ­·å²æ„ç¾© (å¹¾ä¹æ¯å€‹æ¬„ä½éƒ½å€¼å¾—è¬›å¤)ï¼Œæ›´æ˜¯åæ˜ å‡ºè³‡è¨Šç§‘æŠ€ç”¢æ¥­çš„è®Šé·ï¼Œæ ¸å¿ƒç¨‹å¼ç¢¼çš„ task_struct çµæ§‹é«”æ›´æ˜¯ä¸€çµ•ï¼Œå»£æ³›æ¶µè“‹ process ç‹€æ…‹ã€è™•ç†å™¨ã€æª”æ¡ˆç³»çµ±ã€signal è™•ç†ã€åº•å±¤è¿½è¹¤æ©Ÿåˆ¶ç­‰ç­‰è³‡è¨Šï¼Œæ›´ç”šè€…ï¼Œé‚„å¾ˆæ›–æ˜§åœ°ä¿å­˜è‘— thread çš„å¿…è¦æ¬„ä½ï¼Œå¥½ä¼¼é€™å…©è€…å¤©ç”Ÿå°±è„«ä¸äº†å¹²ä¿‚ æ¢è¨ Linux æ ¸å¿ƒè¨­è¨ˆçš„ç‰¹æœ‰æ€ç¶­ï¼Œåƒæ˜¯å¦‚ä½•é€é LWP å’Œ NPTL å¯¦ä½œåŸ·è¡Œç·’ï¼Œåˆå¦‚ä½•é€éè¡Œç¨‹å»ºç«‹è¨˜æ†¶é«”ç®¡ç†çš„ä¸€ç¨®æŠ½è±¡å±¤ï¼Œå†è€…å›é¡§è¡Œç¨‹é–“çš„ context switch åŠæ’ç¨‹æ©Ÿåˆ¶ï¼Œæ­é… signal è™•ç† æ¸¬è©¦ Linux æ ¸å¿ƒçš„è™›æ“¬åŒ–ç’°å¢ƒ å»ºæ§‹ User-Mode Linux çš„å¯¦é©—ç’°å¢ƒ* ã€ˆConcurrency Primerã€‰å°è®€ The C11 and C++11 Concurrency Model Time to move to C11 atomics? C11 atomic variables and the kernel C11 atomics part 2: â€œconsumeâ€ semantics An introduction to lockless algorithms ä¸¦è¡Œå’Œå¤šåŸ·è¡Œç·’ç¨‹å¼è¨­è¨ˆ* CS:APP ç¬¬ 12 ç«  Concurrency / éŒ„å½±* Synchronization: Basic / éŒ„å½±* Synchronization: Advanced / éŒ„å½±* Thread-Level Parallelism / éŒ„å½±* èª²å ‚å•ç­”ç°¡è¨˜ ç¬¬ 8 é€± (Apr 3, 4, 6): ä¸¦è¡Œç¨‹å¼è¨­è¨ˆ, lock-free, Linux åŒæ­¥æ©Ÿåˆ¶ æ•™æè§£èªª* (åƒ…æ­¢æ–¼æ¦‚æ³ï¼Œè«‹è©³é–±ä¸‹æ–¹æ•™æåŠå€‹åˆ¥çš„å°æ‡‰è§£èªªéŒ„å½±) å…¬å‘Š: 4 æœˆ 4 æ—¥ä¸‹åˆåˆ°æ™šé–“å®‰æ’åœ¨å®¶æ¸¬é©—ï¼Œè«‹åœ¨ç•¶æ—¥ 15:00 åˆ·æ–°èª²ç¨‹é€²åº¦è¡¨/è¡Œäº‹æ›†ï¼Œä»¥å¾—çŸ¥æ¸¬é©—æ–¹å¼ 4 æœˆ 6 æ—¥æ™šé–“å®‰æ’æ¸¬é©— ä¸¦è¡Œå’Œå¤šåŸ·è¡Œç·’ç¨‹å¼è¨­è¨ˆï¼Œæ¶µè“‹ Atomics æ“ä½œ POSIX Threads (è«‹å°ç…§ CS:APP ç¬¬ 12 ç« è‡ªè¡Œå­¸ç¿’) Lock-free ç¨‹å¼è¨­è¨ˆ æ¡ˆä¾‹: Hazard pointer æ¡ˆä¾‹: Ring buffer æ¡ˆä¾‹: Thread Pool Linux: æ·ºè«‡åŒæ­¥æ©Ÿåˆ¶* åˆ©ç”¨ lkm ä¾†è®Šæ›´ç‰¹å®š Linux è¡Œç¨‹çš„å…§éƒ¨ç‹€æ…‹ Week8 éš¨å ‚æ¸¬é©—: é¡Œç›® (å…§å«ä½œç­”è¡¨å–®) ç¬¬ 9 é€± (Apr 10, 11, 13): futex, RCU, ä¼ºæœå™¨é–‹ç™¼èˆ‡ Linux æ ¸å¿ƒå°æ‡‰çš„ç³»çµ±å‘¼å« æ•™æè§£èªª* (åƒ…æ­¢æ–¼æ¦‚æ³ï¼Œè«‹è©³é–±ä¸‹æ–¹æ•™æåŠå€‹åˆ¥çš„å°æ‡‰è§£èªªéŒ„å½±) ç¬¬äºŒæ¬¡ä½œæ¥­æª¢è¨ å…¬å‘Š: è«‹æ–¼ 4 æœˆ 14 æ—¥ 10:00PM åˆ·æ–°æœ¬é é¢ï¼Œä»¥å¾—çŸ¥æ–°æŒ‡æ´¾çš„ä½œæ¥­ 4 æœˆ 13 æ—¥æ™šé–“å®‰æ’èª²ç¨‹æ¸¬é©—å’Œä½œæ¥­è§£èªªï¼Œå„ªå…ˆå›è¦†å­¸å“¡åœ¨ç¬¬ 5 æ¬¡ä½œæ¥­çš„æå• ç”±æ–¼å…¶ä»–èª²ç¨‹çš„æœŸä¸­è€ƒé™¸çºŒå‘Šä¸€æ®µè½ï¼Œæœ¬èª²ç¨‹åˆè¦æ¢å¾©ä¹‹å‰çš„å¼·åº¦ï¼Œè«‹å‹™å¿…è·Ÿæˆèª²æ•™å¸«é ç´„ä¸€å°ä¸€è¨è«–ï¼Œä»¥é€²è¡Œç›¸é—œèª¿æ•´ Twitter ä¸Šé¢çš„ç¬‘è©±: index çš„è¤‡æ•¸å¯«ä½œ indices, complex çš„è¤‡æ•¸å¯«ä½œ complices, é‚£ mutex çš„è¤‡æ•¸æ˜¯ä»€éº¼ï¼Ÿç­” â€œdeadlockâ€ â€“ å‡ºè™• A Deep dive into (implicit) Thread Local Storage å…è¨±åŸ·è¡Œç·’æ“æœ‰ç§è‡ªçš„è³‡æ–™ã€‚å°æ–¼æ¯å€‹åŸ·è¡Œç·’ä¾†èªªï¼ŒTLS æ˜¯ç¨ä¸€ç„¡äºŒï¼Œä¸æœƒç›¸äº’å½±éŸ¿ã€‚æ¡ˆä¾‹: å…¨åŸŸè®Šæ•¸ errno å¯èƒ½åœ¨å¤šåŸ·è¡Œç·’ä¸¦è¡ŒåŸ·è¡Œæ™‚éŒ¯èª¤ï¼Œé€é TLS è™•ç† errno æ˜¯å€‹è§£æ±ºæ–¹æ¡ˆ __thread, åœ¨ POSIX Thread ç¨±ç‚º thread-specific dataï¼Œå¯è¦‹ pthread_key_create, pthread_setspecific åœ¨ x86/x86_64 Linuxï¼Œfs segment ç”¨ä»¥è¡¨ç¤º TLS çš„èµ·å§‹ä½ç½®ï¼Œè®“åŸ·è¡Œç·’çŸ¥é“è©²ç”¨çš„ç©ºé–“ä½æ–¼ä½•è™• å»ºç«‹ç›¸å®¹æ–¼ POSIX Thread çš„å¯¦ä½œ RCU åŒæ­¥æ©Ÿåˆ¶* Linux æ ¸å¿ƒè¨­è¨ˆ: é‡å°äº‹ä»¶é©…å‹•çš„ I/O æ¨¡å‹æ¼”åŒ–* ç²¾é€šæ•¸ä½é‚è¼¯å° coding æœ‰ä»€éº¼å¹«åŠ©ï¼Ÿ Linux: é€é eBPF è§€å¯Ÿä½œæ¥­ç³»çµ±è¡Œç‚º*: å‹•æ…‹è¿½è¹¤æŠ€è¡“ï¼ˆdynamic tracingï¼‰æ˜¯ç¾ä»£è»Ÿé«”çš„é€²éšé™¤éŒ¯å’Œè¿½è¹¤æ©Ÿåˆ¶ï¼Œè®“å·¥ç¨‹å¸«ä»¥éå¸¸ä½çš„æˆæœ¬ï¼Œåœ¨éå¸¸çŸ­çš„æ™‚é–“å…§ï¼Œå…‹æœä¸€äº›ä¸æ˜¯é¡¯è€Œæ˜“è¦‹çš„å•é¡Œã€‚å®ƒèˆˆèµ·å’Œç¹æ¦®çš„ä¸€å€‹å¤§èƒŒæ™¯æ˜¯ï¼Œæˆ‘å€‘æ­£è™•åœ¨ä¸€å€‹å¿«é€Ÿå¢é•·çš„ç¶²è·¯äº’é€£ç•°è³ªé‹ç®—ç’°å¢ƒï¼Œå·¥ç¨‹äººå“¡é¢è‡¨è‘—å…©å¤§æ–¹é¢çš„æŒ‘æˆ°ï¼š è¦æ¨¡ï¼šç„¡è«–æ˜¯ä½¿ç”¨è€…è¦æ¨¡é‚„æ˜¯æ©Ÿæˆ¿çš„è¦æ¨¡ã€æ©Ÿå™¨çš„æ•¸é‡éƒ½è™•æ–¼å¿«é€Ÿå¢é•·çš„æ™‚ä»£; è¤‡é›œåº¦ï¼šæ¥­å‹™é‚è¼¯è¶Šä¾†è¶Šè¤‡é›œï¼Œé‹ä½œçš„è»Ÿé«”ä¹Ÿè®Šå¾—è¶Šä¾†è¶Šè¤‡é›œï¼Œæˆ‘å€‘çŸ¥é“å®ƒæœƒåˆ†æˆå¾ˆå¤šå¾ˆå¤šå±¤æ¬¡ï¼ŒåŒ…æ‹¬ä½œæ¥­ç³»çµ±æ ¸å¿ƒå’Œå…¶ä¸Šå„ç¨®ç³»çµ±è»Ÿé«”ï¼Œåƒè³‡æ–™åº«å’Œç¶²é ä¼ºæœå™¨ï¼Œå†å¾€ä¸Šæœ‰è…³æœ¬èªè¨€æˆ–è€…å…¶ä»–é«˜éšèªè¨€çš„è™›æ“¬æ©Ÿå™¨æˆ–åŸ·è¡Œç’°å¢ƒï¼Œæ›´ä¸Šé¢æ˜¯æ‡‰ç”¨å±¤é¢çš„å„ç¨®æ¥­å‹™é‚è¼¯çš„æŠ½è±¡å±¤æ¬¡å’Œå¾ˆå¤šè¤‡é›œçš„ç¨‹å¼é‚è¼¯ã€‚ Week9 éš¨å ‚æ¸¬é©—: é¡Œç›® (å…§å«ä½œç­”è¡¨å–®) èª²å ‚å•ç­”ç°¡è¨˜ ç¬¬ 10 é€± (Apr 17, 18, 20): ç¾ä»£å¾®è™•ç†å™¨ æ•™æè§£èªª* (åƒ…æ­¢æ–¼æ¦‚æ³ï¼Œè«‹è©³é–±ä¸‹æ–¹æ•™æåŠå€‹åˆ¥çš„å°æ‡‰è§£èªªéŒ„å½±) å…¬å‘Š: æœ¬é€±æŒ‡æ´¾æ–°ä½œæ¥­: ktcp* é¸ä¿®ã€ŒLinux æ ¸å¿ƒè¨­è¨ˆ/å¯¦ä½œã€èª²ç¨‹çš„ç ”ç©¶ç”Ÿæœ‰é¡å¤–çš„ä½œæ¥­ (èª²ç¨‹å›é¡§å’Œåˆ†äº«å­¸ç¿’ç¶“é©—çµ¦æŒ‡å°æ•™æˆ)ï¼Œè©³æƒ…è«‹ç•™æ„å¾ŒçºŒä¿¡ä»¶ Cautionary Tales on Implementing the Software That People Want* slides 1990: Queueing Problem: Stochastic Fair Queueing: Hash 2004: Real-Time Linux 2004: Dawn of Multicore Embedded Formal Verification is Heavily Used Natural Selection: Bugs are Software! People donâ€™t know what they want. But for software developers, this is no excuse. ç¾ä»£è™•ç†å™¨è¨­è¨ˆï¼šåŸç†å’Œé—œéµç‰¹å¾µ* ã€ŠDemystifying the Linux CPU Schedulerã€‹ 2.4 Multiprocessing 3.2 Time keeping 3.4 Per-Entity Load Tracking 4.1 Group scheduling and cgroups: Introduction 4.2 Group scheduling and CPU bandwidth Linux: ä¸­æ–·è™•ç†å’Œç¾ä»£æ¶æ§‹è€ƒé‡* Linux: å¤šæ ¸è™•ç†å™¨å’Œ spinlock* CPU caches by Ulrich Drepper é€²è¡Œä¸­çš„ç¹é«”ä¸­æ–‡ç¿»è­¯: ã€Šæ¯ä½ç¨‹å¼é–‹ç™¼è€…éƒ½è©²æœ‰çš„è¨˜æ†¶é«”çŸ¥è­˜ã€‹ æœ¬æ–‡è§£é‡‹ç”¨æ–¼ç¾ä»£é›»è…¦ç¡¬é«”çš„è¨˜æ†¶é«”å­ç³»çµ±çš„çµæ§‹ã€é—¡è¿° CPU å¿«å–ç™¼å±•çš„è€ƒé‡ã€å®ƒå€‘å¦‚ä½•é‹ä½œï¼Œä»¥åŠç¨‹å¼è©²å¦‚ä½•é‡å°è¨˜æ†¶é«”æ“ä½œèª¿æ•´ï¼Œå¾è€Œé”åˆ°æœ€ä½³çš„æ•ˆèƒ½ã€‚ ä½œæ¥­: æˆªæ­¢ç¹³äº¤ May 14 ktcp èª²å ‚å•ç­”ç°¡è¨˜ ç¬¬ 11 é€± (Apr 24, 25, 20): ç¾ä»£å¾®è™•ç†å™¨ + è¨˜æ†¶é«”ç®¡ç† æ•™æè§£èªª* (åƒ…æ­¢æ–¼æ¦‚æ³ï¼Œè«‹è©³é–±ä¸‹æ–¹æ•™æåŠå€‹åˆ¥çš„å°æ‡‰è§£èªªéŒ„å½±) å…¬å‘Š å­¸å“¡æ‡‰åŠæ—©è·Ÿæˆèª²æ•™å¸«é ç´„ä¸€å°ä¸€ç·šä¸Šè¨è«–ï¼Œè«‹åƒç…§èª²ç¨‹è¡Œäº‹æ›†è£¡é ­æ¨™","date":"2024-02-28","objectID":"/posts/linux2023/:1:6","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡/å®ä½œ (Linux Kernel Internals)","uri":"/posts/linux2023/"},{"categories":["Rust"],"content":" We're writing it end-to-end in one sitting, with the hope of ending up with a decent understanding of how hash map works, and how you'd make the interface idiomatic Rust. I have tried to make sure I introduce new concepts we come across, so it should be possible to follow whether you're a newcomer to the language or not. æ•´ç†è‡ª John Gjengset çš„å½±ç‰‡ ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:0:0","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"å½±ç‰‡æ³¨è§£ ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:1:0","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"Data structure and API Usually it is nicer tosepecify the bounds only on the places where you need them (e.g. methods) rather than on the data structure. Struct std::collections::HashMap pub struct HashMap\u003cK, V, S = RandomState\u003e { /* private fields */ } impl\u003cK, V, S\u003e HashMap\u003cK, V, S\u003e where K: Eq + Hash, S: BuildHasher, ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:1:1","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"Hash and Eq Trait std::hash::Hash å¼•ç”¨ When implementing both Hash and Eq, it is important that the following property holds: k1 == k2 -\u003e hash(k1) == hash(k2) In other words, if two keys are equal, their hashes must also be equal. HashMap and HashSet both rely on this behavior. ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:1:2","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"usize vs. u64 let bucket = (hasher.finish() % self.buckets.len() as u64) as usize; let bucket = \u0026mut self.buckets[bucket]; å› ä¸ºå–æ¨¡ % è¿ç®—åçš„æ•°å€¼ä¸å¤§äº buckets.len()ï¼Œå¹¶ä¸” buckets.len() çš„ç±»å‹æ˜¯ usizeï¼Œæ‰€ä»¥å¯ä»¥å°†å–æ¨¡è¿ç®—çš„ç»“æœå®‰å…¨ç¬¬è½¬æ¢æˆ usizeï¼Œå½“ç„¶è¿›è¡Œå–æ¨¡è¿ç®—æ—¶éœ€è¦å°† buckets.len() è½¬æ¢æˆå’Œ finish() çš„è¿”å›å€¼ç±»å‹ u64 å†è¿›è¡Œè¿ç®—ã€‚ ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:1:3","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"swap_remove å¯¹äºæ™®é€šçš„ vector çš„ remove æ–¹æ³•æ¥è¯´ï¼Œå¤„ç†è¿‡ç¨‹å¦‚ä¸‹: vec![a, b, c, d, e, f] remove(b) vec![a, _, c, d, e, f] vec![a, c, d, e, f] å³éœ€è¦è¢«åˆ é™¤å…ƒç´ åé¢çš„å…ƒç´ ä¾æ¬¡è¿›è¡Œç§»ä½ï¼Œè¿™æ ·çš„æ—¶é—´å¤æ‚åº¦å¾ˆé«˜ $O(n)$ã€‚ä½†å¯¹äº swap_remove æ¥è¯´ï¼Œå…¶å¤„ç†è¿‡ç¨‹å¦‚ä¸‹: vec![a, b, c, d, e, f] remove(b) vec![a, f, c, d, e, b] vec![a, f, c, d, e] å…ˆå°†è¢«åˆ é™¤å…ƒç´ å’Œæœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢ä½ç½®ï¼Œç„¶åå†ä¸¢å¼ƒæœ€åä¸€ä¸ªå…ƒç´  (æ­¤æ—¶è¯¥ä½ç½®ä¸Šä¸ºè¢«åˆ é™¤å…ƒç´ )ï¼Œè¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ä»…ä¸º $O(1)$ ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:1:4","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"tail recursion å› ä¸º Rust ç¼–è¯‘å™¨å¹¶æ²¡æœ‰é’ˆå¯¹å°¾é€’å½’çš„æœ€ä¼˜åŒ–ï¼Œæ‰€ä»¥å°½é‡ä¸è¦ä½¿ç”¨å°¾é€’å½’çš„é€»è¾‘ï¼Œä½¿ç”¨å¾ªç¯æ”¹å†™æ¯”è¾ƒå¥½ï¼Œè¿™æ ·å¯ä»¥å°†ç©ºé—´å¤æ‚åº¦ä» $O(n)$ é™åˆ° $O(1)$ã€‚åœ¨ drop æ–¹æ³•çš„å®ç°ä¸­ç‰¹åˆ«æ˜æ˜¾ï¼Œæ‰‹åŠ¨å®ç° drop æ–¹æ³•æ—¶ï¼Œåº”å°½é‡ä½¿ç”¨å¾ªç¯è€Œä¸æ˜¯é€’å½’é€»è¾‘ã€‚ ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:1:5","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"tuple references (\u0026'a K, \u0026'a V) \u0026'a (K, V) è¿™ä¸¤ç§è¡¨ç¤ºæ–¹å¼æ˜¯ä¸å®Œå…¨ç›¸åŒçš„ï¼Œå¯¹äºç¬¬äºŒç§æ–¹å¼ï¼Œéšå«äº†ä¸€ä¸ªå‰æ: K, V æ˜¯åœ¨åŒä¸€ä¸ª tuple é‡Œé¢ï¼Œå³å®ƒä»¬åœ¨å†…å­˜çš„ä½ç½®æ˜¯ç›¸é‚»çš„ï¼Œè¿™ç§æ–¹å¼è¡¨ç¤ºå¼•ç”¨çš„æ˜¯ä¸€ä¸ª tupleã€‚è€Œç¬¬ä¸€ç§ä»…è¡¨ç¤ºä¸¤ä¸ªå¼•ç”¨ç»„æˆäº†ä¸€ä¸ª tupleï¼Œè€Œå¯¹äº K, V è¿™ä¸¤ä¸ªæ•°æ®åœ¨å†…å­˜çš„ä½ç½®å…³ç³»å¹¶æ— é™åˆ¶ï¼ŒK, V æœ¬èº«æ˜¯å¦ç»„æˆ tuple ä¹Ÿä¸åœ¨ä¹ã€‚ ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:1:6","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"borrow Trait std::borrow::Borrow Types express that they can be borrowed as some type T by implementing Borrow\u003cT\u003e, providing a reference to a T in the traitâ€™s borrow method. A type is free to borrow as several different types. If it wishes to mutably borrow as the type, allowing the underlying data to be modified, it can additionally implement BorrowMut\u003cT\u003e. In particular Eq, Ord and Hash must be equivalent for borrowed and owned values: x.borrow() == y.borrow() should give the same result as x == y. If generic code merely needs to work for all types that can provide a reference to related type T, it is often better to use AsRef\u003cT\u003e as more types can safely implement it. By additionally requiring Q: Hash + Eq, it signals the requirement that K and Q have implementations of the Hash and Eq traits that produce identical results. Borrow and AsRef å¼•ç”¨ We can see how theyâ€™re kind of the same: they both deal with owned and borrowed versions of some type. However, theyâ€™re a bit different. Choose Borrow when you want to abstract over different kinds of borrowing, or when youâ€™re building a data structure that treats owned and borrowed values in equivalent ways, such as hashing and comparison. Choose AsRef when you want to convert something to a reference directly, and youâ€™re writing generic code. ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:1:7","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"entry Enum std::collections::hash_map::Entry pub enum Entry\u003c'a, K: 'a, V: 'a\u003e { Occupied(OccupiedEntry\u003c'a, K, V\u003e), Vacant(VacantEntry\u003c'a, K, V\u003e), } A view into a single entry in a map, which may either be vacant or occupied. or_insert å’Œ or_insert_with çš„å¯ä»¥ä»ä¸‹é¢çš„ä¾‹å­ä¸€çª¥åŒºåˆ«: x.or_insert(vec::new()) x.or_insert_with(vec::new) or_insert ä¼šåœ¨è°ƒç”¨å‰å¯¹å‚æ•°è¿›è¡Œè®¡ç®—ï¼Œæ‰€ä»¥ä¸ç®¡ x æ˜¯å“ªä¸ªæšä¸¾å­ç±»å‹ï¼Œvec::new() éƒ½ä¼šè¢«è°ƒç”¨ï¼Œè€Œ or_insert_with çš„å‚æ•°æ˜¯ä¸€ä¸ªé—­åŒ…ï¼Œä»…å½“ x æ˜¯ Vacant æ—¶æ‰ä¼šå¯¹å‚æ•°è¿›è¡Œè°ƒç”¨æ“ä½œï¼Œå³ vec::new() æ“ä½œã€‚ pub fn or_insert(self, value: V) -\u003e \u0026'a mut V { match self { Entry::Occupied(e) =\u003e \u0026mut e.entry.1, Entry::Vacant(e) =\u003e e.insert(value), } } pub fn or_insert_with\u003cF\u003e(self, maker: F) -\u003e \u0026'a mut V where F: FnOnce() -\u003e V, { match self { Entry::Occupied(e) =\u003e \u0026mut e.entry.1, Entry::Vacant(e) =\u003e e.insert(maker()), } } ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:1:8","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"reborrow pub fn entry(\u0026mut self, key: K) -\u003e Entry\u003c'_, K, V\u003e { let bucket = self.bucket(\u0026key); match self.buckets[bucket] .items .iter_mut() .find(|\u0026\u0026 mut (ref ekey, _)| ekey == \u0026key) { Some(index) =\u003e Entry::Occupied(OccupiedEntry { entry }), None =\u003e Entry::Vacant(VacantEntry { key, map: self, bucket, }), } } è¿™ä¸ªå®ä½œä¹ä¸€çœ‹å¥½åƒæ²¡æœ‰é—®é¢˜ï¼Œä½†æ˜¯æ³¨æ„ match è¡¨è¾¾å¼è®© iter_mut() è·å¾—çš„å¯å˜å¼•ç”¨çš„å­˜æ´»åŸŸä¸ºå…¶æ¥ä¸‹æ¥çš„ {} å†…ã€‚ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ª iter_mut() è·å¾—çš„å¯å˜å¼•ç”¨æ˜¯å¯¹è¯¥æ–¹æ³•çš„ \u0026mut self è¿›è¡Œ reborrow å¾—æ¥çš„ï¼Œä¾æ® reborrow çš„è§„åˆ™ï¼Œåœ¨ reborrow å¾—åˆ°çš„å¯å˜å¼•ç”¨çš„ä½¿ç”¨èŒƒå›´å†…ï¼Œä¸èƒ½ä½¿ç”¨è¢« reborrow çš„å¯å˜å¼•ç”¨ (è¿™æ˜¯ä¸ºäº†å‘ç¼–è¯‘å™¨ä¿è¯åŒä¸€æ—¶åˆ»åªä¼šå­˜åœ¨ä¸€ä¸ªå¯å˜å¼•ç”¨)ã€‚ä½†æ˜¯æˆ‘ä»¬çœ‹åˆ° match è¡¨è¾¾å¼çš„ None åˆ†æ”¯é‡Œï¼Œä½¿ç”¨äº†è¢« reborrow çš„å¯å˜å¼•ç”¨ selfï¼Œè¿™è¿åäº† reborrow çš„è§„åˆ™ï¼Œæ•…è€Œç¼–è¯‘ä¸é€šè¿‡ã€‚ æ­£ç¡®å®ä½œå¦‚ä¸‹ï¼Œä»…åœ¨ Some å’Œ None åˆ†æ”¯æ‰ä½¿ç”¨ reborrowï¼Œè¿™æ ·å°±ä¸ä¼šè¿å reborrow çš„è§„åˆ™æœºåˆ¶: pub fn entry(\u0026mut self, key: K) -\u003e Entry\u003c'_, K, V\u003e { let bucket = self.bucket(\u0026key); match self.buckets[bucket] .items .iter() .position(|\u0026(ref ekey, _)| ekey == \u0026key) { Some(index) =\u003e Entry::Occupied(OccupiedEntry { entry: \u0026mut self.buckets[bucket].items[index], }), None =\u003e Entry::Vacant(VacantEntry { key, map: self, bucket, }), } } ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:1:9","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"sorted list å¯ä»¥ç»™ hash map çš„ linked éƒ¨åˆ†è¿›è¡Œæ’åºï¼Œè¿™æ ·æŸ¥æ‰¾çš„æ•ˆèƒ½ä¼šæ¯”è¾ƒé«˜ (ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ï¼Œæ—¶é—´å¤æ‚åº¦ç”±åŸå…ˆçš„ $O(n)$ é™ä½ä¸º $O(log n)$)ï¼Œä½†æ˜¯è¿™æ ·ä¼šé™ä½æ’å…¥çš„æ•ˆèƒ½ (æ—¶é—´å¤æ‚åº¦ç”±åŸå…ˆçš„ $O(1)$ æé«˜è‡³ $O(n)$)ã€‚æ‰€ä»¥éœ€è¦æ ¹æ®åº”ç”¨åœºæ™¯è¿›è¡Œ trade-offï¼Œå¦‚æœæ˜¯åº”ç”¨åœºæ™¯æ˜¯æŸ¥è¯¢æ“ä½œæ¯”è¾ƒå¤šçš„ï¼Œå°±å°† linked éƒ¨åˆ†è®¾ç½®ä¸ºæœ‰åºã€‚ ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:1:10","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"Homework ä¿¡æ¯ ä¸º HashMap å®ç° Trait std::ops::Indexï¼Œä½¿å¾—ä¸‹é¢è¿™æ¡è¯­å¥ç¼–è¯‘é€šè¿‡: println!(\"Review for Jane: {}\", book_reviews[\"Pride and Prejudice\"]); ä¸º HashMap å®ç° method and_modifyï¼Œä½¿å¾—ä¸‹é¢è¿™æ¡è¯­å¥ç¼–è¯‘é€šè¿‡: player_stats .entry(\"mana\") .and_modify(|mana| *mana += 200) .or_insert(100); ä¸º HashMap å®ç° Trait std::convert::Fromï¼Œæ ¹æ®æ‰‹å†Œï¼Œåªéœ€è¦å®ç°å¯¹æ•°ç»„ç±»å‹ [(K, V); N]ï¼Œä½¿å¾—ä¸‹é¢çš„ä»£ç å¯ä»¥é€šè¿‡ç¼–è¯‘: let vikings = HashMap::from([ (Viking::new(\"Einar\", \"Norway\"), 25), (Viking::new(\"Olaf\", \"Denmark\"), 24), (Viking::new(\"Harald\", \"Iceland\"), 12), ]); let solar_distance = HashMap::from([ (\"Mercury\", 0.4), (\"Venus\", 0.7), (\"Earth\", 1.0), (\"Mars\", 1.5), ]); ä¿®æ­£ bucket æ–¹æ³•ï¼Œä½¿å¾—å…¶å¯¹äºç©ºçš„ HashMap ä¹Ÿå¯ä»¥æ­£å¸¸å·¥ä½œ åœ¨æ–¹æ³• from_iter çš„å®ä½œä¸­é‡‡ç”¨å¯¹ HashMap è¿›è¡Œé¢„åˆ†é…çš„ç­–ç•¥ï¼Œå¢å¼ºè¯¥æ–¹æ³•çš„æ•ˆèƒ½ ä¸º HashMap å®ç° \u0026mut çš„è¿­ä»£å™¨ ä¸º HashMap å®ç° drain æ–¹æ³• ä¸º HashMap å®ç° remove_entry æ–¹æ³• ä¸º HashMap å®ç° get_mut æ–¹æ³• ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:2:0","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:3:0","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"Crate std Struct std::collections::HashMap Struct std::collections::hash_map::DefaultHasher Trait std::hash::Hasher Trait std::hash::Hash Enum std::collections::hash_map::Entry Trait std::borrow::Borrow Trait std::borrow::BorrowMut Function std::mem::replace Struct std::vec::Vec method std::vec::Vec::with_capacity method std::vec::Vec::drain method std::vec::Vec::is_empty method std::vec::Vec::retain method std::vec::Vec::swap_remove Trait std::iter::Iterator method std::iter::Iterator::find method std::iter::Iterator::map method std::iter::Iterator::flat_map method std::iter::Iterator::position method std::iter::Iterator::collect method std::iter::Iterator::size_hint Trait std::iter::FromIterator trait method std::iter::Extend::extend method std::option::Option::is_some method slice::last_mut ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:3:1","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":"References Rust API Guidelines The Cargo Book ","date":"2024-06-28","objectID":"/posts/rust-linked-hashmap/:4:0","tags":["Rust","Hash"],"title":"Build a linked hash map in Rust","uri":"/posts/rust-linked-hashmap/"},{"categories":["Rust"],"content":" æ•™å­¦å½•å½± ","date":"2024-06-24","objectID":"/posts/netprog/:0:0","tags":["Rust","Sysprog","Network"],"title":"é€šè¿‡ Rust å­¦ä¹ ç½‘ç»œç¼–ç¨‹","uri":"/posts/netprog/"},{"categories":["Rust"],"content":"TCP Server/Client TCP C/S Server: fn handle_client(mut stream: TcpStream) -\u003e io::Result\u003c()\u003e { let mut buf = [0; 512]; for _ in 0..1000 { let bytes_read = stream.read(\u0026mut buf)?; if bytes_read == 0 { return Ok(()); } stream.write(\u0026buf[..bytes_read])?; thread::sleep(Duration::from_secs(1)); } Ok(()) } fn main() -\u003e io::Result\u003c()\u003e { let listener = TcpListener::bind(\"127.0.0.1:8080\")?; println!(\"TCP Server is running...\"); for stream in listener.incoming() { let stream = stream.expect(\"failed\"); thread::spawn(move || { handle_client(stream).unwrap_or_else(|error| eprintln!(\"{}\", error)); }); } Ok(()) } method std::net::TcpListener::bind method std::net::TcpListener::incoming Client: fn main() -\u003e io::Result\u003c()\u003e { let mut stream = TcpStream::connect(\"127.0.0.1:8080\")?; println!(\"TCP Client is running...\"); for _ in 0..10 { let mut input = String::new(); io::stdin().read_line(\u0026mut input).expect(\"Failed to read\"); stream.write(input.as_bytes()).expect(\"Failed to write\"); let mut reader = BufReader::new(\u0026stream); let mut buffer = vec![]; reader .read_until(b'\\n', \u0026mut buffer) .expect(\"Failed to read\"); println!( \"Read from server: {}\", std::str::from_utf8(\u0026buffer).expect(\"Failed to accept\") ); } Ok(()) } method std::net::TcpStream::connect ","date":"2024-06-24","objectID":"/posts/netprog/:1:0","tags":["Rust","Sysprog","Network"],"title":"é€šè¿‡ Rust å­¦ä¹ ç½‘ç»œç¼–ç¨‹","uri":"/posts/netprog/"},{"categories":["Rust"],"content":"UDP Server/Client UDP C/S Server: fn main() -\u003e io::Result\u003c()\u003e { let socket = UdpSocket::bind(\"127.0.0.1:8080\")?; println!(\"UDP socket is running...\"); loop { let mut buf = [0; 1500]; let (amt, src) = socket.recv_from(\u0026mut buf)?; let buf = \u0026mut buf[..amt]; buf.reverse(); socket.send_to(buf, src)?; } } method std::net::UdpSocket::bind method std::net::UdpSocket::recv_from method std::net::UdpSocket::send_to Client: fn main() -\u003e io::Result\u003c()\u003e { let socket = UdpSocket::bind(\"127.0.0.1:8081\")?; println!(\"UDP socket is running...\"); socket.connect(\"127.0.0.1:8080\")?; loop { let mut input = String::new(); io::stdin().read_line(\u0026mut input)?; socket.send(input.as_bytes())?; let mut buf = [0; 1500]; let bytes_read = socket.recv(\u0026mut buf)?; println!( \"Receive: {}\", std::str::from_utf8(\u0026buf[..bytes_read]).expect(\"Invaild message\") ); } } method std::net::UdpSocket::connect method std::net::UdpSocket::send method std::net::UdpSocket::recv ","date":"2024-06-24","objectID":"/posts/netprog/:2:0","tags":["Rust","Sysprog","Network"],"title":"é€šè¿‡ Rust å­¦ä¹ ç½‘ç»œç¼–ç¨‹","uri":"/posts/netprog/"},{"categories":["Rust"],"content":"IP/Socket Address Enum std::net::IpAddr Enum std::net::SocketAddr Enum ipnet::IpNet ","date":"2024-06-24","objectID":"/posts/netprog/:3:0","tags":["Rust","Sysprog","Network"],"title":"é€šè¿‡ Rust å­¦ä¹ ç½‘ç»œç¼–ç¨‹","uri":"/posts/netprog/"},{"categories":["Rust"],"content":"Homework ä¿¡æ¯ Building a DNS server in Rust Brown: CSCI1680: Computer Networks ","date":"2024-06-24","objectID":"/posts/netprog/:4:0","tags":["Rust","Sysprog","Network"],"title":"é€šè¿‡ Rust å­¦ä¹ ç½‘ç»œç¼–ç¨‹","uri":"/posts/netprog/"},{"categories":["Rust"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-06-24","objectID":"/posts/netprog/:5:0","tags":["Rust","Sysprog","Network"],"title":"é€šè¿‡ Rust å­¦ä¹ ç½‘ç»œç¼–ç¨‹","uri":"/posts/netprog/"},{"categories":["Rust"],"content":"Crate std Module std::net Struct std::net::TcpListener Struct std::net::TcpStream Struct std::net::UdpSocket Enum std::net::IpAddr Enum std::net::SocketAddr Trait std::io::Read Trait std::io::Write Trait std::io::BufRead method std::io::BufRead::read_until Function std::io::stdin Function std::thread::sleep Function std::str::from_utf8 Struct std::time::Duration method str::as_bytes ","date":"2024-06-24","objectID":"/posts/netprog/:5:1","tags":["Rust","Sysprog","Network"],"title":"é€šè¿‡ Rust å­¦ä¹ ç½‘ç»œç¼–ç¨‹","uri":"/posts/netprog/"},{"categories":["Rust"],"content":"Crate ipnet Enum ipnet::IpNet Struct ipnet::Ipv4Net Struxt ipnet::Ipv6Net ","date":"2024-06-24","objectID":"/posts/netprog/:5:2","tags":["Rust","Sysprog","Network"],"title":"é€šè¿‡ Rust å­¦ä¹ ç½‘ç»œç¼–ç¨‹","uri":"/posts/netprog/"},{"categories":["Concurrency"],"content":" This is a two-part talk that covers the C++ memory model, how locks and atomics and fences interact and map to hardware, and more. Even though weâ€™re talking about C++, much of this is also applicable to Java and .NET which have similar memory models, but not all the features of C++ (such as relaxed atomics). åŸæ–‡åœ°å€ (é‡Œé¢æœ‰è§£è¯´å½±ç‰‡é“¾æ¥) ","date":"2024-06-19","objectID":"/posts/atomic-weapons/:0:0","tags":["Sysprog","Concurrency","C++"],"title":"Atomic Weapons: The C++ Memory Model and Modern Hardware","uri":"/posts/atomic-weapons/"},{"categories":["Concurrency"],"content":"å‰ç½®çŸ¥è¯† è‡³å°‘æŠŠ Jserv çš„ å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº çš„å‰åŠæ®µ (å³å†…å­˜æ¨¡å‹å‰é¢çš„é‚£ä¸€éƒ¨åˆ†) æŒæ¡ï¼Œç‰¹åˆ«æ˜¯é‡è¦çš„æ¦‚å¿µ happens-before ","date":"2024-06-19","objectID":"/posts/atomic-weapons/:1:0","tags":["Sysprog","Concurrency","C++"],"title":"Atomic Weapons: The C++ Memory Model and Modern Hardware","uri":"/posts/atomic-weapons/"},{"categories":["Concurrency"],"content":"Part 1 ","date":"2024-06-19","objectID":"/posts/atomic-weapons/:2:0","tags":["Sysprog","Concurrency","C++"],"title":"Atomic Weapons: The C++ Memory Model and Modern Hardware","uri":"/posts/atomic-weapons/"},{"categories":["Concurrency"],"content":"Optimizations, races, and the memory model 3-1 3-2 5-2 7-2 8-2 åœ¨æ²¡æœ‰ç¼–è¯‘å™¨å’Œå¤„ç†å™¨è¿›è¡ŒæŒ‡ä»¤é‡æ’åºçš„æƒ…å†µä¸‹ï¼Œæ‰§è¡Œç»“æœä¹Ÿå¯èƒ½ä¸å¦‚ä½ é¢„æœŸé‚£æ ·ï¼Œå› ä¸º Store Buffer å’Œ Memmory çš„å†…å®¹å¯èƒ½ä¸æ˜¯ä¸€è‡´çš„ï¼Œè¿™æ ·é€ æˆçš„ç»“æœæ˜¯: Itâ€™s exactly as if you had reordered them and done the read before the write Damn! å»é™¤ç¼–è¯‘å™¨å’Œå¤„ç†å™¨çš„æŒ‡ä»¤é‡æ’åºåï¼Œå±…ç„¶è¿˜ä¼šå‡ºç°å’Œé‡æ’åºä¸€æ ·çš„ç»“æœï¼ï¼(è¿™æ˜¯ Cache å¸¦æ¥çš„æŒ‘æˆ˜: æ•°æ®ä¸ä¸€è‡´) è™½ç„¶ Write æ“ä½œå‘ç”Ÿåœ¨ Read ä¹‹å‰ (Write happeding-before Read)ï¼Œä½†æ˜¯ Write çš„æ•ˆæœåœ¨ Read ä¹‹åæ‰å¯è§ (Read happens-before Write)ã€‚æ‰€ä»¥ç¼–è¯‘å™¨ã€å¤„ç†å™¨å’Œ Cache éƒ½å¯ä»¥åšåˆ°æŒ‡ä»¤é‡æ’åºçš„æ•ˆæœã€‚ BTW è¿™æ®µç¨‹åºé‡Œæ¯ä¸ª thread å¯¹ flag çš„ Read å’Œ Write åœ¨ç¼–è¯‘å™¨ / å¤„ç†å™¨çœ‹æ¥æ˜¯ç‹¬ç«‹çš„ (independent)ï¼Œå®ƒä»¬æ²¡æ³•æ¨æ–­å‡ºè¿™ä¸¤ä¸ªæ“ä½œä¹‹é—´çš„é¡ºåº (ordering) å…³ç³»ï¼Œæ‰€ä»¥æå¤§å¯èƒ½ä¼šè¿›è¡Œé‡æ’åºï¼Œå½“ç„¶ç»“æœä¸ä¼šç¬¦åˆä½ çš„é¢„æœŸã€‚ 10-1 10-2 SC-DRF æé«˜äº†ç¨‹åºæ‰§è¡Œçš„æ•ˆèƒ½ 11-1 11-2 pink elephants no sequential jump, for example, you hit step next and you go up, or you hit step next and your current line disappears and you're nowhere. ","date":"2024-06-19","objectID":"/posts/atomic-weapons/:2:1","tags":["Sysprog","Concurrency","C++"],"title":"Atomic Weapons: The C++ Memory Model and Modern Hardware","uri":"/posts/atomic-weapons/"},{"categories":["Concurrency"],"content":"acquire and release ordering ","date":"2024-06-19","objectID":"/posts/atomic-weapons/:2:2","tags":["Sysprog","Concurrency","C++"],"title":"Atomic Weapons: The C++ Memory Model and Modern Hardware","uri":"/posts/atomic-weapons/"},{"categories":["Concurrency"],"content":"mutexes vs. atomics vs. fences ","date":"2024-06-19","objectID":"/posts/atomic-weapons/:2:3","tags":["Sysprog","Concurrency","C++"],"title":"Atomic Weapons: The C++ Memory Model and Modern Hardware","uri":"/posts/atomic-weapons/"},{"categories":["Concurrency"],"content":"Part 2 ","date":"2024-06-19","objectID":"/posts/atomic-weapons/:3:0","tags":["Sysprog","Concurrency","C++"],"title":"Atomic Weapons: The C++ Memory Model and Modern Hardware","uri":"/posts/atomic-weapons/"},{"categories":["Concurrency"],"content":"Restrictions on compilers and hardware (incl. common bugs) ","date":"2024-06-19","objectID":"/posts/atomic-weapons/:3:1","tags":["Sysprog","Concurrency","C++"],"title":"Atomic Weapons: The C++ Memory Model and Modern Hardware","uri":"/posts/atomic-weapons/"},{"categories":["Concurrency"],"content":"code generation and performance on x86/x64, IA64, POWER, ARM, and more ","date":"2024-06-19","objectID":"/posts/atomic-weapons/:3:2","tags":["Sysprog","Concurrency","C++"],"title":"Atomic Weapons: The C++ Memory Model and Modern Hardware","uri":"/posts/atomic-weapons/"},{"categories":["Concurrency"],"content":"relaxed atomics; volatile ","date":"2024-06-19","objectID":"/posts/atomic-weapons/:3:3","tags":["Sysprog","Concurrency","C++"],"title":"Atomic Weapons: The C++ Memory Model and Modern Hardware","uri":"/posts/atomic-weapons/"},{"categories":["Concurrency"],"content":"åŠ é¤ bilibili: ã€ŒC++11ã€å†…å­˜åºç©¶ç«Ÿæ˜¯ä»€ä¹ˆï¼Œå½»åº•å‚æ‚Ÿ C++ å†…å­˜æ¨¡å‹ (é™„å¤šçº¿ç¨‹å®‰å…¨æµ‹è¯•é€šç”¨æ¡†æ¶) ","date":"2024-06-19","objectID":"/posts/atomic-weapons/:4:0","tags":["Sysprog","Concurrency","C++"],"title":"Atomic Weapons: The C++ Memory Model and Modern Hardware","uri":"/posts/atomic-weapons/"},{"categories":["Systems"],"content":"å¤šå¤„ç†å™¨ç¼–ç¨‹: ä»å…¥é—¨åˆ°æ”¾å¼ƒ çº¿ç¨‹åº“ï¼›ç°ä»£å¤„ç†å™¨å’Œå®½æ¾å†…å­˜æ¨¡å‹ ç›´æ’­å½•å½± / è®²ä¹‰é¡µé¢ / é˜…è¯»ææ–™ ç¨‹åº (æºä»£ç  Sã€äºŒè¿›åˆ¶ä»£ç  C) = çŠ¶æ€æœº ç¼–è¯‘å™¨ C = compile(S) å®é™…ä¸Šæºä»£ç å’ŒäºŒè¿›åˆ¶ä»£ç æ¶‰åŠçŠ¶æ€è½¬æ¢çš„æ“ä½œåªæœ‰ å†…å­˜æ“ä½œï¼Œå³åªæœ‰å†…å­˜æ“ä½œæ‰ä¼šæ”¹å˜çŠ¶æ€ï¼Œå› ä¸ºç¼–è¯‘å™¨çš„æœ€ä½³åŒ–ç­–ç•¥å¯èƒ½ä¼šå¯¹æºä»£ç å¯¹åº”çš„æŒ‡ä»¤è¿›è¡Œé‡æ’åºï¼Œæ‰€ä»¥ä¹Ÿå¯èƒ½å¯¹å…¶ä¸­çš„å†…å­˜æ“ä½œæŒ‡ä»¤ load, store è¿›è¡Œé‡æ’åºï¼Œè¿™å°±ä½¿å¾—æºä»£ç çŠ¶æ€æœº $S$ å’ŒäºŒè¿›åˆ¶çŠ¶æ€æœº $C$ å¹¶ä¸å®Œå…¨ç­‰ä»·ï¼Œä½†åªè¦ä¿è¯äºŒè€…çš„å¯è§‚æµ‹è¡Œä¸ºæ˜¯ä¸€è‡´çš„å³å¯ï¼Œè¿™ä¹Ÿæ˜¯ç¼–è¯‘å™¨æœ€ä½³åŒ–çš„ç†è®ºåŸºç¡€ã€‚ å‡½æ•°è°ƒç”¨ç›¸å…³çš„ call å’Œ return è¯­å¥åˆ†åˆ«å¯¹åº”çŠ¶æ€æœºçš„è¿›å…¥æ–°çŠ¶æ€å’Œè¿”å›åŸçŠ¶æ€ (ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¦‚æœæ²¡æœ‰ side-affect çš„è¯)ï¼Œå¯ä»¥ä»ä¸Šé¢æ‰€è¯´çš„å†…å­˜æ“ä½œ/å†…å­˜çŠ¶æ€å˜åŒ–çš„è§’åº¦æ¥æ€è€ƒã€‚ åº”ç”¨è§†è§’çš„æ“ä½œç³»ç»Ÿ = syscall æŒ‡ä»¤ åº”ç”¨ç¨‹åºå¯¹åº”çš„çŠ¶æ€æœºè‡ªèº«å¯è½¬æ¢çš„çŠ¶æ€æœ‰é™ï¼Œå¾ˆå¤šçŠ¶æ€éƒ½æ— æ³•ä»…é€šè¿‡è‡ªå·±è¾¾åˆ°ï¼Œæ‰€ä»¥éœ€è¦æ“ä½œç³»ç»Ÿå¤–åŠ å¹²æ¶‰è½¬æ¢æˆæ–°çš„çŠ¶æ€ æ³¨æ„ å•çº¿ç¨‹ç¨‹åºæ˜¯ deterministic çŠ¶æ€æœºï¼Œè€Œå¤šçº¿ç¨‹ç¨‹åºåˆ™æ˜¯ non-deterministic çŠ¶æ€æœºï¼Œè¿™æ˜¯å› ä¸ºæŸä¸ªæ—¶åˆ»ï¼Œé€‰æ‹©å“ªä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œæ˜¯ä¸ç¡®å®šçš„ï¼Œè€Œä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œå¯¹åº”äº†ä¸€ä¸ªçŠ¶æ€è½¬æ¢ (å› ä¸ºå†…å­˜çŠ¶æ€å‘ç”Ÿäº†å˜åŒ–)ï¼Œæ‰€ä»¥æ˜¯ non-deterministic çŠ¶æ€æœºã€‚ æŠ€å·§ å¯¹äºæ–°äº‹ç‰©çš„å­¦ä¹ ï¼Œå…ˆåœ¨ç½‘ä¸Šæœå¯» Tutorial æ•™ç¨‹é˜…è¯»ï¼Œå†æŸ¥é˜… Manual æ‰‹å†Œï¼Œè¿™æ ·æ•ˆæœæ¯”è¾ƒå¥½ è™½ç„¶ printf æœ‰ç¼“å†²åŒºï¼Œä½†å®ƒæ˜¯å¤šçº¿ç¨‹å®‰å…¨çš„: man 3 printf |Interface â”‚ Attribute | |printf(), fprintf(), â”‚ Thread safety | ç¼–è¯‘å™¨å¯¹å†…å­˜è®¿é—® â€œeventually consistentâ€ çš„å¤„ç†å¯¼è‡´å…±äº«å†…å­˜ä½œä¸ºçº¿ç¨‹åŒæ­¥å·¥å…·çš„å¤±æ•ˆã€‚ ç¼–è¯‘å™¨ å’Œ å¤„ç†å™¨ éƒ½å¯ä»¥è¿›è¡Œ æŒ‡ä»¤é‡æ’åºï¼Œè¿™å¯¼è‡´äº†å†™å¹¶å‘ç¨‹åºçš„å›°éš¾ å»¶ä¼¸é˜…è¯»: Intel ä¸­å›½: CPUæ¶æ„å…¨è§ˆ: CPUå¾®æ¶æ„åˆæ˜¯å•¥ï¼Ÿ ä¸¦è¡Œç¨‹å¼è¨­è¨ˆ: åŸ·è¡Œé †åº ","date":"2024-06-16","objectID":"/posts/nju-osdi-concurrency/:1:0","tags":["Linux","OS"],"title":"å—äº¬å¤§å­¦ OSDI å¹¶å‘ é‡ç‚¹æç¤º","uri":"/posts/nju-osdi-concurrency/"},{"categories":["Systems"],"content":"ç†è§£å¹¶å‘ç¨‹åºæ‰§è¡Œ Petersonç®—æ³•ã€æ¨¡å‹æ£€éªŒä¸è½¯ä»¶è‡ªåŠ¨åŒ–å·¥å…· ç›´æ’­å½•å½± / è®²ä¹‰é¡µé¢ / é˜…è¯»ææ–™ ","date":"2024-06-16","objectID":"/posts/nju-osdi-concurrency/:2:0","tags":["Linux","OS"],"title":"å—äº¬å¤§å­¦ OSDI å¹¶å‘ é‡ç‚¹æç¤º","uri":"/posts/nju-osdi-concurrency/"},{"categories":["Rust"],"content":" æ‘˜è¦ å…¶å®ƒè¯­è¨€ï¼šå…„å¼Ÿï¼Œè¯­è¨€å­¦äº†å—ï¼Ÿæ¥å†™ä¸€ä¸ªé“¾è¡¨è¯æ˜ä½ åŸºæœ¬æŒæ¡äº†è¯­æ³•ã€‚ Rust è¯­è¨€: å…„å¼Ÿï¼Œè¯­è¨€ç²¾é€šäº†å—ï¼Ÿæ¥å†™ä¸€ä¸ªé“¾è¡¨è¯æ˜ä½ å·²ç»ç²¾é€šäº† Rustï¼ æ•™å­¦å½•å½± / åŸæ–‡åœ°å€ / ä¸­æ–‡ç¿»è¯‘ ","date":"2024-06-15","objectID":"/posts/too-many-lists/:0:0","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"é€šè¿‡æšä¸¾å®ç° Lisp é£æ ¼çš„é“¾è¡¨ #[derive(Debug)] enum List\u003cT\u003e { Cons(T, Box\u003cList\u003cT\u003e\u003e), Nil, } fn main() { let list: List\u003ci32\u003e = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil)))); println!(\"{:?}\", list); } æ³¨æ„ è¯¥å®ä½œå°† é“¾è¡¨èŠ‚ç‚¹æ•´ä½“ è§†ä¸º æšä¸¾ è¿›è¡ŒåŒºåˆ†ï¼Œå¯¼è‡´ç©ºå…ƒç´ ä¹Ÿä¼šå æ®å†…å­˜ç©ºé—´ ç¬¦å· [] è¡¨ç¤ºæ•°æ®å­˜æ”¾åœ¨ stack ä¸Šï¼Œ() åˆ™è¡¨ç¤ºæ•°æ®å­˜æ”¾åœ¨ heap ä¸Šï¼Œä¸Šé¢ä¾‹å­çš„å†…å­˜åˆ†å¸ƒä¸º: [List 1, ptr] -\u003e (List 2, ptr) -\u003e (Nil) å­˜åœ¨çš„é—®é¢˜: å…ƒç´  1 æ˜¯åˆ†é…åœ¨ stack è€Œä¸æ˜¯ heap ä¸Š æœ€åçš„ç©ºå…ƒç´  Nil ä¹Ÿéœ€è¦åˆ†é…ç©ºé—´ è€Œæˆ‘ä»¬é¢„æœŸçš„å†…å­˜åˆ†å¸ƒä¸º: [ptr] -\u003e (List 1, ptr) -\u003e (List 2, ptr) -\u003e (Nil) è¿™æ ·çš„å†…å­˜åˆ†å¸ƒæ›´åŠ èŠ‚çœ stack ç©ºé—´ï¼Œå¹¶ä¸”å°†æ‰€æœ‰çš„é“¾è¡¨èŠ‚ç‚¹éƒ½æ”¾ç½®åœ¨ heap ä¸Šï¼Œè¿™æ ·åœ¨é“¾è¡¨æ‹†åˆ†å’Œåˆå¹¶æ—¶å°±ä¸éœ€è¦å¯¹å¤´ç»“ç‚¹è¿›è¡Œé¢å¤–è€ƒé‡å’Œå¤„ç†ï¼Œä¸‹é¢æ˜¯ä¸¤ç§å†…å­˜å¸ƒå±€åœ¨é“¾è¡¨æ‹†åˆ†æ—¶çš„å¯¹æ¯”: // first entry in stack [List 1, ptr] -\u003e (List 2, ptr) -\u003e (List 3, ptr) -\u003e (Nil) split off 3: [List 1, ptr] -\u003e (List 2, ptr) -\u003e (Nil) [List 3, ptr] -\u003e (Nil) // first entry in heap [ptr] -\u003e (List 1, ptr) -\u003e (List 2, ptr) -\u003e (List 3, ptr) -\u003e (Nil) split off 3: [ptr] -\u003e (List 1, ptr) -\u003e (List 2, ptr) -\u003e (Nil) [ptr] -\u003e (List 3, ptr) -\u003e (Nil) æ˜¾ç„¶ç¬¬ä¸€ç§æ–¹å¼åœ¨é“¾è¡¨æ‹†åˆ†æ—¶æ¶‰åŠåˆ°é“¾è¡¨å…ƒç´ åœ¨ stack å’Œ heap ä¹‹é—´çš„ä½ç½®å˜æ¢ï¼Œé“¾è¡¨åˆå¹¶ä¹Ÿç±»ä¼¼ï¼Œè¯·è‡ªè¡Œæ€è€ƒã€‚ ä½†æ˜¯è¿™ä¸ªå†…å­˜å¸ƒå±€å¹¶ä¸æ˜¯æœ€å¥½çš„ï¼Œæˆ‘ä»¬æƒ³è¦è¾¾åˆ°ç±»ä¼¼ C/C++ çš„é“¾è¡¨çš„å†…å­˜å¸ƒå±€: [ptr] -\u003e (List 1, ptr) -\u003e (List 2, ptr) -\u003e (List 3, null) ","date":"2024-06-15","objectID":"/posts/too-many-lists/:1:0","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"å®ä½œ C/C++ é£æ ¼çš„é“¾è¡¨ type Link\u003cT\u003e = Option\u003cBox\u003cNode\u003cT\u003e\u003e\u003e; #[derive(Debug)] pub struct List\u003cT\u003e { head: Link\u003cT\u003e, } #[derive(Debug)] struct Node\u003cT\u003e { elem: T, next: Link\u003cT\u003e, } æ³¨æ„ è¯¥å®ä½œå°† é“¾è¡¨èŠ‚ç‚¹çš„ next æŒ‡é’ˆéƒ¨åˆ† è§†ä¸º æšä¸¾ è¿›è¡ŒåŒºåˆ†ï¼Œè¿™æ ·ç©ºå…ƒç´ ä¸ä¼šå æ®å†…å­˜ç©ºé—´ ","date":"2024-06-15","objectID":"/posts/too-many-lists/:2:0","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"new pub fn new() -\u003e Self { Self { head: None } } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:2:1","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"push pub fn push(\u0026mut self, elem: T) { let next = Box::new(Node { elem, next: self.head.take(), }); self.head = Some(next); } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:2:2","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"pop pub fn pop(\u0026mut self) -\u003e Option\u003cT\u003e { self.head.take().map(|node| { self.head = node.next; node.elem }) } æ³¨æ„è¿™é‡Œçš„ pop æ–¹æ³•å¹¶æ²¡æœ‰å¯¹è¢«å¼¹å‡ºçš„èŠ‚ç‚¹ node è¿›è¡Œé‡Šæ”¾ ","date":"2024-06-15","objectID":"/posts/too-many-lists/:2:3","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"drop impl\u003cT\u003e Drop for List\u003cT\u003e { fn drop(\u0026mut self) { let mut link = self.head.take(); while let Some(mut node) = link { link = node.next.take(); } } } å°†æ¯ä¸ªèŠ‚ç‚¹ node è¢«æŒ‡å‘çš„æŒ‡é’ˆ (Box æŒ‡é’ˆ) éƒ½æ¸…é™¤æ‰ï¼Œè¿™æ · Rust çš„æ‰€æœ‰æƒæœºåˆ¶å°±ä¼šå°†è¿™äº›èŠ‚ç‚¹ node å æ®çš„å†…å­˜ç©ºé—´è¿›è¡Œæ¸…ç†ï¼Œè¿™æ ·ç©ºé—´å¤æ‚åº¦ä¸º $O(1)$ã€‚ é€šè¿‡å¾ªç¯æ‰‹åŠ¨å®ç° drop çš„æ„ä¹‰åœ¨äºï¼Œå¦‚æœä¾èµ–è‡ªåŠ¨æ¸…ç†çš„è¯ï¼Œdrop æœºåˆ¶ä¼šä¸æ–­è¿›è¡Œé€’å½’ï¼Œè¿›è€Œå¯èƒ½å¯¼è‡´æ ˆæº¢å‡º (å› ä¸ºæ²¡æœ‰å°¾é€’å½’ä¼˜åŒ–)ï¼Œæ‰€ä»¥ç©ºé—´å¤æ‚åº¦ä¸º $O(N)$ ($N$ ä¸ºé“¾è¡¨èŠ‚ç‚¹ä¸ªæ•°)ã€‚ä¾‹å¦‚å¯¹äºé“¾è¡¨ [a, b, c] çš„è‡ªåŠ¨ dropï¼Œå…¶è°ƒç”¨æ ˆä¸º: stack | | drop(a) | | | drop(b) | v | drop(c) | è€Œæˆ‘ä»¬é€šè¿‡å¾ªç¯æ¥æ‰‹åŠ¨å®ç°çš„ drop åˆ™ä¸ä¼šå¯¼è‡´æ ˆæº¢å‡ºï¼Œå› ä¸ºç©ºé—´å¤æ‚åº¦ä¸º $O(1)$ã€‚ Trait std::ops::Drop ","date":"2024-06-15","objectID":"/posts/too-many-lists/:2:4","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"peek pub fn peek(\u0026self) -\u003e Option\u003c\u0026T\u003e { self.head.as_ref().map(|node| \u0026node.elem) } pub fn peek_mut(\u0026mut self) -\u003e Option\u003c\u0026mut T\u003e { self.head.as_mut().map(|node| \u0026mut node.elem) } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:2:5","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"into_iter impl\u003cT\u003e IntoIterator for List\u003cT\u003e { type Item = T; type IntoIter = IntoIter\u003cT\u003e; fn into_iter(self) -\u003e Self::IntoIter { IntoIter(self) } } pub struct IntoIter\u003cT\u003e(List\u003cT\u003e); impl\u003cT\u003e Iterator for IntoIter\u003cT\u003e { type Item = T; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { self.0.pop() } } Trait std::iter::IntoIterator Trait std::iter::Iterator ","date":"2024-06-15","objectID":"/posts/too-many-lists/:2:6","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"iter impl\u003c'a, T\u003e IntoIterator for \u0026'a List\u003cT\u003e { type Item = \u0026'a T; type IntoIter = Iter\u003c'a, T\u003e; fn into_iter(self) -\u003e Self::IntoIter { Iter(self.head.as_deref()) } } pub struct Iter\u003c'a, T\u003e(Option\u003c\u0026'a Node\u003cT\u003e\u003e); impl\u003c'a, T\u003e Iterator for Iter\u003c'a, T\u003e { type Item = \u0026'a T; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { self.0.take().map(|node| { self.0 = node.next.as_deref(); \u0026node.elem }) } } impl\u003cT\u003e List\u003cT\u003e { pub fn iter(\u0026self) -\u003e Iter\u003cT\u003e { self.into_iter() } } method std::option::Option::as_deref Leaves the original Option in-place, creating a new one with a reference to the original one, additionally coercing the contents via Deref. åœ¨è¿™é‡Œå¯ä»¥ä¸€çª¥ as_deref çš„ä½œç”¨ï¼Œä¾‹å¦‚ä¸‹é¢ä¸¤æ¡è¯­å¥çš„ä½œç”¨æ˜¯ç›¸åŒçš„: self.0 = node.next.as_ref().map(|next| next.as_ref()); self.0 = node.next.as_deref(); æ‰€ä»¥ as_deref æ˜¯åœ¨ as_ref ä½œç”¨çš„åŸºç¡€ä¸Šæ·»åŠ äº† è‡ªåŠ¨ç±»å‹è½¬æ¢ (Deref) åŠŸèƒ½ ","date":"2024-06-15","objectID":"/posts/too-many-lists/:2:7","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"iter_mut impl\u003c'a, T\u003e IntoIterator for \u0026'a mut List\u003cT\u003e { type Item = \u0026'a mut T; type IntoIter = IterMut\u003c'a, T\u003e; fn into_iter(self) -\u003e Self::IntoIter { IterMut(self.head.as_deref_mut()) } } pub struct IterMut\u003c'a, T\u003e(Option\u003c\u0026'a mut Node\u003cT\u003e\u003e); impl\u003c'a, T\u003e Iterator for IterMut\u003c'a, T\u003e { type Item = \u0026'a mut T; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { self.0.take().map(|node| { self.0 = node.next.as_deref_mut(); \u0026mut node.elem }) } } impl\u003cT\u003e List\u003cT\u003e { pub fn iter_mut(\u0026mut self) -\u003e IterMut\u003cT\u003e { self.into_iter() } } method std::option::Option::as_deref_mut Leaves the original Option in-place, creating a new one containing a mutable reference to the inner typeâ€™s Deref::Target type. ","date":"2024-06-15","objectID":"/posts/too-many-lists/:2:8","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"æŒä¹…åŒ–å…±äº«èŠ‚ç‚¹çš„é“¾è¡¨ åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»é€šè¿‡ Box æŒ‡é’ˆå®ç°äº†ä¸€ä¸ªç®€å•çš„å•é“¾è¡¨ï¼Œä½†ç”±äº Rust çš„æ‰€æœ‰æƒæœºåˆ¶ï¼Œå¯¼è‡´è¿™ä¸ªå•é“¾è¡¨çš„èŠ‚ç‚¹ Node åªèƒ½è¢«ä¸€ä¸ª Box æŒ‡é’ˆæŒ‡å‘ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬é€šè¿‡æ™ºèƒ½æŒ‡é’ˆæ¥è§£é™¤è¿™ä¸ªé™åˆ¶ï¼Œå®ä½œ æŒä¹…åŒ–çš„å…±äº«é“¾è¡¨ã€‚ // current list -\u003e A -\u003e B -\u003e C // expect list 1 -\u003e A ---+ | v list 2 -\u003e B -\u003e C -\u003e D ^ | list 3 -\u003e X ---+ list 1: [A, C, D] list 2: [B, C, D] list 3: [X, C, D] ä¸Šå›¾çš„èŠ‚ç‚¹ B çš„è¢«å¤šä¸ªèŠ‚ç‚¹ (èŠ‚ç‚¹ A å’ŒèŠ‚ç‚¹ X) æ‰€æŒ‡å‘ï¼Œè®¾å®šå…¶æ‰€æœ‰æƒæ˜¯å…±äº«çš„æ¯”è¾ƒå¥½å¤„ç†ï¼Œå› ä¸ºä½¿ç”¨å¼•ç”¨çš„è¯ï¼Œä¼šè¢«å€Ÿç”¨æ£€æŸ¥æœºåˆ¶é™åˆ¶ï¼Œä¿®æ”¹æ—¶æ¯”è¾ƒéº»çƒ¦ (åªèƒ½è¢«ä¸€ä¸ªå¯å˜å¼•ç”¨æ‰€å€Ÿç”¨) æŒä¹…åŒ–: èŠ‚ç‚¹å¦‚æœè¢«è‡³å°‘ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘ï¼Œåˆ™ä¸ä¼šé‡Šæ”¾ï¼›å¦‚æœæ²¡æœ‰è¢«æŒ‡å‘ï¼Œåˆ™è¿›è¡Œé‡Šæ”¾ å…±äº«: èŠ‚ç‚¹å¯ä»¥è¢«å¤šä¸ªæŒ‡é’ˆæ‰€æŒ‡å‘ æ ¹æ®è¿™é‡Œè¿™ä¸¤ç§åŠŸèƒ½éœ€æ±‚ï¼Œä½¿ç”¨å…±äº«æ‰€æœ‰æƒå¹¶è¿›è¡Œè®¡æ•°çš„æ™ºèƒ½æŒ‡é’ˆ std::rc::Rc æ¯”è¾ƒé€‚åˆã€‚ use std::rc::Rc; type Link\u003cT\u003e = Option\u003cRc\u003cNode\u003cT\u003e\u003e\u003e; #[derive(Debug)] pub struct List\u003cT\u003e { head: Link\u003cT\u003e, } #[derive(Debug)] struct Node\u003cT\u003e { elem: T, next: Link\u003cT\u003e, } impl\u003cT\u003e List\u003cT\u003e { pub fn new() -\u003e Self { Self { head: None } } } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:3:0","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"prepend // It takes a list and an element, and returns a List. pub fn prepend(\u0026mut self, elem: T) -\u003e Self { Self { head: Some(Rc::new(Node { elem, next: self.head.clone(), })), } } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:3:1","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"tail // It takes a list and returns the whole list with the first element removed. pub fn tail(\u0026mut self) -\u003e Self { Self { head: self.head.as_ref().and_then(|node| node.next.clone()), } } è¿™é‡Œå¯ä»¥ä½“éªŒ map å’Œ and_then çš„åŒºåˆ«ï¼Œåœ¨äºå…¶æ¥å—çš„é—­åŒ…çš„ä¸åŒï¼Œmap é—­åŒ…çš„è¿”å›å€¼ä¼šè¢«è‡ªåŠ¨çš„ç”¨ Option åŒ…è£…èµ·æ¥ï¼Œè€Œ and_then åˆ™éœ€è¦è‡ªå·±åœ¨é—­åŒ…ä¸­æ‰‹åŠ¨åŒ…è£…: pub fn map\u003cU, F\u003e(self, f: F) -\u003e Option\u003cU\u003e where F: FnOnce(T) -\u003e U, pub fn and_then\u003cU, F\u003e(self, f: F) -\u003e Option\u003cU\u003e where F: FnOnce(T) -\u003e Option\u003cU\u003e, ","date":"2024-06-15","objectID":"/posts/too-many-lists/:3:2","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"head // returns a reference to the first element. pub fn head(\u0026self) -\u003e Option\u003c\u0026T\u003e { self.head.as_ref().map(|node| \u0026node.elem) } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:3:3","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"iter æˆ‘ä»¬åªå®ç° iter è€Œä¸æ˜¯å®ç° into_iter å’Œ iter_mut è¿™ä¸¤ä¸ªæ–¹æ³•ï¼Œå› ä¸ºæŒä¹…åŒ–å…±äº«èŠ‚ç‚¹çš„é“¾è¡¨çš„æŸä¸€äº›èŠ‚ç‚¹æ˜¯è¢«å…±äº«çš„ï¼Œæ‰€ä»¥ into_iter å¸æ˜¾ç„¶å°±ä¸èƒ½è¢«å®ç°ï¼Œå‡è®¾ä¸€ä¸ªé“¾è¡¨ä½¿ç”¨äº† into_iter é‚£ä¹ˆå…¶ä»–å…±äº«å…¶èŠ‚ç‚¹çš„é“¾è¡¨å°±ä¼šæœ‰ä¸€éƒ¨åˆ†å‡­ç©ºæ¶ˆå¤±äº†ï¼Œè¿™è¿åäº†æ‰€æœ‰æƒæœºåˆ¶ï¼Œè€Œ iter_mut ä¹Ÿç±»ä¼¼ï¼Œä¸¤ä¸ªé“¾è¡¨éƒ½æ˜¯ä½¿ç”¨ iter_mutï¼Œå¦‚æœå®ƒä»¬æœ‰å…±äº«èŠ‚ç‚¹ï¼Œé‚£ä¹ˆåœ¨å…±äº«èŠ‚ç‚¹ä¸Šæœ‰ä¸€ä¸ªè¿­ä»£å™¨å°±ä¸èƒ½æ­£å¸¸å·¥ä½œ (æ ¹æ®å€Ÿç”¨æ£€æŸ¥æœºåˆ¶ï¼ŒåŒä¸€æ—¶é—´åªèƒ½å­˜åœ¨ä¸€ä¸ªå¯å˜å¼•ç”¨)ã€‚ impl\u003c'a, T\u003e IntoIterator for \u0026'a List\u003cT\u003e { type Item = \u0026'a T; type IntoIter = Iter\u003c'a, T\u003e; fn into_iter(self) -\u003e Self::IntoIter { Iter(self.head.as_deref()) } } pub struct Iter\u003c'a, T\u003e(Option\u003c\u0026'a Node\u003cT\u003e\u003e); impl\u003c'a, T\u003e Iterator for Iter\u003c'a, T\u003e { type Item = \u0026'a T; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { self.0.take().map(|node| { self.0 = node.next.as_deref(); \u0026node.elem }) } } impl\u003cT\u003e List\u003cT\u003e { pub fn iter(\u0026self) -\u003e Iter\u003cT\u003e { self.into_iter() } } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:3:4","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"drop drop æ–¹æ³•å°†ä¸€ä¸ªé“¾è¡¨ä¸­åªè¢«è¯¥é“¾è¡¨æ‹¥æœ‰çš„èŠ‚ç‚¹ Node è¿›è¡Œé‡Šæ”¾ï¼Œå¯¹äºå…±äº«çš„èŠ‚ç‚¹åˆ™ä¸åšå¤„ç†ã€‚ impl\u003cT\u003e Drop for List\u003cT\u003e { fn drop(\u0026mut self) { let mut link = self.head.take(); while let Some(node) = link { if let Ok(ref mut node) = Rc::try_unwrap(node) { link = node.next.take(); } else { break; } } } } method std::rc::Rc::try_unwrap Returns the inner value, if the Rc has exactly one strong reference. Otherwise, an Err is returned with the same Rc that was passed in. ","date":"2024-06-15","objectID":"/posts/too-many-lists/:3:5","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"å¤šçº¿ç¨‹å®‰å…¨ Rc ä¸æ˜¯å¤šçº¿ç¨‹å®‰å…¨çš„ï¼Œå¦‚æœè¦è®©æˆ‘ä»¬è¿™ä¸ªæŒä¹…åŒ–é“¾è¡¨åœ¨å¤šçº¿ç¨‹æƒ…æ™¯ä¸‹å®‰å…¨ä½¿ç”¨ï¼Œåˆ™éœ€è¦ä½¿ç”¨ Arc æ™ºèƒ½æŒ‡é’ˆã€‚ use std::sync::Arc; type Link\u003cT\u003e = Option\u003cArc\u003cNode\u003cT\u003e\u003e\u003e; impl\u003cT\u003e Drop for List\u003cT\u003e { fn drop(\u0026mut self) { ... if let Ok(ref mut node) = Arc::try_unwrap(node) {...} ... } } method std::sync::Arc::try_unwrap å»¶ä¼¸é˜…è¯» ç†è§£å¤šçº¿ç¨‹å®‰å…¨çš„å†…éƒ¨æœºåˆ¶éœ€è¦äº†è§£å†…å­˜æ¨¡å‹ï¼Œä¸‹é¢è¿™ä¸ªè®²åº§è§£é‡Šå¾—å¾ˆæ£’ï¼ Herb Sutter: atomic Weapons: The C++ Memory Model and Modern Hardware ","date":"2024-06-15","objectID":"/posts/too-many-lists/:3:6","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"åŒç«¯é“¾è¡¨ åœ¨å‰é¢æŒä¹…åŒ–é“¾è¡¨çš„åŸºç¡€ä¸Šï¼Œä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ RefCell æ¥å®ç°èŠ‚ç‚¹ Node çš„å†…éƒ¨å¯å˜æ€§ï¼Œå¹¶æ­é… Rc æ¥è¿›è¡Œå¼•ç”¨è®¡æ•°: use std::{cell::RefCell, rc::Rc}; type Link\u003cT\u003e = Option\u003cRc\u003cRefCell\u003cNode\u003cT\u003e\u003e\u003e; å»¶ä¼¸é˜…è¯»: Crust of Rust: Smart Pointers and Interior Mutability #[derive(Debug)] pub struct List\u003cT\u003e { head: Link\u003cT\u003e, tail: Link\u003cT\u003e, } #[derive(Debug)] struct Node\u003cT\u003e { elem: T, next: Link\u003cT\u003e, prev: Link\u003cT\u003e, } impl\u003cT\u003e Node\u003cT\u003e { pub fn new(elem: T) -\u003e Self { Self { elem, next: None, prev: None, } } } impl\u003cT\u003e List\u003cT\u003e { pub fn new() -\u003e Self { Self { head: None, tail: None, } } } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:4:0","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"push pub fn push_front(\u0026mut self, elem: T) { let node = Rc::new(RefCell::new(Node::new(elem))); match self.head.take() { Some(head) =\u003e { node.borrow_mut().next = Some(head.clone()); head.borrow_mut().prev = Some(node.clone()); self.head = Some(node.clone()); } None =\u003e { self.head = Some(node.clone()); self.tail = Some(node.clone()); } } } pub fn push_back(\u0026mut self, elem: T) { let node = Rc::new(RefCell::new(Node::new(elem))); match self.tail.take() { Some(tail) =\u003e { node.borrow_mut().prev = Some(tail.clone()); tail.borrow_mut().next = Some(node.clone()); self.tail = Some(node.clone()); } None =\u003e { self.head = Some(node.clone()); self.tail = Some(node.clone()); } } } method std::cell::RefCell::borrow_mut ","date":"2024-06-15","objectID":"/posts/too-many-lists/:4:1","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"pop pub fn pop_front(\u0026mut self) -\u003e Option\u003cT\u003e { self.head.take().map(|node| { match node.borrow_mut().next.take() { Some(next) =\u003e { next.borrow_mut().prev.take(); self.head = Some(next.clone()); } None =\u003e { self.tail.take(); } } Rc::try_unwrap(node).ok().unwrap().into_inner().elem }) } pub fn pop_back(\u0026mut self) -\u003e Option\u003cT\u003e { self.tail.take().map(|node| { match node.borrow_mut().prev.take() { Some(prev) =\u003e { prev.borrow_mut().next.take(); self.tail = Some(prev.clone()); } None =\u003e { self.head.take(); } } Rc::try_unwrap(node).ok().unwrap().into_inner().elem }) } Since we donâ€™t care about the case where it fails (if we wrote our program correctly, it has to succeed), we just call unwrap on it. æ­£å¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸ä¼šå¯¹å…±äº«èŠ‚ç‚¹è¿›è¡Œ pop æ“ä½œï¼Œé˜²æ­¢å‡ºç°æ•°æ®ä¸ä¸€è‡´çš„æƒ…å†µï¼Œæ‰€ä»¥è¿™é‡Œå¯ä»¥ç›´æ¥ä½¿ç”¨ unwrap æ¥è·å–å†…éƒ¨æ•°æ® (å› ä¸ºæˆ‘ä»¬é€šè¿‡ contract æ¥ä¿ä½ä¸ä¼šå‡ºç° None çš„æƒ…å†µ)ã€‚ method std::rc::Rc::try_unwrap method std::cell::RefCell::into_inner ","date":"2024-06-15","objectID":"/posts/too-many-lists/:4:2","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"peek pub fn peek_front(\u0026self) -\u003e Option\u003cRef\u003cT\u003e\u003e { self.head .as_ref() .map(|node| Ref::map(node.borrow(), |node| \u0026node.elem)) } pub fn peek_back(\u0026self) -\u003e Option\u003cRef\u003cT\u003e\u003e { self.tail .as_ref() .map(|node| Ref::map(node.borrow(), |node| \u0026node.elem)) } method std::cell::RefCell::borrow method std::cell::Ref::map pub fn peek_mut_front(\u0026mut self) -\u003e Option\u003cRefMut\u003cT\u003e\u003e { self.head .as_ref() .map(|node| RefMut::map(node.borrow_mut(), |node| \u0026mut node.elem)) } pub fn peek_mut_back(\u0026mut self) -\u003e Option\u003cRefMut\u003cT\u003e\u003e { self.tail .as_ref() .map(|node| RefMut::map(node.borrow_mut(), |node| \u0026mut node.elem)) } method std::cell::RefCell::borrow_mut method std::cell::RefMut::map ","date":"2024-06-15","objectID":"/posts/too-many-lists/:4:3","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"iter impl\u003cT\u003e IntoIterator for List\u003cT\u003e { type Item = T; type IntoIter = IntoIter\u003cT\u003e; fn into_iter(self) -\u003e Self::IntoIter { IntoIter(self) } } pub struct IntoIter\u003cT\u003e(List\u003cT\u003e); impl\u003cT\u003e Iterator for IntoIter\u003cT\u003e { type Item = T; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { self.0.pop_front() } } impl\u003cT\u003e DoubleEndedIterator for IntoIter\u003cT\u003e { fn next_back(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { self.0.pop_back() } } impl\u003cT\u003e List\u003cT\u003e { pub fn into_iter(self) -\u003e IntoIter\u003cT\u003e { IntoIterator::into_iter(self) } } Trait std::iter::Iterator Trait std::iter::DoubleEndedIterator ","date":"2024-06-15","objectID":"/posts/too-many-lists/:4:4","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"Unsafe Rust å®ä½œå•é“¾è¡¨ æˆ‘ä»¬å¯¹ä¹‹å‰å®ç°çš„ C/C++ é£æ ¼çš„å•é“¾è¡¨è¿›è¡Œæ”¹è¿›ï¼Œä½¿å…¶ä¸ºæ»¡è¶³ å…ˆè¿›å…ˆå‡º æ€§è´¨çš„å•é“¾è¡¨ã€‚ä½†æ˜¯å¦‚æœä¸ä½¿ç”¨ Unsafe Rust æ¥å®ä½œçš„è¯ï¼Œå¾ˆå®¹æ˜“å°±ä¼šè¿å Rust çš„å€Ÿç”¨è§„åˆ™ (å› ä¸ºæˆ‘ä»¬éœ€è¦ä¸€ä¸ª tail æˆå‘˜æ¥æŒ‡å‘å°¾èŠ‚ç‚¹)ï¼Œä¾‹å¦‚æˆ‘ä»¬å°† List çš„ tail ç”¨å¯å˜å¼•ç”¨æ¥è¡¨ç¤º: pub struct List\u003cT\u003e { head: Link\u003cT\u003e, tail: Option\u003c\u0026mut Node\u003cT\u003e\u003e, } é‚£ä¹ˆå¯¹äº List é‚£äº›ä½¿ç”¨å¯å˜åº”ç”¨ \u0026mut self çš„æ–¹æ³•ï¼Œè°ƒç”¨è¿™äº›æ–¹æ³•æ—¶å¯¹è¿™ä¸ªé“¾è¡¨ä¼šå­˜åœ¨ä¸¤ä¸ªå¯å˜å¼•ç”¨ï¼Œä¸€ä¸ªæ˜¯ tail è¡¨ç¤ºå¯å˜å¼•ç”¨ï¼Œå¦ä¸€ä¸ªåˆ™æ˜¯ \u0026mut self è¡¨ç¤ºçš„å¯å˜å¼•ç”¨ï¼Œè¿™æ˜¾ç„¶è¿åäº† Rust çš„å€Ÿç”¨æ£€æŸ¥æœºåˆ¶ï¼Œå› æ­¤ç¼–è¯‘ä¸é€šè¿‡ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä½¿ç”¨ Unsafe Rust çš„è£¸æŒ‡é’ˆ raw pointer æ¥å®ç°ï¼Œä»¥é¿å¼€ Rust çš„å€Ÿç”¨æ£€æŸ¥æœºåˆ¶ã€‚ æ³¨æ„ ä¹‹æ‰€ä»¥ä¸ä½¿ç”¨ Link\u003cT\u003e æ¥è¡¨ç¤º tailï¼Œæ˜¯å› ä¸º Box æŒ‡é’ˆå’Œ Rc æŒ‡é’ˆä¸ä¸€æ ·ï¼Œå®ƒåªå…è®¸ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å¯¹äºçš„æ•°æ®ï¼Œæ‰€ä»¥å½“é“¾è¡¨åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œhead å’Œ tail éƒ½æŒ‡å‘åŒä¸€ä¸ª Nodeï¼Œä½†è¿™ç§æƒ…å†µ Box æŒ‡é’ˆæ— æ³•åšåˆ°ã€‚ use std::ptr; type Link\u003cT\u003e = Option\u003cBox\u003cNode\u003cT\u003e\u003e\u003e; #[derive(Debug)] pub struct List\u003cT\u003e { head: Link\u003cT\u003e, tail: *mut Node\u003cT\u003e, } #[derive(Debug)] struct Node\u003cT\u003e { elem: T, next: Link\u003cT\u003e, } impl\u003cT\u003e List\u003cT\u003e { pub fn new() -\u003e Self { Self { head: None, tail: ptr::null_mut(), } } } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:5:0","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"push pub fn push(\u0026mut self, elem: T) { let mut node = Box::new(Node { elem, next: None }); let raw_tail: *mut _ = \u0026mut *node; if self.tail.is_null() { self.head = Some(node); } else { unsafe { (*self.tail).next = Some(node); } } self.tail = raw_tail; } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:5:1","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"pop pub fn pop(\u0026mut self) -\u003e Option\u003cT\u003e { self.head.take().map(|head| { let next = head.next; if next.is_none() { self.tail = ptr::null_mut(); } self.head = next; head.elem }) } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:5:2","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"drop impl\u003cT\u003e Drop for List\u003cT\u003e { fn drop(\u0026mut self) { let mut link = self.head.take(); while let Some(mut node) = link { link = node.next.take(); } } } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:5:3","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"iter into_iter impl\u003cT\u003e IntoIterator for List\u003cT\u003e { type Item = T; type IntoIter = IntoIter\u003cT\u003e; fn into_iter(self) -\u003e Self::IntoIter { IntoIter(self) } } pub struct IntoIter\u003cT\u003e(List\u003cT\u003e); impl\u003cT\u003e Iterator for IntoIter\u003cT\u003e { type Item = T; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { self.0.pop() } } iter impl\u003cT\u003e List\u003cT\u003e { pub fn iter(\u0026self) -\u003e Iter\u003cT\u003e { self.into_iter() } } impl\u003c'a, T\u003e IntoIterator for \u0026'a List\u003cT\u003e { type Item = \u0026'a T; type IntoIter = Iter\u003c'a, T\u003e; fn into_iter(self) -\u003e Self::IntoIter { Iter(self.head.as_deref()) } } pub struct Iter\u003c'a, T\u003e(Option\u003c\u0026'a Node\u003cT\u003e\u003e); impl\u003c'a, T\u003e Iterator for Iter\u003c'a, T\u003e { type Item = \u0026'a T; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { self.0.take().map(|node| { self.0 = node.next.as_deref(); \u0026node.elem }) } } iter_mut impl\u003cT\u003e List\u003cT\u003e { pub fn iter_mut(\u0026mut self) -\u003e IterMut\u003cT\u003e { self.into_iter() } } impl\u003c'a, T\u003e IntoIterator for \u0026'a mut List\u003cT\u003e { type Item = \u0026'a mut T; type IntoIter = IterMut\u003c'a, T\u003e; fn into_iter(self) -\u003e Self::IntoIter { IterMut(self.head.as_deref_mut()) } } pub struct IterMut\u003c'a, T\u003e(Option\u003c\u0026'a mut Node\u003cT\u003e\u003e); impl\u003c'a, T\u003e Iterator for IterMut\u003c'a, T\u003e { type Item = \u0026'a mut T; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { self.0.take().map(|node| { self.0 = node.next.as_deref_mut(); \u0026mut node.elem }) } } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:5:4","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"å…¶ä»–æ¡ˆä¾‹å®ä½œ ","date":"2024-06-15","objectID":"/posts/too-many-lists/:6:0","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"Stack Wikipedia: Stack (abstract data type) å®ä½œå’Œä¹‹å‰çš„ C/C++ é£æ ¼çš„å•é“¾è¡¨ç±»ä¼¼ï¼Œè¿™é‡Œä»…åˆ—å‡ºä¸åŒçš„å‡½æ•°: fn push_node(\u0026mut self, mut node: Box\u003cNode\u003cT\u003e\u003e) { node.next = self.head.take(); self.head = Some(node); } fn pop_node(\u0026mut self) -\u003e Option\u003cBox\u003cNode\u003cT\u003e\u003e\u003e { self.head.take().map(|mut node| { self.head = node.next.take(); node }) } fn peek_node(\u0026self) -\u003e Option\u003c\u0026Node\u003cT\u003e\u003e { self.head.as_deref() } fn peek_mut_node(\u0026mut self) -\u003e Option\u003c\u0026mut Node\u003cT\u003e\u003e { self.head.as_deref_mut() } ä¸»è¦æ˜¯ä¸€äº›è¾…åŠ©å‡½æ•°ï¼Œç”¨äºå¸®åŠ©å®ç° push, pop, peek, peek_mut ç­‰ç­‰æ ¸å¿ƒåŠŸèƒ½å‡½æ•° ","date":"2024-06-15","objectID":"/posts/too-many-lists/:6:1","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"Deque Wikipedia: Double-ended queue å¯ä»¥ä½¿ç”¨ä¸¤ä¸ª Stack æ¥å®ä½œåŒç«¯é˜Ÿåˆ—ï¼Œå½“ç„¶è¿™ä¸ª Deque ä½¿ç”¨èµ·æ¥ååˆ†ä¸ä¾¿ï¼Œè¿™é‡Œä»…ä½œä¸ºå±•ç¤ºç”¨é€”: pub struct Deque\u003cT\u003e { left: Stack\u003cT\u003e, right: Stack\u003cT\u003e, } impl\u003cT\u003e Deque\u003cT\u003e { pub fn go_left(\u0026mut self) -\u003e bool { self.left .pop_node() .map(|node| self.right.push_node(node)) .is_some() } pub fn go_right(\u0026mut self) -\u003e bool { self.right .pop_node() .map(|node| self.left.push_node(node)) .is_some() } } ","date":"2024-06-15","objectID":"/posts/too-many-lists/:6:2","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"Homework ä¿¡æ¯ æ•™å­¦å½•å½±ä¸­æ²¡æœ‰å¯¹ Chapter 7 è¿›è¡Œè®²è§£ï¼Œè‡ªè¡Œé˜…è¯»å¹¶å®ä½œé‡Œé¢ç›¸åº”çš„å†…å®¹ã€‚ é˜…è¯»åŸä¹¦ 8.2. The Stack-Allocated Linked List å°èŠ‚ï¼Œå¹¶å®Œæˆç›¸åº”å®ä½œã€‚ ","date":"2024-06-15","objectID":"/posts/too-many-lists/:7:0","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-06-15","objectID":"/posts/too-many-lists/:8:0","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":"Crate std å¯ä»¥ä½¿ç”¨è¿™é‡Œæä¾›çš„æœç´ æ è¿›è¡Œæœç´¢ (BTW ä¸è¦æµªè´¹æ—¶é—´åœ¨ Google æœå¯»ä¸Šï¼) Function std::mem::replace Enum std::option::Option method std::option::Option::take method std::option::Option::map method std::option::Option::and_then method std::option::Option::as_ref method std::option::Option::as_mut method std::option::Option::as_deref method std::option::Option::as_deref_mut method std::option::Option::is_none method std::option::Option::is_some trait method std::convert::AsRef::as_ref method std::boxed::Box::as_ref method std::rc::Rc::as_ref method std::sync::Arc::as_ref method std::result::Result::ok method pointer::is_null Function std::ptr::null_mut ","date":"2024-06-15","objectID":"/posts/too-many-lists/:8:1","tags":["Rust","Sysprog","Linked List"],"title":"æ‰‹æŠŠæ‰‹å¸¦ä½ ä½¿ç”¨ Rust å®ç°é“¾è¡¨","uri":"/posts/too-many-lists/"},{"categories":["Rust"],"content":" Programming the Linux Kernel for Enhanced Observability, Networking, and Security ","date":"2024-06-10","objectID":"/posts/rust-ebpf/:0:0","tags":["Rust","Sysprog","eBPF"],"title":"Rust: é€è¿‡ eBPF æ¢æµ‹æ“ä½œç³»ç»Ÿè¡Œä¸º","uri":"/posts/rust-ebpf/"},{"categories":["Rust"],"content":"å®éªŒç¯å¢ƒ $ neofetch --stdout cai@cai-PC ---------- OS: Deepin 20.9 x86_64 Host: RedmiBook 14 II Kernel: 5.15.77-amd64-desktop Uptime: 1 hour, 55 mins Packages: 2145 (dpkg) Shell: bash 5.0.3 Resolution: 1920x1080 DE: Deepin WM: KWin Theme: deepin-dark [GTK2/3] Icons: bloom-classic-dark [GTK2/3] Terminal: deepin-terminal CPU: Intel i7-1065G7 (8) @ 3.900GHz GPU: NVIDIA GeForce MX350 GPU: Intel Iris Plus Graphics G7 Memory: 11361MiB / 15800MiB å» bpftrace çš„ Github Releases é¡µé¢ï¼Œä¸‹è½½ç›¸åº”ç‰ˆæœ¬çš„ bpftraceï¼Œè¿™é‡Œä»¥ 0.20.4 ä¸ºä¾‹: $ curl --location-trusted -O https://github.com/bpftrace/bpftrace/releases/download/v0.20.4/bpftrace $ chmod a+x bpftrace $ ./bpftrace -V bpftrace v0.20.4 # add path to bpftrace to ~/.bashrc $ bpftrace -V bpftrace v0.20.4 å®‰è£…å†…æ ¸å¯¹åº” bpftool ç»„ä»¶ (è¿™ä¸ªç»„ä»¶è¿æ¥å†…æ ¸ä¸­çš„ eBPF æ¨¡å—å’Œå¤–éƒ¨çš„ bpf å·¥å…·ï¼Œä¾‹å¦‚ bpftrace): $ sudo apt install -y bpftool $ bpftool version bpftool v5.15.5 æ³¨æ„ å› ä¸º eBPF ç¨‹åºæ˜¯åœ¨å†…æ ¸ä¸­æ‰§è¡Œçš„ï¼Œæ‰€ä»¥ä¸‹é¢çš„å®ä¾‹ä»£ç ã€å‘½ä»¤éƒ½éœ€è¦æå‡æƒçº§ï¼Œåœ¨ root æ¨¡å¼ä¸‹æ‰§è¡Œã€‚ è­¦å‘Š ç”±äº deepin 20.9 çš„å†…æ ¸ç‰ˆæœ¬è¿‡ä½ (ä»…ä¸º 5.15)ï¼Œå¯¹ eBPF çš„æ”¯æŒå¹¶æœªå®Œå–„ (ä½¿ç”¨ -l å‚æ•°è¾“å‡ºçš„å¯ç”¨æ¢æµ‹ç‚¹æ¯”è¾ƒå°‘)ï¼Œæ‰€ä»¥åæœŸä¼šä½¿ç”¨ openSUSE Tumbleweed é‡åšæœ¬å®éªŒã€‚ ","date":"2024-06-10","objectID":"/posts/rust-ebpf/:1:0","tags":["Rust","Sysprog","eBPF"],"title":"Rust: é€è¿‡ eBPF æ¢æµ‹æ“ä½œç³»ç»Ÿè¡Œä¸º","uri":"/posts/rust-ebpf/"},{"categories":["Rust"],"content":"å®ä½œæ¡ˆä¾‹: é€šè¿‡ bpftrace æŠ“å– HTTPS æµé‡ ä¿¡æ¯ è®²è§£è§†é¢‘ / è®²ä¹‰ Learning eBPF Chapter 10: eBPF Programming The bpftrace command-line tool converts programs written in this high-level lanâ€ guage into eBPF kernel code and provides some output formatting for the results within the terminal. bpftrace å¯ä»¥å°†æˆ‘ä»¬ç¼–å†™çš„é«˜çº§ç¨‹åºè¯­è¨€è½¬æ¢æˆå¯¹åº”çš„ BPF å­—èŠ‚ç ï¼Œç”¨äºåç»­ç»™å†…æ ¸ä¸­çš„ BPF è™šæ‹Ÿæœºæ‰§è¡Œ bpftrace -e 'kprobe:do_execve { @[comm] = count(); }' Attaching 1 probe... ^C @[node]: 6 @[sh]: 6 @[cpuUsage.sh]: 18 å…¶ä¸­ { @[comm] = count(); } è¡¨ç¤ºåŒ=ç»Ÿè®¡æ¯ä¸ªå‘½ä»¤è§¦å‘ do_execve è¿™ä¸ªæ¢é’ˆç‚¹çš„æ¬¡æ•°ï¼Œcomm è¡¨ç¤º commandï¼Œè€Œ count() é¡¾åæ€ä¹‰å°±æ˜¯ç»Ÿè®¡æ¬¡æ•°ï¼Œæ‰€ä»¥é€šè¿‡ Ctrl-C ä¸­æ–­è¯¥ BPF è„šæœ¬æ‰§è¡Œåï¼Œè¾“å‡ºçš„æ˜¯å„ä¸ªå‘½ä»¤è§¦å‘ do_execve è¿™ä¸ªæ¢é’ˆç‚¹çš„æ¬¡æ•°ã€‚ bpftrace(8) Manual Page: Variables and Maps bpftrace knows two types of variables, â€˜scratchâ€™ and â€˜mapâ€™. â€˜mapâ€™ variables use BPF â€˜mapsâ€™. These exist for the lifetime of bpftrace itself and can be accessed from all action blocks and user-space. Map names always start with a @, e.g. @mymap. æ³¨æ„ å®é™…ä¸Šå½¢å¦‚ @[] è¿™ç±»çš„ä»£ç å…¶å®æ˜¯ eBPF ä¸­çš„ä¸€ä¸ªé‡è¦æ•°æ®ç»“æ„ mapï¼Œå³é”®å€¼å¯¹ï¼Œå®ƒå¸¸è¢«ç”¨äºåœ¨ä¸åŒçš„ eBPF ç¨‹åºä¹‹é—´è¿›è¡Œæ•°æ®çš„ä¼ é€’ã€‚ Scripts for bpftrace can coordinate multiple eBPF programs attached to different events. tracepoint:syscalls:sys_enter_open, tracepoint:syscalls:sys_enter_openat { @filename[tid] = args.filename; } tracepoint:syscalls:sys_exit_open, tracepoint:syscalls:sys_exit_openat /@filename[tid]/ { $ret = args.ret; $fd = $ret \u003e= 0 ? $ret : -1; $errno = $ret \u003e= 0 ? 0 : - $ret; printf(\"%-6d %-16s %4d %3d %s\\n\", pid, comm, $fd, $errno, str(@filename[tid])); delete(@filename[tid]); } @filename å¦‚å‰é¢æ‰€è¯´ï¼Œè¡¨ç¤ºä¸€ä¸ª mapï¼Œè€Œç¬¬ 9 è¡Œçš„ /@filename[tid]/ åˆ™è¡¨ç¤ºï¼Œå½“ filename è¿™ä¸ª map ä¸­é”® tid å¯¹åº”çš„å€¼å­˜åœ¨æ—¶æ‰æ‰§è¡Œè¿™ä¸€éƒ¨åˆ†é€»è¾‘ã€‚ bpftrace(8) Manual Page: Filtering Filters (also known as predicates) can be added after probe names. The probe still fires, but it will skip the action unless the filter is true. #ifndef BPFTRACE_HAVE_BTF #include \u003cnet/tcp_states.h\u003e #include \u003cnet/sock.h\u003e #include \u003clinux/socket.h\u003e #include \u003clinux/tcp.h\u003e #else #include \u003csys/socket.h\u003e #endif uprobe:/usr/local/lib/libssl.so:SSL_write { @write_buf[tid] = arg1; } uretprobe:/usr/local/lib/libssl.so:SSL_write /@write_buf[tid]/ { $buf = @write_buf[tid]; $len = (int32)retval; if ($len \u003c= 0) { return; } @write_sock[tid] = true; $i = 0; $consumed = 0; printf(\"write[%d] starting\\n\", $len); while ($i \u003c= 500) { $i += 1; if ($len - $consumed \u003e 64) { printf(\"%r\\n\", buf($buf, 64)); $buf += (uint64)64; $consumed += 64; } else { $remaining = $len - $consumed; printf(\"%r\\n\", buf($buf, $remaining)); $buf += (uint64)$remaining; $consumed = $len; break; } } printf(\"write[%d] ending\\n\", $len); delete(@write_buf[tid]); } kprobe:tcp_sendmsg /@write_sock[tid]/ { $sk = (struct sock *)arg0; $lport = $sk-\u003e__sk_common.skc_num; $dport = $sk-\u003e__sk_common.skc_dport; $dport = bswap($dport); $saddr = ntop(0); $daddr = ntop(0); $family = $sk-\u003e__sk_common.skc_family; if ($family == AF_INET) { $saddr = ntop(AF_INET, $sk-\u003e__sk_common.skc_rcv_saddr); $daddr = ntop(AF_INET, $sk-\u003e__sk_common.skc_daddr); } else { // AF_INET6 $saddr = ntop(AF_INET6, $sk-\u003e__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr8); $daddr = ntop(AF_INET6, $sk-\u003e__sk_common.skc_v6_daddr.in6_u.u6_addr8); } printf(\"send: %-15s %-5d %-15s %-6d\\n\", $saddr, $lport, $daddr, $dport); delete(@write_sock[tid]); } uprobe:/usr/local/lib/libssl.so:SSL_read { @read_buf[tid] = arg1; } uretprobe:/usr/local/lib/libssl.so:SSL_read /@read_buf[tid]/ { $buf = @read_buf[tid]; $len = (int32)retval; if ($len \u003c= 0) { return; } @read_sock[tid] = true; $i = 0; $consumed = 0; printf(\"read[%d] starting\\n\", $len); while ($i \u003c= 500) { $i += 1; if ($len - $consumed \u003e 64) { printf(\"%r\\n\", buf($buf, 64)); $buf += (uint64)64; $consumed += 64; } else { $remaining = $len - $consumed; printf(\"%r\\n\", buf($buf, $remaining)); $buf += (uint64)$remaining; $consumed = $len; break; } } printf(\"read[%d] ending\\n\", $len); delete(@read_buf[tid]); } kprobe:tcp_recvmsg /@read_sock[tid]/ { $sk = (struct sock *)arg0; $lport = $sk-\u003e__sk_common.skc_num; $dport = $sk-\u003e__sk_common.skc_dport; $dport = bswap($dport); $saddr = ntop(0); $daddr = ntop(0); $family = $sk-\u003e__sk_common.skc_family; if ($family == AF_INE","date":"2024-06-10","objectID":"/posts/rust-ebpf/:2:0","tags":["Rust","Sysprog","eBPF"],"title":"Rust: é€è¿‡ eBPF æ¢æµ‹æ“ä½œç³»ç»Ÿè¡Œä¸º","uri":"/posts/rust-ebpf/"},{"categories":["Rust"],"content":"Improving the eBPF Developer Experience with Rust Dave Tucker/Alessandro Decina: ç›´æ’­å½•å½± / æŠ•å½±ç‰‡ ","date":"2024-06-10","objectID":"/posts/rust-ebpf/:3:0","tags":["Rust","Sysprog","eBPF"],"title":"Rust: é€è¿‡ eBPF æ¢æµ‹æ“ä½œç³»ç»Ÿè¡Œä¸º","uri":"/posts/rust-ebpf/"},{"categories":["Rust"],"content":"References bpftrace ","date":"2024-06-10","objectID":"/posts/rust-ebpf/:4:0","tags":["Rust","Sysprog","eBPF"],"title":"Rust: é€è¿‡ eBPF æ¢æµ‹æ“ä½œç³»ç»Ÿè¡Œä¸º","uri":"/posts/rust-ebpf/"},{"categories":["Linux","Linux Kernel Internals"],"content":" 2001 å¹´ï¼ŒJ. T. S. Moore ä»¥è‡ªç”±è»Ÿé«”å’Œé–‹æ”¾åŸå§‹ç¢¼è»Ÿé«”ç™¼å±•ç‚ºä¸»é¡Œï¼Œå°æ¼”ç›¸ç•¶å¯è²´çš„ç´€éŒ„ç‰‡ã€ŠRevolution OSã€‹ï¼Œè¨ªè«‡è‹¥å¹²å…ˆé‹’è€…ï¼Œæ˜¯ç†è§£é»‘å®¢ (hacker)ã€ GNU è¨ˆç•«ã€è‡ªç”±è»Ÿé«”åŸºé‡‘æœƒ (FSF)ã€Linux æ ¸å¿ƒ (kernel)ã€é–‹æ”¾åŸå§‹ç¢¼ (open source) å’Œè‡ªç”±è»Ÿé«” (free software) åŸºæ–¼ä¸åŒç†å¿µå„è‡ªç™¼å±•ã€Netscape å®£ä½ˆ Mozilla é–‹æ”¾åŸå§‹ç¢¼å°ˆæ¡ˆã€åŸºæ–¼ Apache å’Œä¸€ç³»åˆ—é–‹æ”¾åŸå§‹ç¢¼æŠ€è¡“çš„å…¬å¸ã€åœ¨ NASDAQ ä¸Šå¸‚ç­‰ç­‰æ­·ç¨‹çš„ç¬¬ä¸€æ‰‹è³‡è¨Šã€‚ åŸæ–‡åœ°å€ ","date":"2024-06-09","objectID":"/posts/revolution-os/:0:0","tags":["Sysprog","Linux"],"title":"ä» Revolution OS çœ‹æ“ä½œç³»ç»Ÿç”Ÿæ€å˜åŒ–","uri":"/posts/revolution-os/"},{"categories":["Linux Kernel Internals"],"content":" æ‘˜è¦ ç›®çš„: æ£€éªŒå­¦å‘˜å¯¹ bitwise çš„è®¤çŸ¥ åŸæ–‡åœ°å€ ","date":"2024-06-08","objectID":"/posts/linux2023-quiz2/:0:0","tags":["Sysprog","C","Bitwise"],"title":"Linux æ ¸å¿ƒè®¾è®¡: 2023q2 ç¬¬äºŒå‘¨æµ‹éªŒé¢˜","uri":"/posts/linux2023-quiz2/"},{"categories":["Linux Kernel Internals"],"content":"æµ‹éªŒ 1 åŸæ–‡å¯¹äºæœ¬é¢˜çš„ç›®çš„è¯´æ˜æœ‰ä¸€ç‚¹å°é”™è¯¯ï¼ŒåŸæ–‡å£°ç§°å‡½æ•° next_pow2(x) çš„åŠŸèƒ½ä¸ºã€Œæ‰¾å‡ºæœ€æ¥è¿‘ä¸” å¤§äºç­‰äº 2 çš„å¹‚çš„å€¼ã€ï¼Œä½†å®é™…åº”ä¸ºã€Œæ‰¾å‡ºæœ€æ¥è¿‘ä¸” å¤§äº 2 çš„å¹‚çš„å€¼ã€ å®šä¹‰ MSB1(x) ä¸º x çš„äºŒè¿›åˆ¶è¡¨ç¤ºæ³•çš„å€¼ä¸º 1 çš„æœ€é«˜ä½å…ƒï¼Œä¾‹å¦‚å¯¹äº 8-bit çš„äºŒè¿›åˆ¶æ•° 00001000ï¼Œå…¶ MSB1(x) ä¸º 3 (ä»å³å¾€å·¦å¹¶ä¸”ä» 0 å¼€å§‹è®¡æ•°)ã€‚ å› ä¸ºåœ¨äºŒè¿›åˆ¶ç¼–ç è¡¨ç¤ºä¸­ï¼Œä»»æ„ä¸€ä¸ªä½å…ƒè¡¨ç¤ºçš„å€¼éƒ½æ˜¯ 2 çš„å¹‚ã€‚ä»¥ 8-bit æ— ç¬¦å·æ•°ä¸ºä¾‹ï¼Œå¯¹äº x (äºŒè¿›åˆ¶è¡¨ç¤ºä¸º 00001xxx)ï¼Œå…¶æœ€æ¥è¿‘ä¸”å¤§äº 2 çš„å¹‚çš„å€¼çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸º 00010000ï¼Œå³ MSB1(x) å‘å·¦å‰è¿›äº†ä¸€ä½ï¼ŒMSB1(next_pow2(x)) = MSB1(x) + 1ï¼Œå¹¶ä¸”å°† $[MSB1(x)â€¦0]$ è¿™ä¸ªåŒºé—´çš„ä½å…ƒå…¨éƒ¨ç½®ä¸º 0 å³å¯ã€‚ä»è¿™ä¸ªè§’åº¦å‡ºå‘ï¼Œåªéœ€è¦å°†å‚æ•° x ä»ç¬¬ MSB(x) bit å¼€å§‹ä»å·¦å¾€å³å…¨éƒ¨ç½®ä¸º 1ï¼Œå³$[MSB1(x)â€¦0]$ è¿™ä¸ªåŒºé—´çš„ä½å…ƒå…¨éƒ¨ç½®ä¸º 1ï¼Œç„¶åå¯¹è¯¥å€¼åŠ  1 å³å¯å¾—åˆ° next_pow2(x)ï¼Œå› ä¸ºæ­¤æ—¶$[MSB1(x)â€¦0]$ è¿™ä¸ªåŒºé—´çš„ä½å…ƒå…¨éƒ¨ä¸º 0ï¼Œå¹¶ä¸”ç¬¬ MSB1(x) + 1 bit çš„å€¼ä¸º 1ã€‚ uint64_t next_pow2(uint64_t x) { x |= x \u003e\u003e 1; x |= x \u003e\u003e 1; x |= x \u003e\u003e 1; x |= x \u003e\u003e 1; x |= x \u003e\u003e 1; x |= x \u003e\u003e 1; x |= x \u003e\u003e 1; // x |= x \u003e\u003e AAAA; x |= x \u003e\u003e 8; x |= x \u003e\u003e 16; // x |= x \u003e\u003e BBBB; x |= x \u003e\u003e 32; // return CCCC; return x + 1; } è¿™ä¸ªåšæ³•æ˜¯å…ˆä½¿ç”¨ MSB1(x) å¡«å…… $[MSB1(x)â€¦(MSB1(x)-7)]$ è¿™ä¸ªåŒºé—´çš„ 8 ä¸ªä½å…ƒå…¨éƒ¨ä¸º 1ï¼Œå› ä¸º MSB1(x) æœ¬èº«å€¼å°±ä¸º 1ï¼Œæ‰€ä»¥åªéœ€è¦ä½¿ç”¨ 7 æ¬¡å³ç§»è¿ç®— + æˆ–è¿ç®—å³å¯ã€‚ç„¶åä½¿ç”¨è¯¥ä½å…ƒå…¨ä¸º 1 çš„è¿™ 8-bit ç»§ç»­å¡«å……åé¢çš„ 8 ä¸ªä½å…ƒå¾—åˆ° 16 ä¸ªè¿ç»­ä¸”å€¼ä¸º 1 çš„ä½å…ƒï¼Œç„¶åæ˜¯ä½¿ç”¨ 16-bit å¡«å……ï¼Œæœ€åæ˜¯ 32-bitï¼Œå› ä¸º x æ˜¯ 64-bit çš„æ— ç¬¦å·æ•°ï¼Œæ‰€ä»¥ä½¿ç”¨ 32-bit è¿›è¡Œå¡«å……æ“ä½œæ—¶å·²ç»è¦†ç›–äº†æœ€æç«¯çš„æƒ…å†µ (MSB1(x) = 63)ã€‚æœ€ååŠ ä¸€å³å¯å¾—åˆ°é¢„æœŸç»“æœã€‚ å»¶ä¼¸é—®é¢˜ è§£é‡Šä¸Šè¿°ç¨‹å¼ç åŸç†ï¼Œå¹¶ç”¨ __builtin_clzl æ”¹å†™ int __builtin_clz (unsigned int x) Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined. int __builtin_clzl (unsigned long) Similar to __builtin_clz, except the argument type is unsigned long. ä½¿ç”¨ __builtin_clzl æ¥æ”¹å†™: uint64_t next_pow2(uint64_t x) { return (1 \u003c\u003c (64 - __builtin_clzl(x))); } ä½¿ç”¨ __builtin_clzl é…åˆä½ç§»è¿ç®—ï¼Œå¯ä»¥ç›´æ¥æ„é€ å‡ºæ»¡è¶³é¢„æœŸç»“æœ (MSB1(x) + 1) çš„ç»“æœã€‚ ","date":"2024-06-08","objectID":"/posts/linux2023-quiz2/:1:0","tags":["Sysprog","C","Bitwise"],"title":"Linux æ ¸å¿ƒè®¾è®¡: 2023q2 ç¬¬äºŒå‘¨æµ‹éªŒé¢˜","uri":"/posts/linux2023-quiz2/"},{"categories":["Linux Kernel Internals"],"content":"æµ‹éªŒ 2 int concatenatedBinary(int n) { const int M = 1e9 + 7; int len = 0; /* the bit length to be shifted */ /* use long here as it potentially could overflow for int */ long ans = 0; for (int i = 1; i \u003c= n; i++) { /* removing the rightmost set bit * e.g. 100100 -\u003e 100000 * 000001 -\u003e 000000 * 000000 -\u003e 000000 * after removal, if it is 0, then it means it is power of 2 * as all power of 2 only contains 1 set bit * if it is power of 2, we increase the bit length */ // if (!(DDDD)) if (!(i \u0026 (i - 1))) len++; // ans = (i | (EEEE)) % M; ans = (i | (ans \u003c\u003c len)) % M; } return ans; } é€šè¿‡åˆ¤æ–­ i \u0026 (i - 1) æ˜¯å¦ä¸º 0 å¯ä»¥åˆ¤æ–­äºŒè¿›åˆ¶æ•° i çš„å€¼æ˜¯å¦ä¸º 2 çš„å¹‚ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™é€‚å½“æ‰©å¤§è¡¨ç¤ºè¯¥äºŒè¿›åˆ¶æ•°æ‰€éœ€è¦çš„é•¿åº¦ (å› ä¸ºè¿™å¯¹åº”äºäºŒè¿›åˆ¶çš„è¿›ä½æ¦‚å¿µ)ï¼Œä¾‹å¦‚ 11 åªéœ€è¦é•¿åº¦ 2ï¼Œè€Œ 100 åˆ™éœ€è¦é•¿åº¦ 3 æ¥è¡¨ç¤ºè¯¥å€¼ã€‚ ç„¶åå¯ä»¥é€šè¿‡å·¦ç§»æ¥è®²å¯¹åº”çš„æ•°å€¼è¡¥å……è‡³ ans äºŒè¿›åˆ¶è¡¨ç¤ºçš„æœ«å°¾ i | (ans \u003c\u003c len)ï¼Œæœ€åå€ŸåŠ©åŒä½™çš„æ¦‚å¿µæ¥è¿›è¡Œå–æ¨¡ã€‚ å»¶ä¼¸é—®é¢˜ è§£é‡Šä¸Šè¿°ç¨‹å¼ç è¿ä½œåŸç† å°è¯•ä½¿ç”¨ __builtin_clzl æ”¹å†™ï¼Œå¹¶æ”¹è¿› mod $10^9 + 7$ çš„è¿ç®— ä½¿ç”¨ __builtin_clzl æ¥æ”¹å†™: int concatenatedBinary(int n) { const int M = 1e9 + 7; int len = 0; long ans = 0; for (int i = 1; i \u003c= n; i++) { if (i == (1 \u003c\u003c (31 - __builtin_clz(i)))) len++; ans = (i % M | (ans \u003c\u003c len) % M) % M; } return ans; } é€šè¿‡ __builtin_clz å¯ä»¥æ›´åŠ ç›´è§‚çš„åˆ¤æ–­ i çš„å€¼æ˜¯å¦ä¸º 2 çš„å¹‚æ¬¡æ–¹ï¼Œé™¤æ­¤ä¹‹å¤–è¿ç”¨åŒä½™çš„æ€§è´¨æ”¹è¿›å–æ¨¡è¿ç®—ã€‚ ","date":"2024-06-08","objectID":"/posts/linux2023-quiz2/:2:0","tags":["Sysprog","C","Bitwise"],"title":"Linux æ ¸å¿ƒè®¾è®¡: 2023q2 ç¬¬äºŒå‘¨æµ‹éªŒé¢˜","uri":"/posts/linux2023-quiz2/"},{"categories":["Linux Kernel Internals"],"content":" æ‘˜è¦ ç›®çš„: æ£€éªŒå­¦å‘˜å¯¹ linked list çš„è®¤çŸ¥ åŸæ–‡åœ°å€ ","date":"2024-06-07","objectID":"/posts/linux2023-quiz1/:0:0","tags":["Sysprog","Linux","C","Linked List"],"title":"Linux æ ¸å¿ƒè®¾è®¡: 2023q1 ç¬¬ä¸€å‘¨æµ‹éªŒé¢˜","uri":"/posts/linux2023-quiz1/"},{"categories":["Linux Kernel Internals"],"content":"æµ‹éªŒ 1 if (list_empty(head) || list_is_singular(head)) return; å¦‚æœ linked list çš„èŠ‚ç‚¹æ•°é‡ä¸º 0 æˆ– 1ï¼Œæ­¤æ—¶ linked list å·²ç»æœ‰åºäº†ï¼Œæ— éœ€è¿›è¡Œå¤„ç† struct list_head list_less, list_greater; INIT_LIST_HEAD(\u0026list_less); INIT_LIST_HEAD(\u0026list_greater); // struct item *pivot = list_first_entry(head, AAA, BBB); struct item *pivot = list_first_entry(head, struct item, list); list_del(\u0026pivot-\u003elist); å°† linked list çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸º pivot åˆ†ç¦»å‡ºåŸ linked listï¼Œå¹¶æ–°å»ºä¸¤ä¸ª linked list ç”¨äºåç»­æ¥æ”¶åŸ linked list çš„èŠ‚ç‚¹ï¼Œless ç”¨äºæ¥æ”¶å€¼ $\u003c pivot$ çš„èŠ‚ç‚¹ï¼Œè€Œ greater ç”¨äºæ¥æ”¶å€¼ $\\ge pivot$ çš„èŠ‚ç‚¹: åŸ linked list å¤„ç†å é¢„æœŸæƒ³è¦å°†åŸ linked_list å¤„ç†æˆ $\u003c pivot\\ |\\ pivot\\ | \\ge pivot$ çš„åºåˆ—ï¼Œå³ less è·å–åŸ linked list ä¸­çš„ $\u003c pivot$ çš„èŠ‚ç‚¹ï¼Œgreater è·å– $\\ge pivot$ çš„èŠ‚ç‚¹ï¼Œè¿™æ˜¯ä¸ºäº†æ»¡è¶³ stable çš„è¦æ±‚: stable sorting Stable sort algorithms sort equal elements in the same order that they appear in the input. æ‰€ä»¥è¿™æ ·å¤„ç†åå¾—åˆ°çš„åºåˆ—ï¼Œæ‰€æœ‰ $=pivot$ çš„èŠ‚ç‚¹é‡Œ pivot ä»ç„¶æ’åœ¨æœ€å‰é¢ï¼Œä¸åŸ linked list çš„ä½ç½®å…³ç³»ä¸€è‡´ struct item *itm = NULL, *is = NULL; // CCC(itm, is, head, list) { list_for_each_entry_safe (itm, is, head, list) { if (cmpint(\u0026itm-\u003ei, \u0026pivot-\u003ei) \u003c 0) // DDD(\u0026itm-\u003elist, \u0026list_less); list_move_tail(\u0026itm-\u003elist, \u0026list_less); else // EEE(\u0026itm-\u003elist, \u0026list_greater); list_move_tail(\u0026itm-\u003elist, \u0026list_greater); } æ¥ä¸‹æ¥éå†åŸ linked_listï¼Œä¾æ®èŠ‚ç‚¹å’Œ pivot çš„å…³ç³»ï¼Œä½¿ç”¨ list_move_tail å°†å…¶åŠ å…¥ less æˆ– greaterã€‚è¿™é‡Œä½¿ç”¨ list_move_tail ä¸€æ–¹é¢æ˜¯å°¾æ’å…¥ä¿è¯äº†åŸåºåˆ—çš„é¡ºåºå…³ç³» (ç¬¦åˆ stable)ï¼Œå¦ä¸€æ–¹é¢æ˜¯å®ƒçš„ä½œç”¨æ˜¯å…ˆè¿›è¡Œç§»é™¤åœ¨æ’å…¥ï¼Œä¿è¯äº†åŸ linked list ç»“æ„çš„æ­£ç¡®æ€§ã€‚è¿™ä¸€æ­¥å¤„ç†å®Œæˆåï¼ŒåŸ linked_list æ­¤æ—¶ä¸ºç©ºï¼Œåç»­æˆ‘ä»¬ä¼šå°†æ’åºå®Œæˆçš„ linked list èŠ‚ç‚¹é‡æ–°æ’å…¥å›å®ƒã€‚ list_sort(\u0026list_less); list_sort(\u0026list_greater); ç„¶åå¯¹ $\u003c pivot$ çš„ less å’Œ $\\ge pivot$ çš„ greater åˆ†åˆ«è¿›è¡Œå¿«é€Ÿæ’åºï¼Œæ’åºå®Œæˆåå†å¤„ç†æˆ $$\u003c pivot (sorted)\\ |\\ pivot\\ | \\ge pivot (sorted)$$ list_add(\u0026pivot-\u003elist, head); list_splice(\u0026list_less, head); // FFF(\u0026list_greater, head); list_splice_tail(\u0026list_greater, head); å³å¤§åŠŸå‘Šæˆ æŠ€å·§ å…³äº stable sortingï¼Œå¯ä»¥ä» linked list çš„å…ƒç´ å…¨éƒ¨ç›¸åŒçš„è§’åº¦è¿›è¡Œæ€è€ƒï¼Œä¾‹å¦‚ l = [1 1 1]ï¼Œç„¶åè¿½è¸ªè¯¥ä¾‹å­æ’åºçš„è¿‡ç¨‹ã€‚åœ¨æˆ‘å®ä½œçš„æºä»£ç ä¸­ï¼Œæ˜¯é€šè¿‡èŠ‚ç‚¹çš„åœ°å€æ¥åˆ¤æ–­æ˜¯å¦æ»¡è¶³ stable sorting çš„è¦æ±‚çš„ã€‚ ","date":"2024-06-07","objectID":"/posts/linux2023-quiz1/:1:0","tags":["Sysprog","Linux","C","Linked List"],"title":"Linux æ ¸å¿ƒè®¾è®¡: 2023q1 ç¬¬ä¸€å‘¨æµ‹éªŒé¢˜","uri":"/posts/linux2023-quiz1/"},{"categories":["C","Linux Kernel Internals"],"content":" å·¥ç¨‹é ˜åŸŸå¾€å¾€æ˜¯ä¸€ç³»åˆ—çš„å–æ¨çµæœï¼Œæµ®é»æ•¸æ›´æ˜¯å¦‚æ­¤ï¼Œåœ¨è»Ÿé«”ç™¼é–‹ç™¼æœ‰å¤ªå¤šå¤±èª¤æ¡ˆä¾‹æºè‡ªå·¥ç¨‹äººå“¡å°æµ®é»æ•¸é‹ç®—çš„æŒæ¡ä¸è¶³ï¼Œæœ¬è­°ç¨‹å¸Œæœ›è—‰ç”±æ¢è¨çœŸå¯¦ä¸–ç•Œçš„è¡€æ·‹æ·‹æ¡ˆä¾‹ï¼Œå¸¶è‘—å­¸å“¡æ€è€ƒ IEEE 754 è¦æ ¼å’Œç›¸é—œè»Ÿç¡¬é«”è€ƒé‡é»ï¼Œæœ€å¾Œä¹Ÿæœƒæ¢è¨åœ¨æ·±åº¦å­¸ç¿’é ˜åŸŸç‚ºäº†æ”¹å–„è³‡æ–™è™•ç†æ•ˆç‡ï¼Œè€Œå¼•å…¥çš„ BFloat16 é€™æ¨£çš„æ–°æ¨™æº– åŸæ–‡åœ°å€ ","date":"2024-06-04","objectID":"/posts/c-floating-point/:0:0","tags":["Sysprog","C","Floating POint"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æµ®ç‚¹æ•°","uri":"/posts/c-floating-point/"},{"categories":["draft"],"content":"bilibili: åŠ å·å¤§å­¦å…¬å¼€è¯¾â€”â€”å­¦ä¼šå¦‚ä½•å­¦ä¹  ","date":"2024-05-14","objectID":"/posts/learning-how-to-learn/:0:0","tags":["draft"],"title":"å­¦ä¼šå¦‚ä½•å­¦ä¹  Learning How to Learn","uri":"/posts/learning-how-to-learn/"},{"categories":["draft"],"content":"P1 ä¸“æ³¨æ¨¡å¼ vs. å‘æ•£æ¨¡å¼ ","date":"2024-05-14","objectID":"/posts/learning-how-to-learn/:1:0","tags":["draft"],"title":"å­¦ä¼šå¦‚ä½•å­¦ä¹  Learning How to Learn","uri":"/posts/learning-how-to-learn/"},{"categories":null,"content":"ccrysisa's friends","date":"2024-04-29","objectID":"/friends/","tags":null,"title":"æ‰€æœ‰å‹é“¾","uri":"/friends/"},{"categories":null,"content":"Base info - nickname: Lruihao avatar: https://lruihao.cn/images/avatar.jpg url: https://lruihao.cn description: Lruihao's Note ","date":"2024-04-29","objectID":"/friends/:1:0","tags":null,"title":"æ‰€æœ‰å‹é“¾","uri":"/friends/"},{"categories":null,"content":"Friendly Reminder Notice If you want to exchange link, please leave a comment in the above format. (personal non-commercial blogs / websites only) Â Website failure, stop maintenance and improper content may be unlinked! Those websites that do not respect other peopleâ€™s labor achievements, reprint without source, or malicious acts, please do not come to exchange. ","date":"2024-04-29","objectID":"/friends/:2:0","tags":null,"title":"æ‰€æœ‰å‹é“¾","uri":"/friends/"},{"categories":["Rust"],"content":" Rust is a statically compiled, fast language with great tooling and a rapidly growing ecosystem. That makes it a great fit for writing command line applications: They should be small, portable, and quick to run. Command line applications are also a great way to get started with learning Rust; or to introduce Rust to your team! æ•´ç†è‡ª Command line apps in Rust ","date":"2024-04-29","objectID":"/posts/rust-cli/:0:0","tags":["Rust","CLI"],"title":"Command Line Applications in Rust","uri":"/posts/rust-cli/"},{"categories":["Rust"],"content":"é‡ç‚¹æç¤º ","date":"2024-04-29","objectID":"/posts/rust-cli/:1:0","tags":["Rust","CLI"],"title":"Command Line Applications in Rust","uri":"/posts/rust-cli/"},{"categories":["Rust"],"content":"Arguments C è¯­è¨€çš„ CLI ç¨‹åºå¤„ç†å‚æ•°çš„é€»è¾‘æ˜¯è¿‡ç¨‹å¼çš„ï¼Œå³æ¯æ¬¡æ‰§è¡Œéƒ½ä¼šé€šè¿‡ argv æ¥è·å–æœ¬æ¬¡æ‰§è¡Œçš„å‚æ•°å¹¶è¿›è¡Œç›¸åº”çš„å¤„ç† (Rust çš„ std::env::args() å¤„ç† CLI ç¨‹åºçš„å‚æ•°æ–¹å¼ä¹Ÿç±»ä¼¼ï¼Œéƒ½æ˜¯å¯¹æ¯æ¬¡æ‰§è¡Œå®ä¾‹è¿›è¡Œè¿‡ç¨‹å¼çš„å¤„ç†)ï¼Œè€Œ Clap ä¸åŒï¼Œå®ƒç±»ä¼¼äºé¢å‘å¯¹è±¡çš„æ€æƒ³ï¼Œé€šè¿‡å®šä¹‰ä¸€ä¸ªç»“æ„ä½“ (object)ï¼Œæ¯æ¬¡è¿è¡Œæ—¶é€šè¿‡ clap::Parser::parse è·å–å¹¶å¤„ç†æœ¬æ¬¡è¿è¡Œçš„å‚æ•° (å³å®ä¾‹åŒ– object)ï¼Œè¿™æ ·å¼€å‘çš„ CLI ç¨‹åºæ‰©å±•æ€§ä¼šæ›´å¥½ã€‚ ","date":"2024-04-29","objectID":"/posts/rust-cli/:1:1","tags":["Rust","CLI"],"title":"Command Line Applications in Rust","uri":"/posts/rust-cli/"},{"categories":["Rust"],"content":"BufReader Struct std::io::BufReader ä¸­å…³äºç³»ç»Ÿè°ƒç”¨ (syscall) çš„å¼€é”€ï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨ buffer è¿™ä¸€æœºåˆ¶å‡å°‘ syscall è°ƒç”¨ä»¥æ­¤æé«˜æ•ˆèƒ½ï¼Œè¿›è¡Œäº†æ¯”è¾ƒç›´è§‚çš„æè¿°: It can be excessively inefficient to work directly with a Read instance. For example, every call to read on TcpStream results in a system call. A BufReader performs large, infrequent reads on the underlying Read and maintains an in-memory buffer of the results. BufReader can improve the speed of programs that make small and repeated read calls to the same file or network socket. It does not help when reading very large amounts at once, or reading just one or a few times. It also provides no advantage when reading from a source that is already in memory, like a Vec. When the BufReader is dropped, the contents of its buffer will be discarded. Creating multiple instances of a BufReader on the same stream can cause data loss. Reading from the underlying reader after unwrapping the BufReader with BufReader::into_inner can also cause data loss. ","date":"2024-04-29","objectID":"/posts/rust-cli/:1:2","tags":["Rust","CLI"],"title":"Command Line Applications in Rust","uri":"/posts/rust-cli/"},{"categories":["Rust"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-04-29","objectID":"/posts/rust-cli/:2:0","tags":["Rust","CLI"],"title":"Command Line Applications in Rust","uri":"/posts/rust-cli/"},{"categories":["Rust"],"content":"Crate std å¯ä»¥ä½¿ç”¨è¿™é‡Œæä¾›çš„æœç´ æ è¿›è¡Œæœç´¢ (BTW ä¸è¦æµªè´¹æ—¶é—´åœ¨ Google æœå¯»ä¸Šï¼) Function std::fs::read_to_string Function std::env::args Struct std::path::PathBuf Struct std::io::BufReader method std::iter::Iterator::nth Primitive Type str: method str::lines method str::contains expect: method std::option::Option::expect method std::result::Result::expect ","date":"2024-04-29","objectID":"/posts/rust-cli/:2:1","tags":["Rust","CLI"],"title":"Command Line Applications in Rust","uri":"/posts/rust-cli/"},{"categories":["Rust"],"content":"Crate clap method clap::Parser::parse ","date":"2024-04-29","objectID":"/posts/rust-cli/:2:2","tags":["Rust","CLI"],"title":"Command Line Applications in Rust","uri":"/posts/rust-cli/"},{"categories":["Rust"],"content":"References","date":"2024-04-29","objectID":"/posts/rust-cli/:3:0","tags":["Rust","CLI"],"title":"Command Line Applications in Rust","uri":"/posts/rust-cli/"},{"categories":["C","Linux Kernel Internals"],"content":" ç·¨è­¯å™¨æœ€ä½³åŒ–ç¯‡å°‡ä»¥ gcc / llvm ç‚ºæ¢è¨å°è±¡ï¼Œç°¡è¿°ç·¨è­¯å™¨å¦‚ä½•é‹ä½œï¼Œä»¥åŠå¦‚ä½•å¯¦ç¾æœ€ä½³åŒ–ï¼Œä½ä»¥æ¢ç©¶ C ç·¨è­¯å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æï¼Œç›¸ä¿¡å¯ä»¥é‡æ¸…è¨±å¤šäººå° C ç·¨è­¯å™¨çš„èª¤è§£ï¼Œå¾è€Œé–‹ç™¼å‡ºæ›´å¯é ã€æ›´é«˜æ•ˆçš„ç¨‹å¼ã€‚ åŸæ–‡åœ°å€ ","date":"2024-04-24","objectID":"/posts/c-compiler-optimization/:0:0","tags":["Sysprog","C","Compiler","Optimization"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨å’Œæœ€ä½³åŒ–åŸç†ç¯‡","uri":"/posts/c-compiler-optimization/"},{"categories":["C","Linux Kernel Internals"],"content":"From Source to Binary: How A Compiler Works: GNU Toolchain æŠ•å½±ç‰‡ / PDF æ³¨æ„ è¿™é‡Œçš„æŠ•å½±ç‰‡æ¯”å½±ç‰‡ä¸­è€å¸ˆè®²è§£æ—¶ä½¿ç”¨çš„æŠ•å½±ç‰‡å°‘äº†ä¸€éƒ¨åˆ†ï¼Œè€ŒåŸæ–‡ä½¿ç”¨çš„é¡µç æ˜¯è€å¸ˆè®²è§£æ—¶ä½¿ç”¨çš„æŠ•å½±ç‰‡çš„é¡µç ï¼Œéœ€è¦ç”„åˆ«ã€‚å› ä¸ºæˆ‘åªæœ‰å½“å‰ç‰ˆæœ¬çš„æŠ•å½±ç‰‡ï¼Œæ‰€ä»¥ä¼šä»¥å½“å‰æŠ•å½±ç‰‡çš„é¡µç ä½œä¸ºè®°å½•ï¼ŒåŒæ—¶ä¼šå°†åŸæ–‡æ ‡æ³¨çš„é¡µç è½¬æ¢æˆå½“å‰æŠ•å½±ç‰‡çš„é¡µç ã€‚ è¾…åŠ©ææ–™: Intro To Compiler Development The C++ Build Process Explained è¿™ä¸ªæµç¨‹ååˆ†é‡è¦ï¼Œä¸ä»…å¯ä»¥ç†è§£ç¨‹åºçš„æ‰§è¡Œæµç¨‹ï¼Œä¹Ÿå¯ä»¥ä½œä¸ºç†è§£è¯­è¨€è®¾è®¡çš„è§†è§’ã€‚ [Page 5] åŸæ–‡è¿™éƒ¨åˆ†è¯¦ç»†è§£é‡Šäº† C Runtime (crt) å¯¹äº main å‡½æ•°çš„å‚æ•° argc å’Œ argvï¼Œä»¥åŠè¿”å›å€¼ return 0 çš„å…³ç³»å’Œä½œç”¨ã€‚ [Page 8] ç¼–è¯‘å™¨åˆ†ä¸ºè½¯ä»¶ç¼–è¯‘å™¨å’Œç¡¬ä»¶ç¼–è¯‘å™¨ä¸¤å¤§ç±»å‹ï¼Œç¡¬ä»¶ç¼–è¯‘å™¨å¯èƒ½æ¯”è¾ƒé™Œç”Ÿï¼Œä½†å¦‚æœä½ æœ‰ä¿®è¿‡ nand2tetris åº”è¯¥ä¸éš¾ç†è§£ã€‚ [Page 9] å¯¹äºè½¯ä»¶ç¼–è¯‘å™¨ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰çš„ç¼–è¯‘å™¨éƒ½ä¼šé›†æˆæœ‰å›¾ç¤ºçš„ compile, assemble, link è¿™ä¸‰ç§åŠŸèƒ½ï¼Œä¾‹å¦‚ AMaCC åªæ˜¯å°† C è¯­è¨€æºç¨‹åºç¼–è¯‘æˆ ARM æ±‡ç¼–è€Œå·²ã€‚è¿™å¹¶ä¸éš¾ç†è§£ï¼Œå› ä¸ºæ ¹æ®ç¼–è¯‘å™¨çš„å®šä¹‰ï¼Œè¿™æ˜¯æ¯‹åº¸ç½®ç–‘çš„ç¼–è¯‘å™¨: Wikipedia: Compiler A compiler is Ã¤ computer program (or set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language, often having a binary form known as object code) ä¹‹æ‰€ä»¥å°†ç¼–è¯‘å™¨åˆ†ä¸ºä¸Šé¢æ‰€æçš„ 3 å¤§éƒ¨åˆ†ï¼Œä¸»è¦æ˜¯ä¸ºäº†å¼€å‘æ—¶éªŒè¯åŠŸèƒ½æ—¶çš„ä¾¿åˆ©ï¼Œåˆ†æˆæ¨¡å—å¯¹äºè°ƒè¯•é™¤é”™æ¯”è¾ƒå‹å¥½ã€‚ [Page 16] åŸæ–‡è®²è§£äº† self-hosting çš„å®šä¹‰æå…¶é‡è¦æ€§ï¼Œå¹¶ä»¥å¾®è½¯çš„ C# ä¸ºä¾‹å­è¿›è¡Œè¯´æ˜: How Microsoft rewrote its C# compiler in C# and made it open source [Page 18] ç¨‹åºè¯­è¨€çš„æœ¬è´¨æ˜¯ç¼–è¯‘å™¨ï¼Œæ‰€ä»¥åœ¨ç¨‹åºè¯­è¨€çš„èµ·å§‹é˜¶æ®µï¼Œæ˜¯å…ˆæœ‰ç¼–è¯‘å™¨å†æœ‰è¯­è¨€ï¼Œä½†æ˜¯ä¹‹åå°±å¯ä»¥é€šè¿‡ self-hosting å®ç°è‡ªä¸¾äº†ï¼Œå³ç¨‹åºè¯­è¨€ç¼–è¯‘è‡ªå·±çš„ç¼–è¯‘å™¨ã€‚ +----+ +---+ Source: X | C- | C- | C | C Language: C- | C- | C | C | C+ Compiler: 1 --\u003e | 2 | --\u003e 3 --\u003e | 4 | --\u003e 5 +----+ +---+ è‡ªä¸¾ (self-hosting) æ˜¯æŒ‡ç”¨æŸä¸€ä¸ªè¯­è¨€ X å†™çš„ç¼–è¯‘å™¨ï¼Œå¯ä»¥ç¼–è¯‘ X è¯­è¨€å†™çš„ç¨‹åº In computer programming, self-hosting is the use of a program as part of the toolchain or operating system that produces new versions of that same programâ€”for example, a compiler that can compile its own source code. [Page 32~33] SSA (Static Single Assignment): æ¯æ¬¡èµ‹å€¼éƒ½ä¼šå¯¹åº”åˆ°ä¸€ä¸ªæ–°çš„å˜é‡ï¼Œä½¿ç”¨è®°å· $\\Phi$ è¡¨ç¤ºå€¼çš„å®šä¹‰ç”±ç¨‹åºæµç¨‹æ¥å†³å®š å¯ä»¥ä½¿ç”¨ GCC æ¥è¾“å‡ºåŒ…å« Basic Block çš„ CFGï¼Œä½¿ç”¨èŒƒä¾‹: # \u003cout\u003e is the name of output file $ gcc -c -fdump-tree-cfg=\u003cout\u003e test.c [Page 39] æœ€ä½³åŒ– CFG éƒ¨åˆ†ï¼Œå°† bb2 å’Œ bb3 å¯¹è°ƒäº†ï¼Œè¿™æ ·çš„å¥½å¤„æ˜¯å¯ä»¥å°‘ä¸€æ¡æŒ‡ä»¤ï¼Œå³åŸå…ˆ bb3 çš„ goto bb2 è¢«æ¶ˆé™¤æ‰äº† (äº‹å®ä¸Šæ˜¯å°†è¯¥æŒ‡ä»¤æåˆ°äº† bb1 å¤„ï¼Œè¿™æ ·å°±åªéœ€æ‰§è¡Œä¸€æ¬¡è¯¥æŒ‡ä»¤ï¼Œä¸æ¶ˆé™¤æ‰è¯¥æŒ‡ä»¤å·®ä¸å¤šäº†ï¼Œå› ä¸ºåŸå…ˆåœ¨ bb3 çš„è¯ï¼Œè¿™æ¡æŒ‡ä»¤æ¯æ¬¡éƒ½è¦æ‰§è¡Œ)ï¼Œè¿™å¯¹äº for å¾ªç¯æ˜¯ä¸€ä¸ªå¸¸è§çš„æœ€ä½³åŒ–æŠ€å·§ã€‚ [Page 41~43] Constant Propagation éƒ¨åˆ†å¯ä»¥çœ‹åˆ°ï¼Œa0, b0 å’Œ c0 éƒ½åªå‡ºç°äº†ä¸€æ¬¡ï¼Œåé¢æ²¡æœ‰å†è¢«ä½¿ç”¨è¿‡ï¼Œæ­¤æ—¶å°±å¯ä»¥å°±è¿›è¡Œ Constant Propagationï¼Œå°†å¸¸é‡å€¼å–ä»£åŸå…ˆçš„ a0, b0, å’Œ c0ï¼Œç„¶åè¿›è¡Œ Constant Folding å°†å¸¸é‡å€¼è¡¨è¾¾å¼è®¡ç®—è½¬æ¢æˆå•ä¸€çš„å¸¸é‡å€¼ï¼Œæ¥ç€å› ä¸º Constant Folding äº§ç”Ÿäº†æ–°çš„å•ä¸€å¸¸é‡å€¼ï¼Œå¯ä»¥æ¥ç€è¿›è¡Œ Constant Propagationï¼Œä»¥æ­¤åå¤ï¼Œç›´åˆ°æ— æ³•è¿›è¡Œ Constant Propagationã€‚ ç¬¬ 43 é¡µçš„ result2 = t1/61126 ç–‘ä¼¼ç¬”è¯¯ï¼Œåº”è¯¥ä¸º result1 = t1/61126 [Page 45] Value Range Propagation æ ¹æ® å˜é‡çš„å½¢æ€ (ä¾‹å¦‚æ•°å€¼èŒƒå›´) è¿›è¡Œæ¨æ–­ï¼Œä»è€Œäº§ç”Ÿæ–°çš„å¸¸é‡å€¼ï¼Œè¿™å°±æ˜¯â€œå˜æˆ 0 çš„é­”æ³•â€œçš„åŸç†ã€‚æ¥ä¸‹æ¥ï¼Œæ­£å¦‚ä½ æ‰€æƒ³çš„ï¼Œæœ‰äº†å¸¸é‡å€¼ï¼Œé‚£å°±æ˜¯è¿›è¡Œ Constant Propagation ğŸ¤£ ä½¿ç”¨ SSA çš„ä¸€ä¸ªåŸå› å°±æ˜¯å¯ä»¥è®©è®¡ç®—æœºæŒ‰éƒ¨å°±ç­çš„è¿›è¡Œ Value Range Propagation è¿™ç±»é»‘é­”æ³• ç¼–è¯‘å™¨æœ€ä½³åŒ–æ€»ä½“æµç¨‹å¤§æ¦‚æ˜¯: ","date":"2024-04-24","objectID":"/posts/c-compiler-optimization/:1:0","tags":["Sysprog","C","Compiler","Optimization"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨å’Œæœ€ä½³åŒ–åŸç†ç¯‡","uri":"/posts/c-compiler-optimization/"},{"categories":["C","Linux Kernel Internals"],"content":" C èªè¨€æœ€åˆç‚ºäº†é–‹ç™¼ UNIX å’Œç³»çµ±è»Ÿé«”è€Œç”Ÿï¼Œæœ¬è³ªæ˜¯ä½éšçš„ç¨‹å¼èªè¨€ï¼Œåœ¨èªè¨€è¦ç¯„å±¤ç´šå­˜åœ¨ undefined behaviorï¼Œå¯å…è¨±ç·¨è­¯å™¨å¼•å…¥æ›´å¤šæœ€ä½³åŒ– åŸæ–‡åœ°å€ ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:0:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"ä» C è¯­è¨€è¯•é¢˜è°ˆèµ· int i = 10; i = i++ + ++i; è¯·é—® i çš„å€¼åœ¨ç¬¬ 2 è¡Œæ‰§è¡Œå®Œæ¯•åä¸ºï¼Ÿ C èªè¨€æ²’è¦å®š i++ æˆ– ++i çš„ã€ŒåŠ  1ã€å‹•ä½œåˆ°åº•æ˜¯åœ¨å“ªå€‹æ•˜è¿°çš„å“ªå€‹æ™‚åˆ»åŸ·è¡Œï¼Œå› æ­¤ï¼Œä¸åŒ C ç·¨è­¯å™¨è‹¥åœ¨ä¸åŒçš„ä½ç½® + 1ï¼Œå°±å¯èƒ½å°è‡´æˆªç„¶ä¸åŒçš„çµæœã€‚ è¿™ä¸€éƒ¨åˆ†å¯ä»¥å‚è€ƒã€Œå¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåºã€ä¸­ Evaluation å’Œ Sequenced-before çš„è®²è§£ã€‚ ä¸åŒºåˆ†ã€Œå¹¶è¡Œã€å’Œã€Œå¹³è¡Œã€ç±»ä¼¼ï¼Œæˆ‘ä»¬è¿™é‡Œè¦åŒºåˆ†ã€Œæœªå®šä¹‰è¡Œä¸ºã€å’Œã€ŒæœªæŒ‡å®šè¡Œä¸ºã€: æœªå®šä¹‰è¡Œä¸º (Undefined behavior): ç¨‹åºè¡Œä¸ºå¹¶æœªåœ¨ è¯­è¨€è§„èŒƒ (åœ¨ C ä¸­ï¼Œè‡ªç„¶æ˜¯ ISO/IEC 9899 ä¸€ç±»çš„è§„æ ¼) æ‰€æ˜ç¡®å®šä¹‰è§„èŒƒã€‚ç¼©å†™ä¸º â€œUBâ€ã€‚ undefined behavior (UB) is the result of executing a program whose behavior is prescribed to be unpredictable, in the language specification to which the computer code adheres. æœªæŒ‡å®šè¡Œä¸º (Unspecified behavior): ç¨‹åºè¡Œä¸ºä¾èµ– ç¼–è¯‘å™¨å®ä½œå’Œå¹³å°ç‰¹æ€§ è€Œå®šã€‚ unspecified behavior is behavior that may vary on different implementations of a programming language. ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:1:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"ç¨‹åºè¯­è¨€ä¸éƒ½è¯¥è¯¦ç»†è§„èŒƒï¼Œæ€ä¹ˆä¼šæœ‰ UB å‘¢ï¼Ÿ ç¼–è¯‘å™¨æœ€ä½³åŒ–å»ºç«‹åœ¨ UB çš„åŸºç¡€ä¸Šï¼Œå³ç¼–è¯‘å™¨è¿›è¡Œæœ€ä½³åŒ–ä¼šå¿½ç•¥ UBï¼Œå› ä¸º C è¯­è¨€æ ‡å‡†å’Œç¼–è¯‘å™¨è®¤ä¸ºï¼Œæœªå®šä¹‰è¡Œä¸ºä¸èƒ½å‡ºç°åœ¨ç¨‹åºä¸­ï¼Œå¹¶ä¸”å°†è¿™ä¸ªå‡†åˆ™ä½œä¸ºå‰ææ¥å®ä½œç¼–è¯‘å™¨ã€‚æ‰€ä»¥ C è¯­è¨€ç¼–è¯‘å™¨å¯¹æºä»£ç è¿›è¡Œç¿»è¯‘å’Œä¼˜åŒ–ï¼Œå…¶è¾“å‡ºçš„æœºå™¨ç çš„è¡Œä¸ºåº”è¯¥ä¸ æ ‡å‡†å®šä¹‰çš„è¡Œä¸º ä¸€è‡´ã€‚ä¹Ÿå°±æ˜¯è¯´ç¼–è¯‘å‡ºæ¥çš„æœºå™¨ç åªä¿è¯ä¸æ ‡å‡†çš„å®šä¹‰è¡Œä¸ºå¯¹åº”ï¼Œå¯¹äºæœªå®šä¹‰è¡Œä¸ºä¸ä¿è¯æœ‰å¯¹åº”çš„æœºå™¨ç ã€‚ æ³¨æ„ ç±»ä¼¼äº API çš„ä½¿ç”¨ï¼Œä½ å¿…é¡»åœ¨éµå®ˆ API çš„é™åˆ¶çš„å‰æä¸‹ä½¿ç”¨ APIï¼Œæ‰èƒ½å¾—åˆ°é¢„æœŸçš„ç»“æœï¼Œå¦‚æœä½ ä¸éµå¾ª API çš„é™å®šï¼Œé‚£ä¹ˆ API è¿”å›çš„ç»“æœä¸ä¿è¯ç¬¦åˆä½ çš„é¢„æœŸ (ä½†è¿™ä¸æ„å‘³ç€ä½ åªèƒ½éµå®ˆ API çš„é™åˆ¶ï¼Œä½ å½“ç„¶å¯ä»¥ä¸éµå®ˆï¼Œåªæ˜¯åæœè‡ªè´Ÿï¼ŒUB ä¹Ÿç±»ä¼¼ï¼Œæ²¡è¯´ä¸è¡Œï¼Œä½†æ˜¯åæœè‡ªè´Ÿ ğŸ¤£)ã€‚ä¾‹å¦‚ä¸€ä¸ª API è¦æ±‚ä¼ å…¥çš„å‚æ•°å¿…é¡»æ˜¯éè´Ÿæ•°ï¼Œå¦‚æœä½ ä¼ å…¥äº†ä¸€ä¸ªè´Ÿæ•°ï¼Œé‚£ä¹ˆ API è¿”å›çš„ç»“æœä¸å¤§å¯èƒ½ç¬¦åˆä½ çš„é¢„æœŸï¼Œå› ä¸ºè¿™ä¸ª API çš„å†…éƒ¨å®ç°å¯èƒ½æ²¡è€ƒè™‘è´Ÿæ•°æƒ…å½¢ã€‚ ä»è¿™ä¸ªè§’åº¦çœ‹ï¼ŒUB å…¶å®å°±æ˜¯ä¸éµå®ˆè¯­è¨€è§„èŒƒ (ç­‰ä»·äº API çš„é™åˆ¶) çš„è¡Œä¸ºï¼Œç¼–è¯‘å™¨å¯¹äºè¯­è¨€è§„èŒƒçš„å®ç°ä¸€èˆ¬æ¥è¯´æ˜¯ä¸è€ƒè™‘ UB çš„ (ç­‰ä»·äº API çš„å†…éƒ¨å®ç°)ï¼Œæ‰€ä»¥å› ä¸º UB é€ æˆçš„ç»“æœéœ€è¦ç¨‹åºå‘˜è‡ªè¡Œæ‰¿æ‹… (ç­‰ä»·äºä¸éµå®ˆé™åˆ¶ä¹±ç”¨ API éœ€è¦è‡ªå·±æ‰¿æ‹…è´£ä»»)ã€‚æ‰€ä»¥å•çº¯è€ƒè™‘ UB æ˜¯æ²¡å•¥æ„ä¹‰çš„ï¼Œå› ä¸ºå®ƒåªæ˜¯ç»“æœçš„å…·ä½“è¡¨ç°ï¼Œåº”è¯¥ä»è¯­è¨€è§„èŒƒå’Œç¼–è¯‘å™¨çš„è§’åº¦è€ƒè™‘ã€‚ é™¤æ­¤ä¹‹å¤–ï¼Œå› ä¸ºç¼–è¯‘å™¨ä½œä¸ºè¯­è¨€è§„èŒƒçš„å®ä½œï¼Œå®ƒåœ¨æœ€ä½³åŒ–æ—¶ä¼šä¸€èˆ¬ åªè€ƒè™‘ç¬¦åˆè¯­è¨€è§„èŒƒ çš„éƒ¨åˆ†ï¼Œç®€è€Œè¨€ä¹‹ï¼Œç¼–è¯‘å™¨å¯èƒ½ä¼šå°† ä¾èµ–äº UB éƒ¨åˆ†çš„ä»£ç  ç§»é™¤æ‰ (è¶Šæ¿€è¿›çš„ä¼˜åŒ–è¶Šæœ‰å¯èƒ½)ã€‚å› ä¸ºå®ƒè®¤ä¸ºæºç¨‹åºå·²ç»æ˜¯ç¬¦åˆè¯­è¨€è§„èŒƒçš„ï¼Œæ‰€ä»¥ä¼šç§»é™¤æ‰åœ¨ç¬¦åˆè§„èŒƒæƒ…å†µä¸‹æ˜¾å¾—ä¸å¿…è¦çš„é€»è¾‘ã€‚ int func(unsigned char x) { int value = 2147483600; /* assuming 32 bit int */ value += x; if (value \u003c 2147483600) bar(); return value; } ç¬¬ 4 è¡Œå¯èƒ½ä¼šå¯¼è‡´ signed integer overflowï¼Œè€Œ signed integer overflow åœ¨ C è¯­è¨€æ˜¯ UBï¼Œæ‰€ä»¥ç¼–è¯‘å™¨ä¼˜åŒ–æ—¶ä¼šè®¤ä¸ºä¸ä¼šå‘ç”Ÿ signed integer overflow (å¯¹åº”å‰æ–‡çš„ æœªå®šä¹‰è¡Œä¸ºä¸èƒ½å‡ºç°åœ¨ç¨‹åºä¸­)ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å°±ä¼šç¬¬ 5 è¡Œçš„æ¡ä»¶åˆ¤æ–­æ˜¯ä¸å¯èƒ½æˆç«‹çš„ï¼Œè¿›è€Œå°†å…¶ä¼˜åŒ–æ‰: int foo(unsigned char x) { int value = 2147483600; value += x; return value; } Java è¿™ç±»å¼ºè°ƒå®‰å…¨çš„è¯­è¨€ä¹Ÿä¼šå­˜åœ¨ UB (Java å®‰å…¨çš„ä¸€ä¸ªæ–¹é¢æ˜¯å®ƒåªä½¿ç”¨ signed integer)ï¼Œæ‰€ä»¥æœ‰æ—¶å€™ä½ ä¼šåœ¨é¡¹ç›®ä¸­çœ‹åˆ°ç±»ä¼¼å¦‚ä¸‹çš„æ³¨é‡Š: /* Do not try to optimize this lines. * This is the only way you can do this * without undefined behavior */ ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:2:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"CppCon 2016: Undefined Behavior CppCon 2016: Chandler Carruth Garbage In, Garbage Out: Arguing about Undefined Behavior with Nasal Demons int *p = nullptr; int x = *p; Programming error, like using an API out of contract. /// \\param p must not be null void f(int *p); void f(int *p) [[expects: p != nullptr]]; Programming errors result in incorrect programs. We cannot define the behavior of incorrect programs. UB is a symptom of incorrect programs. The code used a feature out of contract. The feature has a narrow contract! It was a latent error all this time. Can we make every language feature have a wide contract? No. Instead, evaluate wide vs. narrow contracts case by case. Ok, can we at least constrain UB? UB is inherently unconstrainedâ€¦ But this isnâ€™t about UB! Can we define some behavior when out of contract? Yes.. But what do you define? Different users need differemt behaviors. When is it appropriate to have a narrow contract? A narrow contract is a simpler semantic model. But this may not match expectations. Principles for narrow language contracts: Checkable (probabilisticallt) at runtime Provide significant value: bug finding, simplification, and/or optimization Easily explained and taught to programmers Not widely violated by existing code that works correctly and as intended ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:3:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"Examples Letâ€™s examine interesting cases with this framework #include \u003ciostream\u003e int main() { volatile unsigned x = 1; volatile unsigned y = 33; volatile unsigned result = x \u003c\u003c y; std::cout \u003c\u003c \"Bad shift: \" \u003c\u003c result \u003c\u003c \"\\n\"; } å·¦ç§»æ“ä½œ x \u003c\u003c y å¦‚æœ y \u003e= \u003cbits of x\u003e é‚£ä¹ˆè¿™ä¸ªè¡Œä¸ºæ˜¯ UB // Allocate a zeroed rtx vector of N elements // // sizeof(struct rtvec_def) == 16 // sizeof(rtunion) == 8 rtvec rtvec_alloc(int n) { rtvec rt; int i; rt = (rtvec)obstack_alloc( rtl_obstack, sizeof(struct rtvec_def) + (n - 1) + sizeof(rtvunion)); // ... return rt; } è¿™é‡Œéœ€è¦å¯¹ API åŠ ä¸€ä¸ªé™åˆ¶: n \u003e= 1 bool mainGtu(uint32_t i1, uint32_t i2, # BB#0: uint8_t *block) { movl %edi, %eax uint8_t c1, c2; movb (%rdx,%rax), %al movl %esi, %ebp /* 1 */ movb (%rdx,%rbp), %bl c1 = block[i1]; c2 = block[i2]; cmpb %bl, %al if (c1 != c2) return (c1 \u003e c2); jne .LBB27_1 i1++; i2++; # BB#2: leal 1(%rdi), %eax /* 2 */ leal 1(%rsi), %ebp c1 = block[i1]; c2 = block[i2]; movb (%rdx,%rax), %al if (c1 != c2) return (c1 \u003e c2); movb (%rdx,%rbp), %bl i1++; i2++; cmpb %bl, %al jne .LBB27_1 ... # ... } bool mainGtu(int32_t i1, int32_t i2, # BB#0: uint8_t *block) { movzbl (%rdx, %rsi), %eax uint8_t c1, c2; cmpb %al, (%rdx,%rdi) jne .LBB27_1 /* 1 */ c1 = block[i1]; c2 = block[i2]; if (c1 != c2) return (c1 \u003e c2); i1++; i2++; # BB#2: movzbl 1(%rdx, %rsi), %eax /* 2 */ cmpb %al, 1(%rdx,%rdi) c1 = block[i1]; c2 = block[i2]; jne .LBB27_1 if (c1 != c2) return (c1 \u003e c2); i1++; i2++; ... # ... } è¿™é‡Œçš„åº•å±‚æœºåˆ¶æ˜¯: unsigned integer çš„ overflow ä¸æ˜¯ UBï¼Œè€Œæ˜¯ç­‰ä»·äºå¯¹ UMax of its size å–æ¨¡ï¼Œæ‰€ä»¥å½“ä½¿ç”¨ uint32_t æ—¶ï¼Œç¼–è¯‘å™¨éœ€è¦ç”Ÿæˆç‰¹æ®Šçš„æŒ‡ä»¤ç”¨äºä¿è¯ i1 å’Œ i2 çš„å€¼æ˜¯è¿™æ ·çš„åºåˆ—: $i$, $i+1$, â€¦, UMax, $0$, $1$, â€¦ (è¿™æ˜¯ wide contractï¼Œå³å¯¹ä»»æ„çš„ unsigned integer åŠ æ³•çš„è¡Œä¸ºéƒ½æœ‰è§„èŒƒå¹¶ä¸”ç¼–è¯‘å™¨è¿›è¡Œäº†ç›¸åº”å®ä½œ) ä½†æ˜¯å½“ä½¿ç”¨ signed integer æ—¶ï¼Œå› ä¸º signed integer overflow æ˜¯ UBï¼Œæ‰€ä»¥ç¼–è¯‘å™¨åªéœ€ç”ŸæˆæŒ‡ä»¤ç”¨äºä¿è¯ i1 å’Œ i2 çš„å€¼æ˜¯è¿™æ ·çš„åºåˆ—: $i$, $i+1$, $i+2$, â€¦ æ‰€ä»¥åªéœ€è¦ç”Ÿæˆå•çº¯çš„ add æŒ‡ä»¤å³å¯ï¼Œç”šè‡³å¯ä»¥è¿›è¡ŒæŒ‡é’ˆè¿ç®— p + iï¼Œç„¶åé€’å¢è¿™ä¸ªæŒ‡é’ˆå€¼å³å¯ã€‚(è¿™æ˜¯ narrow contractï¼Œå³ä½¿ç”¨ signed integer æ—¶ç¼–è¯‘å™¨ä¸éœ€è¦å…³å¿ƒæ˜¯å¦ä¼šå‘ç”Ÿ overflowï¼Œå› ä¸ºè¿™æ˜¯ç¨‹åºå‘˜çš„è´£ä»»ï¼Œå®ƒå¯¹ signed integer åŠ æ³•çš„å®ä½œä¸è€ƒè™‘ overflow çš„æƒ…æ™¯) æŠ€å·§ è¿™ä¸ªä¾‹å­å†æ¬¡è¯´æ˜ï¼Œæœªå®šä¹‰è¡Œä¸ºå­˜åœ¨çš„é‡è¦ç›®çš„æ˜¯ï¼Œè¯­è¨€æ ‡å‡†ä¸­çš„åˆ»æ„ç•™ç©ºï¼Œè¿è¡Œæ›´æ¿€è¿›æœ€ä¼˜åŒ–çš„å­˜åœ¨ã€‚ä¾‹å¦‚è§„èŒƒé™åˆ¶ signed integer çš„ä½¿ç”¨ä¸ä¼šå‡ºç° overflowï¼Œè¿›è€Œç¼–è¯‘å™¨ä»¥è¿™ä¸ªå‰æè¿›è¡Œæœ€ä¼˜åŒ– (ç±»ä¼¼äº API çš„ä½¿ç”¨é™åˆ¶ä¸èƒ½ä½¿ç”¨è´Ÿæ•°ï¼Œé‚£ä¹ˆ API çš„å®ä½œä¹Ÿä¸ä¼šè€ƒè™‘è´Ÿæ•°çš„æƒ…å½¢)ã€‚ä¸ç®¡æ˜¯è¿›è¡Œæœ€ä¼˜åŒ–è¿˜æ˜¯ä¸è¿›è¡Œæœ€ä¼˜åŒ–çš„ç¼–è¯‘å™¨ï¼Œéƒ½æ˜¯å¯¹è¯­è¨€è§„èŒƒçš„ä¸€ç§å®ç°ã€‚ #include \u003ciostream\u003e #include \u003climits\u003e #include \u003cstdint.h\u003e int main() { volatile int32_t x = std::numeric_limits\u003cint32_t\u003e::min(); volatile int32_t y = 7; volatile int32_t result = (x \u003e\u003e y); std::cout \u003c\u003c \"Arithmetic shift: \" \u003c\u003c std::hex \u003c\u003c result \u003c\u003c \"\\n\"; } Arithmetic shift is Implementation defined behavior. (narrow contract) #include \u003cstring.h\u003e int main() { void *volatile src = nullptr; void *volatile dst = nullptr; volatile size_t size = 0; memcpy(dst, src, size); } The source and destination shall not be nullptr in memcpy. (narrow contract) æ³¨æ„ ç°åœ¨å†å›å¤´çœ‹ä¸‹å¼€å¤´çš„ä¾‹å­ï¼Œå¦‚æœæˆ‘ä»¬å°†ç¬¬ 3 è¡Œçš„ x æ”¹ä¸º unsigned int ç±»å‹ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å°±ä¸ä¼šå°†ç¬¬ 5 è¡Œçš„ if è¯­å¥ä¼˜åŒ–æ‰ (å› ä¸º unsigned int çš„ä½¿ç”¨æ˜¯ wide contract çš„): int func(unsigned char x) { unsigned int value = 2147483600; /* assuming 32 bit */ value += x; if (value \u003c 2147483600) bar(); return value; } ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:3:1","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"Undefined Behavior and Compiler Optimizations Kugan Vivekanandarajah å’Œ Yvan Roux æ¢è®¨ UB å’Œç¼–è¯‘å™¨æœ€ä½³åŒ–çš„æ¼”è®²: BKK16-503 Undefined Behavior and Compiler Optimizations â€“ Why Your Program Stopped Working With A Newer Compiler / æ¼”è®²å½•å½± gcc PR53073 compiles 464.h264ref in SPEC CPU 2006 into infinite loop. C99 6.5.2.1 Array subscripting A postfix expression followed by an expression in square brackets [] is a subscripted designation of an element of an array object. The definition of the subscript operator [] is that E1[E2] is identical to (*((E1)+(E2))). C99 6.5.6 Additive operators (8) If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined. If the result points one past the last element of the array object, it shall not be used as the operand of a unary * operator that is evaluated. æ³¨æ„ è¿™ä¸ªæŠ•å½±ç‰‡å¾ˆå‰å®³ï¼ŒåŸæ–‡åé¢ä»‹ç»çš„ UB çš„å‡ ç§ç±»å‹éƒ½æ˜¯å¯å‘è‡ªè¿™é‡Œã€‚æ‰€ä»¥æˆ‘æ‰“ç®—å°†è¿™ä¸ªæŠ•å½±ç‰‡çš„ç›¸å…³éƒ¨åˆ†ç©¿æ’åœ¨åé¢å¯¹åº”çš„éƒ¨åˆ†ã€‚ ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:4:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"ä¾¦æµ‹ Undefined Behavior Clang: UndefinedBehaviorSanitizer Linux æ ¸å¿ƒä¹Ÿå¼•å…¥ The Undefined Behavior Sanitizer - UBSAN ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:5:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"Undefined Behavior çš„å‡ ç§ç±»å‹ Aliased pointers Another variety of aliasing can occur in any language that can refer to one location in memory with more than one name (for example, with pointers). ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:6:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"Signed integer overflow gcc ä½¿ç”¨ç¼–è¯‘é€‰é¡¹ -fno-strict-overflow å’Œ -fwrapv å¯ä»¥åœ¨æœ€ä½³åŒ–æ—¶é˜»æ­¢è¿™æ ·çš„è¡Œä¸ºã€‚ gcc PR34075 LWN GCC and pointer overflows This behavior is allowed by the C standard, which states that, in a correct program, pointer addition will not yield a pointer value outside of the same object. That kind of optimization often must assume that programs are written correctly; otherwise the compiler is unable to remove code which, in a correctly-written (standard-compliant) program, is unnecessary. ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:6:1","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"Shifting an n-bit integer by n or more bits gcc PR48418 This invokes undefined behavior, any result is acceptable. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99. Generally, the right operand must not be negative and must not be greater than or equal to the width of the (promoted) left operand. An example of invalid shift operation is the following: ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:6:2","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"Divide by zero gcc PR29968 ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:6:3","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"Dereferencing a NULL pointer LWN Fun with NULL pointers There is one little problem with that reasoning, though: NULL (zero) can actually be a valid pointer address. By default, the very bottom of the virtual address space (the â€œzero page,â€ along with a few pages above it) is set to disallow all access as a way of catching null-pointer bugs (like the one described above) in both user and kernel space. But it is possible, using the mmap() system call, to put real memory at the bottom of the virtual address space. This is where the next interesting step in the chain of failures happens: the GCC compiler will, by default, optimize the NULL test out. The reasoning is that, since the pointer has already been dereferenced (and has not been changed), it cannot be NULL. So there is no point in checking it. Once again, this logic makes sense most of the time, but not in situations where NULL might actually be a valid pointer. A NULL pointer was dereferenced before being checked, the check was optimized out by the compiler gcc PR68853 Wikidepia: Linux kernel oops ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:6:4","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"Pointer arithmetic that wraps gcc PR54365 ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:6:5","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"Reading an uninitialized variable #include \u003cstdio.h\u003e int main() { int x; int y = x + 10; printf(\"%d %d\\n\", x, y); return 0; } ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:6:6","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":"å»¶ä¼¸é˜…è¯» LLVM ä¹‹çˆ¶æ’°å†™çš„ç³»åˆ—æ–‡ç« : What Every C Programmer Should Know About Undefined Behavior Part 1 Part 2 Part 3 ä¿¡æ¯ Undefined Behavior in 2017 Why undefined behavior may call a never-called function ","date":"2024-04-24","objectID":"/posts/c-undefined-behavior/:7:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡","uri":"/posts/c-undefined-behavior/"},{"categories":["C","Linux Kernel Internals"],"content":" AMaCC æ˜¯ç”±æˆåŠŸå¤§å­¸å¸«ç”Ÿé–‹ç™¼çš„ self-compiling çš„ C èªè¨€ç·¨è­¯å™¨ï¼Œå¯ç”¢ç”Ÿ Arm æ¶æ§‹çš„åŸ·è¡Œæª” (ELF æ ¼å¼ï¼Œé‹ä½œåœ¨ GNU/Linux)ã€ä¹Ÿæ”¯æ´ just-in-time (JIT) ç·¨è­¯å’ŒåŸ·è¡Œï¼ŒåŸå§‹ç¨‹å¼ç¢¼åƒ… 1500 è¡Œï¼Œåœ¨é€™æ¬¡è¬›åº§ä¸­ï¼Œæˆ‘å€‘å°±ä¾†æ­é–‹ AMaCC èƒŒå¾Œçš„åŸç†å’Œå¯¦ä½œè­°é¡Œã€‚ é æœŸæœƒæ¥è§¸åˆ° IR (Intermediate representation), dynamic linking, relocation, symbol table, parsing tree, language frontend, Arm æŒ‡ä»¤ç·¨ç¢¼å’Œ ABI ç­‰ç­‰ã€‚ åŸæ–‡åœ°å€ ","date":"2024-04-23","objectID":"/posts/c-compiler-construction/:0:0","tags":["Sysprog","C","Compiler"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æ","uri":"/posts/c-compiler-construction/"},{"categories":["C","Linux Kernel Internals"],"content":"å¦‚ä½•æ‰“é€ ä¸€ä¸ªå…·ä½“è€Œå¾®çš„ C è¯­è¨€ç¼–è¯‘å™¨ ç”¨ååˆ†é˜ å‘ jserv å­¸ç¿’ä½œæ¥­ç³»çµ±è¨­è¨ˆ ç”¨1500 è¡Œå»ºæ§‹å¯è‡ªæˆ‘ç·¨è­¯çš„ C ç·¨è­¯å™¨ / æŠ•å½±ç‰‡ AMaCC æ˜¯ç”±æˆåŠŸå¤§å­¸å¸«ç”Ÿé–‹ç™¼çš„ self-compiling çš„ C èªè¨€ç·¨è­¯å™¨ï¼Œå¯ç”¢ç”Ÿ Arm æ¶æ§‹çš„åŸ·è¡Œæª” (ELF æ ¼å¼ï¼Œé‹ä½œåœ¨ GNU/Linux)ã€ä¹Ÿæ”¯æ´ just-in-time (JIT) ç·¨è­¯å’ŒåŸ·è¡Œï¼ŒåŸå§‹ç¨‹å¼ç¢¼åƒ… 1500 è¡Œï¼Œåœ¨é€™æ¬¡è¬›åº§ä¸­ï¼Œæˆ‘å€‘å°±ä¾†æ­é–‹ AMaCC èƒŒå¾Œçš„åŸç†å’Œå¯¦ä½œè­°é¡Œã€‚ é æœŸæœƒæ¥è§¸åˆ° IR (Intermediate representation), dynamic linking, relocation, symbol table, parsing tree, language frontend, Arm æŒ‡ä»¤ç·¨ç¢¼å’Œ ABI ç­‰ç­‰ã€‚ Wikipedia: Executable and Linkable Format GitHub: mini-riscv-os è¿™ä¸ªä¸“æ¡ˆæ˜¯å¯¹ Jserv çš„ 700 è¡Œç³»åˆ—çš„è‡´æ•¬ï¼Œå¯å‘è‡ª mini-arm-os ä¸“æ¡ˆ: Build a minimal multi-tasking OS kernel for RISC-V from scratch. Mini-riscv-os was inspired by jservâ€™s mini-arm-os project. However, ccckmit rewrite the project for RISC-V, and run on Win10 instead of Linux. ","date":"2024-04-23","objectID":"/posts/c-compiler-construction/:1:0","tags":["Sysprog","C","Compiler"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æ","uri":"/posts/c-compiler-construction/"},{"categories":["C","Linux Kernel Internals"],"content":"ç¼–è¯‘å™¨å’Œè½¯ä»¶å·¥ä¸šå¼ºåº¦æ¯æ¯ç›¸å…³ å½¢å¼åŒ–é©—è­‰ (Formal Verification) ","date":"2024-04-23","objectID":"/posts/c-compiler-construction/:2:0","tags":["Sysprog","C","Compiler"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æ","uri":"/posts/c-compiler-construction/"},{"categories":["C","Linux Kernel Internals"],"content":"èƒŒæ™¯çŸ¥è¯† ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨å’Œæœ€ä½³åŒ–åŸç†ç¯‡ ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°å‘¼å«ç¯‡ ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: åŠ¨æ€è¿é“¾æ¥å™¨å’Œæ‰§è¡Œæ—¶æœŸç¯‡ è™šæ‹Ÿæœºå™¨è®¾è®¡ä¸å®ä½œ ","date":"2024-04-23","objectID":"/posts/c-compiler-construction/:3:0","tags":["Sysprog","C","Compiler"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æ","uri":"/posts/c-compiler-construction/"},{"categories":["C","Linux Kernel Internals"],"content":"C ç¨‹åºçš„è§£æå’Œè¯­æ„ æ‰‹æŠŠæ‰‹æ•™ä½ æ„å»º C è¯­è¨€ç¼–è¯‘å™¨ åŒ—å¤§ç¼–è¯‘å®è·µåœ¨çº¿æ–‡æ¡£ Crafting Interpreters descent é»è©•å¹¾æœ¬ç·¨è­¯å™¨è¨­è¨ˆæ›¸ç± desent æ•™ä½ é€æ­¥é–‹ç™¼ç·¨è­¯å™¨ c4 æ˜¯å¾ˆå¥½çš„åˆ‡å…¥é»ï¼ŒåŸä½œè€… Robert Swierczek é‚„åˆå¦ä¸€å€‹ æ›´å®Œæ•´çš„ C ç·¨è­¯å™¨å¯¦ä½œï¼Œè¿™ä¸ªå®ä½œæ”¯æŒ preprocessor AMaCC åœ¨ Robert Swierczek çš„åŸºç¤ä¸Šï¼Œé¡å¤–å¯¦ä½œ C èªè¨€çš„ struct, switch-case, for, C-style comment æ”¯æ´ï¼Œä¸¦ä¸”é‡å¯«äº† IR åŸ·è¡Œç¨‹å¼ç¢¼ï¼Œå¾—ä»¥è¼¸å‡ºåˆæ³• GNU/Linux ELF åŸ·è¡Œæª” (æ”¯æ´ armhf ABI) å’Œ JIT ç·¨è­¯ å¾’æ‰‹å†™ä¸€ä¸ª RISC-V ç¼–è¯‘å™¨ï¼åˆå­¦è€…å‹å¥½çš„å®æˆ˜è¯¾ç¨‹ Write your Own Virtual Machine / ä¸­æ–‡ç¿»è¯‘ æ³¨æ„ ä¸Šé¢çš„ç¬¬ä¸€ä¸ªé“¾æ¥æ˜¯å…³äº c4 çš„æ•™ç¨‹ï¼Œéå¸¸å€¼å¾—ä¸€çœ‹å’Œä¸€åš (Make your hands dirty!)ï¼ŒåŒæ—¶å®ƒä¹Ÿæ˜¯ AMaCC çš„åŸºç¡€ (AMaCC åœ¨è¿™ä¸ªåŸºç¡€ä¸Šè¿›è¡Œäº†é‡å†™å’Œæ‰©å±•)ã€‚ æœ€åä¸€ä¸ªå…³äºè™šæ‹Ÿæœºå™¨çš„è®²åº§ä¹Ÿä¸é”™ï¼Œå¯¹äºå„ç±»è™šæ‹Ÿæœºå™¨éƒ½è¿›è¡Œäº†ä»‹ç»å’Œè¯´æ˜ï¼Œå¹¶æ­é…äº†ç›¸å…³å®ä½œ RTMux è¿›è¡Œäº†è®²è§£ã€‚ ","date":"2024-04-23","objectID":"/posts/c-compiler-construction/:4:0","tags":["Sysprog","C","Compiler"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æ","uri":"/posts/c-compiler-construction/"},{"categories":["C","Linux Kernel Internals"],"content":"æ‰‹æŠŠæ‰‹æ•™ä½ æ„å»º C è¯­è¨€ç¼–è¯‘å™¨ åŸæ–‡åœ°å€ ç¼–è¯‘åŸç†è¯¾ç¨‹æ•™å¯¼çš„æ˜¯å¦‚ä½•å®Œæˆä¸€ä¸ªã€Œç¼–è¯‘å™¨çš„ç¼–è¯‘å™¨ã€ï¼Œå³ Compiler-compilerï¼Œè¿™ä¸ªéš¾åº¦æ¯”è¾ƒå¤§ï¼Œå› ä¸ºéœ€è¦è€ƒè™‘é€šç”¨æ€§ï¼Œä½†æ˜¯å®ä½œä¸€ä¸ªç®€å•çš„ç¼–è¯‘å™¨å¹¶æ²¡æœ‰è¿™ä¹ˆéš¾ã€‚ Wikipedia: Compiler-compiler æ³¨æ„ è¿™ç¯‡æ•™ç¨‹é‡Œé¢ä¼šæœ‰ä¸€äº›æ¯”è¾ƒå¥‡æ€ªå¤æ¿çš„å†™æ³•ï¼Œä¾‹å¦‚: int i; i = 0; // instead of `int i = 0;` a = a + 1; // instead of `a += 1;` è¿™éƒ½æ˜¯ä¸ºäº†å®ç°è¿™ä¸ªç¼–è¯‘å™¨çš„è‡ªä¸¾ (self-host)ï¼Œæ‰€ä»¥åœ¨è¯­æ³•ä¸Šæ²¡æœ‰å¤ªå¤§çš„çµæ´»æ€§ (å› ä¸ºè¿™ä¸ªç¼–è¯‘å™¨ä¸æ”¯æŒè¿™ä¹ˆçµæ´»çš„è¯­æ³• ğŸ¤£) è®¾è®¡ ä¸€èˆ¬è€Œè¨€ï¼Œç¼–è¯‘å™¨çš„ç¼–å†™åˆ†ä¸º 3 ä¸ªæ­¥éª¤ï¼š è¯æ³•åˆ†æå™¨ï¼Œç”¨äºå°†å­—ç¬¦ä¸²è½¬åŒ–æˆå†…éƒ¨çš„è¡¨ç¤ºç»“æ„ã€‚ è¯­æ³•åˆ†æå™¨ï¼Œå°†è¯æ³•åˆ†æå¾—åˆ°çš„æ ‡è®°æµï¼ˆtokenï¼‰ç”Ÿæˆä¸€æ£µè¯­æ³•æ ‘ã€‚ ç›®æ ‡ä»£ç çš„ç”Ÿæˆï¼Œå°†è¯­æ³•æ ‘è½¬åŒ–æˆç›®æ ‡ä»£ç ã€‚ argc \u0026 argv argc--; argv++; main å‡½æ•°è¿™éƒ¨åˆ†çš„å¤„ç†æ˜¯å°†è¯¥è¿›ç¨‹ argc å’Œ argv è®¾å®šä¸ºè§£é‡Šæ‰§è¡Œçš„æºç¨‹åºå¯¹åº”çš„å€¼ï¼Œä»¥è®©è™šæ‹Ÿæœºæ­£ç¡®åœ°è§£é‡Šæ‰§è¡Œæºç¨‹åº (éœ€è¦çœ‹å®Œã€Œè™šæ‹Ÿæœºã€å’Œã€Œè¡¨è¾¾å¼ã€éƒ¨åˆ†æ‰èƒ½ç†è§£è¿™éƒ¨åˆ†å¤„ç†çš„æ„ä¹‰)ã€‚ è™šæ‹Ÿæœº åœ¨è¯¥é¡¹ç›®çš„è™šæ‹Ÿæœºè®¾è®¡ä¸­ï¼Œå‡½æ•°è°ƒç”¨æ—¶ callee çš„å‚æ•°ä½äº caller çš„æ ˆå¸§ (frame) å†…ï¼Œå¹¶ä¸”å‡½æ•°è°ƒç”¨éœ€è¦ä½¿ç”¨åˆ° 4 æ¡æŒ‡ä»¤: CALL æŒ‡ä»¤å°† callee çš„è¿”å›åœ°å€å‹å…¥æ ˆï¼Œç„¶åè·³è½¬åˆ° callee çš„å…¥å£å¤„ ENT æŒ‡ä»¤ä¿å­˜ ebp å¯„å­˜å™¨çš„å€¼å¹¶ä¸º callee çš„æ ˆå¸§è®¾ç½® esp å’Œ ebp å¯„å­˜å™¨ï¼Œåœ¨æ ˆä¸­ç»™ callee çš„å±€éƒ¨å˜é‡åˆ†é…ç©ºé—´ ADJ æŒ‡ä»¤åœ¨ callee é€»è¾‘æ‰§è¡Œå®Œæ¯•åï¼Œé‡Šæ”¾ä¹‹å‰åˆ†é…ç»™å±€éƒ¨å˜é‡çš„æ ˆç©ºé—´ LEV æŒ‡ä»¤å°† ebp å’Œ esp å¯„å­˜å™¨æ¢å¤ä¸ºå¯¹åº” caller æ ˆå¸§ï¼Œå¹¶è·³è½¬åˆ°ä¹‹å‰ä¿å­˜çš„ callee çš„è¿”å›åœ°å€å¤„ é™¤æ­¤ä¹‹å¤–ï¼Œåœ¨ callee æ‰§è¡ŒæœŸé—´ï¼Œå¯èƒ½éœ€è¦é€šè¿‡ LEA æŒ‡ä»¤æ¥è®¿é—®å‡½æ•°å‚æ•°å’Œå±€éƒ¨å˜é‡ã€‚ sub_function(arg1, arg2, arg3); | .... | high address +---------------+ | arg: 1 | new_bp + 4 +---------------+ | arg: 2 | new_bp + 3 +---------------+ | arg: 3 | new_bp + 2 +---------------+ |return address | new_bp + 1 +---------------+ | old BP | \u003c- new BP +---------------+ | local var 1 | new_bp - 1 +---------------+ | local var 2 | new_bp - 2 +---------------+ | .... | low address Wikipedia: Stack machine Wikipedia: x86 calling conventions PRTF else if (op == PRTF) { tmp = sp + pc[1]; ax = printf((char *)tmp[-1], tmp[-2], tmp[-3], tmp[-4], tmp[-5], tmp[-6]); } è¿™é‡Œ c4 å¯¹äº PRTF æŒ‡ä»¤çš„å¤„ç†æš‚æ—¶æ²¡çœ‹æ˜ç™½â€¦ å®Œæˆã€Œè¡¨è¾¾å¼ã€ä¸€èŠ‚çš„é˜…è¯»åï¼Œå¯ä»¥å¾—çŸ¥å‡½æ•°çš„æŒ‡ä»¤ç”Ÿæˆé¡ºåºæ˜¯: å‚æ•°å…¥æ ˆ -\u003e å‡½æ•°è°ƒç”¨ -\u003e é‡Šæ”¾å‚æ•°ç©ºé—´ï¼Œåœ¨ expression() ä¸­æœ‰ç›¸åº”çš„é€»è¾‘: // pass in arguments tmp = 0; // number of arguments while (token != ')') { expression(Assign); *++text = PUSH; tmp ++; ... } ... // function call if (id[Class] == Sys) { // system functions *++text = id[Value]; } else if (id[Class] == Fun) { // function call *++text = CALL; *++text = id[Value]; } ... // clean the stack for arguments if (tmp \u003e 0) { *++text = ADJ; *++text = tmp; } æ‰€ä»¥ PRTF æŒ‡ä»¤å¤„ç†ä¸­çš„ pc[1] è¡¨ç¤ºçš„æ°å¥½æ˜¯é‡Šæ”¾å‚æ•°ç©ºé—´çš„ ADJ æŒ‡å®šå‚æ•°ï¼Œéƒ½æ˜¯è¡¨ç¤ºå‚æ•°çš„ä¸ªæ•°ã€‚å¯ä»¥æ ¹æ®è¿™ä¸ªå‚æ•°æ•°é‡æ¥åœ¨æ ˆä¸­å®šä½å‡½æ•°å‚æ•°ï¼Œå½“ç„¶è¿™é‡Œä¸ºäº†ç®€åŒ–ï¼Œå°† PRTF å¯¹åº”çš„ printf å‚æ•°å›ºå®šä¸ºäº† 6 ä¸ª (è¿™å¯èƒ½ä¼šæœ‰ä¸€äº›æ¼æ´)ã€‚ é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜è¦æ³¨æ„ï¼Œæ ¹æ®ã€Œè¯æ³•åˆ†æå™¨ã€ç« èŠ‚çš„å¤„ç†ï¼Œå­—ç¬¦ä¸²çš„å€¼ (token_val) æ˜¯å®ƒçš„åœ°å€: if (token == '\"') { token_val = (int)last_pos; } æ‰€ä»¥è™šæ‹Ÿæœºåœ¨æ‰§è¡Œ PRTF æŒ‡ä»¤æ—¶å°†ç¬¬ä¸€ä¸ªå‚æ•°è§£é‡Šä¸º char * ç±»å‹ã€‚ gcc -m32 error gcc é€šè¿‡ -m32 å‚æ•°ç¼–è¯‘æœ¬èŠ‚ä»£ç æ—¶å¯èƒ½ä¼šé‡åˆ°ä»¥ä¸‹æŠ¥é”™: fatal error: bits/wordsize.h: No such file or directory è¿™æ˜¯å› ä¸ºå½“å‰å®‰è£…çš„ gcc åªæœ‰ 64 ä½çš„åº“è€Œæ²¡æœ‰ 32 ä½çš„åº“ï¼Œé€šè¿‡ä»¥ä¸‹å‘½ä»¤å®‰è£… 32 ä½åº“è§£å†³é—®é¢˜: $ sudo apt install gcc-multilib Stack Overflow: â€œfatal error: bits/libc-header-start.h: No such file or directoryâ€ while compiling HTK è¯æ³•åˆ†æå™¨ æˆ‘ä»¬å¹¶ä¸ä¼šä¸€æ¬¡æ€§åœ°å°†æ‰€æœ‰æºç å…¨éƒ¨è½¬æ¢æˆæ ‡è®°æµï¼ŒåŸå› æœ‰äºŒï¼š å­—ç¬¦ä¸²è½¬æ¢æˆæ ‡è®°æµæœ‰æ—¶æ˜¯æœ‰çŠ¶æ€çš„ï¼Œå³ä¸ä»£ç çš„ä¸Šä¸‹æ–‡æ˜¯æœ‰å…³ç³»çš„ã€‚ ä¿å­˜æ‰€æœ‰çš„æ ‡è®°æµæ²¡æœ‰æ„ä¹‰ä¸”æµªè´¹ç©ºé—´ã€‚ åœ¨å¤„ç†æ•°å­—æ—¶ä½¿ç”¨åˆ°äº†ä¸€äº›ã€Œæ•°å€¼ç³»ç»Ÿç¯‡ã€æ—¶æåˆ°çš„æŠ€å·§ï¼Œä¾‹å¦‚åˆ©ç”¨ ASCII Table çš„ç‰¹æ€§ã€‚å‡è®¾ token å­˜å‚¨å½“å‰å­—ç¬¦ï¼Œå¦‚æœæ˜¯ 0-9 è¿™ç±»æ•°å­—å­—ç¬¦ï¼Œä½¿ç”¨ token \u0026 15 å¯ä»¥è·å¾—è¯¥æ•°å­—å­—ç¬¦å¯¹åº”çš„æ•°å€¼ï¼›å¦‚æœæ˜¯ a-f æˆ– A-F è¿™ç±»å­—ç¬¦ï¼Œtoken \u0026 15 ä¼šå–å¾—ç›¸å¯¹äº 9 çš„åç§»å€¼ï¼Œä¾‹å¦‚ A \u0026 15 å’Œ a \u0026 15 è¿”å›çš„éƒ½æ˜¯ 1ã€‚ ä¸Šé¢è¿™ä¸€æŠ€å·§ä¾èµ–äºè¿™ä¸€äº‹å®ï¼šå­—ç¬¦ 0-9 å¯¹åº”çš„åå…­è¿›åˆ¶ä¸º 0x30 - 0x39ï¼Œå­—ç¬¦ A-F å¯¹åº”çš„åå…­è¿›åˆ¶ä¸º 0x41 - 0x46ï¼Œå­—ç¬¦ a-f å¯¹åº”çš„åå…­è¿›åˆ¶ä¸º 0x61 - 0x66ã€‚ å¯¹äºã€Œå…³é”®å­—ä¸å†…ç½®å‡½æ•°ã€çš„å¤„ç†: å…³é”®å­—: é¦–å…ˆä½¿ç”¨è¯æ³•åˆ†æå™¨å°†å…¶è¯†åˆ«ä¸º identifierï¼Œç„¶åå°† symbol table ä¸­çš„ token ç±»å‹æ”¹ä¸ºå¯¹åº”çš„å…³é”®å­— å†…ç½®å‡½æ•°: ç±»ä¼¼çš„å…ˆè¿›è¡Œè¯æ³•åˆ†æè¯†åˆ«ä¸º identifierï¼Œç„¶ååœ¨ symbol table ä¸­ä¿®æ”¹å…¶ Class, Type, Value å­—æ®µçš„å€¼ current_id[Value] and system functions æš‚æ—¶æ²¡ææ‡‚ä¸ºä»€ä¹ˆè¦å°†å†…ç½®å‡½æ•°åœ¨ symbol table ä¸­çš„ Value å­—æ®µä¿®æ”¹ä¸ºå¯¹åº”çš„æŒ‡ä»¤ (ä¾‹å¦‚ EXIT) é˜…è¯»å®Œã€Œè¡¨è¾¾å¼ã€ä¸€èŠ‚åå·²ç†è§£ï¼Œè¿™æ ·å†…ç½®å‡½æ•°å¯ä»¥ç›´æ¥é€šè¿‡ symbol table çš„ Value å­—æ®µæ¥ç”Ÿæˆå¯¹åº”çš„æŒ‡ä»¤ï¼Œè€Œä¸åƒæ™®é€šå‡½æ•°ä¸€æ ·æ­é…åœ°å€ç”Ÿæˆç›¸å…³çš„è·³è½¬æŒ‡ä»¤ã€‚ if (id[Class] == Sys) { // system functions *++text = id[Value]; } å±é™© å¯¹äºå…³é”®å­—å’Œå†…ç½®å‡½æ•°çš„å¤„ç†éƒ¨åˆ†: src = \"char else enum if int return sizeof while \" \"open read close printf malloc memset memcmp exit void main\"; ä¸€å®šè¦æ³¨æ„ç¬¬ä¸€è¡Œæœ€åçš„ while åé¢æœ‰ä¸€ä¸ª ç©ºæ ¼ï¼Œè¿™æ˜¯ä¿è¯å­—ç¬¦ä¸²æ‹¼æ¥åå¯ä»¥è¢«è¯æ³•åˆ†æå™¨è¯†åˆ«ä¸ºä¸¤ä¸ª tokenã€‚å¦‚æœä¸åŠ ç©ºæ ¼ï¼Œå­—ç¬¦ä¸²ä¼šæŠŠè¿™ä¸€éƒ¨åˆ†æ‹¼æ¥æˆ ... whileopen ...ï¼Œè¿™æ ·å°±ä¸ç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸäº†ï¼Œè¿›è€Œå¯¼è‡´ç¨‹åºå‡ºé”™ã€‚ é€’å½’ä¸‹é™ è¿™ä¸€èŠ‚æ˜¯ä»¥å››åˆ™è¿ç®—è¡¨è¾¾å¼çš„è¯­æ³•åˆ†æä¸ºä¾‹ï¼Œä»‹ç»é€’å½’ä¸‹é™çš„ç›¸å…³å®ä½œï¼Œå¹¶ä¸æ˜¯ç¼–è¯‘å™¨å®ä½œçš„ä¸€éƒ¨åˆ† ğŸ¤£ ä½†ä¹Ÿç”¨åˆ°äº†å‰ä¸€èŠ‚æ‰€æçš„è¯æ³•åˆ†æï¼Œè™½ç„¶ç®€å•å¾ˆå¤š (å› ä¸ºå››åˆ™è¿ç®—åªéœ€è€ƒè™‘æ ‡è¯†ç¬¦ä¸ºæ•°å­—çš„æƒ…å†µ)ã€‚ è¯­æ³•åˆ†æçš„å…³é”®ç‚¹åœ¨äº: å®ƒæ˜¯æ ¹æ®è¯æ³•åˆ†æè·å¾—çš„ token æµè¿›è¡Œåˆ†æçš„ï¼Œå…¶ä¸­çš„ match æ–¹æ³•æ˜¯ç”¨äºåˆ¤æ–­å½“å‰è·å¾—çš„ token æ˜¯å¦ç¬¦åˆè¯­æ³•åˆ†æçš„é¢„æœŸä»¥åŠåŸºäº token è¿›è¡Œå‘å‰çœ‹ (å¯¹æ¯”ä¸€ä¸‹è¯æ³•åˆ†ææ˜¯åŸºäºå­—ç¬¦çš„å‘å‰çœ‹)ã€‚ What is Left Recursion and how it is eliminated? å˜é‡å®šä¹‰ current_id[Value] and address current_id[Value] = (int)(text + 1); // the memory address of function current_id[Value] = (int)data; // assign memory address è¿™ä¸¤ä¸ªæ¶‰åŠ current_id[Value] å­—æ®µçš„å¤„ç†æš‚æ—¶æ²¡å¼„æ˜ç™½ï¼Œå¯èƒ½éœ€è¦åˆ°åé¢ä»£ç ç”Ÿæˆé˜¶æ®µé…åˆè™šæ‹Ÿæœºè®¾è®¡æ‰èƒ½ç†è§£ã€‚ å…¨å±€å˜é‡ text æŒ‡å‘","date":"2024-04-23","objectID":"/posts/c-compiler-construction/:4:1","tags":["Sysprog","C","Compiler"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æ","uri":"/posts/c-compiler-construction/"},{"categories":["C","Linux Kernel Internals"],"content":"IR (Intermediate representation) Wikipedia: An intermediate representation (IR) is the data structure or code used internally by a compiler or virtual machine to represent source code. An intermediate language is the language of an abstract machine designed to aid in the analysis of computer programs. A popular format for intermediate languages is three-address code. Though not explicitly designed as an intermediate language, Câ€™s nature as an abstraction of assembly and its ubiquity as the de facto system language in Unix-like and other operating systems has made it a popular intermediate language æ‰€ä»¥ä¸€èˆ¬çš„ IR é•¿å¾—å’Œæ±‡ç¼–è¯­è¨€æ¯”è¾ƒåƒï¼Œä½†æ˜¯æ¯”æ±‡ç¼–é«˜é˜¶ï¼Œå› ä¸º IR æ˜¯å»ºç«‹åœ¨è¿™æ ·çš„è™šæ‹Ÿæœºå™¨ (abstract machine designed to aid in the analysis of computer programs) ä¹‹ä¸Šçš„ã€‚ Interpreter, Compiler, JIT from scratch How to JIT - an introduction How to write a very simple JIT compiler How to write a UNIX shell, with a lot of background æ³¨æ„ JIT (Just in time) è¡¨ç¤ºâ€œå³æ—¶â€ï¼Œå½¢è±¡æè¿°å°±æ˜¯â€œåŠæ—¶é›¨â€ ğŸ¤£ åŸç†æ˜¯å°†è§£é‡Šæ‰§è¡Œçš„â€œçƒ­ç‚¹â€œç¼–è¯‘æˆä½äºä¸€ä¸ªå†…å­˜åŒºåŸŸçš„ machine codeï¼Œä»è€Œå‡è½»å†…å­˜çš„å‹åŠ›ã€‚å› ä¸ºè§£é‡Šæ‰§è¡Œæ—¶ä¼šåœ¨å†…å­˜ä¸­è·³æ¥è·³å»ï¼Œè€Œä¸€ä¸ªåŒºåŸŸçš„ machine code æ˜¯è¿ç»­æ‰§è¡Œï¼Œå†…å­˜å‹åŠ›æ²¡è¿™ä¹ˆå¤§å¹¶ä¸”å¯ä»¥å……åˆ†åˆ©ç”¨ cache ä»è€Œæé«˜æ•ˆèƒ½ã€‚å¦ä¸€ä¸ªå› ç´ å¯ä»¥å‚è€ƒ ä½ æ‰€ä¸çŸ¥é“çš„ C èªè¨€: goto å’Œæµç¨‹æ§åˆ¶ç¯‡ï¼Œä» VM çš„ swith-case å’Œ computed goto åœ¨æ•ˆèƒ½å·®å¼‚çš„ä¸»è¦å› ç´ ã€Œåˆ†æ”¯é¢„æµ‹ã€è¿›è¡Œæ€è€ƒã€‚ æœ€åä¸¤ä¸ªé“¾æ¥å¯¹äºæé«˜ç³»ç»Ÿç¼–ç¨‹ (System programming) èƒ½åŠ›éå¸¸æœ‰ç›Šï¼ŒJust do it! ","date":"2024-04-23","objectID":"/posts/c-compiler-construction/:5:0","tags":["Sysprog","C","Compiler"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æ","uri":"/posts/c-compiler-construction/"},{"categories":["C","Linux Kernel Internals"],"content":"Interpreter, Compiler, JIT from scratch åŸæ–‡åœ°å€ ","date":"2024-04-23","objectID":"/posts/c-compiler-construction/:5:1","tags":["Sysprog","C","Compiler"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æ","uri":"/posts/c-compiler-construction/"},{"categories":["C","Linux Kernel Internals"],"content":"How to write a UNIX shell ç³»ç»Ÿç¼–ç¨‹ (System Programming) çš„å…¥é—¨é¡¹ç›®ï¼Œé˜…è¯»è¿‡ç¨‹éœ€è¦æŸ¥è¯¢æ­é… man æ‰‹å†Œï¼Œä»¥ç†Ÿæ‚‰åº“å‡½æ•°å’Œç³»ç»Ÿè°ƒç”¨çš„åŸå‹å’Œä½œç”¨ã€‚ Linux manual page: fflush / elf / exec / perror / getline / strchr / waitpid / fprintf / pipe / dup / close ","date":"2024-04-23","objectID":"/posts/c-compiler-construction/:5:2","tags":["Sysprog","C","Compiler"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æ","uri":"/posts/c-compiler-construction/"},{"categories":["C","Linux Kernel Internals"],"content":"å»¶ä¼¸é˜…è¯» Linux manual page: bsearch ","date":"2024-04-23","objectID":"/posts/c-compiler-construction/:5:3","tags":["Sysprog","C","Compiler"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æ","uri":"/posts/c-compiler-construction/"},{"categories":["C","Linux Kernel Internals"],"content":"ç¨‹åºè¯­è¨€è®¾è®¡å’Œç¼–è¯‘å™¨è€ƒé‡ YouTube: Brian Kernighan on successful language design ","date":"2024-04-23","objectID":"/posts/c-compiler-construction/:6:0","tags":["Sysprog","C","Compiler"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨åŸç†å’Œæ¡ˆä¾‹åˆ†æ","uri":"/posts/c-compiler-construction/"},{"categories":["Toolkit"],"content":"ä»Šæ—¥é—²æ¥æ— äº‹ï¼Œåˆ·äº†ä¼š B ç«™ï¼Œçªå‘å¥‡æƒ³å°†å‘ç°äº†ä¸€å¹´å¤šçš„ WSL2 æ‰¾å›æ¥æŠ˜è…¾ä¸€ä¸‹ (ä¹‹å‰ä¸ºäº†åœ¨ VMware ä¸­å¼€å¯åµŒå¥—è™šæ‹ŸåŒ–ï¼Œä¸å¾—ä»¥å°† WSL2 æ‰“å…¥å†·å®« ğŸ¤£)ã€‚ç”±äºè¿™ä¸€å¹´å†…åŠŸåŠŸåŠ›å¤§æ¶¨ï¼Œå¾ˆå¿«å°±å®Œæˆäº† WLS2 çš„å†å¬é›†å¯ç”¨ï¼Œä¸‹é¢åˆ—å‡ºé…ç½®çš„ä¸»è¦æ­¥éª¤å’Œç›¸å…³ææ–™ã€‚ æ“ä½œç³»ç»Ÿ: Windows 10 ","date":"2024-04-20","objectID":"/posts/wsl2/:0:0","tags":["Windows","WSL","Ubuntu"],"title":"Windows 10 WSL2 Ubuntu 22.04 é…ç½®æŒ‡å—","uri":"/posts/wsl2/"},{"categories":["Toolkit"],"content":"å®‰è£… WSL2 å’Œ Linux å‘è¡Œç‰ˆ å¯ç”¨æˆ–å…³é—­ Windows åŠŸèƒ½ é€‚ç”¨äº Linux çš„ Windows å­ç³»ç»Ÿ è™šæ‹Ÿæœºå¹³å° ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œ PowerShell \u003e bcdedit /v ... hypervisorlaunchtype Auto # ä¿è¯ä¸Šé¢è¿™ä¸ªè™šæ‹ŸåŒ–é€‰é¡¹æ˜¯ Autoï¼Œå¦‚æœæ˜¯ Off åˆ™ä½¿ç”¨ä¸‹é¢å‘½ä»¤è®¾ç½® \u003e bcdedit /set hypervisorlaunchtype auto åœ¨ PowerShell ä¸­å®‰è£… wsl2 \u003e wsl --update \u003e wsl --set-default-version 2 \u003e wsl -l -o NAME FRIENDLY NAME ... Ubuntu-18.04 Ubuntu 18.04 LTS Ubuntu-20.04 Ubuntu 20.04 LTS Ubuntu-22.04 Ubuntu 22.04 LTS ... \u003e wsl --install Ubuntu-22.04 # åé¢éœ€è¦åˆ›å»ºç”¨æˆ·å’Œå¯†ç ï¼Œè‡ªè¡Œè®¾ç½® ä¸Šé¢ä»¥ Ubuntu2 22.04 å‘è¡Œç‰ˆä¸ºä¾‹ï¼Œä½ ä¹Ÿå¯ä»¥å®‰è£…å…¶å®ƒçš„å‘è¡Œç‰ˆã€‚å®‰è£…è¿‡ç¨‹ä¸­å¯èƒ½ä¼šå‡ºç°æ— æ³•è®¿é—®æº / ä»“åº“çš„é—®é¢˜ï¼Œè¿™ä¸ªæ˜¯ç½‘ç»œé—®é¢˜ï¼Œè¯·è‡ªè¡Œé€šè¿‡é­”æ³•/ç§‘å­¦æ–¹æ³•è§£å†³ ","date":"2024-04-20","objectID":"/posts/wsl2/:1:0","tags":["Windows","WSL","Ubuntu"],"title":"Windows 10 WSL2 Ubuntu 22.04 é…ç½®æŒ‡å—","uri":"/posts/wsl2/"},{"categories":["Toolkit"],"content":"è¿ç§»è‡³éç³»ç»Ÿç›˜ ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œ PowerShell # æŸ¥çœ‹å·²å®‰è£…çš„ Linux å‘è¡Œç‰ˆ \u003e wsl -l- v # åœæ­¢æ­£åœ¨è¿è¡Œçš„å‘è¡Œç‰ˆ \u003e wsl --shutdown # å¯¼å‡ºå‘è¡Œç‰ˆçš„é•œåƒ (ä»¥ Ubuntu 22.04 ä¸ºä¾‹) \u003e wsl --export Ubuntu-22.04 D:/ubuntu.tar # å¯¼å‡ºé•œåƒåï¼Œå¸è½½åŸæœ‰å‘è¡Œç‰ˆä»¥é‡Šæ”¾ C ç›˜ç©ºé—´ \u003e wsl --unregister Ubuntu-22.04 # é‡æ–°å¯¼å…¥å‘è¡Œç‰ˆé•œåƒã€‚å¹¶æŒ‡å®šè¯¥å­ç³»ç»Ÿå‚¨å­˜çš„ç›®å½• (å³è¿›è¡Œè¿ç§») \u003e wsl --import Ubuntu-22.04 D:\\Ubuntu\\ D:\\ubuntu.tar --version 2 # ä¸Šé¢å‘½ä»¤å®Œæˆåï¼Œåœ¨ç›®å½• D:\\Ubuntu ä¸‹ä¼šå‡ºç°åä¸º ext4.vhdx çš„æ–‡ä»¶ï¼Œè¿™ä¸ªå°±æ˜¯å­ç³»ç»Ÿçš„è™šæ‹Ÿç£ç›˜ # è®¾ç½®å¯ç”¨å­ç³»ç»Ÿæ—¶çš„é»˜è®¤ç”¨æˆ· (å»ºè®®ä½¿ç”¨è¿ç§»å‰åˆ›å»ºçš„ç”¨æˆ·)ï¼Œå¦åˆ™å¯åŠ¨å­ç³»ç»Ÿæ—¶è¿›å…¥çš„æ˜¯ root ç”¨æˆ· \u003e ubuntu-22.04.exe config --default-user \u003cusername\u003e ","date":"2024-04-20","objectID":"/posts/wsl2/:2:0","tags":["Windows","WSL","Ubuntu"],"title":"Windows 10 WSL2 Ubuntu 22.04 é…ç½®æŒ‡å—","uri":"/posts/wsl2/"},{"categories":["Toolkit"],"content":"Windows Terminal ç¾åŒ– ","date":"2024-04-20","objectID":"/posts/wsl2/:3:0","tags":["Windows","WSL","Ubuntu"],"title":"Windows 10 WSL2 Ubuntu 22.04 é…ç½®æŒ‡å—","uri":"/posts/wsl2/"},{"categories":["Toolkit"],"content":"å…¶å®ƒ ç›®å‰ Windows 10 ä¸Šçš„ WSL2 åº”è¯¥éƒ½æ”¯æŒ WSLg (å¦‚æœä½ ä¸€ç›´æ›´æ–°çš„è¯)ï¼Œå¯ä»¥ä½¿ç”¨ gedit æ¥æµ‹è¯•ä¸€ä¸‹ WLSg çš„åŠŸèƒ½ï¼Œå¯ä»¥å‚è€ƒå¾®è½¯çš„å®˜æ–¹æ–‡æ¡£: https://github.com/microsoft/wslg ","date":"2024-04-20","objectID":"/posts/wsl2/:4:0","tags":["Windows","WSL","Ubuntu"],"title":"Windows 10 WSL2 Ubuntu 22.04 é…ç½®æŒ‡å—","uri":"/posts/wsl2/"},{"categories":["Toolkit"],"content":"æ•ˆæœå±•ç¤º ","date":"2024-04-20","objectID":"/posts/wsl2/:5:0","tags":["Windows","WSL","Ubuntu"],"title":"Windows 10 WSL2 Ubuntu 22.04 é…ç½®æŒ‡å—","uri":"/posts/wsl2/"},{"categories":["CSAPP","Linux Kernel Internals"],"content":" åƒä¸‡ä¸è¦å°çœ‹æ•°å€¼ç³»ç»Ÿï¼Œå²ä¸Šä¸å°‘æœ‰åçš„ è½¯ä½“ç¼ºå¤±æ¡ˆä¾‹ å°±å› ä¸ºå¼€å‘è€…æœªèƒ½å……åˆ†æŒæ¡ç›¸å…³è®®é¢˜ï¼Œè€Œå¯¼è‡´è«å¤§çš„ä¼¤å®³ä¸æŸå¤±ã€‚ åŸæ–‡åœ°å€ æ­é… CMU: 15-213: Intro to Computer Systems: Schedule for Fall 2015 å¯ä»¥åœ¨ è¿™é‡Œ æ‰¾åˆ°ç›¸å…³çš„æŠ•å½±ç‰‡å’Œå½•å½± B ç«™ä¸Šæœ‰ä¸€ä¸ªæ±‰åŒ–ç‰ˆæœ¬çš„ å½•å½± ","date":"2024-04-19","objectID":"/posts/csapp-ch2/:0:0","tags":["Sysprog","CSAPP"],"title":"CS:APP ç¬¬ 2 ç« é‡ç‚¹æç¤ºå’Œç»ƒä¹ ","uri":"/posts/csapp-ch2/"},{"categories":["CSAPP","Linux Kernel Internals"],"content":"æ•°å€¼ç³»ç»Ÿ ","date":"2024-04-19","objectID":"/posts/csapp-ch2/:1:0","tags":["Sysprog","CSAPP"],"title":"CS:APP ç¬¬ 2 ç« é‡ç‚¹æç¤ºå’Œç»ƒä¹ ","uri":"/posts/csapp-ch2/"},{"categories":["CSAPP","Linux Kernel Internals"],"content":"å¯¼è¯» YouTube: åè¿›åˆ¶ï¼ŒåäºŒè¿›åˆ¶ï¼Œå…­åè¿›åˆ¶ä»ä½•è€Œæ¥ï¼Ÿ YouTube: è€é¼ å’Œæ¯’è¯é—®é¢˜æ€ä¹ˆè§£ï¼ŸäºŒè¿›åˆ¶å’Œæ˜“ç»å…«å¦æœ‰å•¥å…³ç³»ï¼Ÿ YouTube: å°ç²¾éˆéŠæˆ²ä¸­çš„å¹½éˆæ˜¯æ€éº¼è¿½è¹¤äººçš„? é®®ç‚ºäººçŸ¥çš„ bug è§£è¯»è®¡ç®—æœºç¼–ç  ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡ ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡ åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹å¼å®‰å…¨è®®é¢˜ ç†Ÿæ‚‰æµ®ç‚¹æ•°æ¯ä¸ªä½çš„è¡¨ç¤ºå¯ä»¥è·å¾—æ›´å¤§çš„æœ€ä½³åŒ–ç©ºé—´ Faster arithmetic by flipping signs Faster floating point arithmetic with Exclusive OR çœ‹äº†ä¸Šé¢çš„ç¬¬ 3 ä¸ªå½±ç‰‡åï¼Œå¯¹ pac-man 256 è«åæ„Ÿå…´è¶£ ğŸ¤£ ","date":"2024-04-19","objectID":"/posts/csapp-ch2/:1:1","tags":["Sysprog","CSAPP"],"title":"CS:APP ç¬¬ 2 ç« é‡ç‚¹æç¤ºå’Œç»ƒä¹ ","uri":"/posts/csapp-ch2/"},{"categories":["CSAPP","Linux Kernel Internals"],"content":"Bits, Bytes \u0026 Integers ä¿¡æ¯ ç¬¬ä¸€éƒ¨åˆ†å½•å½± âœ… / æŠ•å½±ç‰‡ âœ… / é˜…è¯»ç« èŠ‚: 2.1 âœ… ä¿¡æ¯ ç¬¬äºŒéƒ¨åˆ†å½•å½± âœ… / æŠ•å½±ç‰‡ âœ… / é˜…è¯»ç« èŠ‚: 2.2-2.3 âœ… è®¡ç®—ä¹˜æ³•è‡³å¤šéœ€è¦å¤šå°‘ä½å¯ä»¥ä»æ— ç¬¦å·æ•°å’ŒäºŒè¡¥æ•°çš„ç¼–ç æ–¹å¼æ¥æ€è€ƒã€‚æ— ç¬¦å·æ•°ä¹˜æ³•æœ€å¤§å€¼ä¸º $2^{2w}-2^{2+1}+1$ ä¸è¶…è¿‡ $2^{2w}$ï¼Œä¾æ®æ— ç¬¦å·æ•°ç¼–ç æ–¹å¼è‡³å¤šéœ€è¦ $2w$ bits è¡¨ç¤ºï¼›äºŒè¡¥æ•°ä¹˜æ³•æœ€å°å€¼ä¸º $-2^{2w-2}+2^{w-1}$ï¼Œä¾æ®è€ŒäºŒè¡¥æ•°ç¼–ç  MSB è¡¨ç¤ºå€¼ $-2^{2w-2}$ï¼Œæ‰€ä»¥ MSB ä¸ºç¬¬ $2w-2$ ä½ï¼Œè‡³å¤šéœ€è¦ $2w-1$ bits è¡¨ç¤ºäºŒè¡¥æ•°ä¹˜æ³•çš„æœ€å°å€¼ï¼›äºŒè¡¥æ•°ä¹˜æ³•æœ€å¤§å€¼ä¸º $2^{2w-2}$ï¼Œå› ä¸º MSB ä¸ºç¬¦å·ä½ï¼Œæ‰€ä»¥ MSB çš„å³ä¸€ä½è¡¨ç¤ºå€¼ $2^{2w-2}$ï¼Œå³ç¬¬ $2w-2$ ä½ï¼Œæ‰€ä»¥è‡³å¤šéœ€è¦ $2w$ ä½æ¥è¡¨ç¤ºè¯¥å€¼ (å› ä¸ºè¿˜éœ€è¦è€ƒè™‘ä¸€ä¸ªç¬¦å·ä½)ã€‚ CS:APP 2.2.3 Twoâ€™s-Complement Encodings Note the different position of apostrophes: twoâ€™s complement versus onesâ€™ complement. The term â€œtwoâ€™s complementâ€ arises from the fact that for nonnegative x we compute a w-bit representation of âˆ’x as 2w âˆ’ x (a single two.) The term â€œonesâ€™ complementâ€ comes from the property that we can compute âˆ’x in this notation as [111 . . . 1] âˆ’ x (multiple ones). CS:APP 2.2.6 Expanding the Bit Representation of a Number This shows that, when converting from short to unsigned, the program first changes the size and then the type. That is, (unsigned) sx is equivalent to (unsigned) (int) sx, evaluating to 4,294,954,951, not (unsigned) (unsigned short) sx, which evaluates to 53,191. Indeed, this convention is required by the C standards. å…³äºä½æ‰©å±•/è£å‰ªä¸ç¬¦å·ç±»å‹çš„å…³ç³»è¿™éƒ¨åˆ†ï¼Œå¯ä»¥å‚çœ‹æˆ‘æ‰€å†™çš„ç¬”è®° åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜ï¼Œé‡Œé¢æœ‰æ ¹æ®è§„æ ¼ä¹¦è¿›è¡Œäº†æ¢è®¨ã€‚ CS:APP 2.3.1 Unsigned Addition DERIVATION: Detecting overflow of unsigned addition Observe that $x + y \\geq x$, and hence if $s$ did not overflow, we will surely have $s \\geq x$. On the other hand, if $s$ did overflow, we have $s = x + y âˆ’ 2^w$. Given that $y \u003c 2^w$, we have $y âˆ’ 2^w \u003c 0$, and hence $s = x + (y âˆ’ 2^w ) \u003c x$. è¿™ä¸ªè¯æ˜æŒºæœ‰è¶£çš„ï¼Œå¯¹äºåŠ æ³• overflow å¾—å‡ºçš„ç»“æœ $s$ çš„å€¼å¿…ç„¶æ¯”ä»»æ„ä¸€ä¸ªæ“ä½œæ•° $x$ å’Œ $y$ çš„å€¼éƒ½å°ã€‚ Practice Problem 2.31 åˆ©ç”¨äº†é˜¿è´å°”ç¾¤çš„å®šä¹‰æ¥è¯´æ˜äºŒè¡¥æ•°ç¼–ç çš„å¯ç»“åˆçº¿ï¼Œååˆ†æœ‰è¶£ã€‚ Practice Problem 2.32 è¯´æ˜äº†äºŒè¡¥æ•°ç¼–ç çš„ä¸€ä¸ªéœ€è¦ç‰¹åˆ«æ³¨æ„çš„ç‚¹ï¼šäºŒè¡¥æ•°ç¼–ç æ„æˆçš„ç¾¤æ˜¯éå¯¹ç§°çš„ï¼Œ$TMin$ çš„åŠ æ³•é€†å…ƒæ˜¯å…¶è‡ªèº«ï¼Œå…¶åŠ æ³•é€†å…ƒåä»ä¸º $TMin$ã€‚ CS:APP 2.3.3 Twoâ€™s-Complement Negation One technique for performing twoâ€™s-complement negation at the bit level is to complement the bits and then increment the result. A second way to perform twoâ€™s-complement negation of a number $x$ is based on splitting the bit vector into two parts. Let $k$ be the position of the rightmost $1$, so the bit-level representation of $x$ has the form $[x_{wâˆ’1}, x_{wâˆ’2}, â€¦, x_{k+1}, 1, 0, â€¦, 0]$. (This is possible as long as $x \\neq 0$.) The negation is then written in binary form as $[~x_{wâˆ’1}, ~x_{wâˆ’2}, â€¦, ~x_{k+1}, 1, 0, â€¦, 0]$. That is, we complement each bit to the left of bit position $k$. ç¬¬äºŒç§è§£é‡Šåœ¨æŸäº›æƒ…å†µä¸‹ååˆ†æœ‰æ•ˆï¼Œä½†è¿™ä¸¤ç§è®¡ç®—äºŒè¡¥æ•°çš„åŠ æ³•é€†å…ƒçš„æ–¹æ³•æœ¬è´¨éƒ½æ¥è‡ª è§£è¯»è®¡ç®—æœºç¼–ç  ä¸­çš„æ—¶é’Ÿæ¨¡å‹ã€‚ CSAPP: 2.3.5 Twoâ€™s-Complement Multiplication Practice Problem 2.35 ä½¿ç”¨äº†é™¤æ³•çš„å®šä¹‰è¯æ˜äº†ï¼Œä½¿ç”¨é™¤æ³•æ¥æ£€æµ‹äºŒè¡¥æ•°ä¹˜æ³•æº¢å‡ºçš„æ­£ç¡®æ€§ (å¦‚æœä¸çŸ¥é“ä»€ä¹ˆæ˜¯é™¤æ³•çš„å®šä¹‰ï¼Œå¯ä»¥çœ‹å°æ¹¾å¤§å­¦é½éœ‡å®‡è€å¸ˆçš„æ•°å­¦æ–°ç”Ÿè¥æ¼”è®²å½•å½±ï¼Œéå¸¸æ£’)ã€‚ ä¸åŠ æ³•æº¢å‡ºçš„æ£€æµ‹ä¸å¤ªç›¸åŒï¼Œä¹˜æ³•æº¢å‡ºçš„æ£€æµ‹ï¼Œä¸è®ºæ— ç¬¦å·æ•°è¿˜æ˜¯äºŒè¡¥æ•°ï¼Œéƒ½å¯ä»¥ä½¿ç”¨ä¸‹é¢è¿™ç§æ–¹æ³•æ¥æ£€æµ‹: // x and y is N-bit wide int2N_t s = x * y; return s == (intN_t) s; å¦‚æœæ˜¯æ— ç¬¦å·æ•°åˆ™ä½¿ç”¨ç›¸åº”çš„ uint2N_t ç±»å‹ã€‚Practice Problem 2.36 å’Œ 2.37 éƒ½ä½¿ç”¨åˆ°äº†è¿™ä¸ªæŠ€å·§ã€‚ CS:APP 2.3.6 Multiplying by Constants principle: Unsigned multiplication by a power of 2 principle: Twoâ€™s-complement multiplication by a power of 2 è¿™ä¸¤ä¸ªæ€§è´¨ (ä»¥åŠè¯¥æ€§è´¨çš„è¯æ˜) è¯´æ˜ï¼Œæ— è®ºæ˜¯æ— ç¬¦å·æ•°è¿˜æ˜¯äºŒè¡¥æ•°ï¼Œä½¿ç”¨å·¦ç§»è¿ç®—éƒ½å¯ä»¥è¾¾åˆ°ä¸ 2 çš„æ¬¡æ–¹è¿›è¡Œä¹˜æ³•è¿ç®—çš„æ•ˆæœï¼Œç”šè‡³åœ¨æº¢å‡ºçš„æƒ…å†µä¸‹ä½æ¨¡å¼ä¹ŸåŒ¹é…ã€‚è™½ç„¶å¦‚æ­¤ï¼ŒC è¯­è¨€çš„ç¼–è¯‘å™¨çš„å¤„ç†å¯èƒ½å¹¶ä¸ä¼šç¬¦åˆè¿™é‡Œè¯´æ˜çš„ç­‰ä»·æ€§ï¼Œå› ä¸ºæ— ç¬¦å·æ•°å’ŒäºŒè¡¥æ•°å¯¹äºæº¢å‡ºæ˜¯ä¸ä¸€æ ·çš„ã€‚æ— ç¬¦å·æ•°æº¢å‡ºåœ¨ C è¯­è¨€è§„èŒƒå¹¶ä¸æ˜¯ UBï¼Œä½†äºŒè¡¥æ•°æˆ–è€…è¯´æœ‰ç¬¦å·æ•°æº¢å‡ºåœ¨ C è¯­è¨€ä¸­æ˜¯ UBï¼Œæ‰€ä»¥æœ‰æ—¶å€™ä½¿ç”¨æœ‰ç¬¦å·æ•°åˆ†åˆ«è¿›è¡Œï¼Œç†è®ºä¸Šç»“æœç­‰ä»·çš„å·¦ç§»è¿ç®—å’Œä¹˜æ³•è¿ç®—ï¼Œå¾—åˆ°çš„ç»“æœå¯èƒ½å¹¶ä¸ç›¸åŒï¼Œç‰¹åˆ«æ˜¯åœ¨å¯ç”¨äº†ç¼–è¯‘å™¨æœ€ä½³åŒ–çš„æƒ…å†µä¸‹ (å› ä¸ºç¼–è¯‘å™¨å°†ä¾èµ– UB å³æº¢å‡ºçš„æœ‰ç¬¦å·æ•°ä¹˜æ³•è¿ç®—çš„è¡Œä¸ºç§»é™¤äº† ğŸ¤£)ã€‚ç›¸å…³çš„è¯´æ˜è¯·å‚è€ƒé˜…è¯» C è¯­è¨€: æœªå®šä¹‰/æœªæŒ‡å®šè¡Œä¸ºç¯‡ã€‚ CS:APP 2.3.7 Dividing by Powers of 2 principle: Unsigned division by a power of 2 For C variables $x$ and $k$ with unsigned values $x$ and $k$, such that $0 \\leq k \u003c w$, the C expression $x Â» k$ yields the value $\\lfloor x/2k \\rfloor$ ä½¿ç”¨ç®—æœ¯å³ç§»è·å¾—çš„ç»“æœæ˜¯ $\\lfloor x/2k \\rfloor$ï¼Œè¿™ä¸æ•´æ•°é™¤æ³•è·å¾—çš„æ»¡è¶³ å‘ 0 å–æ•´ æ€§è´¨çš„ç»“æœåœ¨è´Ÿæ•°çš„æƒ…å†µä¸‹æ˜¾ç„¶ä¸åŒï¼Œéœ€è¦è¿›è¡Œç›¸åº”çš„è°ƒèŠ‚: (x \u003c 0 ? x+(1\u003c\u003ck)-1 : x) \u003e\u003e k Practice Problem 2.42 æŒºæœ‰æ„æ€çš„ï¼Œæˆ‘æ‰©å±•äº†ä¸€ä¸‹æ€è·¯ï¼Œå°†å…¶æ”¹ç¼–ä¸ºæ”¯æ´ä»»æ„ 2 çš„æ¬¡æ–¹çš„é™¤æ³•: // x / (2^k) int div_2pK(int x, int k) { int s = (x \u003e\u003e 31); return (x + ((-s) \u003c\u003c k) + s) \u003e\u003e k; } ","date":"2024-04-19","objectID":"/posts/csapp-ch2/:1:2","tags":["Sysprog","CSAPP"],"title":"CS:APP ç¬¬ 2 ç« é‡ç‚¹æç¤ºå’Œç»ƒä¹ ","uri":"/posts/csapp-ch2/"},{"categories":["CSAPP","Linux Kernel Internals"],"content":"æµ®ç‚¹æ•° ","date":"2024-04-19","objectID":"/posts/csapp-ch2/:2:0","tags":["Sysprog","CSAPP"],"title":"CS:APP ç¬¬ 2 ç« é‡ç‚¹æç¤ºå’Œç»ƒä¹ ","uri":"/posts/csapp-ch2/"},{"categories":["CSAPP","Linux Kernel Internals"],"content":"å¯¼è¯» ","date":"2024-04-19","objectID":"/posts/csapp-ch2/:2:1","tags":["Sysprog","CSAPP"],"title":"CS:APP ç¬¬ 2 ç« é‡ç‚¹æç¤ºå’Œç»ƒä¹ ","uri":"/posts/csapp-ch2/"},{"categories":["CSAPP","Linux Kernel Internals"],"content":"Floating Point ä¿¡æ¯ å½•å½± âœ… / æŠ•å½±ç‰‡ âœ… / é˜…è¯»ç« èŠ‚: 2.4 æµ®ç‚¹æ•°åå­—çš„æ¥æºæ˜¯æŒ‡æ•°éƒ¨åˆ† $E$ å¯ä»¥è¿›è¡Œè°ƒèŠ‚è¿›è€Œå½±å“å°æ•°ç‚¹çš„ä½ç½®ï¼Œä½¿å¾—å°æ•°ç‚¹åœ¨å„ç§æ•°å­—çš„è¡¨ç¤ºæ—¶åœ¨æµ®åŠ¨ä¸€èˆ¬ã€‚ æ­¤æ—¶è®© Exponent value: E = 1 â€“ Bias (instead of E = 0 â€“ Bias) å¯ä»¥ä½¿å¾—è¿™æ—¶çš„ Exponent value å’Œ exp ä¸º 1 æ—¶ (å…¶ Exponent value ä¹Ÿä¸º E = 1 â€“ Bias) ç›¸åŒï¼Œè®©æµ®ç‚¹æ•°å¯ä»¥åœ¨è§£å†³ 0 çš„éƒ¨åˆ†å‡åˆ†è¡¨ç¤º: $1.xxxxâ€¦ \\times 2^{1 - Bias}$, $0.xxxxâ€¦ \\times 2^{1 - Bias}$ Normalized Encoding æ—¶ï¼ŒæŒ‡æ•°æ¯æ¬¡ $+ 1$ï¼Œå°±ä¼šä½¿å¾—å¯è¡¨ç¤ºçš„æµ®ç‚¹æ•°ä¹‹é—´æ•°å€¼çš„å·®è· $\\times 2$ (å› ä¸ºæ­£å¦‚å‰é¢æ‰€è¯´çš„ï¼Œæµ®ç‚¹æ•°æµ®åŠ¨äº†å°æ•°ç‚¹ï¼Œä½¿å¾—ç”¨äºè¡¨ç¤ºå°æ•°ä½çš„ç¼–ç ä½å˜å°‘äº†)ã€‚æ³¨æ„ä¸‹é¢çš„ $(n)$ å’Œ $(1)$ åªæ˜¯è¡¨ç¤º Significand éƒ¨åˆ†çš„ç¼–ç ï¼Œä¸ä»£è¡¨æ•°å€¼ (å› ä¸ºè¿™éƒ¨åˆ†çš„æ•°å€¼æ˜¯å°æ•°â€¦) $$ 1.(n+1) \\times 2^{K} - 1.(n) \\times 2^{K} = (1) \\times 2^{K} \\\\ 1.(n+1) \\times 2^{K + 1} - 1.(n) \\times 2^{K + 1} = (1) \\times 2^{K + 1} \\\\ (1) \\times 2^{K + 1} = 2 \\times ((1) \\times 2^{K}) $$ æ˜¾ç„¶ä¸¤ä¸ªæµ®ç‚¹æ•°ä¹‹é—´çš„å·®è·å˜ä¸ºäº†åŸå…ˆçš„ 2 å€äº†ã€‚ Nearest Even æ˜¯ç”¨äºå†³å®šï¼Œå½“å‰æ•°å€¼æ˜¯èˆå…¥çš„ä¸¤ä¸ªæ•°å€¼çš„ä¸­é—´å€¼æ—¶ï¼Œå‘å“ªä¸ªæ•°å€¼è¿›è¡Œèˆå…¥çš„ç­–ç•¥ã€‚å‡è®¾å½“å‰æ•°å€¼ä¸º $1.2xxxxâ€¦$ (åè¿›åˆ¶)ï¼Œéœ€è¦èˆå…¥åˆ° $0.1$ çš„ç²¾åº¦: å½“ $xxxxâ€¦ \u003e 5000..0$ æ—¶ï¼Œå³å½“å‰æ•°å€¼ $\u003e 1.25$ï¼Œæ ¹æ®ç²¾åº¦å‘ä¸Šå–æ•´èˆå…¥åˆ° $1.3$ å½“ $xxxxâ€¦ \u003c 5000..0$ æ—¶ï¼Œå³å½“å‰æ•°å€¼ $\u003c 1.25$ï¼Œæ ¹æ®ç²¾åº¦å‘ä¸‹å–æ•´èˆå…¥åˆ° $1.2$ å½“ $xxxxâ€¦ = 5000..0$ æ—¶ï¼Œå³å½“å‰æ•°å€¼ $= 1.25$ï¼Œæ ¹æ®ç²¾åº¦èˆå…¥åˆ°æœ€è¿‘å¶æ•° $1.2$ ç±»ä¼¼çš„ï¼Œå‡è®¾å½“å‰æ•°å€¼ä¸º $1.3xxxxâ€¦$ï¼Œæƒ…å†µå¦‚ä¸‹: å½“ $xxxxâ€¦ \u003e 5000..0$ æ—¶ï¼Œå³å½“å‰æ•°å€¼ $\u003e 1.35$ï¼Œæ ¹æ®ç²¾åº¦å‘ä¸Šå–æ•´èˆå…¥åˆ° $1.4$ å½“ $xxxxâ€¦ \u003c 5000..0$ æ—¶ï¼Œå³å½“å‰æ•°å€¼ $\u003c 1.35$ï¼Œæ ¹æ®ç²¾åº¦å‘ä¸‹å–æ•´èˆå…¥åˆ° $1.3$ å½“ $xxxxâ€¦ = 5000..0$ æ—¶ï¼Œå³å½“å‰æ•°å€¼ $= 1.35$ï¼Œæ ¹æ®ç²¾åº¦èˆå…¥åˆ°æœ€è¿‘å¶æ•° $1.4$ CSAPP 2.4.1 Fractional Binary Numbers Note that numbers of the form $0.11â€¦1_2$ represent numbers just below 1. CSAPP 2.4.2 IEEE Floating-Point Representation Having the exponent value be $1 âˆ’ Bias$ rather than simply $âˆ’Bias$ might seem counterintuitive. We will see shortly that it provides for smooth transition from denormalized to normalized values. é™¤äº†è®©æµ®ç‚¹æ•°åœ¨é è¿‘ 0 çš„éƒ¨åˆ†å¹³æ»‘å‡åˆ†è¡¨ç¤ºä¹‹å¤–ï¼Œä½¿ç”¨ biased form è¿˜å¯ä»¥è®©æµ®ç‚¹æ•°çš„å¤§å°æ¯”è¾ƒå˜å¾—ç®€å•ï¼Œåªéœ€ä½¿ç”¨ æ— ç¬¦å·ç¼–ç  è¡¨ç¤º exponent field ç„¶åè¿›è¡Œæ¯”è¾ƒå³å¯ (å¦‚æœé‡‡å–äºŒè¡¥æ•°ç¼–ç ï¼Œé‚£ä¹ˆç¼–ç å¤§çš„å¯èƒ½è¡¨ç¤ºè´Ÿæ•°ï¼Œå¤§å°æ¯”è¾ƒèµ·æ¥æ›´éº»çƒ¦)ã€‚ Denormalized numbers serve two purposes. First, they provide a way to represent numeric value 0 A second function of denormalized numbers is to represent numbers that are very close to 0.0. Denormalized çš„ä½œç”¨ä¸€æ˜¯è¡¨ç¤º 0ï¼ŒäºŒæ˜¯é…åˆ Normalized åœ¨é è¿‘ 0 çš„éƒ¨åˆ†è¿›è¡Œå¹³æ»‘å‡åˆ†è¡¨ç¤º CSAPP 2.4.3 Example Numbers This is no accidentâ€”the IEEE format was designed so that floating-point numbers could be sorted using an integer sorting routine. A minor difficulty occurs when dealing with negative numbers, since they have a leading 1 and occur in descending order, but this can be overcome without requiring floating-point operations to perform comparisons å¯ä»¥ç›´æ¥ä½¿ç”¨æ•´æ•°æ’åºæ¥å¯¹æµ®ç‚¹æ•°è¿›è¡Œæ’åºï¼Œè€Œæ— éœ€ä½¿ç”¨æµ®ç‚¹æ•°æ“ä½œæ¥è¿›è¡Œæ¯”è¾ƒï¼Œè¿™æ˜¯ IEEE 754 ç²¾å¿ƒè®¾è®¡çš„ We can now see that the region of correlation corresponds to the low-order bits of the integer, stopping just before the most significant bit equal to 1 (this bit forms the implied leading 1), matching the high-order bits in the fraction part of the floating-point representation. æµ®ç‚¹æ•°å’Œæ— ç¬¦å·æ•°çš„ç¼–ç ä¹‹é—´çš„å…³ç³»ï¼Œå…¶ä¸­æ— ç¬¦å·æ•°çš„ MSB which equal 1 è¢«å¿½ç•¥ï¼Œå› ä¸ºæµ®ç‚¹æ•°åœ¨ Normalized æ—¶ä¼šæœ‰ä¸€ä¸ªéšå«çš„ 1 CSAPP 2.4.4 Rounding Rounding toward even numbers avoids this statistical bias in most real-life situations. It will round upward about 50% of the time and round downward about 50% of the time. Round-to-even å¯ä»¥è®© round åçš„æ•°æ®åœ¨ç»Ÿè®¡ä¸Šçš„å‡å€¼ä¸åŸå…ˆæ•°æ®çš„å‡å€¼è¯¯å·®æ¯”è¾ƒå° ","date":"2024-04-19","objectID":"/posts/csapp-ch2/:2:2","tags":["Sysprog","CSAPP"],"title":"CS:APP ç¬¬ 2 ç« é‡ç‚¹æç¤ºå’Œç»ƒä¹ ","uri":"/posts/csapp-ch2/"},{"categories":["Linux","Linux Kernel Internals"],"content":" Linux æ ¸å¿ƒåŸå§‹ç¨‹å¼ç¢¼ä¸­ï¼Œè¨±å¤šåœ°æ–¹å‡ºç¾ç´…é»‘æ¨¹çš„è¹¤å½±ï¼Œä¾‹å¦‚ï¼šhr_timer ä½¿ç”¨ç´…é»‘æ¨¹ä¾†è¨˜éŒ„è¨ˆæ™‚å™¨ (timer) ç«¯ç™¼å‡ºçš„è¦æ±‚ã€ext3 æª”æ¡ˆç³»çµ±ä½¿ç”¨ç´…é»‘æ¨¹ä¾†è¿½è¹¤ç›®éŒ„å…§å®¹è®Šæ›´ï¼Œä»¥åŠ CFS (Completely Fair Scheduler) é€™å€‹ Linux é è¨­ CPU æ’ç¨‹å™¨ï¼Œç”±æ–¼éœ€è¦é »ç¹åœ°æ’å…¥è·Ÿç§»é™¤ç¯€é» (ä»»å‹™)ï¼Œå› æ­¤é–‹ç™¼è€…é¸æ“‡ç”¨ç´…é»‘æ¨¹ (æ­é…ä¸€äº›æ•ˆèƒ½èª¿æ•´)ã€‚VMAï¼ˆVirtual Memory Areaï¼‰ä¹Ÿç”¨ç´…é»‘æ¨¹ä¾†ç´€éŒ„è¿½è¹¤é é¢ (page) è®Šæ›´ï¼Œå› ç‚ºå¾Œè€…ä¸å…å­˜åœ¨é »ç¹çš„è®€å– VMA çµæ§‹ï¼Œå¦‚ page fault å’Œ mmap ç­‰æ“ä½œï¼Œä¸”ç•¶å¤§é‡çš„å·²æ˜ å°„ (mapped) å€åŸŸæ™‚å­˜åœ¨æ™‚ï¼Œè‹¥è¦å°‹æ‰¾æŸå€‹ç‰¹å®šçš„è™›æ“¬è¨˜æ†¶é«”åœ°å€ï¼Œéˆçµä¸²åˆ— (linked list) çš„èµ°è¨ªæˆæœ¬éé«˜ï¼Œå› æ­¤éœ€è¦ä¸€ç¨®è³‡æ–™çµæ§‹ä»¥æä¾›æ›´æœ‰æ•ˆç‡çš„å°‹æ‰¾ï¼Œæ–¼æ˜¯ç´…é»‘æ¨¹å°±å¯å‹ä»»ã€‚ åŸæ–‡åœ°å€ ","date":"2024-04-12","objectID":"/posts/linux-rbtree/:0:0","tags":["Sysprog","Linux","Red Black Tree"],"title":"Linux æ ¸å¿ƒçš„çº¢é»‘æ ‘","uri":"/posts/linux-rbtree/"},{"categories":["Linux","Linux Kernel Internals"],"content":"å¼€ç¯‡ç‚¹é¢˜ ç›¸å…³è®¨è®º: Red-black tree over AVL tree æ•ˆèƒ½è¡¨ç°çš„å·®å¼‚ï¼Œå‚è€ƒ Performance Analysis of BSTs in System Software: The results indicate that when input is expected to be randomly ordered with occasional runs of sorted order, red-black trees are preferred; when insertions often occur in sorted order, AVL trees excel for later random access, whereas splay trees perform best for later sequential or clustered access. ä»¥åŠ Red-black Trees (rbtree) in Linux: Red-black trees are a type of self-balancing binary search tree, used for storing sortable key/value data pairs. This differs from radix trees (which are used to efficiently store sparse arrays and thus use long integer indexes to insert/access/delete nodes) and hash tables (which are not kept sorted to be easily traversed in order, and must be tuned for a specific size and hash function where rbtrees scale gracefully storing arbitrary keys). ","date":"2024-04-12","objectID":"/posts/linux-rbtree/:1:0","tags":["Sysprog","Linux","Red Black Tree"],"title":"Linux æ ¸å¿ƒçš„çº¢é»‘æ ‘","uri":"/posts/linux-rbtree/"},{"categories":["Linux","Linux Kernel Internals"],"content":"ç®€è¿°çº¢é»‘æ ‘ Left-Leaning Red-Black Trees (by Robert Sedgewick): è®ºæ–‡ / æŠ•å½±ç‰‡ è§£è¯´å½•å½±: Left Leaning Red Black Trees (Part 1) Left Leaning Red Black Trees (Part 2) 2-3-4 tree: Problem: Doesnâ€™t work if parent is a 4-node ä¸ºè§£å†³è¯¥é—®é¢˜ï¼ŒæŠ•å½±ç‰‡ä¸»è¦è¯´æ˜çš„æ˜¯ Split 4-nodes on the way down æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•çš„é€»è¾‘æ˜¯ï¼šåœ¨æ’å…¥èŠ‚ç‚¹å‰å‘ä¸‹èµ°è®¿çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå‘ç°æŸä¸ªèŠ‚ç‚¹æ˜¯ 4-nodes åˆ™å¯¹è¯¥èŠ‚ç‚¹è¿›è¡Œ split æ“ä½œï¼Œå…·ä½“ä¾‹å­å¯ä»¥å‚è€ƒæŠ•å½±ç‰‡çš„ P24 ~ P25ã€‚ LLRB tree: Problem: Doesnâ€™t work if parent is a 4-node ä¸ºè§£å†³è¯¥é—®é¢˜ï¼ŒæŠ•å½±ç‰‡ä¸»è¦è¯´æ˜çš„ä¹Ÿæ˜¯ Split 4-nodes on the way down æ–¹æ³•ï¼Œå…¶é€»è¾‘å’Œä¹‹å‰ç›¸åŒï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œåœ¨æ’å…¥èŠ‚ç‚¹åå‘ä¸Šè¿”å›çš„è¿‡ç¨‹ä¸­ï¼Œè¿›è¡Œ rotate æ“ä½œï¼Œä¿è¯äº† LLRB èŠ‚ç‚¹çš„ç»“æ„æ»¡è¶³è¦æ±‚ (å³çº¢è¾¹çš„ä½ç½®)ã€‚ æŠ€å·§ åœ¨æ‹†åˆ† 4-node æ—¶ 3-node å’Œ 4-node çš„å­©å­èŠ‚ç‚¹çš„å¤§å°å…³ç³»ä¸å¤ªç›´è§‚ï¼Œè¿™æ—¶å¯ä»¥å‚è€ƒè§£è¯´å½•å½±çš„è€å¸ˆçš„æ–¹æ³•ï¼Œä½¿ç”¨æ•°å­—æˆ–å­—æ¯æ ‡è¯†èŠ‚ç‚¹ï¼Œè¿›è€Œå¯ä»¥ç›´è§‚çœ‹å‡º 4-node è½¬æ¢å‰åçš„ç­‰ä»·æ€§ã€‚ å¦‚æœæˆ‘ä»¬å°† 4-node èŠ‚ç‚¹çš„æ‹†åˆ†æ”¾åœ¨æ’å…¥èŠ‚ç‚¹åå‘ä¸Šè¿”å›çš„è¿‡ç¨‹è¿›è¡Œå¤„ç†ï¼Œåˆ™ä¼šå°†åŸæœ¬çš„æ ‘ç»“æ„è½¬æ¢æˆ 2-3 treeï¼Œå› ä¸ºè¿™æ ·æ’å…¥èŠ‚ç‚¹åï¼Œä¸ä¼šä¿ç•™æœ‰ 4-node (æ’å…¥äº§ç”Ÿçš„ 4-node ç«‹åˆ»è¢«æ‹†åˆ†)ã€‚ æ³¨æ„ çº¢é»‘æ ‘çš„ perfect-balance çš„ç‰¹æ€§åœ¨äºï¼šå®ƒéšç€èŠ‚ç‚¹çš„å¢å¤šè€Œé€æ¸å°† 4-nodes (å› ä¸ºæ–°å¢èŠ‚ç‚¹éƒ½æ˜¯ red è¾¹ï¼Œæ‰€ä»¥å¶èŠ‚ç‚¹å¾ˆå¤§æ¦‚ç‡åœ¨æ’å…¥ç»“æŸåä¼šæ˜¯ 4-node) ä»æ ¹èŠ‚ç‚¹æ–¹å‘ç§»åŠ¨ (on the way down æ—¶ split 4-nodes çš„æ•ˆæœ)ï¼Œå½“ 4-node ç§»åŠ¨åˆ°æ ¹èŠ‚ç‚¹æ—¶ï¼Œè¿›è¡Œé¢œè‰²åè½¬å¹¶ä¸ä¼šç ´åæ ‘çš„å¹³è¡¡ï¼Œåªæ˜¯æ ‘é«˜åŠ  1 (è¿™å¾ˆå¥½ç†è§£ï¼Œå› ä¸ºæ ¹èŠ‚ç‚¹æ˜¯å”¯ä¸€çš„ï¼Œåªè¦ä¿è¯ 4-node çš„æ ¹èŠ‚ç‚¹æ‹†åˆ†æ“ä½œä¿æŒå¹³è¡¡å³å¯ï¼Œæ˜¾ç„¶æˆç«‹)ã€‚ ","date":"2024-04-12","objectID":"/posts/linux-rbtree/:2:0","tags":["Sysprog","Linux","Red Black Tree"],"title":"Linux æ ¸å¿ƒçš„çº¢é»‘æ ‘","uri":"/posts/linux-rbtree/"},{"categories":["Linux","Linux Kernel Internals"],"content":"çº¢é»‘æ ‘çš„å®šä¹‰ 2-3-4 æ•°å’Œçº¢é»‘æ ‘çš„è½¬æ¢å…³ç³»: ","date":"2024-04-12","objectID":"/posts/linux-rbtree/:2:1","tags":["Sysprog","Linux","Red Black Tree"],"title":"Linux æ ¸å¿ƒçš„çº¢é»‘æ ‘","uri":"/posts/linux-rbtree/"},{"categories":["Linux","Linux Kernel Internals"],"content":"çº¢é»‘æ ‘çš„æ’å…¥ æ³¨æ„ åƒæ™®é€šçš„æ ‘ä¸€æ ·å¯»æ‰¾åˆé€‚çš„ä½ç½®æ’å…¥ çº¢èŠ‚ç‚¹ è‡ªåº•å‘ä¸Š é€šè¿‡æ—‹è½¬ã€åˆ†è£‚ã€åˆå¹¶ç­‰æ“ä½œè¿›è¡Œè°ƒæ•´ Definition: $n$ æ ‘èŠ‚ç‚¹è¡¨ç¤ºè¯¥èŠ‚ç‚¹æœ‰ $n$ ä¸ªå­æ ‘åˆ†æ”¯ çº¢é»‘æ ‘å‘ 2 æ ‘èŠ‚ç‚¹æ’å…¥å¾—åˆ° 3 æ ‘èŠ‚ç‚¹ï¼Œé€šè¿‡æ—‹è½¬æ“ä½œå³å¯å®Œæˆï¼Œä¹Ÿä¸æ¶‰åŠæ ‘é«˜å˜åŒ– (å› ä¸ºä» 2-3-4 æ ‘çš„è§’åº¦æ¥çœ‹ï¼Œæ ‘çš„èŠ‚ç‚¹æ•°ä¸å˜): çº¢é»‘æ ‘å‘ 3 æ ‘èŠ‚ç‚¹æ’å…¥å¾—åˆ° 4 æ ‘èŠ‚ç‚¹å…±æœ‰ 3 ç§æƒ…å½¢ï¼Œé€šè¿‡æ—‹è½¬æ“ä½œå³å¯å®Œæˆï¼Œä¸ä¼šå¯¼è‡´æ ‘é«˜å˜åŒ– (å› ä¸ºä» 2-3-4 æ ‘çš„è§’åº¦æ¥çœ‹ï¼Œæ ‘çš„èŠ‚ç‚¹æ•°ä¸å˜): ç¬¬ä¸€ç§æƒ…å†µ ç¬¬äºŒç§æƒ…å†µ ç¬¬ä¸‰ç§æƒ…å†µ å¦‚æœçº¢é»‘æ ‘è¦æ’å…¥çš„èŠ‚ç‚¹æ˜¯ 4 æ ‘èŠ‚ç‚¹ï¼Œè¿™æ˜¯ä¸è¢«è¿è¡Œçš„ (å› ä¸ºçº¢é»‘æ ‘çš„èŠ‚ç‚¹ä¸å…è®¸è¶…è¿‡ 4 æ ‘èŠ‚ç‚¹)ï¼Œæ­¤æ—¶éœ€è¦æ—‹è½¬æ“ä½œæ­é…åˆ†è£‚å’Œåˆå¹¶ (é€šè¿‡æ”¹å˜è¾¹çš„é¢œè‰²) æ“ä½œï¼Œå°†è¯¥ 4 æ ‘èŠ‚ç‚¹ä¸æ–­åœ°å‘ä¸Šåˆ†è£‚æˆå¯¹åº”ç­‰ä»·çš„ 2 æ ‘èŠ‚ç‚¹ (è¿™å¯èƒ½ä¼šå¯¼è‡´æ ‘é«˜å¢åŠ )ï¼Œç„¶åä¾æ®ä¸Šé¢çš„æ’å…¥æ–¹æ³•å¯¹å‰©ä¸‹çš„ 2 æ ‘èŠ‚ç‚¹ / 3 æ ‘èŠ‚ç‚¹è¿›è¡Œæ’å…¥å³å¯ (å› ä¸ºåŸå…ˆçš„ 4 æ ‘èŠ‚ç‚¹å·²è¢«åˆ†è£‚ï¼Œæ‰€ä»¥è¦æ’å…¥çš„èŠ‚ç‚¹ä¸å¯èƒ½æ˜¯ 4 æ ‘èŠ‚ç‚¹): 4 æ ‘èŠ‚ç‚¹ç¿»è½¬è¿æ¥çˆ¶èŠ‚ç‚¹çš„è¾¹é¢œè‰²è¿›è¡Œåˆ†è£‚: çˆ¶èŠ‚ç‚¹ä¸º 2 æ ‘èŠ‚ç‚¹æ—¶çš„é¢œè‰²ç¿»è½¬åˆ†è£‚ï¼Œæœ‰ 2 ç§æƒ…å†µ: æƒ…å†µ 1: 4 æ ‘èŠ‚ç‚¹ä¸ºçˆ¶èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ æƒ…å†µ 2: 4 æ ‘èŠ‚ç‚¹ä¸ºçˆ¶èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ çˆ¶èŠ‚ç‚¹ä¸º 3 æ ‘èŠ‚ç‚¹æ—¶çš„é¢œè‰²ç¿»è½¬åˆ†è£‚ï¼Œæ¯”è¾ƒå¤æ‚ï¼Œæœ‰ 3 ç§æƒ…å†µ: ç¬¬ä¸€ç§æƒ…å†µ ç¬¬äºŒç§æƒ…å†µ ç¬¬ä¸‰ç§æƒ…å†µ å› ä¸ºçº¢é»‘æ ‘å’Œ 2-3-4 æ ‘ä¸€æ ·ï¼Œéƒ½æ˜¯ä»å¶å­èŠ‚ç‚¹å¤„æ’å…¥æ–°èŠ‚ç‚¹ï¼Œå¦‚æœæ–°æ’å…¥çš„èŠ‚ç‚¹ä½¿å¾—å¶å­èŠ‚ç‚¹å˜æˆäº† 4 æ ‘èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæ­¤æ—¶å°±ä¼šä»ä¸‹å¾€ä¸Šå¯¹ 4 æ ‘èŠ‚ç‚¹è¿›è¡Œåˆ†è£‚é¢œè‰²ç¿»è½¬ï¼Œå¦‚æœè¿™ä¸ªè¿‡ç¨‹ä½¿å¾—çˆ¶èŠ‚ç‚¹æˆä¸ºäº†æ–°çš„ 4 æ ‘èŠ‚ç‚¹ï¼Œé‚£ä¹ˆç»§ç»­å¯¹çˆ¶èŠ‚ç‚¹è¿›è¡Œåˆ†è£‚é¢œè‰²ç¿»è½¬ï¼Œä¾æ¬¡å¤„ç†ï¼Œç›´åˆ°çˆ¶èŠ‚ç‚¹ä¸æ˜¯ 4 æ ‘èŠ‚ç‚¹æˆ–è¾¾åˆ°äº†æ ¹èŠ‚ç‚¹ï¼Œå¦‚æœæ ¹èŠ‚ç‚¹è¢«è¿™ä¸ªè¿‡ç¨‹å˜æˆäº† 4 æ ‘èŠ‚ç‚¹ï¼Œé‚£ä¹ˆåŒæ ·çš„å¯¹çˆ¶èŠ‚ç‚¹è¿›è¡Œåˆ†è£‚é¢œè‰²ç¿»è½¬ï¼Œè¿™ä¸ªæ“ä½œä¼šä½¿å¾—çº¢é»‘æ ‘æ ‘é«˜åŠ  1ã€‚æ‰€ä»¥æ­£å¸¸æƒ…å†µä¸‹ï¼Œ4 æ ‘èŠ‚ç‚¹åªä¼šåœ¨æ’å…¥èŠ‚ç‚¹åæŸä¸ªæ—¶é—´ç‚¹çŸ­æš‚å­˜åœ¨äºçº¢é»‘æ ‘ä¸­ï¼Œæ‰€ä»¥ä¸éœ€è¦è€ƒè™‘çˆ¶èŠ‚ç‚¹ä¸º 4 æ ‘èŠ‚ç‚¹çš„æ’å…¥æƒ…å†µã€‚ ","date":"2024-04-12","objectID":"/posts/linux-rbtree/:2:2","tags":["Sysprog","Linux","Red Black Tree"],"title":"Linux æ ¸å¿ƒçš„çº¢é»‘æ ‘","uri":"/posts/linux-rbtree/"},{"categories":["Linux","Linux Kernel Internals"],"content":"çº¢é»‘æ ‘çš„ç§»é™¤ ","date":"2024-04-12","objectID":"/posts/linux-rbtree/:2:3","tags":["Sysprog","Linux","Red Black Tree"],"title":"Linux æ ¸å¿ƒçš„çº¢é»‘æ ‘","uri":"/posts/linux-rbtree/"},{"categories":["Linux","Linux Kernel Internals"],"content":"Maple tree è§£è¯´å½•å½±: The Linux Maple Tree - Matthew Wilcox, Oracle ","date":"2024-04-12","objectID":"/posts/linux-rbtree/:3:0","tags":["Sysprog","Linux","Red Black Tree"],"title":"Linux æ ¸å¿ƒçš„çº¢é»‘æ ‘","uri":"/posts/linux-rbtree/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":" POSIX (Portable Operating System Interfaces) is a family of standards for maintaining compatibility between operating systems. POSIX is a Unix-like operating system environment and is currently available on Unix/Linux, Windows, OS/2 and DOS. Pthreads (POSIX Threads) is a POSIX standard for threads. The standard, POSIX.1c thread extension, defines thread creation and manipulation. This standard defines thread management, mutexes, conditions, read/write locks, barriers, etc. Except for the monitors, all features are available in Pthreads. åŸæ–‡åœ°å€ ","date":"2024-04-10","objectID":"/posts/posix-threads/:0:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: POSIX Threads","uri":"/posts/posix-threads/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Process vs. Thread vs. Coroutines With threads, the operating system switches running tasksÂ preemptively according to its scheduling algorithm. With coroutines, the programmer chooses, meaning tasks are cooperatively multitasked by pausing and resuming functions at set points. coroutine switches are cooperative, meaning the programmer controls when a switch will happen. The kernel is not involved in coroutine switches. ä¸€å›¾èƒœåƒè¯­: å…·ä½“ä¸€ç‚¹ï¼Œä»å‡½æ•°æ‰§è¡Œæµç¨‹æ¥çœ‹: $\\rightarrow$ åœ¨ä½¿ç”¨ coroutinues åæ‰§è¡Œæµç¨‹å˜æˆ $\\rightarrow$ C è¯­è¨€ç¨‹åºä¸­å®ä½œ coroutinue çš„æ–¹æ³•å¾ˆå¤šï¼Œä¾‹å¦‚ã€ŒC è¯­è¨€: goto å’Œæµç¨‹æ§åˆ¶ç¯‡ã€ä¸­æåˆ°çš„ä½¿ç”¨ switch-case æŠ€å·§è¿›è¡Œå®ä½œã€‚ è¿™ä¸‰ä¸ªæ¦‚å¿µå‡ºç°çš„æ—¶é—´ä¸å®ƒä»¬çš„å¤æ‚åº¦æ­£å¥½ç›¸åï¼Œæœ€å¤æ‚çš„ Process æœ€å…ˆå‡ºç°ï¼Œè€Œæœ€è½»é‡çš„ Coroutines åè€Œæœ€æ™šå‡ºç°ã€‚ ","date":"2024-04-10","objectID":"/posts/posix-threads/:1:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: POSIX Threads","uri":"/posts/posix-threads/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Thread \u0026 Process Wikipedia: Light-weight process On Linux, user threads are implemented by allowing certain processes to share resources, which sometimes leads to these processes to be called â€œlight weight processesâ€. å› ä¸º Linux åœ¨å®ä½œä¸Šæ•…æ„æ··æ·†äº† Process å’Œ Threadï¼Œæ‰€ä»¥ä¸€èˆ¬ä¸ä½¿ç”¨ Linux ä½œä¸º Thread çš„è§£é‡Šæ¡ˆä¾‹ Wikipedia: Thread-local storage On a modern machine, where multiple threads may be modifying the errno variable, a call of a system function on one thread may overwrite the value previously set by a call of a system function on a different thread, possibly before following code on that different thread could check for the error condition. The solution is to have errno be a variable that looks as if it is global, but is physically stored in a per-thread memory pool, the thread-local storage. ","date":"2024-04-10","objectID":"/posts/posix-threads/:1:1","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: POSIX Threads","uri":"/posts/posix-threads/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"PThread (POSIX threads) POSIX çš„å…¨ç§°æ˜¯ Portable Operating System Interfacesï¼Œç»“åˆä¸Šå›¾ï¼Œæ‰€ä»¥ä½ æ˜ç™½ pthread çš„ P ä»£è¡¨çš„æ„ä¹‰äº†å—ï¼Ÿ Answer ä» CPU å‚å•†ç¾¤é­”ä¹±èˆä¸­è¯ç”Ÿçš„æ ‡å‡†ï¼Œè‡ªç„¶æ˜¯è¦ä¿è¯å¯ç§»æ¤ Portable çš„å•¦ ğŸ¤£ æˆåŠŸ ä¸‹é¢çš„è¿™ä¸ªç”± Lawrence Livermore National Laboratory æ’°å†™çš„æ•™ç¨‹æ–‡æ¡£å†™çš„éå¸¸æ£’ï¼Œå€¼å¾—ä¸€è¯» (ä»–ä»¬è¿˜æœ‰å…³äº HPC é«˜æ€§èƒ½è®¡ç®—çš„ç›¸å…³æ•™ç¨‹æ–‡æ¡£): POSIX Threads Programming ","date":"2024-04-10","objectID":"/posts/posix-threads/:1:2","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: POSIX Threads","uri":"/posts/posix-threads/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Synchronizing Threads 3 basic synchronization primitives (ä¸ºä»€ä¹ˆæ˜¯è¿™ 3 ä¸ªï¼Ÿè¯·ä» synchronized-with å…³ç³»è¿›è¡Œæ€è€ƒ) mutex locks condition variables semaphores å–æè‡ª Ching-Kuang Shene æ•™æˆçš„è®²ä¹‰: Part IV Other Systems: IIIPthreads: A Brief Review Conditions in Pthreads are usually used with a mutex to enforce mutual exclusion. mutex locks pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; int pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t *attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); Only the owner can unlock a mutex. Since mutexes cannot be copied, use pointers. If pthread_mutex_trylock() returns EBUSY, the lock is already locked. Otherwise, the calling thread becomes the owner of this lock. With pthread_mutexattr_settype(), the type of a mutex can be set to allow recursive locking or report deadlock if the owner locks again æ³¨æ„ å•çº¯çš„ Mutex æ— æ³•åº”å¯¹å¤æ‚æƒ…å½¢çš„ã€Œç”Ÿäº§è€…-æ¶ˆè´¹è€…ã€é—®é¢˜ï¼Œä¾‹å¦‚å•ç”Ÿäº§è€…å•æ¶ˆè´¹è€…ã€å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…ã€å•ç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…ï¼Œç”šè‡³æ˜¯å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€… ğŸ˜µ éœ€è¦é…åˆ condition variables æˆ‘æœ‰ç”¨ Rust å†™è¿‡ä¸€ä¸ªã€Œå¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…ã€çš„ç¨‹åºï¼Œç›¸å…³çš„åšå®¢è§£è¯´åœ¨ è¿™é‡Œ condition variables int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr); int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); // all threads waiting on a condition need to be woken up Condition variables allow a thread to block until a specific condition becomes true blocked thread goes to wait queue for condition When the condition becomes true, some other thread signals the blocked thread(s) Conditions in Pthreads are usually used with a mutex to enforce mutual exclusion. the wait call should occur under the protection of a mutex ä½¿ç”¨ condition variables æ”¹å†™ä¹‹å‰ mutex éƒ¨åˆ†çš„ producer å®ä½œ (å®ä½œæ˜¯å•ç”Ÿäº§è€…å•æ¶ˆè´¹è€…æ¨¡å‹ï¼Œä¸”ç¼“å†²åŒºæœ‰ MAX_SIZE ä¸ªå…ƒç´ ): void producer(char *buf) { for (;;) { pthread_mutex_lock(lock); while (count == MAX_SIZE) pthread_cond_wait(notFull, lock); buf[count] = getChar(); count++; pthread_cond_signal(notEmpty); pthread_mutex_unlock(lock); } } semaphores semaphores æ˜¯ç«™åœ¨ã€Œèµ„æºçš„æ•°é‡ã€çš„è§’åº¦æ¥çœ‹å¾…é—®é¢˜ï¼Œè¿™ä¸ condition variables æ˜¯ä¸åŒçš„ sem_t semaphore; int sem_init(sem_t *sem, int pshared, unsigned int value); int sem_wait(sem_t *sem); int sem_post(sem_t *sem); Can do increments and decrements of semaphore value Semaphore can be initialized to any value Thread blocks if semaphore value is less than or equal to zero when a decrement is attempted As soon as semaphore value is greater than zero, one of the blocked threads wakes up and continues no guarantees as to which thread this might be æ³¨æ„ æ€»ç»“ä¸€ä¸‹ï¼Œmutex åœ¨æ„çš„æ˜¯ æŒæœ‰è€…ï¼Œsemaphore åœ¨æ„çš„æ˜¯ èµ„æºçš„æ€»é‡ï¼Œè€Œ condition variables åœ¨æ„çš„æ˜¯ æŒæœ‰çš„æ¡ä»¶ã€‚ ","date":"2024-04-10","objectID":"/posts/posix-threads/:1:3","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: POSIX Threads","uri":"/posts/posix-threads/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"POSIX Threads ","date":"2024-04-10","objectID":"/posts/posix-threads/:2:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: POSIX Threads","uri":"/posts/posix-threads/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"å®ä¾‹: å…‰çº¿è¿½è¸ª å…‰çº¿è¿½è¸ª (Ray tracing) ç›¸å…³: 2016q1 Homework #2 UCLA Computer Science 35L, Winter 2016. Software Construction Laboratory CS35L_Assign8_Multithreading å…‰çº¿è¿½è¸ªéœ€è¦å¾ˆå¤§çš„è¿ç®—é‡ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è‡ªç„¶åœ°æƒ³åˆ°ï¼Œèƒ½ä¸èƒ½ä½¿ç”¨ pthreads å¯¹è¿ç®—è¿›è¡ŒåŠ é€Ÿï¼Œä¸Šé¢çš„æœ€åä¸€ä¸ªé“¾æ¥å°±æ˜¯å¯¹è¿™ç§æ€è·¯çš„å®ä½œã€‚ ç¼–è¯‘ä¸æµ‹è¯•: $ git clone https://github.com/maxwyb/CS35L_Assign8_Multithreading.git raytracing-threads $ cd raytracing-threads $ make clean all $ ./srt 4 \u003e out.ppm $ diff -u out.ppm baseline.ppm $ open out.ppm é¢„æœŸå¾—åˆ°ä¸‹é¢çš„å›¾ï¼š å¯ä»¥å°†ä¸Šé¢çš„ ./srt å‘½ä»¤åé¢çš„æ•°å­—æ”¹ä¸º 1, 2, 8 ä¹‹ç±»çš„è¿›è¡Œå°è¯•ï¼Œè¿™ä¸ªæ•°å­—ä»£è¡¨ä½¿ç”¨çš„æ‰§è¡Œç»ªçš„æ•°é‡ã€‚å¦å¤–ï¼Œåœ¨ ./srt å‘½ä»¤ä¹‹å‰ä½¿ç”¨ time å‘½ä»¤å¯ä»¥è®¡ç®—æœ¬æ¬¡è¿›è¡Œå…‰çº¿è¿½è¸ªæ‰€ä½¿ç”¨çš„æ—¶é—´ï¼Œç”±æ­¤å¯ä»¥å¯¹æ¯”ä¸åŒæ•°é‡æ‰§è¡Œç»ªä¸‹çš„æ•ˆèƒ½å·®å¼‚ã€‚ å¯ä»¥çœ‹ä¸‹ç›¸å…³çš„ç¨‹å¼ç  main.c: #include \u003cpthread.h\u003e pthread_t* threadID = malloc(nthreads * sizeof(pthread_t)); int res = pthread_create(\u0026threadID[t], 0, pixelProcessing, (void *)\u0026intervals[t]); int res = pthread_join(threadID[t], \u0026retVal); æ˜¾ç„¶æ˜¯ç»å…¸çš„ fork-join æ¨¡å‹ (pthread_create è¿›è¡Œ â€œforkâ€ï¼Œpthread_join è¿›è¡Œ â€œjoinâ€)ï¼Œæ³¨æ„è¿™é‡Œå¹¶æ²¡æœ‰ä½¿ç”¨åˆ° mutex ä¹‹ç±»çš„äº’æ–¥é‡ï¼Œè¿™æ˜¯å¯ä»¥åšåˆ°çš„ï¼Œåªè¦ä½ äº‹å…ˆåŒºåˆ†å¼€ä¸ç›¸å…³çš„åŒºåŸŸåˆ†åˆ«è¿›è¡Œè®¡ç®—å³å¯ï¼Œå³ä¸ä¼šå‘ç”Ÿæ•°æ®ç«äº‰ï¼Œé‚£ä¹ˆä¹…æ²¡å¿…è¦ä½¿ç”¨ mutex äº†ã€‚ ","date":"2024-04-10","objectID":"/posts/posix-threads/:2:1","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: POSIX Threads","uri":"/posts/posix-threads/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"POSIX Thread POSIX Threads Programming Condition variables provide yet another way for threads to synchronize. While mutexes implement synchronization by controlling thread access to data, condition variables allow threads to synchronize based upon the actual value of data. condition variables ç”±ä¸¤ç§ä¸åŒçš„åˆå§‹åŒ–æ–¹å¼: é™æ€åˆå§‹åŒ– (static): PTHREAD_COND_INITIALIZER åŠ¨æ€åˆå§‹åŒ– (dynamic): pthread_cond_init() ","date":"2024-04-10","objectID":"/posts/posix-threads/:2:2","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: POSIX Threads","uri":"/posts/posix-threads/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Synchronization CMU 15-213: Intro to Computer Systems $23^{rd}$ Lecture Concurrent Programming $24^{rd}$ Lecture Synchroniza+on: Basics # ä»¥ä¸‹å››å¥ç‚º Head éƒ¨åˆ†ï¼Œè¨˜ç‚º H movq (%rdi), %rcx testq %rcx, %rcx jle .L2 movl $0, %eax .L3: movq cnt(%rip), %rdx # è®€å– cntï¼Œè¨˜ç‚º L addq $1, %rdx # æ›´æ–° cntï¼Œè¨˜ç‚º U movq %rdx, cnt(%rip) # å¯«å…¥ cntï¼Œè¨˜ç‚º S # ä»¥ä¸‹ç‚º Tail éƒ¨åˆ†ï¼Œè¨˜ç‚º T addq $1, %rax cmpq %rcx, %rax jne .L3 .L2: cnt ä½¿ç”¨ volatile é—œéµå­—è²æ˜ï¼Œæ„æ€æ˜¯é¿å…ç·¨è­¯å™¨ç”¢ç”Ÿçš„ç¨‹å¼ç¢¼ä¸­ï¼Œé€éæš«å­˜å™¨ä¾†ä¿å­˜æ•¸å€¼ï¼Œç„¡è«–æ˜¯è®€å–é‚„æ˜¯å¯«å…¥ï¼Œéƒ½åœ¨ä¸»è¨˜æ†¶é«”æ“ä½œã€‚ ç´°éƒ¨çš„æ­¥é©Ÿåˆ†æˆ 5 æ­¥ï¼šH -\u003e L -\u003e U -\u003e S -\u003e Tï¼Œå°¤å…¶è¦æ³¨æ„ LUS é€™ä¸‰å€‹æ“ä½œï¼Œé€™ä¸‰å€‹æ“ä½œå¿…é ˆåœ¨ä¸€æ¬¡åŸ·è¡Œä¸­å®Œæˆï¼Œä¸€æ—¦æ¬¡åºæ‰“äº‚ï¼Œå°±æœƒå‡ºç¾å•é¡Œï¼Œä¸åŒåŸ·è¡Œç·’æ‹¿åˆ°çš„å€¼å°±ä¸ä¸€å®šæ˜¯æœ€æ–°çš„ã€‚ä¹Ÿå°±æ˜¯èªªè©²å‡½å¼çš„æ­£ç¢ºåŸ·è¡Œå’ŒæŒ‡ä»¤çš„åŸ·è¡Œé †åºæœ‰é—œ mutual exclusion (äº’æ–¥) æ‰‹æ®µçš„é¸æ“‡ï¼Œä¸æ˜¯æ ¹æ“š CS çš„å¤§å°ï¼Œè€Œæ˜¯æ ¹æ“š CS çš„æ€§è³ªï¼Œä»¥åŠæœ‰å“ªäº›éƒ¨åˆ†çš„ç¨‹å¼ç¢¼ï¼Œä¹Ÿå°±æ˜¯ï¼Œä»°è³´æ–¼æ ¸å¿ƒå…§éƒ¨çš„åŸ·è¡Œè·¯å¾‘ã€‚ semaphore å’Œ spinlock å±¬æ–¼ä¸åŒå±¤æ¬¡çš„äº’æ–¥æ‰‹æ®µï¼Œå‰è€…çš„å¯¦ç¾ä»°è³´æ–¼å¾Œè€…ï¼Œå¯é¡æ¯”æ–¼ HTTP å’Œ TCP/IP çš„é—œä¿‚ï¼Œå„˜ç®¡éƒ½ç®—æ˜¯ç¶²è·¯é€šè¨Šå”å®šï¼Œä½†å±¤æ¬¡æˆªç„¶ä¸åŒ ","date":"2024-04-10","objectID":"/posts/posix-threads/:3:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: POSIX Threads","uri":"/posts/posix-threads/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"System Programming wiki-book: Synchronization Part 1: Mutex Locks åŸæ–‡åœ°å€ You can use the macro PTHREAD_MUTEX_INITIALIZER only for global (â€˜staticâ€™) variables. m = PTHREAD_MUTEX_INITIALIZER is equivalent to the more general purpose pthread_mutex_init(\u0026m,NULL). The init version includes options to trade performance for additional error-checking and advanced sharing options. é™æ€ (static) åˆå§‹åŒ–å’ŒåŠ¨æ€ (dynamic) åˆå§‹åŒ–ï¼Œå…¶ä¸­é™æ€åˆå§‹åŒ–åˆ›å»ºçš„æ˜¯ä¸€ä¸ªå…¨å±€ (global) çš„ mutexï¼Œè€ŒåŠ¨æ€åˆå§‹åŒ–åˆ™æ˜¯å¯¹å·²æœ‰çš„ mutex è¿›è¡Œåˆå§‹åŒ–è®¾ç½® Multiple threads doing init/destroy has undefined behavior Destroying a locked mutex has undefined behavior Basically try to keep to the pattern of one thread initializing a mutex and one and only one thread destroying a mutex. mutex çš„åˆå§‹åŒ–å’Œé”€æ¯éœ€è¦æ³¨æ„åªèƒ½è°ƒç”¨ä¸€æ¬¡ï¼Œå¦åˆ™ä¼šå¯¼è‡´ UB This process runs slower because we lock and unlock the mutex a million times, which is expensive - at least compared with incrementing a variable. (And in this simple example we didnâ€™t really need threads - we could have added up twice!) A faster multi-thread example would be to add one million using an automatic(local) variable and only then adding it to a shared total after the calculation loop has finished æœ‰æ—¶å€™å¹¶ä¸éœ€è¦æ¯æ¬¡ä½¿ç”¨ mutexï¼Œè¿™æ ·ä¼šå¯¼è‡´æ€§èƒ½é™ä½ï¼Œåˆ†æç¨‹åºçš„é€»è¾‘ä»è€Œå‡å°‘ mutex çš„ä½¿ç”¨æ¬¡æ•° Linux man page: pthread_mutex_lock pthread_mutex_unlock pthread_mutex_init pthread_mutex_destroy Part 2: Counting Semaphores åŸæ–‡åœ°å€ A counting semaphore contains a value[ non negative ] and supports two operations â€œwaitâ€ and â€œpostâ€. Post increments the semaphore and immediately returns. â€œwaitâ€ will wait if the count is zero. If the count is non-zero the wait call decrements the count and immediately returns. ä¿¡å·é‡çš„å®šä¹‰å’Œçš„ä¸¤ç§æ“ä½œ: wait å’Œ postï¼Œæœ¬è´¨ä¸Šéƒ½æ˜¯å¯¹èµ„æºæ€»é‡çš„æ“ä½œ First decide if the initial value should be zero or some other value (e.g. the number of remaining spaces in an array). åˆ›å»ºä¿¡å·é‡æ—¶ä¹Ÿæ˜¯éœ€è¦å…ˆç¡®å®šèµ„æºæ€»é‡ï¼Œä¾‹å¦‚æ•°ç»„å…ƒç´ çš„ä¸ªæ•° Unlike a mutex, the increment and decrement can be from different threads. ä¿¡å·é‡å’Œ mutex é‚£ç§æŒæœ‰è€…æ‰æœ‰æƒåˆ©è¿›è¡Œé‡Šæ”¾çš„è®¾ç½®ä¸åŒï¼Œä¿¡å·é‡ä¸å­˜åœ¨æŒæœ‰è€…è¿™ä¸€è¯´æ³• (å› ä¸ºå®ƒæ˜¯ä»èµ„æºæ€»é‡è¿›è¡Œè€ƒé‡çš„ï¼Œè‡ªç„¶ä¸å­˜åœ¨ä¿¡å·é‡çš„æŒæœ‰è€…è¿™ä¸€æ¦‚å¿µ)ï¼Œæ‰€ä»¥ä¸åŒ thread éƒ½å¯ä»¥å¯¹ä¿¡å·é‡è¿›è¡Œæ“ä½œ (é€šè¿‡ wait å’Œ post) A mutex is an initialized semaphore that always waits before it posts å½“ä¿¡å·é‡è®¾å®šçš„èµ„æºæ€»é‡ä¸º 1 æ—¶ï¼Œå®ƒå’Œ mutex çš„åŠŸèƒ½ååˆ†ç›¸ä¼¼ï¼Œå½“ç„¶è¿˜éœ€è¦ä¿è¯ä½¿ç”¨æ—¶å…ˆä½¿ç”¨ wait åœ¨ä½¿ç”¨ post æ“ä½œï¼Œå…¶åŠŸèƒ½æ‰å’Œ mutex ä¸€è‡´ï¼Œå¦åˆ™ä¼šé€ æˆæ•°æ®ç«äº‰ (å…ˆä½¿ç”¨ post ä¼šå¯¼è‡´èµ„æºæ€»é‡ç”± 1 å˜ä¸º 2) sem_post is one of a handful of functions that can be correctly used inside a signal handler. This means we can release a waiting thread which can now make all of the calls that we were not allowed to call inside the signal handler itself (e.g. printf). void handler(int signal) { sem_post(\u0026s); /* Release the Kraken! */ } void *singsong(void *param) { sem_wait(\u0026s); // see the value of semaphore value which was used to initialize it printf(\"I had to wait until your signal released me!\\n\"); } Linux man page: sem_init sem_wait sem_post sem_destroy Part 3: Working with Mutexes And Semaphores åŸæ–‡åœ°å€ Incrementing a variable (i++) is not atomic because it requires three distinct steps: Copying the bit pattern from memory into the CPU; performing a calculation using the CPUâ€™s registers; copying the bit pattern back to memory. During this increment sequence, another thread or process can still read the old value and other writes to the same memory would also be over-written when the increment sequence completes. ä¸€ä¸ªå¸¸è§çš„æ•°æ®ç«äº‰çš„ä¾‹å­ We will call these two semaphores â€˜sremainâ€™ and â€˜sitemsâ€™. Remember sem_wait will wait if the semaphoreâ€™s count has been decremented to zero (by another thread calling sem_post). åœ¨ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…æ¨¡å‹ä¸­ï¼Œé€šå¸¸æ˜¯ä½¿ç”¨ä¸¤ä¸ªä¿¡å·é‡æ¥è¡¡é‡èµ„æºæ€»é‡ï¼Œä¸¤ä¸ªè§’åº¦ (ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…) æ¥çœ‹å¾…èµ„æºçš„å¯ç”¨é‡ However there is no mutual exclusion: Two threads can be in the critical section at the same time, which would corrupt the data structure (or least lead to data loss). The fix is to wrap a mutex around the critical section ä¿¡å·é‡åªèƒ½ä¿è¯èµ„æºæ€»é‡çš„æ­£ç¡®ä½¿ç”¨ï¼Œä½†æ— æ³•ç”Ÿæˆæ›´å°ç²¾åº¦ (ä¾‹å¦‚é’ˆå¯¹æŸä¸ªå…ƒç´ ) çš„äº’æ–¥åŒºï¼Œæ­¤æ—¶éœ€è¦æ­é… mutex æ¥ä½¿ç”¨ï¼Œå³ semaphore ç”¨äºæ§åˆ¶èµ„æºæ€»é‡ï¼Œmutex ç”¨äºä¿è¯ç‰¹å®šèµ„æºçš„äº’æ–¥ã€‚ Part 4: The Critical Section Problem åŸæ–‡åœ°å€ æ’æ——è¡¨ç¤ºæ­¤æ—¶ç”±è‡ªå·±æŒæ§ï¼Œç±»ä¼¼ç¤¾å›¢äº‰æ–—ï¼Œæ’æ——è¡¨ç¤ºä¸»æƒ: // Candidate #1 wait until your flag is lowered raise my flag // Do Critical Section stuff lower my flag Candidate solution #1 also suffers a race condition i.e. it does not ","date":"2024-04-10","objectID":"/posts/posix-threads/:3:1","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: POSIX Threads","uri":"/posts/posix-threads/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Mutex and Semaphore","date":"2024-04-10","objectID":"/posts/posix-threads/:3:2","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: POSIX Threads","uri":"/posts/posix-threads/"},{"categories":["C","Linux Kernel Internals"],"content":" æœ¬æ¬¡è¬›åº§å°‡é¸å®šå¹¾å€‹æ¡ˆä¾‹ï¼Œè—‰æ­¤è§£èªª C èªè¨€ç¨‹å¼è¨­è¨ˆçš„æŠ€å·§ï¼Œåƒæ˜¯å°çŸ©é™£æ“ä½œé€²è¡ŒåŒ…è£ã€åˆå§‹åŒ–ç‰¹å®šçµæ§‹çš„æˆå“¡ã€è¿½è¹¤ç‰©ä»¶é…ç½®çš„è¨˜æ†¶é«”ã€Smart Pointer ç­‰ç­‰ã€‚ åŸæ–‡åœ°å€ ","date":"2024-04-10","objectID":"/posts/c-trick/:0:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŠ€å·§ç¯‡","uri":"/posts/c-trick/"},{"categories":["C","Linux Kernel Internals"],"content":"ä»çŸ©é˜µæ“ä½œè°ˆèµ· C è¯­è¨€ä¹Ÿå¯ä½œå®ç° Object-oriented programming (éœ€è¦æ­é…å‰ç½®å¤„ç†å™¨æ‰©å……è¯­æ³•) GNU Manual 6.29 Designated Initializers Stack Overflow: Why does C++11 not support designated initializer lists as C99? ä» C99 (å«) ä»¥åï¼ŒC å’Œ C++ å°±åˆ†é“æ‰¬é•³äº†ã€‚ç›¸å…³å·®å¼‚å¯ä»¥å‚è€ƒ: Incompatibilities Between ISO C and ISO C++ ç»“æ„ä½“çš„æˆå‘˜å‡½æ•°å®ä½œæ—¶ä½¿ç”¨ staticï¼Œå¹¶æ­é… API gateway å¯ä»¥è·å¾—ä¸€éƒ¨åˆ† namespace çš„åŠŸèƒ½ Fun with C99 Syntax ","date":"2024-04-10","objectID":"/posts/c-trick/:1:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŠ€å·§ç¯‡","uri":"/posts/c-trick/"},{"categories":["C","Linux Kernel Internals"],"content":"æ˜ç¡®åˆå§‹åŒ–ç‰¹å®šç»“æ„çš„æˆå‘˜ é™æ€ç©ºé—´åˆå§‹åŒ–é…ç½®: åŠ¨æ€ç©ºé—´åˆå§‹åŒ–é…ç½®: Initializing a heap-allocated structure in C ","date":"2024-04-10","objectID":"/posts/c-trick/:2:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŠ€å·§ç¯‡","uri":"/posts/c-trick/"},{"categories":["C","Linux Kernel Internals"],"content":"è¿½è¸ªç‰©ä»¶é…ç½®çš„è®°å¿†ä½“ ","date":"2024-04-10","objectID":"/posts/c-trick/:3:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŠ€å·§ç¯‡","uri":"/posts/c-trick/"},{"categories":["C","Linux Kernel Internals"],"content":"Smart Pointer ","date":"2024-04-10","objectID":"/posts/c-trick/:4:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŠ€å·§ç¯‡","uri":"/posts/c-trick/"},{"categories":["C","Linux Kernel Internals"],"content":"C99 Variable Length Arrays (VLA) ","date":"2024-04-10","objectID":"/posts/c-trick/:5:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŠ€å·§ç¯‡","uri":"/posts/c-trick/"},{"categories":["C","Linux Kernel Internals"],"content":"å­—ç¬¦ä¸²å’Œæ•°å€¼è½¬æ¢ Integer to string conversion ","date":"2024-04-10","objectID":"/posts/c-trick/:6:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŠ€å·§ç¯‡","uri":"/posts/c-trick/"},{"categories":["C","Linux Kernel Internals"],"content":"GCC æ”¯æ´ Plan 9 C Extension GCC 6.65 Unnamed Structure and Union Fields ","date":"2024-04-10","objectID":"/posts/c-trick/:7:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŠ€å·§ç¯‡","uri":"/posts/c-trick/"},{"categories":["C","Linux Kernel Internals"],"content":"GCC transparent union GCC 6.35.1 Common Type Attributes ","date":"2024-04-10","objectID":"/posts/c-trick/:8:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŠ€å·§ç¯‡","uri":"/posts/c-trick/"},{"categories":["C","Linux Kernel Internals"],"content":"é«˜é˜¶çš„ C è¯­è¨€çš„ã€Œå¼€å‘æ¡†æ¶ã€ cello æ˜¯ä¸Šé¢æåˆ°çš„æŠ€å·§çš„é›†å¤§æˆè€…ï¼Œåœ¨ C è¯­è¨€åŸºç¡€ä¸Šï¼Œæä¾›ä»¥ä¸‹è¿›é˜¶ç‰¹å¾: ","date":"2024-04-10","objectID":"/posts/c-trick/:9:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŠ€å·§ç¯‡","uri":"/posts/c-trick/"},{"categories":["C","Linux Kernel Internals"],"content":"å–„ç”¨ GNU extension çš„ typeof GCC 6.7 Referring to a Type with typeof typeof åœ¨ C23 ä¸­å·²ç”± GNU extenison è½¬æ­£ä¸º C è¯­è¨€æ ‡å‡† ","date":"2024-04-10","objectID":"/posts/c-trick/:10:0","tags":["Sysprog","C"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŠ€å·§ç¯‡","uri":"/posts/c-trick/"},{"categories":["Rust"],"content":" ä»åŸºç¡€åˆ°è¿›é˜¶è®²è§£æ¢è®¨ Rust ç”Ÿå‘½å‘¨æœŸï¼Œä¸ä»…ä»…æ˜¯ lifetime kataï¼Œè¿˜æœ‰æ›´å¤šçš„ lifetime èµ„æ–™ï¼Œéƒ½æ¥è®²è§£å’Œæ¢è®¨ï¼Œä»ã€Œå…¥é—¨ Rustã€åˆ°ã€Œè¿›é˜¶ Rustã€ æ•´ç†è‡ª B ç«™ UP ä¸» @è¿™å‘¨ä½ æƒ³å¹²å•¥ çš„ æ•™å­¦å½±ç‰‡åˆé›† æ³¨æ„ å­¦ä¹  John Gjengset çš„æ•™å­¦å½±ç‰‡ Subtying and Variance æ—¶å‘ç°è‡ªå·±å¯¹ Rust ç”Ÿå‘½å‘¨æœŸ (lifetime) è¿˜æ˜¯ä¸å¤ªç†è§£ï¼Œäºæ˜¯ä¾¿å‰æ¥è¡¥è¯¾ ğŸ¤£ ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:0:0","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"å¼•ç”¨ \u0026 ç”Ÿå‘½å‘¨æœŸ ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:1:0","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ åœ¨ å•çº¿ç¨‹ çš„ç¨‹åºä¸­ï¼Œé€šè¿‡å‡½æ•°å‚æ•°ä¼ å…¥çš„å¼•ç”¨ï¼Œæ— è®ºå…¶ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸåœ¨è¯¥å‡½æ•°çš„å‡½æ•°ä½“èŒƒå›´å†…éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚å› ä¸ºä» çŠ¶æ€æœº æ¨¡å‹æ¥è€ƒè™‘ï¼Œè¯¥å‡½æ•°æ²¡æœ‰ä¼ å…¥çš„å¼•ç”¨çš„æ‰€æœ‰æƒ (å› ä¸ºæ˜¯é€šè¿‡å‚æ•°ä¼ å…¥çš„)ï¼Œæ‰€ä»¥è¯¥å‡½æ•°ä¸å¯èƒ½åœ¨å…¶å‡½æ•°ä½“èŒƒå›´å†…æŸä¸€èŠ‚ç‚¹ï¼Œå°±ç»“æŸä¼ å…¥çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸã€‚ä½†æ˜¯åœ¨ å¤šçº¿ç¨‹ çš„ç¨‹åºï¼Œä¸Šè¿°è§„åˆ™å°±ä¸ä¸€å®šæˆç«‹äº†ã€‚ fn split\u003c'a, 'b\u003e(text: \u0026'a str, delimiter: \u0026'b str) {...} å•çº¿ç¨‹æƒ…å†µä¸‹ï¼Œå‚æ•° text å’Œ delimiter åœ¨å‡½æ•° split èŒƒå›´å†…éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚ ä¹Ÿå› ä¸ºè¿™ä¸ªçŠ¶æ€æœºæ¨¡å‹ï¼ŒRust çš„ç”Ÿå‘½å‘¨æœŸå¯¹äºå‚æ•°åœ¨å‡½æ•°ä½“å†…çš„ä½¿ç”¨çš„å½±å“å¹¶ä¸å¤§ï¼Œä¸»è¦å½±å“çš„æ˜¯æ¶‰åŠç”Ÿå‘½å‘¨æœŸçš„å‚æ•°æˆ–è¿”å›å€¼åœ¨ å‡½æ•°è°ƒç”¨åçš„ç”Ÿå‘½å‘¨æœŸä½¿ç”¨çº¦æŸï¼Œä¸‹é¢ç»™å‡ºä¸€äº›æŠ€å·§: æŠ€å·§ æœ€å¤§å…±åŒç”Ÿå‘½å‘¨æœŸ: ä»å¼•ç”¨çš„å½“å‰å…±åŒä½¿ç”¨å¼€å§‹ï¼Œç›´åˆ°ä»»ä¸€å¼•ç”¨å¯¹åº”çš„ object æ¶ˆäº¡ï¼Œå³å…¶ç”Ÿå‘½å‘¨æœŸç»“æŸã€‚ å½“ä»¥ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œæ¥å¯¹å‡½æ•°å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸè¿›è¡Œæ ‡æ³¨æ—¶ï¼Œå…¶è¡¨ç¤ºå‚æ•°çš„æœ€å¤§å…±åŒç”Ÿå‘½å‘¨æœŸï¼Œä¾‹å¦‚: fn f\u003c'a\u003e(x: \u0026'a i32, y: \u0026'a i32, z: \u0026'a i32) {...} ç”Ÿå‘½å‘¨æœŸ 'a è¡¨ç¤ºå‚æ•° x, y, z çš„æœ€å¤§å…±åŒç”Ÿå‘½å‘¨æœŸï¼Œå³ x, y, z å¯ä»¥å…±åŒå­˜æ´»çš„æœ€å¤§ç”Ÿå‘½å‘¨æœŸã€‚ å½“ä»¥ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œæ¥å¯¹å‡½æ•°å‚æ•°å’Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸè¿›è¡Œæ ‡æ³¨æ—¶ï¼Œå…¶è¡¨ç¤ºè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»åœ¨å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸå†…ï¼Œä¾‹å¦‚: fn f\u003c'a\u003e(x: \u0026'a i32) -\u003e \u0026'a i32 {...} ç”Ÿå‘½å‘¨æœŸ 'a è¡¨ç¤ºè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»åœ¨å‚æ•° x çš„ç”Ÿå‘½å‘¨æœŸå†…ï¼Œå³è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸæ˜¯å‚æ•°å’Œè¿”å›å€¼çš„æœ€å¤§å…±åŒç”Ÿå‘½å‘¨æœŸã€‚æ‰€ä»¥åœ¨è¿”å›å€¼å¯ä»¥ä½¿ç”¨çš„åœ°æ–¹ï¼Œå‚æ•°éƒ½å¿…é¡»å­˜æ´»ï¼Œè¿™ä¹Ÿæ˜¯å¸¸å‡ºç°é—®é¢˜çš„åœ°æ–¹ã€‚ æœ€åçœ‹ä¸€ä¸‹å°†è¿™ä¸¤ä¸ªæŠ€å·§ç»“åˆèµ·æ¥çš„ä¸€ä¸ªä¾‹å­: fn f\u003c'a\u003e(x: \u0026'a i32, y: \u0026'a i32) -\u003e \u0026'a i32 {...} å‚æ•°å–æœ€å¤§ç”Ÿå‘½å‘¨æœŸåœ¨å®¹å™¨æƒ…å†µä¸‹ä¼šè¢«å¦ä¸€ä¸ªæŠ€å·§å–ä»£ï¼Œå³å®¹å™¨å’Œå®¹å™¨å†…éƒ¨å…ƒç´ éƒ½è¢«æ ‡æ³¨ä¸ºç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸï¼Œè¿™ç§æƒ…å†µä¼šè®©å®¹å™¨çš„ç”Ÿå‘½å‘¨æœŸå’Œå®¹å™¨å†…çš„å…ƒç´ çš„ç”Ÿå‘½å‘¨æœŸä¿æŒä¸€è‡´ã€‚è¿™æ˜¯å› ä¸ºéšå¼è§„åˆ™: å®¹å™¨çš„ç”Ÿå‘½å‘¨æœŸ $\\leq$ å®¹å™¨å†…å…ƒç´ çš„ç”Ÿå‘½å‘¨æœŸï¼Œè¿™æ˜¾ç„¶å·²ç»æ»¡è¶³äº†æœ€å¤§ç”Ÿå‘½å‘¨æœŸçš„è¦æ±‚ï¼Œè€Œæ­¤æ—¶æ ‡æ³¨ä¸€æ ·çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¼šè¢«ç¼–è¯‘å™¨æ¨å¯¼ä¸ºäºŒè€…çš„ç”Ÿå‘½å‘¨æœŸç›¸åŒï¼Œå³ å®¹å™¨çš„ç”Ÿå‘½å‘¨æœŸå’Œå®¹å™¨å†…çš„å…ƒç´ çš„ç”Ÿå‘½å‘¨æœŸä¸€è‡´: fn strtok(x: \u0026'a mut \u0026'a str, y: char) {...} ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:2:0","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"ç”Ÿå‘½å‘¨æœŸåœ¨å‡½æ•°ä¸Šçš„çœç•¥è§„åˆ™ The Rust Reference: Lifetime elision Each elided lifetime in the parameters becomes a distinct lifetime parameter. If there is exactly one lifetime used in the parameters (elided or not), that lifetime is assigned to all elided output lifetimes. If the receiver has type \u0026Self or \u0026mut Self, then the lifetime of that reference to Self is assigned to all elided output lifetime parameters. æ­£å¦‚æŠ•å½±ç‰‡æ‰€è¯´ï¼Œè™½ç„¶æœ‰ç”Ÿå‘½å‘¨æœŸçš„çœç•¥è§„åˆ™ï¼Œä½†æœ‰æ—¶å¹¶ä¸ç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸï¼Œè¿™æ—¶å€™éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨æ ‡æ³¨ã€‚è¿™ç§æƒ…å†µå¸¸å‡ºç°äºå¯å˜å¼•ç”¨ \u0026mut self çš„ä½¿ç”¨: struct S {} impl S { fn as_slice_mut\u003c'a\u003e(\u0026'a mut self) -\u003e \u0026'a [u8] {...} } let s: S = S{}; let x: \u0026[u8] = s.as_slice_mut(); //--- ... // | ... // | scope ... // | // end of s's lifetime //--- åœ¨ä¸Šé¢ä¾‹å­ä¸­ï¼Œç”±äºå°†æ–¹æ³• as_slice_mut çš„å¯å˜å¼•ç”¨å‚æ•°å’Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸéƒ½æ ‡æ³¨ä¸ºç›¸åŒ 'aï¼Œæ‰€ä»¥åœ¨èŒƒå›´ scope ä¸­ï¼Œåœ¨ç¼–è¯‘å™¨çœ‹æ¥ s çš„å¯å˜å¼•ç”¨ä»ç„¶æœ‰æ•ˆ (å›æƒ³ä¸€ä¸‹ä¹‹å‰çš„å‚æ•°å’Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸæ¨å¯¼æŠ€å·§)ï¼Œæ‰€ä»¥åœ¨è¿™ä¸ªèŒƒå›´å†…æ— æ³•ä½¿ç”¨ s çš„å¼•ç”¨ (ä¸ç®¡æ˜¯å¯å˜è¿˜æ˜¯ä¸å¯å˜ï¼Œå›æƒ³ä¸€ä¸‹ Rust çš„å¼•ç”¨è§„åˆ™)ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¸¸è§çš„å¯å˜å¼•ç”¨å¼•èµ·éé¢„æœŸçš„ç”Ÿå‘½å‘¨æœŸçš„ä¾‹å­ï¼Œä¸‹ä¸€èŠ‚ä¼šè¿›ä¸€æ­¥ä»‹ç»ã€‚ ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:3:0","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"å…³æ³¨å¯å˜å¼•ç”¨ fn insert_value\u003c'a\u003e(my_vec: \u0026'a mut Vec\u003c\u0026'a i32\u003e, value: \u0026'a i32) {...} è¿™ä¸ªä¾‹å­å’Œä¹‹å‰çš„ä¾‹å­å¾ˆç±»ä¼¼ï¼ŒåŒæ ·çš„ï¼Œä½¿ç”¨æˆ‘ä»¬çš„å‚æ•°ç”Ÿå‘½å‘¨æœŸæ¨å¯¼æŠ€å·§ï¼Œè°ƒç”¨å‡½æ•° insert_value åï¼Œå½“å‚æ•° vec å’Œ value çš„æœ€å¤§å…±åŒç”Ÿå‘½å‘¨æœŸçš„èŒƒå›´å¾ˆå¹¿æ—¶ï¼Œè¿™æ—¶å°±éœ€è¦æ³¨æ„ï¼Œåœ¨è¿™ä¸ªèŒƒå›´å†…ï¼Œæˆ‘ä»¬æ— æ³•ä½¿ç”¨ my_vec å¯¹åº”çš„ object çš„ä»»ä½•å…¶å®ƒå¼•ç”¨ (å› ä¸ºç¼–è¯‘å™¨ä¼šè®¤ä¸ºæ­¤æ—¶è¿˜å­˜åœ¨å¯å˜å¼•ç”¨ my_vec)ï¼Œä»è€Œç¼–è¯‘é”™è¯¯ã€‚è¿™å°±æ˜¯å®¹å™¨å’Œå¼•ç”¨ä½¿ç”¨ç›¸åŒç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œè€Œå¯¼è‡´çš„å¼ºçº¦æŸã€‚ä¸ºé¿å…è¿™ç§éé¢„æœŸçš„ç”Ÿå‘½å‘¨æœŸï¼Œåº”å½“å°†å‡½æ•°åŸå‹æ”¹å†™å¦‚ä¸‹: fn insert_value\u003c'a, 'b\u003e(my_vec: \u0026'a mut Vec\u003c\u0026'b i32\u003e, value: \u0026'b i32) {...} è¿™æ ·æ”¹å†™ä¼šåŒ…å«ä¸€ä¸ªéšå¼çš„ç”Ÿå‘½å‘¨æœŸè§„åˆ™: 'a $\\leq$ 'bï¼Œè¿™å¾ˆå¥½ç†è§£ï¼Œå®¹å™¨çš„ç”Ÿå‘½å‘¨æœŸåº”è¯¥æ¯”æ‰€å¼•ç”¨çš„ object çŸ­ï¼Œè¿™ä¸ªéšå¼è§„åˆ™åœ¨ä¸‹ä¸€èŠ‚çš„ struct/enum çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨éå¸¸é‡è¦ã€‚ æ³¨æ„ ä»æ­£ç¡®å†™æ³• (æœ‰ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸæ ‡æ³¨) å‡ºå‘ï¼Œæ¢è®¨åªä½¿ç”¨ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„æƒ…å†µæ¯”è¾ƒç¬¦åˆäººç±»çš„æ€ç»´ï¼Œè¿™ä¹Ÿæ˜¯åŸæ–‡å®‰æ’çš„é¡ºåºã€‚ å¦‚æœä¼ å…¥çš„å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸå‡ä¸ºå·²çŸ¥ï¼Œåˆ™åŒä¸€ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä»£è¡¨çš„ç”Ÿå‘½å‘¨æœŸé•¿åº¦ä¸ºï¼Œå·²çŸ¥ç”Ÿå‘½å‘¨æœŸçš„æœ€å°å€¼ã€‚å¦‚æœä¼ å…¥çš„å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸå­˜åœ¨æœªçŸ¥çš„ï¼Œåˆ™åŒä¸€ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„ç”Ÿå‘½å‘¨æœŸé•¿åº¦ä¸ºå·²çŸ¥çš„ç”Ÿå‘½å‘¨æœŸçš„æœ€å°å€¼ï¼Œå¹¶ä¸”è¦æ±‚æœªçŸ¥ç”Ÿå‘½å‘¨æœŸé•¿åº¦çš„å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸä¸å¾—å°‘äºè¯¥æœ€å°å€¼ã€‚ ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:4:0","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"struct / enum ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ struct / enum çš„ç”Ÿå‘½å‘¨æœŸæ¨å¯¼å¯ä»¥ä» æ„é€ å‡½æ•° æ¥ç†è§£ï¼Œæœ¬è´¨ä¸Šå’Œä¹‹å‰æ‰€ä»‹ç»çš„å‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¸€è‡´ã€‚ struct / enum çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¹Ÿå¯ä»¥é€šè¿‡ä¹‹å‰æ‰€æçš„ çŠ¶æ€æœº æ¨¡å‹æ¥è¿›è¡Œç†è§£ï¼Œå› ä¸º struct / enum æœ¬èº«ä¸å…·å¤‡å¼•ç”¨å¯¹åº”çš„ object çš„æ‰€æœ‰æƒï¼Œåœ¨è¿›è¡Œæ–¹æ³• (method) è°ƒç”¨æ—¶å¹¶ä¸èƒ½æˆªæ–­å¼•ç”¨å¯¹åº”çš„ object çš„ç”Ÿå‘½å‘¨æœŸã€‚ struct / enum ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¸»è¦éœ€è¦ç‰¹åˆ«æ³¨æ„ä¸€ç‚¹ï¼Œå°±æ˜¯ struct / enum æœ¬èº«çš„å¯å˜å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œæœ€å¥½ä¸è¦å’Œä¸ºå¼•ç”¨çš„æˆå‘˜çš„ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨ï¼Œæ ‡æ³¨ä¸ºç›¸åŒï¼Œå› ä¸ºè¿™æå¤§å¯èƒ½ä¼šå¯¼è‡´ ç”Ÿå‘½å‘¨æœŸå¼ºçº¦æŸï¼Œä¾‹å¦‚: fn strtok(x: \u0026mut 'a Vec\u003c'a i32\u003e, y: \u0026'a i32) {...} å¦‚æœå‚æ•° Vec\u003c'a i32\u003e çš„ vector é‡Œçš„ i32 å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ static çš„è¯ï¼Œä¾æ®æˆ‘ä»¬ä¹‹å‰æ‰€æçš„æŠ€å·§ï¼Œä¼šå°†å¯å˜å¼•ç”¨ \u0026'a mut çš„ç”Ÿå‘½å‘¨æœŸä¹Ÿæ¨å¯¼ä¸º staticï¼Œè¿™å°±å¯¼è‡´å†ä¹Ÿæ— æ³•å€Ÿç”¨ x å¯¹åº”çš„ objectã€‚ ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:5:0","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"'static å’Œ '_ fn foo(_input: \u0026'a str) -\u003e 'static str { \"abc\" } å¦‚æœä¸è¿›è¡Œ static ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œä¾æ®çœç•¥è§„åˆ™ï¼Œç¼–è¯‘å™¨ä¼šæŠŠè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸæ¨å¯¼ä¸º 'aï¼Œå³å’Œè¾“å…¥å‚æ•°ä¸€æ ·ï¼Œè¿™å°±ä¸ç¬¦åˆæˆ‘ä»¬é¢„æœŸä½¿ç”¨äº†ã€‚ å¦‚æœä½¿ç”¨ static æ ‡æ³¨ struct / enum é‡Œçš„æˆå‘˜ï¼Œåˆ™æ— éœ€æ ‡æ³¨ struct / enum çš„ç”Ÿå‘½å‘¨æœŸï¼Œå› ä¸º static è¡¨ç¤ºåœ¨æ•´ä¸ªç¨‹åºè¿è¡Œèµ·è§éƒ½æœ‰æ•ˆï¼Œæ²¡å¿…è¦å¯¹å®¹å™¨è¿›è¡Œç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ã€‚ struct UniqueWords { sentence: \u0026'static str, unique_words: Vec\u003c\u0026'static str\u003e, } impl UniqueWords {...} åœ¨æ²¡æœ‰ä½¿ç”¨åˆ° struct çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨æ—¶ï¼Œimpl å¯ä»¥ä¸æ˜¾å¼æŒ‡æ˜ç”Ÿå‘½å‘¨æœŸï¼Œè€Œæ˜¯é€šè¿‡ '_ è®©ç¼–è¯‘å™¨è‡ªè¡Œæ¨å¯¼: struct Counter\u003c'a\u003e { inner: \u0026'a mut i32, } impl Counter\u003c'_\u003e { fn increment(\u0026mut self) {...} } // is the same as impl\u003c'a\u003e Counter\u003c'a\u003e { fn increment(\u0026mut self) {...} } å‡½æ•°è¿”å›å€¼ä¸æ˜¯å¼•ç”¨ï¼Œä½†æ˜¯è¿”å›å€¼ç±»å‹é‡Œæœ‰æˆå‘˜æ˜¯å¼•ç”¨ï¼Œä¾æ®çœç•¥è§„åˆ™ï¼Œç¼–è¯‘å™¨æ— æ³•è‡ªè¡Œæ¨å¯¼è¯¥æˆå‘˜çš„ç”Ÿå‘½å‘¨æœŸï¼Œæ­¤æ—¶å¯ä»¥é€šè¿‡ '_ æ¥æç¤ºç¼–è¯‘å™¨ä¾æ®çœç•¥è§„åˆ™ï¼Œå¯¹è¿”å›å€¼çš„æˆå‘˜çš„ç”Ÿå‘½å‘¨æœŸè¿›è¡Œæ¨å¯¼: struct StrWrap\u003c'a\u003e(\u0026'a str); fn make_wrapper(string: \u0026str) -\u003e StrWrap\u003c'_\u003e {...} // is the same as fn make_wrapper\u003c'a\u003e(string: \u0026'a str) -\u003e StrWrap\u003c'a\u003e {...} ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:6:0","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"ç”Ÿå‘½å‘¨æœŸå‹å˜å’Œç»‘å®š å› ä¸º Rust æ˜¯æ²¡æœ‰ç»§æ‰¿çš„æ¦‚å¿µï¼Œæ‰€ä»¥ä¸‹é¢ä»¥ scala æ¥å¯¹ç±»å‹çš„å‹å˜ä¸¾ä¾‹å­è¿›è¡Œè®²è§£ (ä½†æ˜¯ä¸éœ€è¦ä½ å¯¹ Scala æœ‰ä»»ä½•äº†è§£): class A class B extends A // B is subclass of A private def f1(a: A): Unit = { println(\"f1 works!\") } def main(args: Array[STring]): Unit = { val a = new A val b = new B f1(a) // succeed f1(b) // succeed } è¿™ä¸ªä¾‹å­å¾ˆå¥½ç†è§£ï¼Œå› ä¸º B æ˜¯ A çš„å­ç±»ï¼Œæ‰€ä»¥ä½œä¸ºå‚æ•°ä¼ å…¥å‡½æ•° f1 æ˜¾ç„¶æ˜¯å¯ä»¥æ¥å—çš„ã€‚ä½†æ˜¯å½“æ³›å‹ (generic) å’Œå­ç±» (subclass) ç»“åˆèµ·æ¥æ—¶ï¼Œå°±å˜å¾—å¤æ‚äº†: class A class B extends A // B is subclass of A class Foo[T] // generic private def f1(a: Foo[A]): Unit = { println(\"f1 works!\") } def main(args: Array[STring]): Unit = { val foo_a = new Foo[A] val foo_b = new Foo[B] f1(a) // succeed f1(b) // error } åœ¨ç¼–è¯‘å™¨çœ‹æ¥ï¼Œè™½ç„¶ B æ˜¯ A çš„å­ç±»ï¼Œä½†æ˜¯ç¼–è¯‘å™¨è®¤ä¸º Foo[A] å’Œ Foo[B] æ˜¯ä¸¤ä¸ªç‹¬ç«‹çš„ç±»å‹ï¼Œè¿™ä¸ªè¢«ç§°ä¸º ä¸å˜ (invariant)ã€‚è€Œæˆ‘ä»¬çš„ç›´è§‰æ˜¯ï¼Œè¿™ç§æƒ…å†µ Foo[B] åº”è¯¥æ˜¯ Foo[A] çš„å­ç±»ï¼Œè¿™å°±å¼•å‡ºäº† åå˜ (covariant)ã€‚å°†ä¸Šé¢ä¾‹å­çš„ç¬¬ 3 è¡Œçš„ Foo å®šä¹‰ä¿®æ”¹å¦‚ä¸‹: class Foo[+T] // covariant å°±å¯ä»¥è®©ç¼–è¯‘å™¨æ¨å¯¼å‡º Foo[B] æ˜¯ Foo[A] çš„å­ç±»ï¼Œè¿›è€Œè®©ç¬¬ 14 è¡Œç¼–è¯‘é€šè¿‡ã€‚ é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰ é€†å˜ (contra-variant)ï¼Œå®ƒä¼šå°†å­ç±»å…³ç³»åè½¬ã€‚å°†ä¸Šé¢ä¾‹å­çš„ç¬¬ 3 è¡Œçš„ Foo å®šä¹‰ä¿®æ”¹å¦‚ä¸‹: class Foo[-T] // contra-variant ç¼–è¯‘å™¨å°±ä¼šæ¨å¯¼å‡ºå…³ç³»: Foo[A] æ˜¯ Foo[B] çš„å­ç±»ï¼Œè¿™ä¸ªå…³ç³»åˆšå¥½æ˜¯ A å’Œ B çš„åè½¬ã€‚ åœ¨ Scala ä¸­ï¼Œå‡½æ•°ä¹‹é—´çš„å…³ç³»ä¹Ÿä½“ç°äº†åå˜å’Œé€†å˜ï¼Œå³ å‚æ•°æ˜¯é€†å˜çš„ï¼Œè¿”å›å€¼æ˜¯åå˜çš„: class A class B extends A // B is subclass of A class C extends B // C is subclass of B /* * `A =\u003e C` is subclass of `B =\u003e B` */ ä¸ºä»€ä¹ˆ A =\u003e C æ˜¯ B =\u003e B çš„å­ç±»å‘¢ï¼Ÿå…¶å®ä¹Ÿå¾ˆå¥½ç†è§£ï¼ŒB =\u003e B çš„è¿”å›å€¼æ˜¯ Bï¼Œè¿™ä¸ªè¿”å›å€¼å¯ä»¥ç”¨ C æ¥ä»£æ›¿ï¼Œä½†ä¸èƒ½ç”¨ A æ¥ä»£æ›¿ï¼Œè¿™æ˜¾ç„¶æ»¡è¶³åå˜ã€‚B =\u003e B çš„å‚æ•°æ˜¯ Bï¼Œè¿™ä¸ªå‚æ•°å¯ä»¥ç”¨ A æ¥ä»£æ›¿è€Œä¸èƒ½ç”¨ C æ¥ä»£æ›¿ (å› ä¸ºæœ‰ä¸€éƒ¨åˆ† B ä¸ä¸€å®šæ˜¯ Cï¼Œè€Œ B åˆ™ä¸€å®šæ˜¯ A)ï¼Œè¿™æ»¡è¶³é€†å˜ã€‚ T å¯ä»¥è¡¨ç¤ºæ‰€æœ‰æƒ…å†µ: ownership, immutable reference, mutable referenceï¼Œä¾‹å¦‚ T å¯ä»¥è¡¨ç¤º i32, \u0026i32, \u0026mut i32 (å¦‚æœä½ ä½¿ç”¨è¿‡ into_iterator çš„è¯åº”è¯¥ä¸é™Œç”Ÿ) T: 'a æ˜¯è¯´ï¼šå¦‚æœ T é‡Œé¢å«æœ‰å¼•ç”¨ï¼Œé‚£ä¹ˆè¿™ä¸ªå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»æ˜¯ 'a çš„å­ç±»ï¼Œå³æ¯” 'a é•¿æˆ–å’Œ 'a ç›¸ç­‰ã€‚T: 'static ä¹Ÿç±»ä¼¼ï¼Œè¡¨ç¤º T é‡Œé¢çš„å¼•ç”¨ (å¦‚æœæœ‰çš„è¯)ï¼Œè¦ä¹ˆæ¯” 'static é•¿æˆ–å’Œ 'static ç›¸ç­‰ï¼Œå› ä¸ºä¸å¯èƒ½æœ‰æ¯” 'static æ›´é•¿çš„ç”Ÿå‘½å‘¨æœŸï¼Œæ‰€ä»¥è¿™ä¸ªæ ‡æ³¨æœ‰ä¸¤ç§è¡¨ç¤ºæ„ä¹‰è¡¨: è¦ä¹ˆ T é‡Œé¢çš„å¼•ç”¨å’Œ 'static ä¸€æ ·é•¿ï¼Œè¦ä¹ˆ T é‡Œé¢æ²¡æœ‰å¼•ç”¨åªæœ‰æ‰€æœ‰æƒ (owneship)ã€‚ The Rust Reference: Subtyping and Variance The Rustonomicon: Subtyping and Variance åŸºæœ¬å’Œæˆ‘ä»¬ä¹‹å‰æ‰€è¯´çš„ä¸€è‡´ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„ä¸€ç‚¹: å‡¡æ˜¯æ¶‰åŠå¯å˜å¼•ç”¨çš„ Tï¼Œéƒ½æ˜¯ä¸å˜ (invariant)ã€‚è¿™ä¹Ÿå¾ˆå¥½ç†è§£ï¼Œå› ä¸ºå¯å˜å¼•ç”¨éœ€è¦ä¿è¯æ‰€å¼•ç”¨çš„ç±»å‹ T æ˜¯ä¸€è‡´å¹¶ä¸”æ˜¯å”¯ä¸€çš„ï¼Œå¦åˆ™ä¼šæ‰°ä¹± Rust çš„å¼•ç”¨æ¨¡å‹ã€‚å› ä¸ºå¯å˜å¼•ç”¨ä¸ä»…å¯ä»¥æ”¹å˜æ‰€æŒ‡å‘çš„ object çš„å†…å®¹ï¼Œè¿˜å¯ä»¥æ”¹å˜è‡ªèº«ï¼Œå³æ”¹å˜æŒ‡å‘çš„ objectï¼Œå¦‚æœæ­¤æ—¶ T ä¸æ˜¯ä¸å˜ (invariant) çš„ï¼Œé‚£ä¹ˆå¯ä»¥å°†è¿™ä¸ªå¯å˜å¼•ç”¨æŒ‡å‘ T çš„å­ç±»ï¼Œè¿™ä¼šå¯¼è‡´è¯¥å¯å˜å¼•ç”¨æŒ‡å‘çš„ object è¢«å¯å˜å€Ÿç”¨ä¸€æ¬¡åæ— æ³•å½’è¿˜ï¼Œä»è€Œå¯¼è‡´åç»­å†ä¹Ÿæ— æ³•å¼•ç”¨è¯¥ objectã€‚æ­¤å¤–è¿˜ä¼šå¯¼è‡´åŸæœ¬æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸçº¦æŸçš„ä¸¤ä¸ªç‹¬ç«‹ç±»å‹ï¼Œè¢«ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œå…·ä½“è§åé¢çš„ä¾‹å­ã€‚ struct Foo\u003c'a\u003e { _phantom: PhantomData\u003c\u0026'a i32\u003e, } fn foo\u003c'short, 'long: 'short\u003e( // long is subclass of short mut short_foo: Foo\u003c'short\u003e, mut long_foo: Foo\u003c'long\u003e, ) { short_foo = long_foo; // succeed long_foo = short_foo; // error } ä¸‹é¢æ˜¯ä¸€ä¸ªå¯å˜å¼•ç”¨çš„ä¾‹å­ã€‚å‚æ•° short_foo å’Œ long_foo æ²¡æœ‰å…³ç³»ï¼Œæ˜¯ä¸¤ä¸ªç‹¬ç«‹çš„ç±»å‹ï¼Œæ‰€ä»¥æ— æ³•ç›¸äº’èµ‹å€¼ï¼Œè¿™ä¿è¯äº†å¯å˜å¼•ç”¨çš„æ¨¡å‹çº¦æŸã€‚é™¤æ­¤ä¹‹å¤–ï¼Œå¦‚æœå¯å˜å¼•ç”¨çš„å‹å˜è§„åˆ™ä¸æ˜¯ä¸å˜ (inariant) åˆ™ä¼šå¯¼è‡´ short_foo å’Œ long_foo åœ¨å‡½æ•° foo è°ƒç”¨åçš„ç”Ÿå‘½å‘¨æœŸçº¦æŸä¸º: short_foo $\\leq$ long_foo (åå˜) long_foo $\\leq$ short_foo (é€†å˜) è€Œå®ƒä»¬æœ¬èº«å¯èƒ½å¹¶æ²¡æœ‰è¿™ç§çº¦æŸï¼Œç”Ÿå‘½å‘¨æœŸæ˜¯äº’ç›¸ç‹¬ç«‹çš„ã€‚ struct Foo\u003c'a\u003e { _phantom: PhantomData\u003c\u0026'a i32\u003e, } fn foo\u003c'short, 'long: 'short\u003e( // long is subclass of short mut short_foo: \u0026mut Foo\u003c'short\u003e, mut long_foo: \u0026mut Foo\u003c'long\u003e, ) { short_foo = long_foo; // error long_foo = short_foo; // error } ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:7:0","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"ç”Ÿå‘½å‘¨æœŸ reborrow let mut i = 42; let x = \u0026mut i; // x: \u0026mut i32 let y = x; // y: \u0026mut i32 *y = 43; println(\"{}\", *y); *x = 44; println(\"{}\", *x); æŒ‰ç…§ Rust çš„å€Ÿç”¨æ£€æŸ¥æœºåˆ¶ï¼Œç¬¬ 3 è¡Œå¤„ä¼šå¯¼è‡´åç»­å‡ºç°ä¸¤ä¸ªæŒ‡å‘ i çš„å¯å˜å¼•ç”¨ x å’Œ yï¼Œç¼–è¯‘ä¼šå¤±è´¥ï¼Œä½†å®é™…ä¸Šç¼–è¯‘æ˜¯æ²¡é—®é¢˜çš„ï¼Œè¿™æ˜¯å› ä¸ºé‡å¼•ç”¨ reborrow æœºåˆ¶ï¼Œå…¶ä½¿å¾—ç¬¬ 3 è¡Œå®è´¨ä¸Šè¢«ç¼–è¯‘å™¨å¤„ç†ä¸º: let y = \u0026mut *x; // y: \u0026mut i32 æ‰€ä»¥ y å…¶å®æ˜¯å¯¹ x çš„é‡å¼•ç”¨ï¼Œåœ¨ é‡å¼•ç”¨çš„ä½¿ç”¨èŒƒå›´ å†…ï¼Œåªè¦ä¸ä½¿ç”¨ è¢«é‡å¼•ç”¨çš„å¼•ç”¨ x å’Œ å¯¹è±¡æœ¬èº« iï¼Œç¼–è¯‘å™¨ä¼šè®¤ä¸ºè¿™æ˜¯æ²¡é—®é¢˜çš„ï¼Œä¸ªäººæ„Ÿè§‰ç›¸å½“äºæ¯”è¾ƒé«˜é˜¶çš„å˜é‡é®è”½ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ reborrow æœºåˆ¶åªåº”ç”¨äº å¯å˜å¼•ç”¨ï¼Œå› ä¸ºä¸å¯å˜å¼•ç”¨å¯ä»¥åŒæ—¶å­˜åœ¨å¤šä¸ªï¼Œæ— éœ€æ‹…å¿ƒé‡å¼•ç”¨æ—¶ä¸èƒ½ä½¿ç”¨çš„é—®é¢˜ã€‚ä¸‹é¢æ˜¯å¦ä¸€ä¸ªä¾‹å­ï¼Œä¹Ÿæ˜¯å› ä¸º reborrow æœºåˆ¶ä»è€Œé€šè¿‡ç¼–è¯‘: fn main() { let mut i = 42; let x = \u0026mut i; // x: \u0026mut i32 change_it(x); println(\"{}\", *y); *x = 44; println(\"{}\", *x); } fn change_it(mut_i32: \u0026mut i32) { *mut_i32 = 43; } ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:8:0","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"Homework ä¿¡æ¯ é˜…è¯»åšå®¢ Common Rust Lifetime Misconceptions ä»¥å¯¹ Rust ç”Ÿå‘½å‘¨æœŸåŠå¸¸è§çš„è¯¯åŒºæœ‰å……åˆ†è®¤çŸ¥ å®Œæˆ LifetimeKata çš„ç›¸å…³ç»ƒä¹  ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:9:0","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"LifetimeKata Chapter 1: Lifetimes Needed Lifetime Annotations are used to help the compiler understand what's going on when it can't rely on scope brackets (i.e. across function boundaries; and within structs and enums). Chapter 3: Lifetime Elision We saw that the compiler was unable to automatically tell how references in the arguments or return values might relate to each other. This is why we needed to tell the compiler that the references related to each other. å³ Rust ç¼–è¯‘å™¨å¯ä»¥é€šè¿‡ä½œç”¨èŒƒå›´æ¥ç¡®å®šå¼•ç”¨æ˜¯å¦åˆæ³•ï¼Œè¿›è€Œé˜²æ­¢ æ‚¬å‚å¼•ç”¨ï¼Œä½†æ˜¯å¯¹äºå‡½æ•°è°ƒç”¨æˆ–è€…æ˜¯ç»“æ„ä½“çš„æ„é€ ï¼ŒRust ç¼–è¯‘å™¨å°±æ— æ³•é€šè¿‡ä¸Šä¸‹æ–‡æ¥è¿›è¡Œæ£€æŸ¥äº† (å› ä¸ºæ¯æ¬¡å‡½æ•°è°ƒç”¨æˆ–ç»“æ„ä½“æ„é€ ä½¿ç”¨çš„å¼•ç”¨éƒ½å¯èƒ½ä¸åŒ)ï¼Œæ‰€ä»¥éœ€è¦ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œå®ƒçš„ä½œç”¨æ˜¯è®©ç¼–è¯‘å™¨æŒ‰ç…§æ ‡æ³¨æŒ‡å®šçš„å…³ç³»å¯¹å¼•ç”¨è¿›è¡Œæ£€æŸ¥ã€‚ Chapter 7: Special Lifetimes Lifetime bounds can be applied to types or to other lifetimes. The bound 'a: 'b is usually read as 'a outlives 'b. 'a: 'b means that 'a lasts at least as long as 'b, so a reference \u0026'a () is valid whenever \u0026'b () is valid. ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œå®è´¨ä¸Šæ˜¯ç”¨äºè§„å®š Variance çš„å…³ç³» Chapter 10: Footnote on Trait Lifetime Bounds Itâ€™s important to realise that since trait objects might or might not contain a reference (or any number of references), all trait objects have lifetimes. This is true, even if no implementors of the trait contain references. Trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸæ¯”è¾ƒå¤æ‚ï¼Œä½†ä¸€èˆ¬ä¸ä¼šå¤ªå¤šæ¶‰åŠåˆ°ï¼Œæ¯”è¾ƒå¸¸è§çš„ä¾‹å­æ˜¯ Box\u003cdyn Trait\u003e ç­‰ä»·äº Box\u003cdyn 'static Trait\u003e ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:9:1","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:10:0","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"Crate std å¯ä»¥ä½¿ç”¨è¿™é‡Œæä¾›çš„æœç´ æ è¿›è¡Œæœç´¢ (BTW ä¸è¦æµªè´¹æ—¶é—´åœ¨ Google æœå¯»ä¸Šï¼) ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:10:1","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["Rust"],"content":"References Common Rust Lifetime Misconceptions The Rust Reference æ³›å‹ä¸­çš„å‹å˜ (åå˜ï¼Œé€†å˜ï¼Œä¸å¯å˜) Variant Types and Polymorphism ","date":"2024-04-05","objectID":"/posts/lifetime-in-rust/:11:0","tags":["Rust","Lifetime"],"title":"Rust Lifetime: ç”±æµ…å…¥æ·±ç†è§£ç”Ÿå‘½å‘¨æœŸ","uri":"/posts/lifetime-in-rust/"},{"categories":["C","Linux Kernel Internals"],"content":" goto åœ¨ C èªè¨€è¢«æŸäº›äººçœ‹åšæ˜¯å¦–é­”èˆ¬çš„å­˜åœ¨ï¼Œä¸éå¯¦åœ¨ä¸ç”¨é€™æ¨£çœ‹å¾…ï¼Œè‡³å°‘åœ¨ Linux æ ¸å¿ƒåŸå§‹ç¨‹å¼ç¢¼ä¸­ï¼Œgoto æ˜¯å¤§é‡å­˜åœ¨ (è·Ÿä½ æƒ³åƒä¸­ä¸åŒå§)ã€‚æœ‰æ™‚ä¸ç”¨ goto æœƒå¯«å‡ºæ›´å¯æ€•çš„ç¨‹å¼ç¢¼ã€‚ åŸæ–‡åœ°å€ Stack Overflow: GOTO still considered harmful? ","date":"2024-04-05","objectID":"/posts/c-control-flow/:0:0","tags":["Sysprog","C","Control flow"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: goto å’Œæµç¨‹æ§åˆ¶ç¯‡","uri":"/posts/c-control-flow/"},{"categories":["C","Linux Kernel Internals"],"content":"MISRA C MISRA-C:2004 Guidelines for the use of the C language in critical systems MISRA C ç¦ç”¨ goto å’Œ continueï¼Œä½†å¯ç”¨ break: Rule 14.4 (required): The goto statement shall not be used. Rule 14.5 (required): The continue statement shall not be used. Rule 14.6 (required): For any iteration statement there shall be at most one break statement used for loop termination. These rules are in the interests of good structured programming. One break statement is allowed in a loop since this allows, for example, for dual outcome loops or for optimal coding. Stack Overflow ä¸Šçš„ç›¸å…³è®¨è®º: Why â€œcontinueâ€ is considered as a C violation in MISRA C:2004? ä½¿ç”¨ goto å¯èƒ½ä¼šæ··æ·†é™æ€åˆ†æçš„å·¥å…· (å½“ç„¶ä½¿ç”¨ goto ä¼šæå¤§å¯èƒ½å†™å‡º ugly çš„ç¨‹å¼ç ): Case in point: MISRA C forbids goto statements primarily because it can mess up static analysis. Yet this rule is gratuitously followed even when no static analysis tools are used, thus yielding none of the gains that you trade off for occasionally writing ugly code. ","date":"2024-04-05","objectID":"/posts/c-control-flow/:1:0","tags":["Sysprog","C","Control flow"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: goto å’Œæµç¨‹æ§åˆ¶ç¯‡","uri":"/posts/c-control-flow/"},{"categories":["C","Linux Kernel Internals"],"content":"GOTO æ²¡æœ‰æƒ³è±¡ä¸­é‚£ä¹ˆå¯æ€• è™½ç„¶ MISRA C è¿™ç±»è§„èŒƒéƒ½æ˜ç¡®ç¦æ­¢äº†ä½¿ç”¨ gotoï¼Œä½† goto å¹¶æ²¡æœ‰æƒ³åƒä¸­çš„é‚£ä¹ˆå¯æ€•ï¼Œåœ¨ä¸€äº›é¢†åŸŸè¿˜æ˜¯æå…·æ´»åŠ›çš„ã€‚ åœ¨ C è¯­è¨€ä¸­ goto è¯­å¥æ˜¯å®ä½œé”™è¯¯å¤„ç†çš„æä½³é€‰æ‹© (å¦‚æœä½ çœ‹è¿‡ xv6 åº”è¯¥ä¸é™Œç”Ÿ)ï¼Œæœ‰æ—¶ä¸ç”¨ goto å¯èƒ½ä¼šå†™å‡ºæ›´å¯æ€•çš„ç¨‹å¼ç : Using goto for error handling in C Wikipedia: RAII C requires significant administrative code since it doesnâ€™t support exceptions, try-finally blocks, or RAII at all. A typical approach is to separate releasing of resources at the end of the function and jump there with gotos in the case of error. This way the cleanup code need not be duplicated. ç›¸å…³å®ä½œ: goto åœ¨ Linux æ ¸å¿ƒå¹¿æ³›åº”ç”¨ OpenBSDâ€™s httpd Linux kernel é‡Œ NFS inode éªŒè¯çš„å‡½æ•°: fs/nfs/inode.c ä»¥ goto ä¸ºå…³é”®å­—è¿›è¡Œæ£€ç´¢ Wikipedia: Common usage patterns of Goto To make the code more readable and easier to follow Error handling (in absence of exceptions), particularly cleanup code such as resource deallocation. ","date":"2024-04-05","objectID":"/posts/c-control-flow/:2:0","tags":["Sysprog","C","Control flow"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: goto å’Œæµç¨‹æ§åˆ¶ç¯‡","uri":"/posts/c-control-flow/"},{"categories":["C","Linux Kernel Internals"],"content":"switch \u0026 goto switch é€šè¿‡ jump table çš„å†…éƒ¨å®ä½œå¯ä»¥æ¯”å¤§é‡çš„ if-else æ•ˆç‡æ›´é«˜ã€‚ GCC: 6.3 Labels as Values You can get the address of a label defined in the current function (or a containing function) with the unary operator â€˜\u0026\u0026â€™. The value has type void *. To use these values, you need to be able to jump to one. This is done with the computed goto statement6, goto *exp;. ä¸‹é¢è¿™ç¯‡æ–‡ç« ä»¥ VM ä¸ºä¾‹å­å¯¹ computed goto å’Œ switch çš„æ•ˆèƒ½è¿›è¡Œäº†å¯¹æ¯” (ä¹‹å‰å­¦çš„ RISC-V æ¨¡æ‹Ÿå™¨æ´¾ä¸Šç”¨åœºäº†hhh): Computed goto for efficient dispatch tables the condition serves as an offset into a lookup table that says where to jump next. To anyone with a bit of experience with assembly language programming, the computed goto immediately makes sense because it just exposes a common instruction that most modern CPU architectures have - jump through a register (aka. indirect jump). computed goto æ¯” switch æ•ˆèƒ½æ›´é«˜çš„åŸå› : The switch does a bit more per iteration because of bounds checking. The effects of hardware branch prediction. C99: If no converted case constant expression matches and there is no default label, no part of the switch body is executed. å› ä¸ºæ ‡å‡†çš„è¿™ä¸ªè¦æ±‚ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨å¯¹äº switch ä¼šç”Ÿæˆé¢å¤–çš„ safe æ£€æŸ¥ä»£ç ï¼Œä»¥ç¬¦åˆä¸Šé¢æƒ…å½¢çš„ â€œno part of the switch body is executedâ€ çš„è¦æ±‚ã€‚ Since the switch statement has a single â€œmaster jumpâ€ that dispatches all opcodes, predicting its destination is quite difficult. On the other hand, the computed goto statement is compiled into a separate jump per opcode, so given that instructions often come in pairs itâ€™s much easier for the branch predictor to â€œhome inâ€ on the various jumps correctly. ä½œè€…æåˆ°ï¼Œta ä¸ªäººè®¤ä¸ºåˆ†æ”¯é¢„æµ‹æ˜¯å¯¼è‡´æ•ˆèƒ½å·®å¼‚çš„ä¸»è¦å› ç´ : I canâ€™t say for sure which one of the two factors weighs more in the speed difference between the switch and the computed goto, but if I had to guess Iâ€™d say itâ€™s the branch prediction. é™¤æ­¤ä¹‹å¤–ï¼Œæœ‰è¿™ç¯‡æ–‡ç« çš„ disassembly éƒ¨åˆ†å¯ä»¥å¾—çŸ¥ï¼Œswitch çš„åº•å±‚æ˜¯é€šè¿‡æ‰€è°“çš„ jump table æ¥å®ä½œçš„: å¼•ç”¨ How did I figure out which part of the code handles which opcode? Note that the â€œtable jumpâ€ is done with: jmpq *0x400b20(,%rdx,8) bounds checking æ˜¯åœ¨ switch ä¸­åŸ·è¡Œçš„ä¸€å€‹ç’°ç¯€ï¼Œæ¯æ¬¡è¿´åœˆä¸­æª¢æŸ¥æ˜¯å¦æœ‰ default case çš„ç‹€æ³ï¼Œå³ä½¿ç¨‹å¼ä¸­çš„ switch æ²’æœ‰ç”¨åˆ° default caseï¼Œç·¨è­¯æœŸé–“ä»æœƒç”¢ç”Ÿå¼·åˆ¶æª¢æŸ¥çš„ç¨‹å¼ï¼Œæ‰€ä»¥ switch æœƒè¼ƒ computed goto å¤šèŠ±ä¸€å€‹ bounds checking çš„æ­¥é©Ÿ branch prediction çš„éƒ¨åˆ†ï¼Œswitch éœ€è¦é æ¸¬æ¥ä¸‹ä¾†è·³åˆ°å“ªå€‹åˆ†æ”¯ caseï¼Œè€Œ computed goto å‰‡æ˜¯åœ¨æ¯å€‹ instruction é æ¸¬ä¸‹ä¸€å€‹ instructionï¼Œé€™ä¹‹ä¸­æ¯”è¼ƒç›´è¦ºçš„æƒ³æ³•æ˜¯ computed goto çš„predictionå¯ä»¥æ ¹æ“šä¸Šå€‹æŒ‡ä»¤ä¾†é æ¸¬ï¼Œä½†æ˜¯ switch çš„predictionæ¯æ¬¡é æ¸¬æ²’è¾¦æ³•æ ¹æ“šä¸Šå€‹æŒ‡ä»¤ï¼Œå› æ­¤åœ¨ branch prediction accuracy ä¸Š computed goto æœƒæ¯”è¼ƒé«˜ã€‚ æ‰€ä»¥åœ¨å®é™…ä¸­å¤§éƒ¨åˆ†ä¹Ÿæ˜¯é‡‡å– computed goto æ¥å®ä½œ VM: Ruby 1.9 (YARV): also uses computed goto. Dalvik (the Android Java VM): computed goto Lua 5.2: uses a switch ","date":"2024-04-05","objectID":"/posts/c-control-flow/:3:0","tags":["Sysprog","C","Control flow"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: goto å’Œæµç¨‹æ§åˆ¶ç¯‡","uri":"/posts/c-control-flow/"},{"categories":["C","Linux Kernel Internals"],"content":"do {â€¦} while (0) å® ç”¨äºé¿å… dangling elseï¼Œå³ if å’Œ else æœªç¬¦åˆé¢„æœŸçš„é…å¯¹ (å¸¸è§äºæœªä½¿ç”¨ {} åŒ…è£¹) Stack Overflow: C multi-line macro: do/while(0) vs scope block æˆ‘å†™äº† ç›¸å…³ç¬”è®° è®°å½•åœ¨å‰ç½®å¤„ç†å™¨ç¯‡ã€‚ ","date":"2024-04-05","objectID":"/posts/c-control-flow/:4:0","tags":["Sysprog","C","Control flow"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: goto å’Œæµç¨‹æ§åˆ¶ç¯‡","uri":"/posts/c-control-flow/"},{"categories":["C","Linux Kernel Internals"],"content":"ç”¨ goto å®ä½œ RAII å¼€å‘é£æ ¼ RAII in C If you have functions or control flows that allocate resources and a failure occurs, then goto turns out to be one of the nicest ways to unwind all resources allocated before the point of failure. Linux æ ¸å¿ƒä¸­çš„å®ä½œ: shmem.c ä»¥ goto ä¸ºå…³é”®å­—è¿›è¡Œæ£€ç´¢ ","date":"2024-04-05","objectID":"/posts/c-control-flow/:5:0","tags":["Sysprog","C","Control flow"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: goto å’Œæµç¨‹æ§åˆ¶ç¯‡","uri":"/posts/c-control-flow/"},{"categories":["C","Linux Kernel Internals"],"content":"æ£€é˜… C è¯­è¨€è§„æ ¼ä¹¦ ISO/IEC 9899:201x Committee Draft 6.8.6 Jump statements A jump statement causes an unconditional jump to another place. The identifier in a goto statement shall name a label located somewhere in the enclosing function. A goto statement shall not jump from outside the scope of an identifier having a variably modified type to inside the scope of that identifier. è§„æ ¼ä¹¦åé¢çš„ä¾‹å­ä¹Ÿå€¼å¾—ä¸€çœ‹ (ç‰¹åˆ«æ˜¯å½“ä½ çœ‹ä¸æ‡‚è§„æ ¼ä¹¦ä¸¥æ ¼çš„è‹±è¯­è¯­æ³•æƒ³è¡¨è¾¾ä»€ä¹ˆçš„æ—¶å€™ ğŸ¤£) ä»è§„æ ¼ä¹¦ä¸­ä¹Ÿå¯ä»¥å¾—çŸ¥ï¼Œgoto è™½ç„¶æ˜¯æ— æ¡ä»¶è·³è½¬ (å¯¹åº”æ±‡ç¼–è¯­è¨€çš„ jmp è¿™ç±»æ— æ¡ä»¶è·³è½¬æŒ‡ä»¤)ï¼Œä½†å®ƒçš„è·³è½¬èŒƒå›´æ˜¯æœ‰é™åˆ¶çš„ (jump to another place)ï¼Œè€Œä¸æ˜¯å¯ä»¥è·³è½¬åˆ°ä»»æ„ç¨‹å¼ç  (è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ setjmp/longjmp è¢«ç§°ä¸ºã€Œé•¿è·³è½¬ã€çš„åŸå› ï¼Œä¸ goto è¿™ç±»ã€ŒçŸ­è·³è½¬ã€ç›¸å¯¹åº”)ã€‚ ç›¸å…³å®ä½œ: CPython çš„ Modules/_asynciomodule.c ä»¥ goto ä¸ºå…³é”®å­—è¿›è¡Œæ£€ç´¢ Modern C ä½œè€…ä¹Ÿæ€»ç»“äº† 3 é¡¹å’Œ goto ç›¸å…³çš„è§„èŒƒ (å¤§å¯ä¸å¿…è§† goto ä¸ºæ´ªæ°´çŒ›å…½ï¼Œæ¯•ç«Ÿæˆ‘ä»¬æœ‰è§„èŒƒä½œä¸ºæŒ‡å¯¼æ˜¯ä¸æ˜¯): Rule 2.15.0.1: Labels for goto are visible in the whole function that contains them. Rule 2.15.0.2: goto can only jump to a label inside the same function. Rule 2.15.0.3: goto should not jump over variable initializations. ","date":"2024-04-05","objectID":"/posts/c-control-flow/:6:0","tags":["Sysprog","C","Control flow"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: goto å’Œæµç¨‹æ§åˆ¶ç¯‡","uri":"/posts/c-control-flow/"},{"categories":["C","Linux Kernel Internals"],"content":"å’Œæƒ³è±¡ä¸­ä¸åŒçš„ switch-case switch-case è¯­å¥ä¸­çš„ case éƒ¨åˆ†æœ¬è´¨ä¸Šæ˜¯ labelï¼Œæ‰€ä»¥ä½¿ç”¨å…¶å®ƒè¯­å¥ (ä¾‹å¦‚ if) å°†å…¶åŒ…è£¹èµ·æ¥å¹¶ä¸å½±å“ switch è¯­å¥çš„è·³è½¬ã€‚æ‰€ä»¥å°† swicth-case çš„ case éƒ¨åˆ†ç”¨ if (0) åŒ…è£¹èµ·æ¥å°±æ— éœ€ä½¿ç”¨ break æ¥è¿›è¡Œè·³å‡ºäº†: switch (argc - 1) { case 0: num = \"zero\"; if (0) { case 1: num = \"one\"; } if (0) { case 2: num = \"two\"; } if (0) { case 3: num = \"three\"; } if (0) { default: num = \"many\"; } å½’çº³ä¸€ä¸‹ï¼Œè¿™ç§å®ä½œæ–¹æ³•ç¬¦åˆä»¥ä¸‹ç»“æ„: if (0) { label: ... } Cliffordâ€™s Device A Cliffordâ€™s Device is a section of code is surrounded by if (0) { label: â€¦ } so it is skipped in the normal flow of execution and is only reached via the goto label, reintegrating with the normal flow of execution and the end of the if (0) statement. It solves a situation where one would usually need to duplicate code or create a state variable holding the information if the additional code block should be called. A switch statement is nothing else than a computed goto statement. So it is possible to use Cliffordâ€™s Device with a switch statement as well. ç®€å•æ¥è¯´ï¼Œè¿™ç§æ–¹æ³•ä¸»è¦ç”¨äºå¼€å‘é˜¶æ®µæ—¶çš„è¿è¡Œæ—¶ä¿¡æ¯è¾“å‡ºï¼Œåœ¨å‘è¡Œé˜¶æ®µè¿è¡Œæ—¶ä¸å†è¾“å‡ºè¿™ä¸€ä¿¡æ¯çš„æƒ…æ™¯ï¼Œæœ‰åŠ©äºå¼€å‘æ—¶ç¨‹åºå‘˜è¿›è¡Œä¾¦é”™ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œåœ¨ä½¿ç”¨æšä¸¾ä½œä¸º switch-case çš„è¡¨è¾¾å¼æ—¶ï¼Œå¦‚æœ case æ²¡æœ‰å¯¹å…¨éƒ¨çš„æšä¸¾å€¼è¿›è¡Œå¤„ç†çš„è¯ï¼Œç¼–è¯‘å™¨ä¼šç»™å‡ºè­¦å‘Š (Rust è­¦å‘Š ğŸ¤£ ä½† Rust ä¼šç›´æ¥æŠ¥é”™)ï¼Œä½¿ç”¨ if (0) { ... } æŠ€å·§å°†æœªå¤„ç†çš„æšä¸¾å€¼å¯¹åº”çš„ case åŒ…è£¹å°±ä¸ä¼šå‡ºç°è­¦å‘Šï¼ŒåŒæ—¶ä¹Ÿä¸å½±å“ä»£ç é€»è¾‘ã€‚ åœ¨ OpenSSL ä¸­ä¹Ÿæœ‰ç±»ä¼¼æ‰‹æ³•çš„å®ä½œ: if (!ok) goto end; if (0) { end: X509_get_pubkey_parameters(NULL, ctx-\u003echain); } Something You May Not Know About the Switch Statement in C/C++ How to Get Fired Using Switch Statements \u0026 Statement Expressions ","date":"2024-04-05","objectID":"/posts/c-control-flow/:7:0","tags":["Sysprog","C","Control flow"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: goto å’Œæµç¨‹æ§åˆ¶ç¯‡","uri":"/posts/c-control-flow/"},{"categories":["C","Linux Kernel Internals"],"content":"Duffâ€™s Device è¿™ä¸ªæŠ€å·§å¸¸ç”¨äºå†…å­˜æ•°æ®çš„å¤åˆ¶ï¼Œç±»ä¼¼äº memcpyã€‚ä¸»è¦æ€è·¯ç±»ä¼¼äºåœ¨æ•°å€¼ç³»ç»Ÿç¯‡æåˆ°çš„ strcpyï¼Œé’ˆå¯¹ alignment å’Œ unalignment çš„æƒ…å†µåˆ†åˆ«è¿›è¡Œç›¸åº”çš„å¤„ç†ï¼Œä½†æ•ˆèƒ½æ¯”ä¸ä¸Šä¼˜åŒ–è¿‡çš„ memcpyã€‚ Wikipedia: Duffâ€™s Device To handle cases where the number of iterations is not divisible by the unrolled-loop increments, a common technique among assembly language programmers is to jump directly into the middle of the unrolled loop body to handle the remainder. Duff implemented this technique in C by using Câ€™s case label fall-through feature to jump into the unrolled body. Linux æ ¸å¿ƒä¸­çš„å®ä½œè¿ç”¨: void dsend(int count) { if (!count) return; int n = (count + 7) / 8; switch (count % 8) { case 0: do { puts(\"case 0\"); case 7: puts(\"case 7\"); case 6: puts(\"case 6\"); case 5: puts(\"case 5\"); case 4: puts(\"case 4\"); case 3: puts(\"case 3\"); case 2: puts(\"case 2\"); case 1: puts(\"case 1\"); } while (--n \u003e 0); } } è¯•ç€å°†ä¸Šé¢è¿™æ®µç¨‹å¼ç ä¿®æ”¹ä¸º memcpy åŠŸèƒ½çš„å®ä½œï¼Œè¿›ä¸€æ­¥ä½“ä¼š Duffâ€™s Device çš„æ ¸å¿ƒæœºåˆ¶ï¼ŒåŒæ—¶ç»“åˆã€ŒCè¯­è¨€: å†…å­˜ç®¡ç†ç¯‡ã€æ€è€ƒä¸ºä»€ä¹ˆè¯¥å®ä½œæ•ˆèƒ½ä¸é«˜ã€‚ Answer æœªå……åˆ†åˆ©ç”¨ data alignment å’Œç°ä»£å¤„ç†å™¨çš„å¯„å­˜å™¨å¤§å°ï¼Œæ¯æ¬¡åªå¤„ç†ä¸€ä¸ª byte å¯¼è‡´æ•ˆç‡ä½ä¸‹ã€‚ Duffâ€™s Device çš„è¯¦ç»†è§£é‡Š Tom Duff æœ¬äººçš„è§£é‡Š å¼•ç”¨ ä½†åœ¨ç¾ä»£çš„å¾®è™•ç†å™¨ä¸­ï¼ŒDuffâ€™s Device ä¸è¦‹å¾—æœƒå¸¶ä¾†å¥½è™•ï¼Œæ”¹ç”¨å·²é‡å°è™•ç†å™¨æ¶æ§‹æœ€ä½³åŒ–çš„ memcpy å‡½å¼ï¼Œä¾‹å¦‚ Linux æ ¸å¿ƒçš„ä¿®æ”¹ fbdev: Improve performance of sys_fillrect() ä½¿ç”¨ Duffâ€™s Device çš„ sys_fillrect(): 166,603 cycles é‹ç”¨å·²æœ€ä½³åŒ– memcpy çš„ sys_fillrect(): 26,586 cycles ","date":"2024-04-05","objectID":"/posts/c-control-flow/:8:0","tags":["Sysprog","C","Control flow"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: goto å’Œæµç¨‹æ§åˆ¶ç¯‡","uri":"/posts/c-control-flow/"},{"categories":["C","Linux Kernel Internals"],"content":"co-routine åº”ç”¨ Wikipedia: Coroutine ä¸å€ŸåŠ©æ“ä½œç³»ç»Ÿä¹Ÿå¯ä»¥å®ä½œå‡ºå¤šå·¥äº¤æ‰§è¡Œçš„ illusion (é€šè¿‡ switch-case é»‘é­”æ³•æ¥å®ç° ğŸ¤£) PuTTY ä½œè€… Simon Tatham: Coroutines in C æ³¨æ„ è¿™æ˜¯ä¸€ç¯‡å¥½æ–‡ç« ï¼Œä¸‹é¢æˆ‘å¯¹æ–‡ç« ç”»ä¸€äº›é‡ç‚¹ In The Art of Computer Programming, Donald Knuth presents a solution to this sort of problem. His answer is to throw away the stack concept completely. Stop thinking of one process as the caller and the other as the callee, and start thinking of them as cooperating equals. The callee has all the problems. For our callee, we want a function which has a â€œreturn and continueâ€ operation: return from the function, and next time it is called, resume control from just after the return statement. For example, we would like to be able to write a function that says int function(void) { int i; for (i = 0; i \u003c 10; i++) return i; /* won't work, but wouldn't it be nice */ } and have ten successive calls to the function return the numbers 0 through 9. How can we implement this? Well, we can transfer control to an arbitrary point in the function using a goto statement. So if we use a state variable, we could do this: int function(void) { static int i, state = 0; switch (state) { case 0: goto LABEL0; case 1: goto LABEL1; } LABEL0: /* start of function */ for (i = 0; i \u003c 10; i++) { state = 1; /* so we will come back to LABEL1 */ return i; LABEL1:; /* resume control straight after the return */ } } è¿™ä¸ªå®ä½œé‡Œé¢ï¼Œstaic è¿™ä¸ªä¿®é¥°è¯ä¹Ÿèµ·åˆ°äº†å¾ˆå¤§ä½œç”¨ï¼Œå°è¯•å¸¦å…¥ä¸€ä¸ªæµç¨‹å»ä½“ä¼š static åœ¨è¿™æ®µç¨‹å¼ç çš„ä½œç”¨ï¼Œå¹¶è¯•ç€æƒ³ä¸€ä¸‹å¦‚æœæ²¡æœ‰ static ä¿®é¥°å˜é‡ i å’Œ state ä¼šå¯¼è‡´ä¸Šé¢åæœã€‚ The famous â€œDuffâ€™s deviceâ€ in C makes use of the fact that a case statement is still legal within a sub-block of its matching switch statement. We can put it to a slightly different use in the coroutine trick. Instead of using a switch statement to decide which goto statement to execute, we can use the switch statement to perform the jump itself: int function(void) { static int i, state = 0; switch (state) { case 0: /* start of function */ for (i = 0; i \u003c 10; i++) { state = 1; /* so we will come back to \"case 1\" */ return i; case 1:; /* resume control straight after the return */ } } } Now this is looking promising. All we have to do now is construct a few well chosen macros, and we can hide the gory details in something plausible-looking: #define crBegin static int state=0; switch(state) { case 0: #define crReturn(i,x) do { state=i; return x; case i:; } while (0) #define crFinish } int function(void) { static int i; crBegin; for (i = 0; i \u003c 10; i++) crReturn(1, i); crFinish; } è¿™é‡Œåˆç”¨åˆ°äº† do { ... } while (0) æ­é…å®çš„æŠ€å·§ ğŸ¤£ The only snag remaining is the first parameter to crReturn. Just as when we invented a new label in the previous section we had to avoid it colliding with existing label names, now we must ensure all our state parameters to crReturn are different. The consequences will be fairly benign - the compiler will catch it and not let it do horrible things at run time - but we still need to avoid doing it. Even this can be solved. ANSI C provides the special macro name LINE, which expands to the current source line number. So we can rewrite crReturn as #define crReturn(x) do { state=__LINE__; return x; \\ case __LINE__:; } while (0) è¿™ä¸ªå®ä½œæ‰‹æ³•æœ¬è´¨ä¸Šå’Œ Knuth æ‰€æçš„æœºåˆ¶ç›¸åŒï¼Œå°†å‡½æ•°çš„çŠ¶æ€å­˜å‚¨åœ¨å…¶å®ƒåœ°æ–¹è€Œä¸æ˜¯å­˜æ”¾åœ¨ stack ä¸Šï¼Œè¿™é‡Œå­˜å‚¨çš„åœ°æ–¹å°±æ˜¯ä¹‹å‰æ‰€æçš„é‚£äº›è¢« static ä¿®é¥°çš„å˜é‡ (å› ä¸º static ä¿®é¥°çš„å˜é‡å­˜å‚¨åœ¨ data æ®µè€Œä¸åœ¨æ ˆä¸Š)ï¼Œäº‹å®ä¸Šè¿™äº› static å˜é‡å®ç°äº†ä¸€ä¸ªå°å‹çš„çŠ¶æ€æœºã€‚ We have achieved what we set out to achieve: a portable ANSI C means of passing data between a producer and a consumer without the need to rewrite one as an explicit state machine. We have done this by combining the C preprocessor with a little-used feature of the switch statement to create an implicit state machine. static å˜é‡çš„è¡¨è¾¾èƒ½åŠ›æœ‰é™ï¼Œä½†æ˜¯å¯ä»¥é€šè¿‡é¢„å…ˆåˆ†é…ç©ºé—´ï¼Œå¹¶é€šè¿‡æŒ‡é’ˆæ“ä½œå–ä»£ static å˜é‡æ“ä½œæ¥å®ç° coroutine çš„å¯é‡å…¥æ€§: In a serious application, this toy coroutine implementation is unlikely to be useful, because it relies on static variables and so it fails to be re-entrant or multi-threadable. Ideally, in a real application, you would want to be able to call the same function in several different contexts, and at each call in a given context, have control resume just","date":"2024-04-05","objectID":"/posts/c-control-flow/:9:0","tags":["Sysprog","C","Control flow"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: goto å’Œæµç¨‹æ§åˆ¶ç¯‡","uri":"/posts/c-control-flow/"},{"categories":["Systems"],"content":" ç†è§£ä¸€ä¸ªç³»ç»Ÿçš„æœ€ä½³å®è·µå°±æ˜¯å»å®ç°å®ƒã€‚å› æ­¤åœ¨æœ¬è¯¾ç¨‹çš„PA éƒ¨åˆ†ï¼Œä½ å°†ä¼šåœ¨æ¡†æ¶ä»£ç çš„åŸºç¡€ä¸Šå®ç°ä¸€ä¸ª RISC-V å…¨ç³»ç»Ÿæ¨¡æ‹Ÿå™¨ NEMUï¼Œå®ƒä¸ä»…èƒ½è¿è¡Œå„ç±»æµ‹è¯•ç¨‹åºï¼Œç”šè‡³è¿˜å¯ä»¥è¿è¡Œæ“ä½œç³»ç»Ÿå’Œ â€œä»™å‰‘å¥‡ä¾ ä¼ â€ã€‚æ¨¡æ‹Ÿè¿‡ç¡¬ä»¶çš„æ‰§è¡Œï¼Œè‡ªç„¶å°±èƒ½æ·± (ç—›) å…¥ (è‹¦) ç†è§£è®¡ç®—æœºç³»ç»Ÿäº†ã€‚ è¯¾ç¨‹ç½‘é¡µ ç›´æ’­å½•å½± å®éªŒè®²ä¹‰ ä¿¡æ¯ æˆè¯¾è§†é¢‘çš„ç›´æ’­å½•å½±ä¸ PA/Lab å¹¶æ²¡æœ‰å…ˆåæ¬¡åºçš„å¼ºå…³è”æ€§ï¼Œæˆè¯¾ä¸»è¦æ˜¯åˆ†äº«ä¸€äº›åœ¨ PA/Lab æ—¶å¯æ´¾ä¸Šç”¨åœºçš„å°å·¥å…·ï¼Œæ‰€ä»¥æˆè¯¾è§†é¢‘ä¹‹é—´ä¹Ÿæ²¡æœ‰å…ˆåæ¬¡åºï¼ŒæŒ‰éœ€è§‚çœ‹å³å¯ã€‚ ","date":"2024-03-31","objectID":"/posts/nju-ics/:0:0","tags":["Linux"],"title":"å—äº¬å¤§å­¦ è®¡ç®—æœºç³»ç»ŸåŸºç¡€ é‡ç‚¹æç¤º","uri":"/posts/nju-ics/"},{"categories":["Systems"],"content":"Programming Assignmets (PA) ","date":"2024-03-31","objectID":"/posts/nju-ics/:1:0","tags":["Linux"],"title":"å—äº¬å¤§å­¦ è®¡ç®—æœºç³»ç»ŸåŸºç¡€ é‡ç‚¹æç¤º","uri":"/posts/nju-ics/"},{"categories":["Systems"],"content":"PA0: ç¯å¢ƒå®‰è£…ä¸é…ç½® Installing GNU/Linux First Exploration with GNU/Linux Installing Tools Configuring vim More Exploration Getting Source Code for PAs å®‰è£…æ–‡æ¡£è¿›è¡Œé…ç½®å³å¯ï¼Œæˆ‘ä½¿ç”¨çš„ Linux å‘è¡Œç‰ˆæ˜¯ deepin 20.9 $ neofetch --stdout cai@cai-PC ---------- OS: Deepin 20.9 x86_64 Host: RedmiBook 14 II Kernel: 5.15.77-amd64-desktop Uptime: 45 mins Packages: 2146 (dpkg) Shell: bash 5.0.3 Resolution: 1920x1080 DE: Deepin WM: KWin Theme: deepin-dark [GTK2/3] Icons: bloom-classic-dark [GTK2/3] Terminal: deepin-terminal CPU: Intel i7-1065G7 (8) @ 3.900GHz GPU: NVIDIA GeForce MX350 GPU: Intel Iris Plus Graphics G7 Memory: 3967MiB / 15800MiB ä¸€äº›æœ‰æ„æ€çš„è¶…é“¾æ¥: Wikipedia: Unix philosophy Command line vs. GUI ","date":"2024-03-31","objectID":"/posts/nju-ics/:1:1","tags":["Linux"],"title":"å—äº¬å¤§å­¦ è®¡ç®—æœºç³»ç»ŸåŸºç¡€ é‡ç‚¹æç¤º","uri":"/posts/nju-ics/"},{"categories":["draft"],"content":"This post is used to record the process of my English learning. ","date":"2024-03-30","objectID":"/posts/english/:0:0","tags":["draft"],"title":"English Everyday","uri":"/posts/english/"},{"categories":["draft"],"content":"Preface å·¥æ¬²å–„å…¶äº‹ï¼Œå¿…å…ˆåˆ©å…¶å™¨ If I had eight hours to chop down a tree, Iâ€™d spend six hours sharpening my axe. å•è¯ä¹¦: Merriam-Websterâ€™s Vocabulary Builder å†™ä½œä¹¦: The Elements of Style è¯­æ³•ä¹¦: https://grammar.codeyu.com/ å‘éŸ³æ•™å­¦: ä¸€äº› YouTube channels: https://www.youtube.com/@LearnEnglishWithTVSeries https://www.youtube.com/@letstalk https://www.youtube.com/@bbclearningenglish https://www.youtube.com/@coachshanesesl ä¸€äº› B ç«™ UP ä¸»: å¦ˆå¦ˆä¸ç”¨æ‹…å¿ƒæˆ‘çš„è‹±è¯­ è‹±è¯­å…” ä¸€äº› GitHub ä»“åº“: https://github.com/byoungd/English-level-up-tips https://github.com/xiaolai/everyone-can-use-english https://github.com/IammyselfBOOKS/New_concept_English https://github.com/protogenesis/NewConceptEnglish ä»“åº“ä¸­å…³äºæ–°æ¦‚å¿µè‹±è¯­çš„ç½‘å€ï¼Œå½•éŸ³æ˜¯æ­£ç¡®çš„ï¼Œä½†æ˜¯æœ‰ä¸€äº›æ­£æ–‡ä¸å¤ªå‡†ç¡®ï¼Œå¯ä»¥ä¸‹è½½ä¹¦ç±è¿›è¡Œå¯¹æ¯” ","date":"2024-03-30","objectID":"/posts/english/:1:0","tags":["draft"],"title":"English Everyday","uri":"/posts/english/"},{"categories":["draft"],"content":"New Concept English ","date":"2024-03-30","objectID":"/posts/english/:2:0","tags":["draft"],"title":"English Everyday","uri":"/posts/english/"},{"categories":["draft"],"content":"NCE 1 001: Excuse me! 003: Sorry, sir! 005: Nice to meet you! 007: Are you a teacher? 009: How are you today? 011: Is this your shirt? 013: A new dress 015: Your passports, please 017: How do you do 019: Tired and thirsty 021: Which book? 023: Which glasses? 025: Mrs. Smithâ€™s kitchen 027: Mrs. Smithâ€™s living room 029: Come in, Amy 031: Whereâ€™s Sally 033: A fine day 035: Our village 037: Making a bookcase 039: Donâ€™t drop it! 041: Pennyâ€™s bag 043: Hurry up! 045: The bossâ€™s letter 047: A cup of coffee 049: At the butcherâ€™s 051: A pleasant climate 053: An interesting climate 055: The Sawyer family 057: An unusual day 059: Is that all? 063: Thank you, doctor. 065: Not a baby. 067: The weekend 069: The car race 071: Heâ€™s awful 073: The way to King Street 075: Uncomfortable shoes 077: Terrible toothache 079: Peggyâ€™s shopping list 081: Roast beef and potato 083: Going on a holiday Source: Cambridge Dictionary handbag n. a small bag used by a woman to carry everyday personal items. umbrella n. a device consisting of a circular canopy of cloth on a folding metal frame supported by a central rod, used as protection against rain. nationality n. the official right to belong to a particular country. engineer n. a person whose job is to design or build machines, engines, or electrical equipment, or things such as roads, railways, or bridges, using scientific principles. perhaps adv. used to show that something is possible or that you are not certain about something. refrigerator n. a piece of kitchen equipment that uses electricity to preserve food at a cold temperature. armchair n. a comfortable chair with sides that support your arms. stereo n. wardrobe n. a tall cupboard in which you hang your clothes. dust v. to use a cloth to remove dust from the surface of something. sweep v. to clean something, especially a floor by using a brush to collect the dirt into one place from which it can be removed. aeroplane n. vase n. tobacco n. kettle n. cupboard n. beef n. lamb n. steak n. mince n. mild pad n. chalk n. greengrocer n. phrase n. jam n. grocer n. bear n. wine n. cinema n. attendant n. garage n. lamp-post n. pilot n. ","date":"2024-03-30","objectID":"/posts/english/:2:1","tags":["draft"],"title":"English Everyday","uri":"/posts/english/"},{"categories":["RISC-V"],"content":" pretask ä½œä¸ºç¤¾åŒºå…¥é—¨æ¢ç´¢ï¼Œç›®çš„æ˜¯å¸®åŠ©å®ä¹ ç”Ÿä¸€èµ·æ­å»ºå·¥ä½œç¯å¢ƒï¼Œç†Ÿæ‚‰ oerv çš„å·¥ä½œæµç¨‹å’Œåˆä½œæ–¹å¼ã€‚pretask åˆ†ä¸ºä¸‰ä¸ªæ­¥éª¤: ä»»åŠ¡ä¸€ï¼šé€šè¿‡ QEMU ä»¿çœŸ RISC-V ç¯å¢ƒå¹¶å¯åŠ¨ openEuler RISC-V ç³»ç»Ÿï¼Œè®¾æ³•è¾“å‡º neofetch ç»“æœå¹¶æˆªå›¾æäº¤ ä»»åŠ¡äºŒï¼šåœ¨ openEuler RISC-V ç³»ç»Ÿä¸Šé€šè¿‡ obs å‘½ä»¤è¡Œå·¥å…· oscï¼Œä»æºä»£ç æ„å»º RISC-V ç‰ˆæœ¬çš„ rpm åŒ…ï¼Œæ¯”å¦‚ pcre2ã€‚æç¤ºé¦–å…ˆéœ€è¦åœ¨ openEuler çš„ OBS ä¸Šæ³¨å†Œè´¦å· ä»»åŠ¡ä¸‰ï¼šå°è¯•ä½¿ç”¨ qemu user \u0026 nspawn æˆ–è€… docker åŠ é€Ÿå®Œæˆä»»åŠ¡äºŒ ","date":"2024-03-28","objectID":"/posts/oerv-pretask/:0:0","tags":["RISC-V","openEuler","QEMU","Neofetch","Container","chroot","nspawn"],"title":"OERV ä¹‹ Pretask","uri":"/posts/oerv-pretask/"},{"categories":["RISC-V"],"content":"Pretask 1: Neofetch ä»»åŠ¡ä¸€ï¼šé€šè¿‡ QEMU ä»¿çœŸ RISC-V ç¯å¢ƒå¹¶å¯åŠ¨ openEuler RISC-V ç³»ç»Ÿï¼Œè®¾æ³•è¾“å‡º neofetch ç»“æœå¹¶æˆªå›¾æäº¤ ç”±äºå·¥ä½œå†…å®¹æ˜¯å¯¹è½¯ä»¶åŒ…è¿›è¡Œ: ç¼–è¯‘ -\u003e å¤±è´¥ -\u003e å®šä½é—®é¢˜ -\u003e ä¿®å¤ -\u003e é‡æ–°ç¼–è¯‘ï¼Œæ‰€ä»¥æˆ‘ä»¬å€¾å‘äºç›´æ¥ä»æºç ç¼–è¯‘ï¼Œæ ¹æ® neofetch wiki ä» git æ‹‰å–æœ€æ–°æ•°æ®è¿›è¡Œæ„å»º: # enter into euler openEuler RISC-V QEMU $ git clone https://github.com/dylanaraps/neofetch $ cd neofetch $ make install $ neofetch ","date":"2024-03-28","objectID":"/posts/oerv-pretask/:1:0","tags":["RISC-V","openEuler","QEMU","Neofetch","Container","chroot","nspawn"],"title":"OERV ä¹‹ Pretask","uri":"/posts/oerv-pretask/"},{"categories":["RISC-V"],"content":"Pretask 2: Open Build Service (OBS) ä»»åŠ¡äºŒï¼šåœ¨ openEuler RISC-V ç³»ç»Ÿä¸Šé€šè¿‡ obs å‘½ä»¤è¡Œå·¥å…· oscï¼Œä»æºä»£ç æ„å»º RISC-V ç‰ˆæœ¬çš„ rpm åŒ…ï¼Œæ¯”å¦‚ pcre2ã€‚æç¤ºé¦–å…ˆéœ€è¦åœ¨ openEuler çš„ OBS ä¸Šæ³¨å†Œè´¦å· è§‚çœ‹æ•™å­¦å½±ç‰‡: openEuleræ„å»ºä¹‹OBSä½¿ç”¨æŒ‡å¯¼ - bilibili å¹¶å¯¹æ¯”é˜…è¯» BeginnerÊ¼s Guide openSUSE:Build Service æ–°æ‰‹å…¥é—¨ å¦‚ä½•é€šè¿‡OpenSUSE Open Build Serviceï¼ˆOBSï¼‰æ„å»ºDebianåŒ… for RISCV-64 äº†è§£æŒæ¡ OBS çš„åŸºæœ¬æ¦‚å¿µã€OBS ç½‘é¡µ ä»¥åŠ OSC å‘½ä»¤è¡Œå·¥å…· çš„ä½¿ç”¨æ–¹æ³•ã€‚ è¿™éƒ¨åˆ†å†…å®¹å¾ˆé‡è¦ï¼Œå’Œåç»­å·¥ä½œå†…å®¹æ¯æ¯ç›¸å…³ï¼Œåœ¨è¿™é‡Œä¸è¦å›¾å¿«ï¼Œæ‰“ç‰¢åŸºç¡€æ¯”è¾ƒå¥½ã€‚ OBS çš„ Package ä¸­ _service é…ç½®æ–‡ä»¶ï¼Œrevision å­—æ®µæ˜¯å¯¹åº”ä¸ Git ä»“åº“çš„ commit id (å¦‚æœä½ ä½¿ç”¨çš„ Source Code Management (SCM) æ–¹å¼æ˜¯ Git æ‰˜ç®¡çš„è¯) å‚è€ƒä»“åº“: https://gitee.com/zxs-un/doc-port2riscv64-openEuler å†…çš„ç›¸å…³æ–‡æ¡£ oscå‘½ä»¤å·¥å…·çš„å®‰è£…ä¸~/.oscrcé…ç½®æ–‡ä»¶ åœ¨ openEuler ä¸Šå®‰è£… osc build æœ¬åœ°æ„å»ºå·¥å…· ä½¿ç”¨ osc build åœ¨æœ¬åœ°æ„å»º openEuler OBS æœåŠ¡ç«¯çš„å†…å®¹ åœ¨ openEuler RISC-V QEMU è™šæ‹Ÿæœºå†…å®Œæˆ OBSã€OSC ç›¸å…³åŸºç¡€è®¾æ–½çš„å®‰è£…: # install osc and build $ sudo yum install osc build # configure osc in ~/.oscrc [general] apiurl = https://build.openeuler.openatom.cn no_verify = 1 # æœªé…ç½®è¯ä¹¦æƒ…å†µä¸‹ä¸éªŒè¯ [https://build.openeuler.openatom.cn] user=username # ç”¨æˆ·å pass=password # æ˜æ–‡å¯†ç  trusted_prj=openEuler:selfbuild:function # æ­¤é¡¹ç›®ä¸ºopenEuler:Mailine:RISC-Vé¡¹ç›®çš„ä¾èµ–åº“ åœ¨ openEuler RISC-V QEMU è™šæ‹Ÿæœºå†…å®Œæˆ pcre2 çš„æœ¬åœ°ç¼–è¯‘æ„å»º: # é€‰å®š pcre2 åŒ… $ osc co openEuler:Mainline:RISC-V/pcre2 $ cd openEuler\\:Mainline\\:RISC-V/pcre2/ # æ›´æ–°å¹¶ä¸‹è½½ç›¸å…³æ–‡ä»¶åˆ°æœ¬åœ° $ osc up -S # é‡å‘½ååˆšåˆšä¸‹è½½çš„æ–‡ä»¶ $ rm -f _service;for file in `ls | grep -v .osc`;do new_file=${file##*:};mv $file $new_file;done # æŸ¥çœ‹ä¸€ä¸‹ä»“åº“ä¿¡æ¯ï¼Œæ–¹ä¾¿åç»­æ„å»º $ osc repos standard_riscv64 riscv64 mainline_gcc riscv64 # æŒ‡å®šä»“åº“å’Œæ¶æ„å¹¶è¿›è¡Œæœ¬åœ°æ„å»º $ osc build standard_riscv64 riscv64 æ€»è®¡ç”¨æ—¶ 1301s ","date":"2024-03-28","objectID":"/posts/oerv-pretask/:2:0","tags":["RISC-V","openEuler","QEMU","Neofetch","Container","chroot","nspawn"],"title":"OERV ä¹‹ Pretask","uri":"/posts/oerv-pretask/"},{"categories":["RISC-V"],"content":"Pretask 3: å®¹å™¨åŠ é€Ÿæ„å»º ä»»åŠ¡ä¸‰ï¼šå°è¯•ä½¿ç”¨ qemu user \u0026 nspawn æˆ–è€… docker åŠ é€Ÿå®Œæˆä»»åŠ¡äºŒ å‚è€ƒ æ–‡æ¡£ ç”±äº deepin 20.9 çš„ Python3 ç‰ˆæœ¬ä»…ä¸º 3.7ï¼Œæ„å»º osc å’Œ qemu æ˜¾ç„¶ä¸å¤ªå¤Ÿï¼Œæ‰€ä»¥æˆ‘é€šè¿‡ KVM æ„å»ºäº†ä¸€ä¸ª openEuler 22.03 LTS SP3 çš„è™šæ‹Ÿæœºï¼Œåœ¨ä¸Šé¢è¿›è¡Œè¿™é¡¹ä»»åŠ¡ã€‚ Deepin 20.9 KVM å®‰è£…å’Œç®¡ç† openEuler 22.03 LTS SP3 ç¼–è¯‘ QEMU æ—¶å¸¸è§é”™è¯¯ä¿®æ­£: ERROR: Python package 'sphinx' was not found nor installed. $ sudo yum install python3-sphinx ERROR: cannot find ninja $ sudo yum install ninja-build openEuler 22.03 LTS SP3 æ²¡æœ‰é¢„å…ˆå®‰è£…å¥½ nspawnï¼Œæ‰€ä»¥éœ€è¦æ‰‹åŠ¨å®‰è£…: $ sudo yum install systemd-container systemd-nspawn å…¶ä½™åŒä»»åŠ¡äºŒã€‚ å°è¯•ä½¿ç”¨ nspawn æ¥æ„å»º pcre2: $ osc build standard_riscv64 riscv64 --vm-type=nspawn ä¼šé‡åˆ°ä»¥ä¸‹æŠ¥é”™ (ä¸”ç»è¿‡ç›¸å½“å¤šæ—¶é—´æ’é”™ï¼Œä»æ— æ³•è§£å†³è¯¥é—®é¢˜ï¼Œä¸ªäººçŒœæµ‹æ˜¯å¹³å°é—®é¢˜): can't locate file/copy.pm: /usr/lib64/perl5/vendor_perl/file/copy.pm: permission denied at /usr/bin/autoreconf line 49. æ‰€ä»¥é€€è€Œæ±‚å…¶æ¬¡ï¼Œä½¿ç”¨ chroot æ¥æ„å»º: $ osc build standard_riscv64 riscv64 --vm-type=chroot æ€»è®¡ç”¨æ—¶ 749sï¼Œæ¯” qemu-system-riscv64 å¿«äº†å°†è¿‘ 2 å€ï¼Œæ•ˆèƒ½æå‡ç›¸å½“å¯è§‚ã€‚ ","date":"2024-03-28","objectID":"/posts/oerv-pretask/:3:0","tags":["RISC-V","openEuler","QEMU","Neofetch","Container","chroot","nspawn"],"title":"OERV ä¹‹ Pretask","uri":"/posts/oerv-pretask/"},{"categories":["RISC-V"],"content":"References https://gitee.com/zxs-un/doc-port2riscv64-openEuler/blob/master/doc/build-osc-config-oscrc.md https://gitee.com/zxs-un/doc-port2riscv64-openEuler/blob/master/doc/build-osc-build-tools.md https://gitee.com/zxs-un/doc-port2riscv64-openEuler/blob/master/doc/build-osc-obs-service.md https://gitee.com/openeuler/RISC-V/blob/master/doc/tutorials/qemu-user-mode.md https://stackoverflow.com/questions/5308816/how-can-i-merge-multiple-commits-onto-another-branch-as-a-single-squashed-commit ","date":"2024-03-28","objectID":"/posts/oerv-pretask/:4:0","tags":["RISC-V","openEuler","QEMU","Neofetch","Container","chroot","nspawn"],"title":"OERV ä¹‹ Pretask","uri":"/posts/oerv-pretask/"},{"categories":["Toolkit"],"content":"æœ¬ç¯‡ä¸»è¦ä»‹ç»åœ¨ deepin20.9 æ“ä½œç³»ç»Ÿå¹³å°ä¸‹ï¼Œä½¿ç”¨ KVM è™šæ‹ŸåŒ–æŠ€æœ¯æ¥åˆ›å»ºå’Œå®‰è£… Linux å‘è¡Œç‰ˆï¼Œå¹¶ä»¥åˆ›å»ºå®‰è£… openEuler 22.03 LTS SP3 çš„ KVM è™šæ‹Ÿæœºä½œä¸ºç¤ºèŒƒï¼Œè®©å­¦å‘˜é¢†ç•¥ KVM è™šæ‹ŸåŒ–æŠ€æœ¯çš„å¼ºå¤§é­…åŠ›ã€‚ ","date":"2024-03-28","objectID":"/posts/deepin-kvm/:0:0","tags":["Linux","Deepin","KVM","QEMU","openEuler"],"title":"Deepin 20.9 KVM å®‰è£…å’Œç®¡ç†","uri":"/posts/deepin-kvm/"},{"categories":["Toolkit"],"content":"ä»€ä¹ˆæ˜¯è™šæ‹ŸåŒ–? ä»€ä¹ˆæ˜¯è™šæ‹ŸåŒ–æŠ€æœ¯ï¼ŸKVM è™šæ‹ŸåŒ–å’Œ Virtual Boxã€VMware è¿™ç±»è™šæ‹Ÿæœºè½¯ä»¶çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿè¯·é˜…è¯»ä¸‹é¢çš„è¿™ç¯‡æ–‡ç« ã€‚ KVM ä¸ VMware çš„åŒºåˆ«ç›˜ç‚¹ ","date":"2024-03-28","objectID":"/posts/deepin-kvm/:1:0","tags":["Linux","Deepin","KVM","QEMU","openEuler"],"title":"Deepin 20.9 KVM å®‰è£…å’Œç®¡ç†","uri":"/posts/deepin-kvm/"},{"categories":["Toolkit"],"content":"é…ç½®è™šæ‹ŸåŒ–ç¯å¢ƒ é¦–å…ˆéœ€è¦æ£€æŸ¥ CPU æ˜¯å¦æ”¯æŒè™šæ‹ŸåŒ– (ä»¥ Intel å¤„ç†å™¨ä¸ºä¾‹): # intel vmxï¼Œamd svm $ egrep '(vmx|svm)' /proc/cpuinfo ...vmx... $ lscpu | grep Virtualization Virtualization: VT-x æ£€æŸ¥ KVM æ¨¡å—æ˜¯å¦å·²åŠ è½½: $ lsmod | grep -i kvm kvm_intel 278528 11 kvm 901120 1 kvm_intel ç¡®ä¿ CPU æ”¯æŒè™šæ‹ŸåŒ–å¹¶ä¸” KVM æ¨¡å—å·²è¢«åŠ è½½ï¼Œæ¥ä¸‹æ¥æ˜¯å®‰è£… QEMU å’Œ virt-manager (è™šæ‹Ÿç³»ç»Ÿç®¡ç†å™¨)ã€‚ç›´æ¥é€šè¿‡ apt å®‰è£…çš„ QEMU ç‰ˆæœ¬è¿‡ä½ï¼Œè€Œé€šè¿‡ GitHub ä¸‹è½½æœ€æ–°çš„ QEMU æºç ç¼–è¯‘å®‰è£…éœ€è¦Python3.9ï¼Œè€Œ deepin 20.9 çš„ Python 3 ç‰ˆæœ¬æ˜¯ 3.7 (ä¿é™©èµ·è§ä¸è¦éšä¾¿å‡çº§)ï¼Œæ‰€ä»¥æŠ˜ä¸­ä¸€ä¸‹ï¼Œç¼–è¯‘å®‰è£… QEMU 7.2.0 ğŸ¤£ å®‰è£… QEMU: $ wget https://download.qemu.org/qemu-7.2.0.tar.xz $ tar xvJf qemu-7.2.0.tar.xz $ mv qemu-7.2.0 qemu $./configure $ sudo make -j$(nproc) # in ~/.bashrc export PATH=$PATH:/path/to/qemu/build å®‰è£… virt-manager: $ sudo apt install virt-manager ","date":"2024-03-28","objectID":"/posts/deepin-kvm/:2:0","tags":["Linux","Deepin","KVM","QEMU","openEuler"],"title":"Deepin 20.9 KVM å®‰è£…å’Œç®¡ç†","uri":"/posts/deepin-kvm/"},{"categories":["Toolkit"],"content":"å®‰è£… openEuler KVM è™šæ‹Ÿæœº å¯ä»¥åœ¨å¯åŠ¨å™¨çœ‹åˆ°ä¸€ä¸ªè™šæ‹Ÿæœºç®¡ç†åº”ç”¨å›¾æ ‡ï¼Œå¦‚ä¸‹: ç‚¹å‡»æ‰“å¼€ (éœ€è¦è¾“å…¥å¯†ç è®¤è¯ï¼Œä»¥ä¸‹å›¾ç‰‡ä¸­çš„ â€œæœ¬åœ°â€ å¯èƒ½ä¼šæ˜¾ç¤ºä¸º â€œQEMU/KVMâ€): æ¥ä¸‹æ¥åˆ›å»ºè™šæ‹Ÿæœº: ä¸‹å›¾çš„æ“ä½œç³»ç»Ÿé€‰æ‹©å¯¹åº”çš„ç±»å‹ (å¯ä»¥åœ¨ è¿™é‡Œ ä¸‹è½½ openEuler 22.03 LTS SP3 é•œåƒï¼Œå¯¹äº openEuler è¿™ç±»æœªè¢«æ”¶å½•çš„ç±»å‹ï¼Œé€‰æ‹© Generic): è¿™é‡Œé€‰æ‹© iso é•œåƒåå¯èƒ½ä¼šæ˜¾ç¤ºè·¯å¾„æœç´¢é—®é¢˜ï¼Œé€‰æ‹© â€œæ˜¯â€ å°†è¯¥è·¯å¾„åŠ å…¥å­˜å‚¨æ± å³å¯ æ¥ä¸‹æ¥æ˜¯å¤„ç†å™¨å’Œå†…å­˜é…ç½®ï¼Œå»ºè®®é…ç½® 8 æ ¸ 8G å†…å­˜ï¼Œæ ¹æ®è‡ªå·±ç‰©ç†æœºé…ç½®é€‰æ‹©å³å¯: æ¥ä¸‹æ¥æ˜¯è™šæ‹Ÿç£ç›˜çš„å¤§å°è®¾ç½®å’Œå­˜æ”¾ä½ç½®ï¼Œå»ºè®®é€‰æ‹©è‡ªå®šä¹‰å­˜å‚¨è·¯å¾„ï¼Œå¹¶æ­é… æ›´æ”¹ KVM è™šæ‹Ÿæœºé»˜è®¤å­˜å‚¨è·¯å¾„ï¼Œç‰¹åˆ«æ˜¯å¦‚æœä½ çš„æ ¹ç›®å½•ç©ºé—´ä¸å¤ªå¤Ÿçš„æƒ…å†µï¼š åœ¨å¯¹åº”çš„å­˜å‚¨å·ä¸­åˆ›å»ºè™šæ‹Ÿç£ç›˜ (æ³¨æ„: å¦‚æœä½ æ›´æ”¹äº†é»˜è®¤å­˜å‚¨è·¯å¾„ï¼Œè¯·é€‰æ‹©å¯¹åº”çš„å­˜å‚¨æ± è€Œä¸æ˜¯ default): åˆ›å»ºè™šæ‹Ÿç£ç›˜ (åç§°å¯ä»¥è‡ªå®šä¹‰ï¼Œåˆ†é…é»˜è®¤åˆå§‹ä¸º 0ï¼Œå®ƒä¼šéšç€è™šæ‹Ÿæœºä½¿ç”¨è€Œå¢å¤§ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ç›´æ¥å°†åˆ†é…ç­‰äºæœ€å¤§å®¹é‡ï¼Œè¿™æ ·å°±ä¼šç›´æ¥åˆ†é…ç›¸åº”çš„ç£ç›˜ç©ºé—´ï¼Œç©è¿‡è™šæ‹Ÿæœºçš„å­¦å‘˜åº”è¯¥å¾ˆç†Ÿæ‚‰): æ¥ä¸‹æ¥è‡ªå®šä¹‰è™šæ‹Ÿæœºåç§°å¹¶ç”Ÿæˆè™šæ‹Ÿæœºå³å¯: æœ€åå°±æ˜¯ç†Ÿæ‚‰çš„å®‰è£…ç•Œé¢: å‚è€ƒ è¿™é‡Œ å®‰è£… openEuler å³å¯ã€‚ ","date":"2024-03-28","objectID":"/posts/deepin-kvm/:3:0","tags":["Linux","Deepin","KVM","QEMU","openEuler"],"title":"Deepin 20.9 KVM å®‰è£…å’Œç®¡ç†","uri":"/posts/deepin-kvm/"},{"categories":["Toolkit"],"content":"é€è¿‡ SSH è¿æ¥ KVM è™šæ‹Ÿæœº é¦–å…ˆå…ˆæ£€æŸ¥ Guest OS ä¸Š ssh æœåŠ¡æ˜¯å¦å¼€å¯ (ä¸€èˆ¬æ˜¯å¼€å¯çš„): $ sudo systemctl status sshd sshd.service - OpenSSH server daemon Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled) Active: active (running) since Thu 2024-03-28 14:40:15 CST; 20min ago ... ç„¶ååœ¨ Guest OS ä¸Šè·å–å…¶ IP åœ°å€ (ens3 çš„ inet åçš„æ•°å­—å³æ˜¯ï¼ŒopenEuler å¯åŠ¨æ—¶ä¹Ÿä¼šè¾“å‡ºä¸€ä¸‹ IP åœ°å€): $ ip addr åœ¨ Host OS ä¸Šé€šè¿‡ ssh è¿æ¥ç™»å½• GuestOS: $ ssh user@ip # user: user name in the guest os # ip ip addr of guest os ","date":"2024-03-28","objectID":"/posts/deepin-kvm/:4:0","tags":["Linux","Deepin","KVM","QEMU","openEuler"],"title":"Deepin 20.9 KVM å®‰è£…å’Œç®¡ç†","uri":"/posts/deepin-kvm/"},{"categories":["Toolkit"],"content":"Development Tools ç”±äºæ˜¯æœ€å°å®‰è£…ï¼Œå¾ˆå¤šè¶æ‰‹çš„å·¥å…·éƒ½æ²¡æœ‰ï¼Œä¿—è¯è¯´â€œå·¥æ¬²å–„å…¶äº‹ï¼Œå¿…å…ˆåˆ©å…¶å™¨â€ï¼Œæ‰€ä»¥å…ˆå®‰è£…å¿…è¦çš„å¼€å‘å·¥å…·ã€‚å¹¸å¥½ openEuler æä¾›äº†æ•´åˆåŒ… Development Toolsï¼Œç›´æ¥å®‰è£…å³å¯: $ sudo yum group install -y \"Development Tools\" ","date":"2024-03-28","objectID":"/posts/deepin-kvm/:5:0","tags":["Linux","Deepin","KVM","QEMU","openEuler"],"title":"Deepin 20.9 KVM å®‰è£…å’Œç®¡ç†","uri":"/posts/deepin-kvm/"},{"categories":["Toolkit"],"content":"Neofetch å®‰è£… neofetch æ¥é…·ç‚«åœ°è¾“å‡ºä¸€ä¸‹ç³»ç»Ÿä¿¡æ¯: $ git clone https://github.com/dylanaraps/neofetch $ cd neofetch $ make install $ neofetch ","date":"2024-03-28","objectID":"/posts/deepin-kvm/:6:0","tags":["Linux","Deepin","KVM","QEMU","openEuler"],"title":"Deepin 20.9 KVM å®‰è£…å’Œç®¡ç†","uri":"/posts/deepin-kvm/"},{"categories":["Toolkit"],"content":"References ä½¿ç”¨ KVM å®‰è£…å’Œç®¡ç† deepin Linux ä¸‹ä½¿ç”¨ KVM è™šæ‹Ÿæœºå®‰è£… OpenEuler ç³»ç»Ÿ KVM æ›´æ”¹è™šæ‹Ÿæœºé»˜è®¤å­˜å‚¨è·¯å¾„ å®è·µ KVM on Deepin ","date":"2024-03-28","objectID":"/posts/deepin-kvm/:7:0","tags":["Linux","Deepin","KVM","QEMU","openEuler"],"title":"Deepin 20.9 KVM å®‰è£…å’Œç®¡ç†","uri":"/posts/deepin-kvm/"},{"categories":["C","Linux Kernel Internals"],"content":" C è¯­è¨€ä¹‹æ‰€ä»¥ä¸éœ€è¦æ—¶å¸¸å‘å¸ƒæ–°çš„è¯­è¨€ç‰¹æ€§åˆå¯ä»¥ä¿æŒæ´»åŠ›ï¼Œå‰ç½®å¤„ç†å™¨ (preprocessor) æ˜¯å¾ˆé‡è¦çš„å› ç´ ï¼Œæœ‰å¿ƒè€…å¯è¿›è¡Œã€Œæ‰©å……ã€C è¯­è¨€ã€‚ åŸæ–‡åœ°å€ ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:0:0","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"ä¸è¦å°çœ‹ preprocessor man gcc -D name Predefine name as a macro, with definition 1. -D name=definition The contents of definition are tokenized and processed as if they appeared during translation phase three in a #define directive. In particular, the definition is truncated by embedded newline characters. åœ¨ Makefile ä¸­å¾€ CFLAGS åŠ å…¥ -Dâ€™;â€™=â€™Í¾â€™ è¿™ç±»ææ€ªä¿¡æ¯ï¼Œä¼šå¯¼è‡´ç¼–è¯‘æ—¶å‡ºç°ä¸€äº›ä¸æ˜æ‰€ä»¥çš„ç¼–è¯‘é”™è¯¯ (æ¶æä¸“ç”¨ ğŸ¤£) æ—©æœŸçš„ C++ æ˜¯å’Œ C è¯­è¨€å…¼å®¹çš„ï¼Œé‚£æ—¶å€™çš„ C++ ç›¸å½“äº C è¯­è¨€çš„ä¸€ç§ preprocessorï¼Œå°† C++ ä»£ç é¢„ç¼–è¯‘ä¸ºå¯¹åº”çš„ C è¯­è¨€ä»£ç ï¼Œå…·ä½“å¯ä»¥å‚è€ƒ C with Classesã€‚äº‹å®ä¸Šç°åœ¨çš„ C++ å’Œ C è¯­è¨€æ—©å·²åˆ†é“æ‰¬é•³ï¼Œå½¢åŒé™Œè·¯ï¼Œè™½ç„¶è¯­æ³•ä¸Šæœ‰ç›¸ä¼¼çš„åœ°æ–¹ï¼Œä½†è¯·æŠŠè¿™ä¸¤ä¸ªè¯­è¨€å½“æˆä¸åŒçš„è¯­è¨€çœ‹å¾… ğŸ¤£ ä½“éªŒä¸€ä¸‹ C++ æ¨¡ç‰ˆ (template) çš„å¨åŠ› âŒ ä¸‘é™‹ âœ”ï¸ : C è¯­è¨€: å¤§é“è‡³ç®€ âœ… ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:1:0","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"Object Oriented Programming é¢å‘å¯¹è±¡ç¼–ç¨‹æ—¶ï¼Œå–„ç”¨å‰ç½®å¤„ç†å™¨å¯å¤§å¹…ç®€åŒ–å’Œå¼€å‘ #: Stringizing convert a macro argument into a string constant ##: Concatenation merge two tokens into one while expanding macros. å®çš„å®é™…ä½œç”¨: generate (äº§ç”Ÿ/ç”Ÿæˆ) ç¨‹å¼ç  Rust çš„è¿‡ç¨‹å® (procedural macros) è¿›ä¸€æ­¥å¼ºåŒ–äº†è¿™ä¸€ç›®çš„ï¼Œå¯ä»¥è‡ªå®šä¹‰è¯­æ³•æ ‘è¿›è¡Œä»£ç ç”Ÿæˆã€‚ å¯ä»¥ gcc -E -P æ¥è§‚å¯Ÿé¢„å¤„ç†åçš„è¾“å‡º: man gcc -E Stop after the preprocessing stage; do not run the compiler proper. The output is in the form of preprocessed source code, which is sent to the standard output. Input files that don't require preprocessing are ignored. -P Inhibit generation of linemarkers in the output from the preprocessor. This might be useful when running the preprocessor on something that is not C code, and will be sent to a program which might be confused by the linemarkers. å¯ä»¥ä¾æ®ä¸åŒæ—¶æœŸçš„æ ‡å‡†æ¥å¯¹ C æºç¨‹åºç¼–è¯‘ç”Ÿæˆç›®æ ‡æ–‡ä»¶: Feature Test Macros The exact set of features available when you compile a source file is controlled by which feature test macros you define. ä½¿ç”¨ gcc -E -P è§‚å¯Ÿ objects.h é¢„å¤„ç†åçš„è¾“å‡ºï¼Œé€è¿‡ make å’Œ make check ç©ä¸€ä¸‹è¿™ä¸ªæœ€ç®€å•å…‰çº¿è¿½è¸ªå¼•æ“ GitHub: raytracing object oriented programming ä¸ç­‰äº class based programming, åªéœ€è¦æ»¡è¶³ Object-oriented programming (OOP) is a computer programming model that organizes software design around data, or objects, rather than functions and logic. è¿™ä¸ªæ¦‚å¿µçš„å°±æ˜¯ OOPã€‚ Source ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:2:0","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"C11: _Generic é˜…è¯» C11 è§„æ ¼ä¹¦ 6.5.1.1 Generic selection The controlling expression of a generic selection is not evaluated. If a generic selection has a generic association with a type name that is compatible with the type of the controlling expression, then the result expression of the generic selection is the expression in that generic association. Otherwise, the result expression of the generic selection is the expression in the default generic association. None of the expressions from any other generic association of the generic selection is evaluated. #define cbrt(X) \\ _Generic((X), \\ long double: cbrtl, \\ default: cbrt, \\ const float: cbrtf, \\ float: cbrtf \\ )(X) ç»è¿‡ func.c/func.cpp çš„è¾“å‡ºå¯¹æ¯”ï¼ŒC++ æ¨¡ç‰ˆåœ¨å­—ç¬¦ç±»å‹çš„çš„åˆ¤å®šæ¯”è¾ƒå‡†ç¡®ï¼ŒC11 çš„ _Generic ä¼šå…ˆå°† char è½¬æ¢æˆ int å¯¼è‡´ç»“æœç¨æœ‰ç‘•ç–µï¼Œè¿™æ˜¯å› ä¸ºåœ¨ C è¯­è¨€ä¸­å­—ç¬¦å¸¸é‡ (ä¾‹å¦‚ â€˜aâ€™) çš„ç±»å‹æ˜¯ int è€Œä¸æ˜¯ charã€‚ Stack Overflow: What to do to make â€˜_Generic(â€˜aâ€™, char : 1, int : 2) == 1â€™ true ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:3:0","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"Block Wikipedia: Blocks (C language extension) Blocks are a non-standard extension added by Apple Inc. to Clangâ€™s implementations of the C, C++, and Objective-C programming languages that uses a lambda expression-like syntax to create closures within these languages. Like function definitions, blocks can take arguments, and declare their own variables internally. Unlike ordinary C function definitions, their value can capture state from their surrounding context. A block definition produces an opaque value which contains both a reference to the code within the block and a snapshot of the current state of local stack variables at the time of its definition. The block may be later invoked in the same manner as a function pointer. The block may be assigned to variables, passed to functions, and otherwise treated like a normal function pointer, although the application programmer (or the API) must mark the block with a special operator (Block_copy) if itâ€™s to be used outside the scope in which it was defined. ä½¿ç”¨ BLock å¯ä»¥å‡å°‘å®å±•å¼€æ—¶çš„é‡å¤è®¡ç®—æ¬¡æ•°ã€‚ç›®å‰ clang æ˜¯æ”¯æŒ Block è¿™ä¸ªæ‰©å±•çš„ï¼Œä½†æ˜¯åœ¨ç¼–è¯‘æ—¶éœ€è¦åŠ ä¸Šå‚æ•° -fblocks: $ clang -fblocks blocks-test.c -lBlocksRuntime åŒæ—¶è¿˜éœ€è¦ BlocksRuntime è¿™ä¸ªåº“ï¼ŒæŒ‰ç…§ä»“åº“ README å®‰è£…å³å¯: # clone repo $ git clone https://github.com/mackyle/blocksruntime.git $ cd blocksruntime/ # building $ ./buildlib # testing $ ./checktests # installing $ sudo ./installlib é™¤äº† Block ä¹‹å¤–ï¼Œå¸¸è§çš„é¿å… double evaluation çš„æ–¹æ³•è¿˜æœ‰åˆ©ç”¨ typeof æå‰è®¡ç®—: #define DOUBLE(a) ((a) + (a)) #define DOUBLE(a) ({ \\ __typeof__(a) _x_in_DOUBLE = (a); \\ _x_in_DOUBLE + _x_in_DOUBLE; \\ }) ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:4:0","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"ARRAY_SIZE å® // get the number of elements in array #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0])) è¿™æ ·å®ä½œçš„ ARRAY_SIZE å®æœ‰å¾ˆå¤§çš„éšæ‚£ï¼Œä¾‹å¦‚å®ƒæ— æ³•å¯¹ä¼ å…¥çš„ arr è¿›è¡Œç±»å‹æ£€æŸ¥ï¼Œå¦‚æœç¢°ä¸Šä¸åˆæ ¼çš„ C ç¨‹åºå‘˜ï¼Œåœ¨æ•°ç»„éšå¼è½¬æ¢æˆæŒ‡é’ˆåä½¿ç”¨ ARRAY_SIZE å®ä¼šå¾—åˆ°éé¢„æœŸçš„ç»“æœï¼Œæˆ‘ä»¬éœ€è¦åœ¨ç¼–è¯‘å™¨å°±æé†’ç¨‹åºå‘˜ä¸è¦é”™ç”¨è¿™ä¸ªå®ã€‚ æ³¨æ„ é˜…è¯»ä»¥ä¸‹åšå®¢ä»¥ç†è§£ Linux æ ¸å¿ƒçš„ ARRAY_SIZE åŸç†æœºåˆ¶å’Œå®ä½œæ‰‹æ³•: Linux Kernel: ARRAY_SIZE() Linux æ ¸å¿ƒçš„ ARRAY_SIZE å®åœ¨ä¸Šé¢é‚£ä¸ªç®€é™‹ç‰ˆçš„å®çš„åŸºç¡€ä¸Šï¼ŒåŠ ä¸Šäº†ç±»å‹æ£€æŸ¥ï¼Œä¿è¯ä¼ å…¥çš„æ˜¯æ•°ç»„è€Œä¸æ˜¯æŒ‡é’ˆï¼š #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr)) /* \u0026a[0] degrades to a pointer: a different type from an array */ #define __must_be_array(a) BUILD_BUG_ON_ZERO(__same_type((a), \u0026(a)[0])) /* Are two types/vars the same type (ignoring qualifiers)? */ #ifndef __same_type # define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b)) #endif 6.54 Other built-in functions provided by GCC You can use the built-in function __builtin_types_compatible_p to determine whether two types are the same. This built-in function returns 1 if the unqualified versions of the types type1 and type2 (which are types, not expressions) are compatible, 0 otherwise. The result of this built-in function can be used in integer constant expressions. 6.6 Referring to a Type with typeof Another way to refer to the type of an expression is with typeof. The syntax of using of this keyword looks like sizeof, but the construct acts semantically like a type name defined with typedef. æ‰€ä»¥ Linux æ ¸å¿ƒçš„ ARRAY_SIZE å®é¢å¤–åŠ ä¸Šäº† __must_be_array å®ï¼Œä½†æ˜¯è¿™ä¸ªå®åœ¨ç¼–è¯‘æˆåŠŸæ—¶ä¼šè¿”å› 0ï¼Œç¼–è¯‘å¤±è´¥è‡ªç„¶å°±ä¸éœ€è¦è€ƒè™‘è¿”å›å€¼äº† ğŸ¤£ æ‰€ä»¥å®ƒèµ·åˆ°çš„ä½œç”¨æ˜¯ä¹‹å‰æåˆ°çš„ç±»å‹æ£€æŸ¥ï¼Œé€è¿‡ BUILD_BUG_ON_ZERO å®å’Œ __same_type å®ã€‚ ä» Linux æ ¸å¿ƒ ã€Œæç‚¼ã€ å‡ºçš„ array_size _countof Macro ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:5:0","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"do { â€¦ } while (0) å® ç”¨äºé¿å… dangling elseï¼Œå³ if å’Œ else æœªç¬¦åˆé¢„æœŸçš„é…å¯¹ (å¸¸è§äºæœªä½¿ç”¨ {} åŒ…è£¹) è€ƒè™‘ä»¥ä¸‹æƒ…å½¢: #define handler(cond) if (cond) foo() if (\u003ccondition1\u003e) handler(\u003cconditional2\u003e) else bar() è¿™ä¸ªå†™æ³•ä¹ä¸€çœ‹æ²¡ä»€ä¹ˆé—®é¢˜ï¼Œä½†æ˜¯æˆ‘ä»¬æŠŠå®ƒå±•å¼€æ¥çœ‹ä¸€ä¸‹: if (\u003ccondition1\u003e) if (\u003cconditional2\u003e) foo() else bar() æ˜¾ç„¶æ­¤æ—¶ç”±äºæœªä½¿ç”¨ {} åŒºå—è¿›è¡ŒåŒ…è£¹ï¼Œå¯¼è‡´ else éƒ¨åˆ†ä¸ handler å®çš„ if é€»è¾‘è¿›è¡Œé…å¯¹äº†ã€‚do {...} while (0) å®çš„ä½œç”¨å°±æ˜¯æä¾›ç±»ä¼¼äº {} åŒºå—çš„éš”ç¦»æ€§ (å› ä¸ºå®ƒçš„å¾ªç¯ä½“åªèƒ½æ‰§è¡Œä¸€é ğŸ¤£) æ³¨æ„ ä¸‹é¢çš„è®¨è®ºæ˜¯å…³äºä¸ºä»€ä¹ˆè¦ä½¿ç”¨ do {...} while(0) è€Œä¸æ˜¯ {}ï¼Œéå¸¸å€¼å¾—ä¸€è¯»: Stack Overflow: C multi-line macro: do/while(0) vs scope block The more elegant solution is to make sure that macro expand into a regular statement, not into a compound one. ä¸»è¦æ˜¯è€ƒè™‘åˆ°å¯¹åŒ…å« {} çš„å®ï¼Œåƒä¸€èˆ¬çš„ statement ä¸€æ ·åŠ ä¸Š ; ä¼šå¯¼è‡´ä¹‹å‰çš„ if è¯­å¥ç»“æŸï¼Œä»è€Œå¯¼è‡´åé¢çš„ else è¯­å¥æ— æ³•é…å¯¹è¿›è€Œç¼–è¯‘å¤±è´¥ï¼Œè€Œä½¿ç”¨ do {...} while (0) åé¢åŠ ä¸Š ; å¹¶ä¸ä¼šå¯¼è‡´è¿™ä¸ªé—®é¢˜ã€‚ ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:6:0","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"åº”ç”¨: String switch in C è¿™ç¯‡åšæ–‡å±•ç¤ºäº†å¦‚ä½•åœ¨ C è¯­è¨€ä¸­å¯¹ string ä½¿ç”¨ switch case: String switch in C #define STRING_SWITCH_L(s) switch (*((int32_t *)(s)) | 0x20202020) #define MULTICHAR_CONSTANT(a,b,c,d) ((int32_t)((a) | (b) \u003c\u003c 8 | (c) \u003c\u003c 16 | (d) \u003c\u003c 24)) Note that STRING_SWITCH_L performs a bitwise OR with the 32-bit integral value â€“ this is a fast means of lowering the case of four characters at once. è¿™é‡Œæœ‰ä¸€ä¸ª | 0x20202020 çš„ä½è¿ç®—æ“ä½œï¼Œè¿™ä¸ªè¿ç®—çš„ä½œç”¨æ˜¯å°†å¯¹åº”çš„å­—ç¬¦è½¬æ¢æˆå¯¹åº”å°å†™å­—ç¬¦ï¼Œå…·ä½“å¯ä»¥å‚è€ƒæœ¬äººäºæ•°å€¼ç³»ç»Ÿç¯‡çš„ è®°å½• (æç¤º: å­—ç¬¦ ' ' å¯¹åº”çš„ ASCII ç¼–ç ä¸º 0x20)ã€‚ ç„¶å MULTICHAR_CONSTANT åˆ™æ˜¯å°†å‚æ•°æŒ‰å°ç«¯å­—èŠ‚åºè®¡ç®—å‡ºå¯¹åº”çš„æ•°å€¼ã€‚ è¿™ç¯‡åšæ–‡è¯´æ˜äº†åœ¨ C è¯­è¨€ä¸­å¯¹ string ä½¿ç”¨ switch case æå‡æ•ˆèƒ½çš„åŸç† (é™¤æ­¤ä¹‹å¤–è¿˜è®²è§£äº†å†…å­˜å¯¹é½ç›¸å…³çš„æ•ˆèƒ½é—®é¢˜): More on string switch in C ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:7:0","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"åº”ç”¨: Linked List çš„å„å¼å˜ç§ å®å’Œå‡½æ•°è°ƒç”¨çš„æ•ˆèƒ½å¯¹æ¯”: Simple code for checking the speed difference between function call and macro åœ¨é€²è¡Œå‡½å¼å‘¼å«æ™‚ï¼Œæˆ‘å€‘é™¤äº†éœ€è¦æŠŠåƒæ•¸æ¨å…¥ç‰¹å®šçš„æš«å­˜å™¨æˆ–æ˜¯å †ç–Šï¼Œé‚„è¦å„²å­˜ç›®å‰æš«å­˜å™¨çš„å€¼åˆ°å †ç–Šã€‚åœ¨å‡½å¼å‘¼å«æ•¸é‡å°‘çš„ç‹€æ³ï¼Œå½±éŸ¿ä¸é¡¯è‘—ï¼Œä½†éš¨è‘—æ•¸é‡å¢é•·ï¼Œå°±æœƒå°è‡´ç¨‹å¼é‹ä½œæ¯”ç”¨ macro å¯¦ä½œæ™‚æ…¢ã€‚ è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ Linux æ ¸å¿ƒå¯¹äº linked list çš„åŠŸèƒ½å¤§é‡é‡‡ç”¨å®æ¥å®ç°ã€‚ é™æ€çš„ linked list åˆå§‹åŒ–éœ€è¦ä½¿ç”¨åˆ° compound literal: C99 6.5.2.5 Compound literals The type name shall specify an object type or an array of unknown size, but not a variable length array type. A postfix expression that consists of a parenthesized type name followed by a braceenclosed list of initializers is a compound literal. It provides an unnamed object whose value is given by the initializer list. If the type name specifies an array of unknown size, the size is determined by the initializer list as specified in 6.7.8, and the type of the compound literal is that of the completed array type. Otherwise (when the type name specifies an object type), the type of the compound literal is that specified by the type name. In either case, the result is an lvalue. C99 6.7.8 Initialization Each brace-enclosed initializer list has an associated current object. When no designations are present, subobjects of the current object are initialized in order according to the type of the current object: array elements in increasing subscript order, structure members in declaration order, and the first named member of a union. In contrast, a designation causes the following initializer to begin initialization of the subobject described by the designator. Initialization then continues forward in order, beginning with the next subobject after that described by the designator. ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:8:0","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"å…¶å®ƒåº”ç”¨ ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:9:0","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"Unit Test æµ‹è¯•æ¡†æ¶æœ¬è´¨æ˜¯æä¾›ä¸€ä¸ªæ¡†æ¶æ¨¡ç‰ˆï¼Œè®©ç¨‹åºå‘˜å°†ç²¾åŠ›æ”¾åœ¨æµ‹è¯•é€»è¾‘çš„ç¼–å†™ä¸Šã€‚ä½¿ç”¨ C è¯­è¨€çš„å®é…åˆå‰ç½®å¤„ç†å™¨ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿åœ°å®ç°è¿™ä¸ªåŠŸèƒ½ã€‚ unity/unity_fixture.h Google Test ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:9:1","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"Object Model åŒæ ·çš„ï¼Œä½¿ç”¨ C è¯­è¨€çš„å®å’Œå‰ç½®å¤„ç†å™¨ï¼Œå¯ä»¥è®© C è¯­è¨€æ‹¥æœ‰ OOP çš„è¡¨è¾¾èƒ½åŠ›: ObjectC: use as a superset of the C language adding a lot of modern concepts missing in C ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:9:2","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"Exception Handling é€šè¿‡å®å’Œ setjmp/longjmp å¯ä»¥å¾ˆè½»æ¾åœ°å®ä½œå‡º C è¯­è¨€çš„å¼‚å¸¸æœºåˆ¶: ExtendedC library extends the C programming language through complex macros and other tricks that increase productivity, safety, and code reuse without needing to use a higher-level language such as C++, Objective-C, or D. include/exception.h ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:9:3","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"ADT ä¸ä¹‹å‰æ‰€æçš„ Linux æ ¸å¿ƒçš„ linked list ç±»ä¼¼ï¼Œä½¿ç”¨å®å–ä»£å‡½æ•°è°ƒç”¨å¯ä»¥é™ä½ æŠ½è±¡æ•°æ®ç±»å‹ (ADT) çš„ç›¸å…³æ“ä½œçš„æ•ˆèƒ½æŸå¤±: pearldb: A Lightweight Durable HTTP Key-Value Pair Database in C klib/ksort.h é€šè¿‡å®å±•å¼€å®ä½œçš„æ’åºç®—æ³• Linux æ ¸å¿ƒåŸå§‹ç¨‹å¼ç ä¹Ÿå–„ç”¨å®æ¥æ‰©å…… ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:9:4","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"Linux æ ¸å¿ƒåŸå§‹ç¨‹å¼ç å® ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:10:0","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"container_of åŸæ–‡åœ°å€ ä½¿ç”¨ C è¯­è¨€è¿›è¡Œç‰©ä»¶å¯¼å‘ç¨‹åºè®¾è®¡çš„æ ¸å¿ƒï¼Œç¬”è€…æ‰€è‘—çš„è§£é‡Šè¯´æ˜çš„ åšæ–‡ã€‚ ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:10:1","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"BUILD_BUG_ON_ZERO åŸæ–‡åœ°å€ ç®€å•æ¥è¯´å°±æ˜¯ç¼–è¯‘æ—¶æœŸå°±è¿›è¡Œæ£€æŸ¥çš„ assertï¼Œç¬”è€…å†™äº† ç›¸å…³ç¬”è®° æ¥è¯´æ˜å®ƒçš„åŸç†ã€‚ ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:10:2","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"max, min æˆåŠŸ æœ¬æ–‡æ¢è¨ Linux æ ¸å¿ƒåŸå§‹ç¨‹å¼ç¢¼ max å’Œ min å·¨é›† (macro) çš„å¯¦ä½œï¼Œé™¤äº†åˆ†æå¯¦å‹™è€ƒé‡ï¼Œä¹Ÿå¸Œæœ›çœ‹å€Œå¾—ä»¥æ·±åˆ»æ„Ÿå—åˆ° Linux æ ¸å¿ƒé–‹ç™¼è€…å°æ–¼å·¥ç¨‹ç´°ç¯€å’Œ C èªè¨€è¦æ ¼ çš„é‡è¦–ï¼Œåæ˜ æ–¼æŒçºŒçš„æ·¬éŠä¸­ã€‚ åŸæ–‡åœ°å€ ","date":"2024-03-25","objectID":"/posts/c-preprocessor/:10:3","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["C","Linux Kernel Internals"],"content":"Linux æ ¸å¿ƒæ¨¡ç»„ (æŒ‚è½½æœºåˆ¶) åŸæ–‡åœ°å€","date":"2024-03-25","objectID":"/posts/c-preprocessor/:11:0","tags":["Sysprog","C","Preprocessor"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‰ç½®å¤„ç†å™¨åº”ç”¨ç¯‡","uri":"/posts/c-preprocessor/"},{"categories":["Systems"],"content":" æ‘˜è¦ æ“ä½œç³»ç»Ÿä½¿ç”¨æ­£ç¡®çš„æŠ½è±¡ä½¿æ„é€ åºå¤§çš„è®¡ç®—æœºè½¯ä»¶/ç¡¬ä»¶ç”Ÿæ€ä»ä¸å¯èƒ½å˜ä¸ºå¯èƒ½ã€‚è¿™é—¨è¯¾å›´ç»•æ“ä½œç³»ç»Ÿæ˜¯ å¦‚ä½•è®¾è®¡ (åº”ç”¨ç¨‹åºè§†è§’)ã€æ€æ ·å®ç° (ç¡¬ä»¶è§†è§’) ä¸¤ä¸ªè§’åº¦å±•å¼€ï¼Œåˆ†ä¸ºä¸¤ä¸ªä¸»è¦éƒ¨åˆ†ï¼š åŸç†è¯¾ (å¹¶å‘/è™šæ‹ŸåŒ–/æŒä¹…åŒ–)ï¼šä»¥æ•™ç§‘ä¹¦å†…å®¹ä¸ºä¸»ï¼Œä»‹ç»æ“ä½œç³»ç»Ÿçš„åŸç†æ€§å†…å®¹ã€‚è¯¾ç¨‹åŒæ—¶æ³¨é‡è®²è§£æ“ä½œç³»ç»Ÿç›¸å…³çš„ä»£ç å®ç°å’Œç¼–ç¨‹æŠ€å·§ï¼ŒåŒ…æ‹¬æ“ä½œç³»ç»Ÿä¸­å¸¸ç”¨çš„å‘½ä»¤è¡Œ/ä»£ç å·¥å…·ã€æ•™å­¦æ“ä½œç³»ç»Ÿ xv6 çš„ä»£ç è®²è§£ç­‰ ç†è§£æ“ä½œç³»ç»Ÿæœ€é‡è¦çš„å®éªŒéƒ¨åˆ†: Mini labs (åº”ç”¨ç¨‹åºè§†è§’ï¼›è®¾è®¡)ï¼šé€šè¿‡å®ç°ä¸€ç³»åˆ—æœ‰è¶£çš„ (é»‘ç§‘æŠ€) ä»£ç ç†è§£æ“ä½œç³»ç»Ÿä¸­å¯¹è±¡å­˜åœ¨çš„æ„ä¹‰å’Œæ“ä½œç³»ç»Ÿ API çš„ä½¿ç”¨æ–¹æ³•ã€è®¾è®¡ç†å¿µ OS labs (è®¡ç®—æœºç¡¬ä»¶è§†è§’ï¼›å®ç°)ï¼šåŸºäºä¸€ä¸ªç®€åŒ–çš„ç¡¬ä»¶æŠ½è±¡å±‚å®ç°å¤šå¤„ç†å™¨æ“ä½œç³»ç»Ÿå†…æ ¸ï¼Œå‘åº”ç”¨ç¨‹åºæä¾›ä¸€äº›åŸºç¡€æ“ä½œç³»ç»Ÿ API æ—¶éš”ä¸€å¹´ï¼Œåœ¨è·Ÿéš B ç«™ up ä¸» @è¸Œèº‡æœˆå…‰ ä»é›¶ç¼–å†™ä¸€ä¸ªåŸºäº x86 æ¶æ„çš„å†…æ ¸ Txics åï¼Œç»ˆäºå¯ä»¥è·Ÿå¾—ä¸Š @ç»¿å¯¼å¸ˆ çš„è¯¾ç¨‹äº† ğŸ¤£ è¿™æ¬¡ä»¥ 2022 å¹´çš„ OS è¯¾ç¨‹ ä½œä¸ºä¸»çº¿å­¦ä¹ ï¼Œè¾…ä»¥ 2023 å¹´è¯¾ç¨‹ å’Œ 2024 å¹´è¯¾ç¨‹ çš„å†…å®¹åŠ ä»¥è¡¥å……ã€æ‰©å±•ï¼Œå¹¶æ­é…å—å¤§çš„ ICS è¯¾ç¨‹è¿›è¡Œä½œä¸šï¼ŒåæœŸå¯èƒ½ä¼šåŠ å…¥æ¸…åå¤§å­¦çš„ rCore å®éªŒ (å¾…å®š)ã€‚ tux é—®é¢˜ JYY 2022 å¹´çš„ OSDI è¯¾ç¨‹è®²ä¹‰å’Œé˜…è¯»ææ–™æ˜¯åˆ†å¼€çš„ï¼Œ2023 å¹´å’Œ 2024 å¹´è¿›è¡Œäº†æ”¹è¿›ï¼Œè®²ä¹‰å’Œé˜…è¯»ææ–™åˆå¹¶æˆç±»ä¼¼äºå…±ç¬”çš„ææ–™ï¼Œæ‰€ä»¥ä¸‹é¢æœ‰ä¸€äº› lectures æ˜¯æ²¡æœ‰é˜…è¯»ææ–™é“¾æ¥çš„ã€‚ ","date":"2024-03-24","objectID":"/posts/nju-osdi/:0:0","tags":["Linux","OS"],"title":"å—äº¬å¤§å­¦ æ“ä½œç³»ç»Ÿ: è®¾è®¡ä¸å®ç° é‡ç‚¹æç¤º","uri":"/posts/nju-osdi/"},{"categories":["Systems"],"content":"æ“ä½œç³»ç»Ÿæ¦‚è¿° ä¸ºä»€ä¹ˆè¦å­¦æ“ä½œç³»ç»Ÿ ç›´æ’­å½•å½± / è®²ä¹‰é¡µé¢ / é˜…è¯»ææ–™ ä¸€ä¸ª Talk çš„ç»å…¸ä¸‰æ®µå¼ç»“æ„: Why? What? How? (è¿™ä¸ªçœŸæ˜¯æ±‡æŠ¥çš„å¤§æ€å™¨ ğŸ¤£) 1950s çš„è®¡ç®—æœº I/O è®¾å¤‡çš„é€Ÿåº¦å·²ç»ä¸¥é‡ä½äºå¤„ç†å™¨çš„é€Ÿåº¦ï¼Œä¸­æ–­æœºåˆ¶å‡ºç° (1953) å¸Œæœ›ä½¿ç”¨è®¡ç®—æœºçš„äººè¶Šæ¥è¶Šå¤šï¼›å¸Œæœ›è°ƒç”¨ API è€Œä¸æ˜¯ç›´æ¥è®¿é—®è®¾å¤‡ æ‰¹å¤„ç†ç³»ç»Ÿ = ç¨‹åºçš„è‡ªåŠ¨åˆ‡æ¢ (æ¢å¡) + åº“å‡½æ•° API æ“ä½œç³»ç»Ÿä¸­å¼€å§‹å‡ºç° è®¾å¤‡ã€æ–‡ä»¶ã€ä»»åŠ¡ ç­‰å¯¹è±¡å’Œ API 1960s çš„è®¡ç®—æœº å¯ä»¥åŒæ—¶è½½å…¥å¤šä¸ªç¨‹åºè€Œä¸ç”¨ â€œæ¢å¡â€ äº† èƒ½è½½å…¥å¤šä¸ªç¨‹åºåˆ°å†…å­˜ä¸”çµæ´»è°ƒåº¦å®ƒä»¬çš„ç®¡ç†ç¨‹åºï¼ŒåŒ…æ‹¬ç¨‹åºå¯ä»¥è°ƒç”¨çš„ API æ—¢ç„¶æ“ä½œç³»ç»Ÿå·²ç»å¯ä»¥åœ¨ç¨‹åºä¹‹é—´åˆ‡æ¢ï¼Œä¸ºä»€ä¹ˆä¸è®©å®ƒä»¬å®šæ—¶åˆ‡æ¢å‘¢ï¼Ÿ æ“ä½œç³»ç»Ÿæœºåˆ¶å‡ºç°å’Œå‘å±•çš„åŸå› ï¼Œä¸éœ€è¦æ­»è®°ç¡¬èƒŒï¼Œè¿™äº›æœºåˆ¶éƒ½æ˜¯åº”éœ€æ±‚è€Œè¯ç”Ÿã€å‘å±•çš„ï¼Œéå¸¸çš„è‡ªç„¶ã€‚ ä»€ä¹ˆæ˜¯æ“ä½œç³»ç»Ÿï¼Ÿ ç¨‹åºè§†è§’ï¼šå¯¹è±¡ + API ç¡¬ä»¶è§†è§’ï¼šä¸€ä¸ª C ç¨‹åº å®éªŒç¯å¢ƒ: deepin 20.9 $ uname -a Linux cai-PC 5.15.77-amd64-desktop #2 SMP Thu Jun 15 16:06:18 CST 2023 x86_64 GNU/Linux å®‰è£… tldr: $ sudo apt install tldr æœ‰äº›ç³»ç»Ÿå¯èƒ½æ²¡æœ‰é¢„è£… man æ‰‹å†Œ: $ sudo apt install manpages manpages-de manpages-de-dev manpages-dev manpages-posix manpages-posix-dev glibc-doc ","date":"2024-03-24","objectID":"/posts/nju-osdi/:1:0","tags":["Linux","OS"],"title":"å—äº¬å¤§å­¦ æ“ä½œç³»ç»Ÿ: è®¾è®¡ä¸å®ç° é‡ç‚¹æç¤º","uri":"/posts/nju-osdi/"},{"categories":["Systems"],"content":"æ“ä½œç³»ç»Ÿä¸Šçš„ç¨‹åº ä»€ä¹ˆæ˜¯ç¨‹åºå’Œç¼–è¯‘å™¨ ç›´æ’­å½•å½± / è®²ä¹‰é¡µé¢ / é˜…è¯»ææ–™ UNIX å“²å­¦: Make each program do one thing well Expect the output of every program to become the input to another ","date":"2024-03-24","objectID":"/posts/nju-osdi/:2:0","tags":["Linux","OS"],"title":"å—äº¬å¤§å­¦ æ“ä½œç³»ç»Ÿ: è®¾è®¡ä¸å®ç° é‡ç‚¹æç¤º","uri":"/posts/nju-osdi/"},{"categories":["Systems"],"content":"ä»€ä¹ˆæ˜¯ç¨‹åº è®¡ç®—æœºæ˜¯æ„å»ºåœ¨çŠ¶æ€æœº (æ•°å­—ç”µè·¯) ä¹‹ä¸Šçš„ï¼Œæ‰€ä»¥è¿è¡Œåœ¨è®¡ç®—æœºä¹‹ä¸Šçš„ç¨‹åº (ä¸ç®¡æ˜¯æ“ä½œç³»ç»Ÿè¿˜æ˜¯åº”ç”¨ï¼Œæ— è®ºæ˜¯æºä»£ç è¿˜æ˜¯äºŒè¿›åˆ¶) éƒ½æ˜¯çŠ¶æ€æœºã€‚Cç¨‹åºçš„çŠ¶æ€æœºæ¨¡å‹ä¸­ï¼ŒçŠ¶æ€æ˜¯ç”±å †æ ˆç¡®å®šçš„ï¼Œæ‰€ä»¥å‡½æ•°è°ƒç”¨æ˜¯çŠ¶æ€è¿ç§»ï¼Œå› ä¸ºå®ƒæ”¹å˜äº†å †æ ˆï¼Œå³æ”¹å˜äº†çŠ¶æ€æœºçš„çŠ¶æ€ã€‚æ˜ç¡®è¿™ä¸€ç‚¹ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ¨¡æ‹Ÿå †æ ˆçš„æ–¹å¼ï¼Œæ¥å°†ä»»æ„çš„é€’å½’ç¨‹åºæ”¹å†™ä¸ºéé€’å½’ç¨‹åºï¼Œä¾‹å¦‚ç»å…¸çš„æ±‰è¯ºå¡”ç¨‹åºã€‚ ç¨‹åº = çŠ¶æ€æœº æºä»£ç  $S$ (çŠ¶æ€æœº): çŠ¶æ€è¿ç§» = æ‰§è¡Œè¯­å¥ äºŒè¿›åˆ¶ä»£ç  $C$ (çŠ¶æ€æœº): çŠ¶æ€è¿ç§» = æ‰§è¡ŒæŒ‡ä»¤ æ³¨æ„ jyy æ‰€ç»™çš„éé€’å½’æ±‰è¯ºå¡”ç¨‹åºä¹Ÿæ˜¯é€šè¿‡æ¨¡æ‹Ÿå †æ ˆçŠ¶æ€è½¬ç§»å®ç°çš„ï¼Œä½†æ˜¯æ¯”è¾ƒæ™¦æ¶©çš„ä¸€ç‚¹æ˜¯ï¼Œå¯¹äºæ¯ä¸€ä¸ªå †æ ˆçŠ¶æ€ï¼Œéƒ½æœ‰å¯èƒ½éœ€è¦æ‰§è¡Œæœ€å¤š 4 æ¡è¯­å¥ (å¯¹åº” for å¾ªç¯å’Œ pc)ï¼Œè¿™ä¸€ç‚¹æ¯”è¾ƒéš¾æ‡‚ã€‚ åªä½¿ç”¨çº¯\"è®¡ç®—\"çš„æŒ‡ä»¤ (æ— è®ºæ˜¯ deterministic è¿˜æ˜¯ non-deterministic) æ— æ³•ä½¿ç¨‹åºåœä¸‹æ¥ï¼Œå› ä¸ºå°†ç¨‹åºæœ¬è´¨æ˜¯çŠ¶æ€æœºï¼Œè€ŒçŠ¶æ€æœºé€šè¿‡â€œè®¡ç®—â€çš„æŒ‡ä»¤åªèƒ½ä»ä¸€ä¸ªçŠ¶æ€è¿ç§»åˆ°å¦ä¸€ä¸ªçŠ¶æ€ï¼Œæ— æ³•å®ç°é”€æ¯çŠ¶æ€æœºçš„æ“ä½œ (å¯¹åº”é€€å‡º/åœä¸‹ç¨‹åº)ï¼Œè¦ä¹ˆæ­»å¾ªç¯ï¼Œè¦ä¹ˆ undefined behaviorã€‚è¿™æ—¶éœ€è¦ç¨‹åºå¯¹åº”çš„çŠ¶æ€æœºä¹‹å¤–çš„å¦ä¸€ä¸ªä¸œè¥¿æ¥æ§åˆ¶ã€ç®¡ç†è¯¥çŠ¶æ€æœºï¼Œä»¥å®ç°ç¨‹åºçš„åœä¸‹/é€€å‡ºæ“ä½œï¼Œè¿™å°±æ˜¯ OS çš„ syscall å­˜åœ¨çš„æ„ä¹‰ï¼Œå®ƒå¯ä»¥æ¸¸ç¦»åœ¨ç¨‹åºå¯¹åº”çš„çŠ¶æ€æœºä¹‹å¤–ï¼Œå¹¶ä¿®æ”¹çŠ¶æ€æœºçš„å†…å®¹ (å› ä¸ºç¨‹åºå‘¼å« syscall æ—¶å·²ç»å…¨æƒæˆäºˆ OS å¯¹å…¶çŠ¶æ€å†…å®¹è¿›è¡Œä¿®æ”¹)ã€‚ ç©ºçš„ _start å‡½æ•°å¯ä»¥æˆåŠŸç¼–è¯‘å¹¶é“¾æ¥ï¼Œä½†æ˜¯ç”±äºå‡½æ•°æ˜¯ç©ºçš„ï¼Œå®ƒä¼šç¼–è¯‘ç”Ÿæˆ retq æŒ‡ä»¤ï¼Œè¿™ä¼šå¯¼è‡´ pc è·³è½¬åˆ°ä¸åˆæ³•çš„åŒºåŸŸï¼Œè€Œæ­£ç¡®çš„åšæ³•åº”è¯¥æ˜¯ä½¿ç”¨ syscall exit æ¥ç»“æŸè¯¥ç¨‹åº (ç†Ÿæ‚‰ C è¯­è¨€å‡½æ•°è°ƒç”¨çš„åŒå­¦åº”è¯¥èƒ½çœ‹æ‡‚è¿™æ®µæè¿°)ã€‚ // start.c int _start() {} // start.o 0000000000000000 \u003c_start\u003e: 0: 55 push %rbp 1: 48 89 e5 mov %rsp,%rbp 4: 90 nop 5: 5d pop %rbp 6: c3 retq é€šè¿‡ syscall å®ç°äº†å’Œ mininal.S åŠŸèƒ½ä¸€è‡´çš„æœ€å° C è¯­è¨€ hello, world ç¨‹åº mininal.c: #include \u003csys/syscall.h\u003e #include \u003cunistd.h\u003e int main() { char buf[] = \"\\033[01;31mHello, OS World\\033[0m\\n\"; syscall(SYS_write, 1, buf, sizeof(buf)); syscall(SYS_exit, 42); } System Calls Manual ","date":"2024-03-24","objectID":"/posts/nju-osdi/:2:1","tags":["Linux","OS"],"title":"å—äº¬å¤§å­¦ æ“ä½œç³»ç»Ÿ: è®¾è®¡ä¸å®ç° é‡ç‚¹æç¤º","uri":"/posts/nju-osdi/"},{"categories":["Systems"],"content":"å¦‚ä½•åœ¨ç¨‹åºçš„ä¸¤ä¸ªè§†è§’ä¹‹é—´åˆ‡æ¢ï¼Ÿ ä»â€œçŠ¶æ€æœºâ€çš„è§’åº¦å¯ä»¥å¸®æˆ‘ä»¬è§£å†³ä¸€ä¸ªé‡è¦çš„åŸºæœ¬é—®é¢˜: ä»€ä¹ˆæ˜¯ç¼–è¯‘å™¨ï¼Ÿï¼Ÿï¼Ÿ ç¼–è¯‘å™¨: æºä»£ç  S (çŠ¶æ€æœº) $\\rightarrow$ äºŒè¿›åˆ¶ä»£ç  C (çŠ¶æ€æœº) $$C=compile(S)$$ å³ç¼–è¯‘å™¨çš„åŠŸèƒ½æ˜¯å°†æºä»£ç å¯¹åº”çš„çŠ¶æ€æœº $S$ è½¬æ¢æˆäºŒè¿›åˆ¶ä»£ç å¯¹åº”çš„çŠ¶æ€æœº $C$ã€‚ä½†æ˜¯è¿™é‡Œéœ€è¦æ³¨æ„ï¼Œè¿™ä¸¤ä¸ªçŠ¶æ€æœºä¸éœ€è¦å®Œå…¨ç­‰ä»·ï¼Œåªéœ€è¦æ»¡è¶³ $S$ ä¸ $C$ çš„å¯è§‚æµ‹è¡Œä¸ºä¸¥æ ¼ä¸€è‡´ å³å¯ï¼Œè¿™ä¹Ÿæ˜¯ç¼–è¯‘ä¼˜åŒ–çš„ç†è®ºåŸºç¡€ï¼šåœ¨ä¿è¯è§‚æµ‹ä¸€è‡´æ€§ (sound) çš„å‰æä¸‹æ”¹å†™ä»£ç  (rewriting)ã€‚ Jserv çš„è®²åº§ ä¸¦è¡Œç¨‹å¼è¨­è¨ˆ: åŸ·è¡Œé †åº å¯¹è¿™ä¸ªæœ‰æ›´æ¸…æ™°çš„è®²è§£ å¯ä»¥é€šè¿‡ä»¥ä¸‹æŒ‡ä»¤æ¥è§‚å¯Ÿç¼–è¯‘å™¨çš„ä¼˜åŒ–æƒ…å†µï¼Œä»¥ç†è§£ä»€ä¹ˆæ˜¯è§‚æµ‹ä¸€è‡´æ€§: $ gcc -On -c a.c # n couldbe 0, 1, 2, 3 $ objdump -d a.o ","date":"2024-03-24","objectID":"/posts/nju-osdi/:2:2","tags":["Linux","OS"],"title":"å—äº¬å¤§å­¦ æ“ä½œç³»ç»Ÿ: è®¾è®¡ä¸å®ç° é‡ç‚¹æç¤º","uri":"/posts/nju-osdi/"},{"categories":["Systems"],"content":"æ“ä½œç³»ç»Ÿä¸­çš„ä¸€èˆ¬ç¨‹åº å¯¹äºæ“ä½œç³»ç»Ÿä¹‹ä¸Šçš„ç¨‹åºï¼Œå®ƒä»¬çœ‹å¾…æ“ä½œç³»ç»Ÿçš„è§†è§’æ˜¯ API (syscall)ï¼Œæ‰€ä»¥è¿™é—¨è¯¾ä¸­æœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„å·¥å…·ï¼šstrace (system call trace è¿½è¸ªç¨‹åºè¿è¡Œæ—¶ä½¿ç”¨çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå¯ä»¥æŸ¥çœ‹ç¨‹åºå’Œæ“ä½œç³»ç»Ÿçš„äº¤äº’): $ sudo apt install strace $ strace ./hello-goodbye Linux manual page: strace æ³¨æ„ å¯ä»¥é€šè¿‡ apt-file æ¥æ£€ç´¢æ–‡ä»¶åå¯èƒ½åœ¨é‚£äº› package é‡Œï¼Œä¾‹å¦‚: $ sudo apt install apt-file $ sudo apt-file update $ sudo apt-file search \u003cfilename\u003e ","date":"2024-03-24","objectID":"/posts/nju-osdi/:2:3","tags":["Linux","OS"],"title":"å—äº¬å¤§å­¦ æ“ä½œç³»ç»Ÿ: è®¾è®¡ä¸å®ç° é‡ç‚¹æç¤º","uri":"/posts/nju-osdi/"},{"categories":["Rust"],"content":" In this episode of Crust of Rust, we go over subtyping and variance â€” a niche part of Rust that most people donâ€™t have to think about, but which is deeply ingrained in some of Rustâ€™s borrow ergonomics, and occasionally manifests in confusing ways. In particular, we explore how trying to implement the relatively straightforward strtok function from C/C++ in Rust quickly lands us in a place where the function is more or less impossible to call due to variance! æ•´ç†è‡ª John Gjengset çš„å½±ç‰‡ ","date":"2024-03-17","objectID":"/posts/subtying-and-variance/:0:0","tags":["Rust","Subtying","Variance"],"title":"Crust of Rust: Subtying and Variance","uri":"/posts/subtying-and-variance/"},{"categories":["Rust"],"content":"å½±ç‰‡æ³¨è§£ ","date":"2024-03-17","objectID":"/posts/subtying-and-variance/:1:0","tags":["Rust","Subtying","Variance"],"title":"Crust of Rust: Subtying and Variance","uri":"/posts/subtying-and-variance/"},{"categories":["Rust"],"content":"strtok A sequence of calls to this function split str into tokens, which are sequences of contiguous characters separated by any of the characters that are part of delimiters. cplusplus: strtok cppreference: strtok ","date":"2024-03-17","objectID":"/posts/subtying-and-variance/:1:1","tags":["Rust","Subtying","Variance"],"title":"Crust of Rust: Subtying and Variance","uri":"/posts/subtying-and-variance/"},{"categories":["Rust"],"content":"shortening lifetimes å½±ç‰‡å¤§æ¦‚ 19 åˆ†æ—¶ç»™å‡ºäº†ä¸ºä½• cargo test å¤±è´¥çš„æ¨å¯¼ï¼Œä¸ªäººè§‰å¾—éå¸¸å·§å¦™ pub fn strtok\u003c'a\u003e(s: \u0026'a mut \u0026'a str, delimiter: char) { ... } let mut x = \"hello world\"; strtok(\u0026mut x, ' '); ä¸ºäº†æ›´ç›´è§‚åœ°è¡¨ç¤ºå’Œå‡½æ•° strtok çš„è¿”å›å€¼ lifetime æ— å…³ï¼Œè¿™é‡Œå°†è¿”å›å€¼å…ˆå»æ‰äº†ã€‚åœ¨è°ƒç”¨ strtok æ—¶ï¼Œç¼–è¯‘å™¨å¯¹äºå‚æ•° s çš„ lifetime æ¨å¯¼å¦‚ä¸‹: parameter: \u0026'a mut \u0026'a str argument: \u0026 mut x parameter: \u0026'a mut \u0026'a str argument: \u0026 mut \u0026'static str parameter: \u0026'a mut \u0026'static str argument: \u0026 mut \u0026'static str parameter: \u0026'static mut \u0026'static str argument: \u0026 mut \u0026'static str parameter: \u0026'static mut \u0026'static str argument: \u0026'static mut \u0026'static str æ‰€ä»¥ strtok åœ¨æ¥æ”¶å‚æ•° s å (é€šè¿‡ä¼ å…¥ \u0026mut x)ï¼Œä¼šæ¨å¯¼å…¶ lifetime ä¸º staticï¼Œè¿™å°±ä¼šå¯¼è‡´åé¢ä½¿ç”¨ x çš„ä¸å¯å˜å¼•ç”¨ (\u0026x) æ—¶å‘ç”Ÿå†²çªã€‚ ","date":"2024-03-17","objectID":"/posts/subtying-and-variance/:1:2","tags":["Rust","Subtying","Variance"],"title":"Crust of Rust: Subtying and Variance","uri":"/posts/subtying-and-variance/"},{"categories":["Rust"],"content":"Subtypes ä¸‹é¢æ˜¯ Covariance çš„ä¸€ä¸ªä¾‹å­ï¼Œç”Ÿå‘½å‘¨æœŸé•¿çš„å¼•ç”¨æ˜¯ç”Ÿå‘½å‘¨æœŸçŸ­çš„å¼•ç”¨çš„ subtype fn main() { let s = String::new(); let x: \u0026'static str = \"hello, world\"; let mut y: \u0026str = \u0026s; y = x; } Since 'static is subtype of 'a T: U T is at least as useful as U // e.g. 'static: 'a 'static is at least as useful as 'a ","date":"2024-03-17","objectID":"/posts/subtying-and-variance/:1:3","tags":["Rust","Subtying","Variance"],"title":"Crust of Rust: Subtying and Variance","uri":"/posts/subtying-and-variance/"},{"categories":["Rust"],"content":"Variance Covariance fn foo(\u0026'a str) {} let x = \u0026'a str foo(\u0026'a str) -\u003e x = 'a str foo(\u0026'static str) -\u003e x = \u0026'static str Contravariance Type Variance in T fn(T) -\u003e () contravariant The only contravariance in Rust now (2024/6/25). /* covariance */ \u0026'static str // more useful \u0026'a str // \u0026'static str is subtype of \u0026'a str // since 'static str is at least as useful as 'a str 'static \u003c: 'a \u0026'static T \u003c: \u0026'a T /* contravariance */ Fn(\u0026'static str) Fn(\u0026'a str) // more useful // Fn(\u0026'a str) subtype of Fn(\u0026'static str) // since Fn(\u0026'a str) is at least as useful as Fn(\u0026'static str) 'static \u003c: 'a Fn(\u0026'a T) \u003c: Fn(\u0026'static T) Invariance Type Variance in 'a Variance in T \u0026'a T covariant covariant \u0026'a mut T covariant invariant fn foo(s: \u0026mut \u0026'a str, x: \u0026'a str) { *s = x; } let mut x: \u0026'static str = \"hello world\"; let z = String::new(); foo(\u0026mut x, \u0026z); foo(\u0026mut \u0026'a str, \u0026'a str) foo(\u0026mut \u0026'static str, \u0026'a str) foo(\u0026mut \u0026'static str, \u0026'static str) drop(z); println(\"{}\", z); // should compiler error! \u0026'a mut T æ˜¯ Invariantï¼Œå¦‚æœå®ƒæ˜¯ Covariant çš„è¯ï¼Œä¸Šé¢ä¾‹å­ä¼šé€ æˆ x çš„ç”Ÿå‘½å‘¨æœŸç¼©çŸ­ (å› ä¸º \u0026mut å¯ä»¥æ”¹å˜å€¼ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´åŸé¢„å®šç”Ÿå‘½å‘¨æœŸå†…å‡ºç°äº†æ‚¬å‚å¼•ç”¨)ï¼Œè¿™ä¸ç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸï¼Œæ‰€ä»¥éœ€è¦å°†å‡½æ•°å‚æ•°çš„ \u0026mut è®¾ç½®ä¸º Invariantï¼Œå³åªèƒ½ä¼ å…¥å’ŒåŸå…ˆç”Ÿå‘½å‘¨æœŸå®Œå…¨ä¸€è‡´çš„æ‰è¡Œï¼Œmore useful æˆ– less useful éƒ½ä¸è¡Œã€‚è€Œ \u0026 å¹¶ä¸èƒ½æ”¹å˜å€¼ï¼Œå¹¶ä¸ä¼šéšå½¢è¢«å¼•ç”¨éƒ¨åˆ†çš„ç”Ÿå‘½å‘¨æœŸï¼Œæ‰€ä»¥æ˜¯ Covariantã€‚ Invariant ä¹Ÿæ˜¯ç¼–è¯‘å™¨æ¨å¯¼æœªçŸ¥ç”Ÿå‘½å‘¨æœŸçš„ä¸€ä¸ªä¸»è¦ç†è®ºä¾æ®ï¼Œæ­¤æ—¶å¯ä»¥è¿ç”¨è¯¥è§„åˆ™å»æ€è€ƒä¸€ä¸‹ä¹‹å‰ strtok çš„é”™è¯¯ã€‚ æ³¨æ„ä¸Šé¢è¡¨æ ¼è§„å®šçš„æ˜¯ \u0026'a mut T é‡Œçš„ 'a æ˜¯ Covariant: pub fn bar() { let mut y = true; let mut z /* \u0026'y mut bool */ = \u0026mut y; let x = Box::new(true); let x: \u0026'static mut bool = Box::leak(x); // ignore this line let _ = z; z = x; // \u0026'y mut bool = \u0026'static mut bool // ignore this line drop(z); } ","date":"2024-03-17","objectID":"/posts/subtying-and-variance/:1:4","tags":["Rust","Subtying","Variance"],"title":"Crust of Rust: Subtying and Variance","uri":"/posts/subtying-and-variance/"},{"categories":["Rust"],"content":"å†çœ‹ strtok åˆ†æ check_is_static() è¿™ä¸ªå‡½æ•°å¯¹ç”Ÿå‘½å‘¨æœŸçš„å½±å“: å½“æ²¡æœ‰è°ƒç”¨ check_is_static(x) æ—¶ï¼Œç¼–è¯‘å™¨ä¼šè®¤ä¸º x æ‰€æŒ‡å‘çš„å­—ç¬¦ä¸²çš„ç”Ÿå‘½å‘¨æœŸä¸ºå½“å‰è¿™ä¸ªå‡½æ•°èŒƒå›´ ('x)ï¼Œæ‰€ä»¥åªè¦ strtok è°ƒç”¨åæ²¡æœ‰ä½¿ç”¨ä»»æ„ x çš„å¼•ç”¨éƒ½ä¸ä¼šå‡ºç°é—®é¢˜ å½“è°ƒç”¨äº† check_is_static(x) åï¼Œç¼–è¯‘å™¨åªèƒ½è®¤ä¸º x æ‰€æŒ‡å‘çš„å­—ç¬¦ä¸²çš„ç”Ÿå‘½å‘¨æœŸä¸º 'static äº†ï¼Œè¿™å°±å¯¼è‡´äº† x åœ¨è¶…è¿‡è¿™ä¸ªå‡½æ•°åå°±è¢« drop äº† ('x)ï¼Œä½†æ˜¯ \u0026mut x è¿™ä¸ªå¼•ç”¨è¢«ç¼–è¯‘å™¨æ¨å¯¼ä¸º 'staticï¼Œä¼šå‡ºç° \u0026mut x è¿™ä¸ªå¼•ç”¨ ('static) è¶…è¿‡äº† x çš„ä½œç”¨åŸŸ ('x) çš„é”™è¯¯ = fn check_is_static(_: \u0026'static str) {} let mut x = \"Hello world\"; check_is_static(x); \u003c'a\u003e \u0026'a mut \u0026'a str \u0026'x mut \u0026'x str // without check_is_static() \u0026'static mut \u0026'static str // with check_is_static() let hello = strtok(\u0026mut x, ' '); æ­¤æ—¶å¯¹å¯å˜å¼•ç”¨ \u0026mut ä½¿ç”¨é¢å¤–çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨å³å¯è§£å†³ä¸Šé¢çš„ä¸¤ä¸ªé—®é¢˜: pub fn strtok\u003c'a, 'b\u003e(s: \u0026'a mut \u0026'b str, delimiter: char) -\u003e \u0026'b str { strtok\u003c'a, 'b\u003e(\u0026'a mut \u0026'b str) -\u003e 'b str strtok (\u0026'x mut \u0026'static str) -\u003e 'static str let z = \u0026mut x; // \u0026'x -\u003e \u0026'until-ZZZ // until-ZZZ: borrow of x stop here let hello = strtok(\u0026mut x, ' '); å› ä¸º \u0026 é‡Œçš„ 'a æ˜¯ covariantï¼Œæ‰€ä»¥å®é™…ä¸Šç¼–è¯‘å™¨ä¼šè®¤ä¸º z çš„ç±»å‹ä¸º \u0026'until-ZZZ mutï¼Œä¾æ® Covariance å¯ä»¥æ¥å— \u0026'x mut çš„å˜é‡ã€‚ ","date":"2024-03-17","objectID":"/posts/subtying-and-variance/:1:5","tags":["Rust","Subtying","Variance"],"title":"Crust of Rust: Subtying and Variance","uri":"/posts/subtying-and-variance/"},{"categories":["Rust"],"content":"PhantomData and drop check PhantomData æœ‰ä½•ä½œç”¨? The reason why yu use PhantomData in general is yu might have a type that is generic over T, but doesnâ€™t contain a T. THis comes up often if you do something with FFI, like you do some kind of deserialzing something. You want a deserializer that is generic over the type itâ€™s going to deserialze, but it doesnâ€™t contain a T, itâ€™s just that you want the deserializer to know which types to produce. So you add a field thatâ€™s PhantomData and PhantomData is the only type in Rust that is generic over a type parameter, but doesnâ€™t contain that type parameter. struct TouchDrop\u003cT: std::fmt::Debug\u003e(T); impl\u003cT: std::fmt::Debug\u003e Drop for TouchDrop\u003cT\u003e { fn drop(\u0026mut self) { println!(\"{:?}\", self.0); } } fn main() { let x = String::new(); let z = vec![TouchDrop(\u0026x)]; drop(x); // drop(z) } è¿™æ®µç¨‹å¼ç ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸ºåœ¨ main å‡½æ•°çš„æœ«å°¾ä¼šæœ‰ä¸€ä¸ªéšå¼çš„ drop(z)ï¼Œè€Œ drop(z) è¿™ä¸ªè°ƒç”¨ä¾æ®ä¸Šé¢çš„è‡ªå®šä¹‰ drop å‡½æ•°ï¼Œéœ€è¦è®¿é—® self.0ï¼Œä½†æ˜¯ self.0 è¿™ä¸ªå¼•ç”¨æ‰€æŒ‡å‘çš„å¯¹è±¡ï¼Œåœ¨ä¸Šä¸€è¡Œçš„ drop(x) æ—¶å°±è¢«é”€æ¯äº†ï¼Œæ‰€ä»¥æ­¤æ—¶éšå¼è°ƒç”¨çš„ drop(z) ä¼šæœ‰æ‚¬å‚å¼•ç”¨çš„å±é™©ï¼Œä»è€Œå¯¼è‡´ç¼–è¯‘é”™è¯¯ã€‚ ä½†æ˜¯å°†ä¸Šé¢ç¨‹å¼ç çš„ç¬¬ 11 è¡Œæ”¹ä¸º let z = vec![\u0026x]; åˆ™ä¸ä¼šæœ‰ç¼–è¯‘é”™è¯¯ï¼Œè¿™æ˜¯å› ä¸º Vec ç±»å‹çš„ drop æ–¹æ³•å¹¶ä¸ä¼šè®¿é—®å†…éƒ¨çš„ T (è¿™æ®µç¨‹å¼ç é‡Œå¯¹åº” \u0026String)ï¼Œä¸ä¼šå‡ºç°æ‚¬å‚å¼•ç”¨ã€‚ use std::marker::PhantomData; struct Deserializer\u003cT\u003e { // some fields _t: PhantomData\u003cT\u003e, } struct Deserializer2\u003cT\u003e { // some fields _t: PhantomData\u003cfn() -\u003e T\u003e, } struct Deserializer3\u003cT\u003e { // some fields _t: PhantomData\u003cfn(T)\u003e, } struct Deserializer4\u003cT\u003e { // some fields _t1: PhantomData\u003cfn(T)\u003e, _t2: PhantomData\u003cfn() -\u003e T\u003e, // or just _t: PhantomData\u003cfn(T) -\u003e T\u003e, } ä¸Šé¢çš„ç¬¬ä¸€ç§ç»“æ„ä½“ Deserializerï¼Œç¼–è¯‘å™¨åœ¨ drop check æ—¶ä¼šæ£€æŸ¥æ˜¯å¦ä¹Ÿ drop äº†æ³›å‹å‚æ•°è¡¨ç¤ºçš„å†…éƒ¨æ•°æ®ç±»å‹ Tï¼Œä½†è¿™ä¸ª T ç±»å‹æ‰€æŒ‡å‘çš„å¯¹è±¡åœ¨ drop å¯èƒ½æ—©è¢« drop äº† (æ‚¬å‚å¼•ç”¨ï¼Œæ¯”å¦‚ T ä¸ºå¼•ç”¨çš„åœºæ™¯)ï¼Œè€Œç¬¬äºŒç§ç»“æ„ä½“ Deserializer2ï¼Œç¼–è¯‘å™¨ drop check æ—¶å°±ä¸ä¼šè¿›è¡Œè¿™ç§æ£€æŸ¥ï¼Œå› ä¸ºåŒ…å«çš„ä»…ä»…æ˜¯å‡½æ•°ç­¾åï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ç¬¬ä¸‰ç§ç»“æ„ä½“ Deserializer3 å’Œç¬¬äºŒç§ç»“æ„ä½“ Deserializer3 æ˜¯ä¸åŒçš„ï¼Œè¿™æ˜¯å› ä¸º Variance çš„å­˜åœ¨ï¼Œå¯¹äºç¬¬äºŒç§ç»“æ„ä½“ Deserializer2ï¼Œå®ƒæ˜¯ Covarianceï¼Œè€Œç¬¬ä¸‰ç§ç»“æ„ä½“ Deserializer3 å´æ˜¯ Contravariance çš„ã€‚ ç¬¬å››ç§ç»“æ„ä½“ Deserializer4 çš„å†…éƒ¨æ•°æ®ç±»å‹ T åˆ™æ˜¯ Invarianceï¼Œå› ä¸º _t1 è¯´æ˜å®ƒæ˜¯ Covarianceï¼Œ_t2 è¯´æ˜å®ƒæ˜¯ Contravarianceï¼Œç»“åˆèµ·æ¥å°±æ˜¯ Invarianceã€‚è¿™ä¸ªç»“æ„ä½“ä¹Ÿå¯ä»¥æ”¹ä¸ºä»¥ä¸‹æ¥å®ç° INvariance: struct Deserializer4\u003cT\u003e { // some fields _t: PhantomData\u003c*mut T\u003e, } ä½¿ç”¨å¯å˜è£¸æŒ‡é’ˆ *mutï¼Œè¿™æ˜¯å› ä¸ºå¦‚æœä½¿ç”¨å¯å˜å¼•ç”¨ \u0026mut çš„è¯éœ€è¦å¼•å…¥ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œè€Œä½¿ç”¨å¯å˜è£¸æŒ‡é’ˆ *mut ä¹Ÿå¯ä»¥è¾¾åˆ° Invariance çš„æ•ˆæœåˆæ— éœ€æ·»åŠ ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ã€‚ Type Variance in T *const T covariant *mut T invariant æ³¨æ„ å…³äº drop check è¿™éƒ¨åˆ†çš„å†…å®¹ï¼Œä¸‹ä¸€æœŸä¼šç‰¹åˆ«é’ˆå¯¹æ€§çš„è®²è§£ï¼Œè¿™é‡Œæœ‰ä¸ªå¤§æ¦‚å°è±¡å³å¯ã€‚ ","date":"2024-03-17","objectID":"/posts/subtying-and-variance/:1:6","tags":["Rust","Subtying","Variance"],"title":"Crust of Rust: Subtying and Variance","uri":"/posts/subtying-and-variance/"},{"categories":["Rust"],"content":"Homework ä¿¡æ¯ å®Œå–„ strtok å‡½æ•°ä½¿å…¶å¯ä»¥æ¥å—å¤šä¸ªåˆ†éš”ç¬¦ä½œä¸ºå‚æ•° ","date":"2024-03-17","objectID":"/posts/subtying-and-variance/:2:0","tags":["Rust","Subtying","Variance"],"title":"Crust of Rust: Subtying and Variance","uri":"/posts/subtying-and-variance/"},{"categories":["Rust"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-03-17","objectID":"/posts/subtying-and-variance/:3:0","tags":["Rust","Subtying","Variance"],"title":"Crust of Rust: Subtying and Variance","uri":"/posts/subtying-and-variance/"},{"categories":["Rust"],"content":"Crate std å¯ä»¥ä½¿ç”¨è¿™é‡Œæä¾›çš„æœç´ æ è¿›è¡Œæœç´¢ (BTW ä¸è¦æµªè´¹æ—¶é—´åœ¨ Google æœå¯»ä¸Šï¼) method str::find method char::len_utf8 method std::boxed::Box::leak Struct std::marker::PhantomData Struct std::ptr::NonNull ","date":"2024-03-17","objectID":"/posts/subtying-and-variance/:3:1","tags":["Rust","Subtying","Variance"],"title":"Crust of Rust: Subtying and Variance","uri":"/posts/subtying-and-variance/"},{"categories":["Rust"],"content":"References The Rust Reference: Subtyping and Variance The Rustonomicon: Subtyping and Variance Lifetime variance in Rust ","date":"2024-03-17","objectID":"/posts/subtying-and-variance/:4:0","tags":["Rust","Subtying","Variance"],"title":"Crust of Rust: Subtying and Variance","uri":"/posts/subtying-and-variance/"},{"categories":["C","Linux Kernel Internals"],"content":" åœ¨è®¸å¤šåº”ç”¨ç¨‹åºä¸­ï¼Œé€’å½’ (recursion) å¯ä»¥ç®€å•åˆä¼˜é›…åœ°è§£å†³è²Œä¼¼ç¹ççš„é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯ä¸æ–­åœ°æ‹†è§£åŸæœ‰é—®é¢˜ä¸ºç›¸ä¼¼çš„å­é—®é¢˜ï¼Œç›´åˆ°æ— æ³•æ‹†è§£ä¸ºæ­¢ï¼Œå¹¶ä¸”å®šä¹‰æœ€ç®€åŒ–çŠ¶å†µçš„å¤„ç†æœºåˆ¶ï¼Œä¸€å¦‚æ•°å­¦æ€ç»´ã€‚é€’å½’å¯¹ C è¯­è¨€ç¨‹åºå¼€å‘è€…æ¥è¯´ï¼Œç»å¯¹ä¸ä¼šé™Œç”Ÿï¼Œä½†èƒ½æŒæ¡è€…å´å°‘ï¼Œå¾ˆå¤šäººç”šè‡³éš¾ä»¥è®²å‡ºæ±‰è¯ºå¡”ä¹‹å¤–çš„ä½¿ç”¨æ¡ˆä¾‹ã€‚ ç©¶ç«Ÿé€’å½’æ˜¯å¦‚ä½•ä¼˜é›…åœ°è§£å†³çœŸå®ä¸–ç•Œçš„é—®é¢˜ï¼Œåˆå¦‚ä½•å…¼é¡¾æ‰§è¡Œæ•ˆç‡å‘¢ã€‹æˆ‘ä»¬ä»è¿ä½œåŸç†å¼€å§‹æ¢è®¨ï¼Œæ­é…è‹¥å¹² C ç¨‹åºè§£è¯´ï¼Œå¹¶ä¸”æˆ‘ä»¬å°†ä»¥ç®€åŒ–è¿‡çš„ UNIX å·¥å…·ä¸ºä¾‹ï¼Œåˆ†æé€è¿‡é€’å½’æ¥å¤§å¹…ç¼©å‡ç¨‹å¼ç ã€‚ æˆ–è®¸è·Ÿä½ æƒ³è±¡ä¸­ä¸åŒï¼ŒLinux æ ¸å¿ƒçš„åŸå§‹ç¨‹å¼ç é‡Œå¤´ä¹Ÿç”¨åˆ°é€’å½’å‡½æ•°å‘¼å«ï¼Œç‰¹åˆ«åœ¨è¾ƒå¤æ‚çš„å®ä½œï¼Œä¾‹å¦‚æ–‡ä»¶ç³»ç»Ÿï¼Œå–„ç”¨é€’å½’å¯å¤§å¹…ç¼©å‡ç¨‹å¼ç ï¼Œä½†è¿™ä¹Ÿå¯¼è‡´è¿½è¸ªç¨‹åºè¿ä½œçš„éš¾åº¦å¤§å¢ã€‚ åŸæ–‡åœ°å€ ","date":"2024-03-16","objectID":"/posts/c-recursion/:0:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["C","Linux Kernel Internals"],"content":"Recursion To Iterate is Human, to Recurse, Divine. http://coder.aqualuna.me/2011/07/to-iterate-is-human-to-recurse-divine.html æ³¨æ„ ç¬”è€…çš„é€’å½’ (Recursion) æ˜¯é€šè¿‡ UC Berkeley çš„ CS61A: Structure and Interpretation of Computer Programs CS70: Discrete Mathematics and Probability Theory å­¦ä¹ çš„ï¼Œè¿™ä¸ªæ­é…å¼çš„å­¦ä¹ æ¨¡å¼ä½¿å¾—æˆ‘åœ¨å®ä½œâ€”â€”é€’å½’ (cs61a) å’Œç†è®ºâ€”â€”å½’çº³æ³• (cs70) ä¸Šç›¸äº’é…åˆç†è§£ï¼Œä»è€Œå¯¹é€’å½’åœ¨å®ä½œå’Œç†è®ºä¸Šéƒ½æœ‰äº†å……åˆ†è®¤çŸ¥ã€‚ ","date":"2024-03-16","objectID":"/posts/c-recursion/:1:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["C","Linux Kernel Internals"],"content":"é€’å½’å¹¶æ²¡æœ‰æƒ³è±¡çš„é‚£ä¹ˆæ…¢ ä»¥æœ€å¤§å…¬å› æ•° (Greatest Common Divisor, GCD) ä¸ºä¾‹ï¼Œåˆ†åˆ«ä»¥å¾ªç¯å’Œé€’å½’è¿›è¡Œå®ä½œ: unsigned gcd_rec(unsigned a, unsigned b) { if (!b) return a; return gcd_rec(b, a % b); } unsigned gcd_itr(unsigned a, unsigned b) { while (b) { unsigned t = b; b = a % b; a = t; } return a; } è¿™ä¸¤ä¸ªå‡½æ•°åœ¨ clang/llvm ä¼˜åŒ–åçš„ç¼–è¯‘è¾“å‡º (clang -S -O2 gcd.c) çš„æ±‡ç¼–æ˜¯ä¸€æ ·çš„: .LBB0_2: movl %edx, %ecx xorl %edx, %edx divl %ecx movl %ecx, %eax testl %edx, %edx jne .LBB1_2 æŠ€å·§ éè¿´ (Recursion) Tail recursion å¯ä»¥è¢«ç¼–è¯‘å™¨è¿›è¡Œkç©ºé—´åˆ©ç”¨æœ€ä¼˜åŒ–ï¼Œä»è€Œè¾¾åˆ°å’Œå¾ªç¯ä¸€æ ·èŠ‚çœç©ºé—´ï¼Œä½†è¿™éœ€è¦ç¼–è¯‘å™¨æ”¯æŒï¼Œæœ‰äº›ç¼–è¯‘å™¨å¹¶ä¸æ”¯æŒ tail recursion ä¼˜åŒ– ğŸ¤£ è™½ç„¶å¦‚æ­¤ï¼Œå°†ä¸€èˆ¬çš„é€’å½’æ”¹å†™ä¸º tail recursion è¿˜æ˜¯å¯ä»¥è·å¾—æå¤§çš„æ•ˆèƒ½æå‡ã€‚ Source ","date":"2024-03-16","objectID":"/posts/c-recursion/:2:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["C","Linux Kernel Internals"],"content":"æ¡ˆä¾‹åˆ†æ: ç­‰æ•ˆç”µé˜» r ----------###------------- A -------- A | | | # # # R(r, n - 1) # r # ==\u003e # R(r, n) # # # | | | --------------------------- B -------- B $$ R(r,n)= \\begin{cases} r \u0026 \\text{if n = 1}\\\\ 1 / (\\frac1r + \\frac1{R(r, n - 1) + r}) \u0026 \\text{if n \u003e 1} \\end{cases} $$ def circuit(n, r): if n == 1: return r else: return 1 / (1 / r + 1 / (circuit(n - 1, r) + r)) ","date":"2024-03-16","objectID":"/posts/c-recursion/:3:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["C","Linux Kernel Internals"],"content":"æ¡ˆä¾‹åˆ†æ: æ•°åˆ—è¾“å‡º man 3 printf RETURN VALUE Upon successful return, these functions return the number of characters printed (excluding the null byte used to end output to strings). å¯ä»¥é€šè¿‡ ulimit -s æ¥æ”¹ stack sizeï¼Œé¢„è®¾ä¸º 8MB ulimit User limits - limit the use of system-wide resources. -s The maximum stack size. ç°ä»£ç¼–è¯‘å™¨çš„æœ€ä¼˜åŒ–å¯èƒ½ä¼šé€ æˆé€’å½’å®ä½œçš„éé¢„æœŸæ”¹å˜ï¼Œå› ä¸ºç¼–è¯‘å™¨å¯èƒ½ä¼šå¯¹é€’å½’å®ä½œåœ¨ç¼–è¯‘æ—¶æœŸè¿›è¡Œä¸€äº›ä¼˜åŒ–ï¼Œä»è€Œæé«˜æ•ˆèƒ½å’Œé™ä½å†…å­˜ä½¿ç”¨ã€‚ ","date":"2024-03-16","objectID":"/posts/c-recursion/:4:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["C","Linux Kernel Internals"],"content":"é€’å½’ç¨‹åºè®¾è®¡ Recursive Programming ","date":"2024-03-16","objectID":"/posts/c-recursion/:5:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["C","Linux Kernel Internals"],"content":"Fibonacci sequence ä½¿ç”¨çŸ©é˜µé…åˆå¿«é€Ÿå¹‚ç®—æ³•ï¼Œå¯ä»¥å°†æ—¶é—´å¤æ‚åº¦ä» $O(n)$ é™ä½åˆ° $O(\\log n)$ æ–¹æ³• æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ Rcursive $O(2^n)$ $O(n)$ Iterative $O(n)$ $O(1)$ Tail recursion $O(n)$ $O(1)$ Q-Matrix $O(\\log n)$ $O(n)$ Fast doubling $O(\\log n)$ $O(1)$ åŸæ–‡çš„ Q-Matrix å®ä½œæŒºå¤šæ¼æ´çš„ï¼Œä¸‹é¢ä¸ºä¿®æ­£åçš„å®ä½œ (æ³¨æ„çŸ©é˜µä¹˜æ³•çš„ memset æ˜¯å¿…é¡»çš„ï¼Œå¦åˆ™ä¼šä½¿ç”¨åˆ°æ ˆä¸Šè¶…å‡ºç”Ÿå‘½å‘¨æœŸçš„ obeject): void matrix_multiply(int a[2][2], int b[2][2], int t[2][2]) { memset(t, 0, sizeof(int) * 2 * 2); for (int i = 0; i \u003c 2; i++) for (int j = 0; j \u003c 2; j++) for (int k = 0; k \u003c 2; k++) t[i][j] += a[i][k] * b[k][j]; } void matrix_pow(int a[2][2], int n, int t[2][2]) { if (n == 1) { t[0][0] = a[0][0]; t[0][1] = a[0][1]; t[1][0] = a[1][0]; t[1][1] = a[1][1]; return; } if (n % 2 == 0) { int t1[2][2]; matrix_pow(a, n \u003e\u003e 1, t1); matrix_multiply(t1, t1, t); return; } else { int t1[2][2], t2[2][2]; matrix_pow(a, n \u003e\u003e 1, t1); matrix_pow(a, (n \u003e\u003e 1) + 1, t2); matrix_multiply(t1, t2, t); return; } } int fib(int n) { if (n \u003c= 0) return 0; int A1[2][2] = {{1, 1}, {1, 0}}; int result[2][2]; matrix_pow(A1, n, result); return result[0][1]; } Fast doubling å…¬å¼: $$ \\begin{split} F(2k) \u0026= F(k)[2F(k+1) - F(k)] \\\\ F(2k+1) \u0026= F(k+1)^2+F(k)^2 \\end{split} $$ å…·ä½“æ¨å¯¼: $$ \\begin{split} \\begin{bmatrix} F(2n+1) \\\\ F(2n) \\end{bmatrix} \u0026= \\begin{bmatrix} 1 \u0026 1 \\\\ 1 \u0026 0 \\end{bmatrix}^{2n} \\begin{bmatrix} F(1) \\\\ F(0) \\end{bmatrix}\\\\ \\\\ \u0026= \\begin{bmatrix} 1 \u0026 1 \\\\ 1 \u0026 0 \\end{bmatrix}^n \\begin{bmatrix} 1 \u0026 1 \\\\ 1 \u0026 0 \\end{bmatrix}^n \\begin{bmatrix} F(1) \\\\ F(0) \\end{bmatrix}\\\\ \\\\ \u0026= \\begin{bmatrix} F(n+1) \u0026 F(n) \\\\ F(n) \u0026 F(n-1) \\end{bmatrix} \\begin{bmatrix} F(n+1) \u0026 F(n) \\\\ F(n) \u0026 F(n-1) \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\\\ \\\\ \u0026= \\begin{bmatrix} F(n+1)^2 + F(n)^2\\\\ F(n)F(n+1) + F(n-1)F(n) \\end{bmatrix} \\end{split} $$ ç„¶åæ ¹æ® $F(k + 1) = F(k) + F(k - 1)$ å¯å¾— $F(2k)$ æƒ…å†µçš„å…¬å¼ã€‚ åŸæ–‡ä¸­éé€’å¢æƒ…å½¢æ¯”è¾ƒæ™¦æ¶©ï¼Œä½†å…¶æœ¬è´¨æ˜¯é€šè¿‡ç´¯åŠ æ¥é€¼è¿‘ç›®æ ‡å€¼: else { t0 = t3; // F(n-2); t3 = t4; // F(n-1); t4 = t0 + t4; // F(n) i++; } ","date":"2024-03-16","objectID":"/posts/c-recursion/:6:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["C","Linux Kernel Internals"],"content":"æ¡ˆä¾‹åˆ†æ: å­—ç¬¦ä¸²åè½¬ åŸæ–‡å¯¹äºæ—¶é—´å¤æ‚åº¦çš„åˆ†æè²Œä¼¼æœ‰äº›é—®é¢˜ï¼Œä¸‹é¢ç»™å‡ºæœ¬äººçš„è§è§£ã€‚ç¬¬ä¸€ç§æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º: $$ T(n) = 2T(n-1) + T(n-2) $$ æ‰€ä»¥ç¬¬ä¸€ç§æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(2^n)$ã€‚ ç¬¬äºŒç§æ–¹æ³•åªæ˜¯åˆ—å‡ºäº†ç¨‹å¼ç ï¼Œè€Œæ²¡æœ‰è¯´æ˜é€’å½’å‡½æ•°çš„ä½œç”¨ï¼Œåœ¨æœ¬äººçœ‹æ¥ï¼Œé€’å½’å‡½æ•°ä¸€å®šè¦æ˜ç¡®è¯´æ˜å…¶ç›®çš„ï¼Œæ‰èƒ½æ¯”è¾ƒå¥½ç†è§£é€’å½’çš„ä½œç”¨ï¼Œæ‰€ä»¥ä¸‹é¢ç»™å‡ºé€’å½’å‡½æ•° rev_core çš„åŠŸèƒ½è¯´æ˜: // è¿”å›å­—ç¬¦ä¸² head çš„æœ€å¤§ä¸‹æ ‡ (ä¸‹æ ‡ç›¸å¯¹äº idx åç§»)ï¼Œå¹¶ä¸”å°†å­—ç¬¦ä¸² head ç›¸å¯¹äº // æ•´æ¡å­—ç¬¦ä¸²çš„ä¸­é—´å¯¹ç§°ç‚¹è¿›è¡Œåè½¬ int rev_core(char *head, int idx) { if (head[idx] != '\\0') { int end = rev_core(head, idx + 1); if (idx \u003e end / 2) swap(head + idx, head + end - idx); return end; } return idx - 1; } char *reverse(char *s) { rev_core(s, 0); return s; } æ—¶é—´å¤æ‚åº¦æ˜¾ç„¶ä¸º $O(n)$ ","date":"2024-03-16","objectID":"/posts/c-recursion/:7:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["C","Linux Kernel Internals"],"content":"æ¡ˆä¾‹åˆ†æ: å»ºç«‹ç›®å½• mkdir [Linux manual page (2)] DESCRIPTION Create the DIRECTORY(ies), if they do not already exist. è¡¥å……ä¸€ä¸‹é€’å½’å‡½æ•° mkdir_r çš„åŠŸèƒ½æè¿°: // ä»è·¯å¾„ `path` çš„ç¬¬ `level` å±‚å¼€å§‹åˆ›å»ºç›®å½• int mkdir_r(const char *path, int level); ","date":"2024-03-16","objectID":"/posts/c-recursion/:8:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["C","Linux Kernel Internals"],"content":"æ¡ˆä¾‹åˆ†æ: ç±»ä¼¼ find çš„ç¨‹åº opendir [Linux manual page (3)] RETURN VALUE The opendir() and fdopendir() functions return a pointer to the directory stream. On error, NULL is returned, and errno is set to indicate the error. readdir [Linux manual page (3)] RETURN VALUE On success, readdir() returns a pointer to a dirent structure. (This structure may be statically allocated; do not attempt to free(3) it.) If the end of the directory stream is reached, NULL is returned and errno is not changed. If an error occurs, NULL is returned and errno is set to indicate the error. To distinguish end of stream from an error, set errno to zero before calling readdir() and then check the value of errno if NULL is returned. ç»ƒä¹ : è¿åŒæ–‡ä»¶ä¸€èµ·è¾“å‡º ç»ƒä¹ : å°†è¾“å‡ºçš„ . å’Œ .. è¿‡æ»¤æ‰ ","date":"2024-03-16","objectID":"/posts/c-recursion/:9:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["C","Linux Kernel Internals"],"content":"æ¡ˆä¾‹åˆ†æ: Merge Sort Program for Merge Sort in C MapReduce with POSIX Thread ","date":"2024-03-16","objectID":"/posts/c-recursion/:10:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["C","Linux Kernel Internals"],"content":"å‡½æ•°å¼ç¨‹åºå¼€å‘ Toward Concurrency Functional programming in C Functional Programming é£æ ¼çš„ C è¯­è¨€å®ä½œ ","date":"2024-03-16","objectID":"/posts/c-recursion/:11:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["C","Linux Kernel Internals"],"content":"é€’å½’èƒŒåçš„ç†è®º YouTube: Lambda Calculus - Computerphile YouTube: Essentials: Functional Programmingâ€™s Y Combinator - Computerphile ç¬¬ä¸€ä¸ªå½±ç‰‡ç›¸å¯¹è¿˜è›®å¥½æ‡‚ï¼Œç¬¬äºŒä¸ªå½±ç‰‡å¯¹äºé PL èƒŒæ™¯çš„äººæ¥è¯´å®Œå…¨æ˜¯çœ‹ä¸æ‡‚ï¼Œæ‰€ä»¥æš‚æ—¶å…ˆæ”¾å¼ƒäº† ç¬¬ä¸€ä¸ªå½±ç‰‡ä¸»è¦ä»‹ç»å‡½æ•°å¼ç¼–ç¨‹çš„æ ¸å¿ƒæ¦‚å¿µ: å‡½æ•°å¯ä»¥åƒå…¶å®ƒ object ä¸€æ ·è¢«ä¼ é€’ä½¿ç”¨ï¼Œæ²¡æœ‰é¢å¤–çš„é™åˆ¶ï¼Œå¹¶ä¸” object æ˜¯å¯ä»¥ç”±å‡½æ•°æ¥å®šä¹‰ã€æ„å»ºçš„ï¼Œä¾‹å¦‚æˆ‘ä»¬å¯ä»¥å®šä¹‰ true å’Œ false: TRUE: $\\lambda x.\\ \\lambda y.\\ x$ FALSE: $\\lambda x.\\ \\lambda y.\\ y$ å› ä¸º true å’Œ false å°±æ˜¯ç”¨æ¥æ§åˆ¶æµç¨‹çš„ï¼Œä¸º true æ—¶æˆ‘ä»¬ do somthingï¼Œä¸º false æˆ‘ä»¬ do otherï¼Œæ‰€ä»¥ä¸Šé¢è¿™ç§å®šä¹‰æ˜¯æœ‰æ„ä¹‰çš„ï¼Œå½“ç„¶ä½ ä¹Ÿå¯ä»¥å®šä¹‰ä¸ºå…¶å®ƒï¼Œæ¯•ç«Ÿå‡½æ•°å¼ç¼–ç¨‹è®©æˆ‘ä»¬å¯ä»¥å®šä¹‰ä»»æ„æˆ‘ä»¬æƒ³å®šä¹‰çš„ä¸œè¥¿ ğŸ¤£ æ¥ä¸‹æ¥æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡å…ˆå‰å®šä¹‰çš„ TRUE å’Œ FALSE æ¥å®ç° NOT, AND, OR è¿™ç±»æ“ä½œäº†: NOT: $\\lambda b.\\ b.$ FALSE TRUE AND: $\\lambda x.\\ \\lambda y.\\ x.\\ y.$ FALSE OR: $\\lambda x.\\ \\lambda y.\\ x$ TRUE $y.$ ä¹ä¸€çœ‹è¿™ä¸ªæŒºæŠ½è±¡çš„ï¼Œå…¶å®ä¸Šé¢çš„å®ç°æ­£ä½“ç°äº†å‡½æ•°å¼ç¼–ç¨‹çš„å¨åŠ›ï¼Œæˆ‘ä»¬ä»¥ NOT TRUE çš„æ¨å¯¼å¸¦å¤§å®¶ä½“ä¼šä¸€ä¸‹: NOT TRUE $\\ \\ \\ \\ $ $b.$ FALSE TRUE $\\ \\ \\ \\ $ TRUE FALSE TRUE $\\ \\ \\ \\ $ TRUE (FALSE TRUE) $\\ \\ \\ \\ $ FALSE å…¶ä½™æ¨å¯¼åŒç† ","date":"2024-03-16","objectID":"/posts/c-recursion/:12:0","tags":["Sysprog","C","Recursion"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: é€’å½’è°ƒç”¨ç¯‡","uri":"/posts/c-recursion/"},{"categories":["Linux","Linux Kernel Internals"],"content":" Linux æ ¸å¿ƒå¦‚åŒå…¶å®ƒå¤æ‚çš„èµ„è®¯ç³»ç»Ÿï¼Œä¹Ÿæä¾› hash table çš„å®ä½œï¼Œä½†å…¶åŸå§‹ç¨‹å¼ç ä¸­å´è—æœ‰é—´æ¥æŒ‡é’ˆ (å¯å‚è§ ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­å†…å­˜) çš„å·§å¦™å’Œæ•°å­¦å¥¥ç§˜ã€‚ åŸæ–‡åœ°å€ ","date":"2024-03-16","objectID":"/posts/linux-hashtable/:0:0","tags":["Sysprog","Linux","Hash"],"title":"Linux æ ¸å¿ƒçš„ hash table å®ä½œ","uri":"/posts/linux-hashtable/"},{"categories":["Linux","Linux Kernel Internals"],"content":"é—´æ¥æŒ‡é’ˆ Linux æ ¸å¿ƒçš„ hashtable ç»“æ„ç¤ºæ„å›¾ï¼š ä¸éš¾çœ‹å‡ºï¼Œpprev æ˜¯æŒ‡å‘ä¸Šä¸€ä¸ªèŠ‚ç‚¹ next çš„æŒ‡é’ˆï¼Œå³æ˜¯æŒ‡å‘ hlist_node * çš„æŒ‡é’ˆï¼Œè€Œä¸æ˜¯æŒ‡å‘ä¸Šä¸€ä¸ªèŠ‚ç‚¹ (hlist_node) çš„æŒ‡é’ˆï¼Œå› ä¸º hashtable çš„æ•°ç»„ä¸­å­˜æ”¾çš„æ˜¯ hlist_node *ï¼Œæ‰€ä»¥è¿™æ ·ä¹Ÿç®€åŒ–äº†è¡¨ç¤ºæ–¹æ³•ï¼Œå°†æ‹‰é“¾å’Œæ•°ç»„å…ƒç´ ç›¸äº’è”ç³»äº†èµ·æ¥ã€‚éœ€è¦ä½¿ç”¨é—´æ¥æŒ‡é’ˆæ¥å®ç° doubly linked æœ¬è´¨ä¸Šæ˜¯å› ä¸ºï¼šæ‹‰é“¾èŠ‚ç‚¹å’Œæ•°ç»„èŠ‚ç‚¹åœ¨è¡¨ç¤ºå’Œæ“ä½œä¸Šçš„ä¸ç­‰ä»·ã€‚ å½“ç„¶ä¹Ÿå¯ä»¥å°†æ•°ç»„å…ƒç´ å’Œæ‹‰é“¾å…ƒç´ éƒ½ç»Ÿä¸€ä¸ºå¸¦æœ‰ä¸¤ä¸ªæŒ‡é’ˆ prev å’Œ next çš„ doubly linked list nodeï¼Œè¿™æ ·è§£å†³äº†ä¹‹å‰æ‰€æçš„ä¸ç­‰ä»·ï¼Œå¯ä»¥æ¶ˆé™¤ç‰¹åˆ¤ï¼Œä½†è¿™æ ·ä¼šå¯¼è‡´å­˜å–æ•°ç»„å…ƒç´ æ—¶å†…å­˜å¼€é”€å¢å¤§ï¼Œè¿›è€Œé™ä½ cache çš„åˆ©ç”¨ç‡ã€‚ ä¿¡æ¯ List, HList, and Hash Table å†…æ ¸åŸºç¡€è®¾æ–½â€”â€”hlist_head/hlist_node ç»“æ„è§£æ hlistæ•°æ®ç»“æ„å›¾ç¤ºè¯´æ˜ ","date":"2024-03-16","objectID":"/posts/linux-hashtable/:1:0","tags":["Sysprog","Linux","Hash"],"title":"Linux æ ¸å¿ƒçš„ hash table å®ä½œ","uri":"/posts/linux-hashtable/"},{"categories":["Linux","Linux Kernel Internals"],"content":"hash å‡½æ•° Wikipedia: Hash function A hash function is any function that can be used to map data of arbitrary size to fixed-size values, though there are some hash functions that support variable length output. ","date":"2024-03-16","objectID":"/posts/linux-hashtable/:2:0","tags":["Sysprog","Linux","Hash"],"title":"Linux æ ¸å¿ƒçš„ hash table å®ä½œ","uri":"/posts/linux-hashtable/"},{"categories":["Linux","Linux Kernel Internals"],"content":"å¸¸è§ hash ç­–ç•¥ Division method $$ h(k) = k % N $$ Mid-square $$ h(k) = bits_{i,i+r-1}(k^2) $$ Folding addition $$ key = 3823749374 \\\\ 382\\ |\\ 374\\ |\\ 937\\ |\\ 4 \\\\ index = 382 + 374 + 937 + 4 = 1697 \\\\ $$ å…ˆå°† key åˆ‡æˆç‰‡æ®µåå†ç›¸åŠ ï¼Œä¹Ÿå¯ä»¥å¯¹ç›¸åŠ åçš„ç»“æœåšå…¶ä»–è¿ç®— Multiplication Method ","date":"2024-03-16","objectID":"/posts/linux-hashtable/:2:1","tags":["Sysprog","Linux","Hash"],"title":"Linux æ ¸å¿ƒçš„ hash table å®ä½œ","uri":"/posts/linux-hashtable/"},{"categories":["Linux","Linux Kernel Internals"],"content":"Linux æ ¸å¿ƒçš„ hash å‡½æ•° Linux æ ¸å¿ƒçš„ hash.h ä½¿ç”¨çš„æ˜¯ Multiplication Method ç­–ç•¥ï¼Œä½†æ˜¯æ˜¯é€šè¿‡æ•´æ•°å’Œä½è¿ç®—å®ç°çš„ï¼Œæ²¡æœ‰ä½¿ç”¨åˆ°æµ®ç‚¹æ•°ã€‚ $$ \\begin{split} h(K) \u0026= \\lfloor m \\cdot (KA - \\lfloor KA \\rfloor) \\rfloor \\\\ h(K) \u0026= K \\cdot 2^w \\cdot A \u003e\u003e (w - p) \\end{split} $$ $K$: key value $A$: a constant, ä¸” $0 \u003c A \u003c 1$ $m$: bucket æ•°é‡ï¼Œä¸” $m = 2^p$ $w$: ä¸€ä¸ª word æœ‰å‡ ä¸ª bit ä¸Šé¢ä¸¤æ¡å¼å­çš„ç­‰ä»·å…³é”®åœ¨äºï¼Œä½¿ç”¨ äºŒè¿›åˆ¶ç¼–ç  è¡¨ç¤ºçš„æ•´æ•°å’Œå°æ•°é…åˆè¿›è¡Œæ¨å¯¼ï¼Œè¿›è€Œåªä½¿ç”¨æ•´æ•°æ¥å®ç°ï¼Œå…·ä½“æ¨å¯¼è§åŸæ–‡ã€‚ $(\\sqrt{5} - 1 ) / 2 = 0.618033989$ $2654435761 / 4294967296 = 0.618033987$ $2^{32} = 4294967296$ å› æ­¤ val * GOLDEN_RATIO_32 \u003e\u003e (32 - bits) $\\equiv K \\times A \\times 2^w \u003e\u003e (w - p)$ï¼Œå…¶ä¸­ GOLDEN_RATIO_32 ç­‰äº $2654435761$ Linux æ ¸å¿ƒçš„ 64 bit çš„ hash å‡½æ•°: #ifndef HAVE_ARCH_HASH_64 #define hash_64 hash_64_generic #endif static __always_inline u32 hash_64_generic(u64 val, unsigned int bits) { #if BITS_PER_LONG == 64 /* 64x64-bit multiply is efficient on all 64-bit processors */ return val * GOLDEN_RATIO_64 \u003e\u003e (64 - bits); #else /* Hash 64 bits using only 32x32-bit multiply. */ return hash_32((u32)val ^ __hash_32(val \u003e\u003e 32), bits); #endif } Linux æ ¸å¿ƒé‡‡ç”¨ golden ratio ä½œä¸º $A$ï¼Œè¿™æ˜¯å› ä¸ºè¿™æ ·ç¢°æ’è¾ƒå°‘ï¼Œä¸”åˆ†å¸ƒå‡åŒ€: ","date":"2024-03-16","objectID":"/posts/linux-hashtable/:3:0","tags":["Sysprog","Linux","Hash"],"title":"Linux æ ¸å¿ƒçš„ hash table å®ä½œ","uri":"/posts/linux-hashtable/"},{"categories":["C","Linux Kernel Internals"],"content":" æœ¬è®²åº§å°†å¸¦ç€å­¦å‘˜é‡æ–°æ¢ç´¢å‡½æ•°å‘¼å«èƒŒåçš„åŸç†ï¼Œä»ç¨‹åºè¯­è¨€å’Œè®¡ç®—æœºç»“æ„çš„å‘å±•ç®€å²è°ˆèµ·ï¼Œè®©å­¦å‘˜è‡ªç”µè„‘è½¯ç¡¬ä»¶æ¼”åŒ–è¿‡ç¨‹å»æŒæ¡ calling convention çš„è€ƒé‡ï¼Œä¼´éšç€ stack å’Œ heap çš„æ“ä½œï¼Œå†æ¢è®¨ C ç¨‹åºå¦‚ä½•å¤„ç†å‡½æ•°å‘¼å«ã€è·¨è¶Šå‡½æ•°é—´çš„è·³è·ƒ (å¦‚ setjmp å’Œ longjmp)ï¼Œå†æ¥æ€ç´¢èµ„è®¯å®‰å…¨å’Œæ‰§è¡Œæ•ˆç‡çš„è®®é¢˜ã€‚ç€é‡åœ¨è®¡ç®—æœºæ¶æ„å¯¹åº”çš„æ”¯æ´å’Œè¡Œä¸ºåˆ†æã€‚ åŸæ–‡åœ°å€ ","date":"2024-03-15","objectID":"/posts/c-function/:0:0","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"function prototype Very early C compilers and language ä¸€ä¸ªå°æ•…äº‹ï¼Œå¯ä»¥è§£é‡Š C è¯­è¨€çš„ä¸€äº›è®¾è®¡ç†å¿µï¼Œä¾‹å¦‚ switch-case ä¸­æ¯ä¸ª case éƒ½éœ€è¦ break The Development of the C Language Dennis M. Ritchie è®²è¿° C è¯­è¨€æ¼«é•¿çš„å‘å±•å²ï¼Œå¹¶æ­é…ç¨‹å¼ç æ¥è¯´æ˜å½“åˆä¸ºä½•å¦‚æ­¤è®¾è®¡ã€å–èˆè€ƒé‡ã€‚äº†è§£è¿™äº›å†å²èƒŒæ™¯å¯ä»¥è®©æˆ‘ä»¬æˆä¸ºæ›´ä¸“ä¸šçš„ C è¯­è¨€ Programmer Rationale for International Standard â€“ Programming Languages â€“ C è®²è¿° C è¯­è¨€æ ‡å‡†çš„å˜æ›´ï¼Œå¹¶æ­é…ç¨‹å¼ç è§£é‡Šå˜æ›´çš„åŸç†å’Œè€ƒé‡ åœ¨æ—©æœŸçš„ C è¯­è¨€ä¸­ï¼Œå¹¶ä¸éœ€è¦ function prototypeï¼Œå› ä¸ºå½“ç¼–è¯‘å™¨å‘ç°ä¸€ä¸ªå‡½æ•°åå‡ºç°åœ¨è¡¨è¾¾å¼å¹¶ä¸”åé¢è·Ÿç€å·¦æ‹¬å· (ï¼Œä¾‹å¦‚ a = func(...)ï¼Œå°±ä¼šå°†è¯¥å‡½æ•°è§£è¯»ä¸ºï¼šè¿”å›å€¼ç±»å‹é¢„è®¾ä¸º intï¼Œå‚æ•°ç±»å‹å’Œä¸ªæ•°ç”±è°ƒç”¨è€…æä¾›æ¥å†³å®šï¼ŒæŒ‰ç…§è¿™æ ·è§„åˆ™ç¼–å†™ç¨‹å¼ç ï¼Œå¯ä»¥åœ¨æ— éœ€äº‹å…ˆå®šä¹‰å‡½æ•°å³å¯å…ˆå†™è°ƒç”¨å‡½æ•°çš„é€»è¾‘ã€‚ä½†æ˜¯è¿™æ ·è®¾è®¡ä¹Ÿä¼šé€ æˆæ½œåœ¨é—®é¢˜ï¼šç¨‹åºå‘˜åœ¨è°ƒç”¨å‡½æ•°æ—¶éœ€è¦è°¨æ…å¤„ç†ï¼Œéœ€è¦è‡ªå·±æ£€æŸ¥è°ƒç”¨æ—¶çš„å‚æ•°ç±»å‹å’Œä¸ªæ•°ç¬¦åˆå‡½æ•°å®šä¹‰ (å› ä¸ºå½“æ—¶çš„ç¼–è¯‘å™¨æ— æ³•æ­£ç¡®åˆ¤æ–­è°ƒç”¨å‡½æ•°æ—¶çš„å‚æ•°æ˜¯å¦ç¬¦åˆé¢„æœŸçš„ç±»å‹å’Œä¸ªæ•°ï¼Œå½“æ—¶ç¼–è¯‘å™¨çš„èƒ½åŠ›ä¸å…ˆå‰æåˆ°çš„è§„åˆ™æ˜¯ä¸€ä½“ä¸¤é¢)ï¼Œå¹¶ä¸”è¿”å›å€¼ç±»å‹é¢„è®¾ä¸º int (å½“æ—¶è¿˜æ²¡æœ‰ void ç±»å‹)ï¼Œæ‰€ä»¥å¯¹äºå‡½æ•°è¿”å›å€¼ï¼Œä¹Ÿéœ€è¦è°¨æ…å¤„ç†ã€‚ æ˜¾ç„¶ function prototype çš„ç¼ºå¤±å¯¼è‡´ç¨‹å¼ç ç¼–å†™æå…¶å®¹æ˜“å‡ºé”™ï¼Œæ‰€ä»¥ä» C99 å¼€å§‹å°±è§„èŒƒäº† function prototypeï¼Œè¿™ä¸ªè§„èŒƒé™¤äº†å¯ä»¥é™ä½ programmer å¿ƒæ™ºè´Ÿæ‹…ä¹‹å¤–ï¼Œè¿˜å¯ä»¥æé«˜ç¨‹åºæ•ˆèƒ½ã€‚ç¼–è¯‘å™¨çš„æœ€ä½³åŒ–é˜¶æ®µ (optimizer) å¯ä»¥é€šè¿‡ function prototype æ¥å¾—çŸ¥å†…å­˜ç©ºé—´çš„ä½¿ç”¨æƒ…å½¢ï¼Œä»è€Œå…è®¸ç¼–è¯‘å™¨åœ¨å‡½æ•°è°ƒç”¨è¡¨è¾¾å¼çš„ä¸Šä¸‹æ–‡è¿›è¡Œæ¿€è¿›çš„æœ€ä½³åŒ–ç­–ç•¥ï¼Œä¾‹å¦‚ const çš„ä½¿ç”¨å¯ä»¥è®©ç¼–è¯‘å™¨çŸ¥é“åªä¼šè¯»å–å†…å­˜æ•°æ®è€Œä¸ä¼šä¿®æ”¹å†…å­˜æ•°æ®ï¼Œä»è€Œæ²¡æœ‰ side effectï¼Œå¯ä»¥è¿›è¡Œæ¿€è¿›çš„æœ€ä¼˜åŒ–ã€‚ int compare(const char *string1, const char *string2); void func2(int x) { char *str1, *str2; // ... x = compare(str1, str2); // ... } Rust çš„ä¸å¯å˜å¼•ç”¨ä¹Ÿæ˜¯ç¼–è¯‘å™¨å¯ä»¥è¿›è¡Œæ›´æ¿€è¿›çš„æœ€ä¼˜åŒ–å¤„ç†çš„ä¸€ä¸ªä¾‹å­ æ³¨æ„ ä¸ºä»€ä¹ˆæ—©æœŸçš„ C è¯­è¨€æ²¡æœ‰ function prototype å‘¢ï¼Ÿå› ä¸ºæ—©æœŸçš„ C è¯­è¨€ï¼Œä¸ç®¡æœ‰å¤šå°‘ä¸ªæºç¨‹åºæ–‡ä»¶ï¼Œéƒ½æ˜¯å…ˆé€šè¿‡ cat åˆå¹¶æˆä¸€ä¸ªå•å…ƒæ–‡ä»¶ï¼Œåœ¨è¿›è¡Œç¼–è¯‘é“¾æ¥ç”Ÿæˆç›®æ ‡æ–‡ä»¶ã€‚è¿™æ ·å°±å¯¼è‡´äº†å°±ç®—å†™äº† function prototyeï¼Œä½¿ç”¨ cat åˆå¹¶æ—¶ï¼Œè¿™äº› prototype ä¸ä¸€å®šä¼šå‡ºç°åœ¨æˆ‘ä»¬æœŸæœ›çš„ç¨‹åºå¼€å§‹å¤„ï¼Œå³æ— æ³•åˆ©ç”¨ prototype å¯¹äºå‡½æ•°è°ƒç”¨è¿›è¡Œæ£€æŸ¥ï¼Œæ‰€ä»¥å¹²è„†ä¸å†™ prototypeã€‚ åœ¨ preprocessor å‡ºç°åï¼Œé€šè¿‡ #include è¿™ç±»è¯­æ³•å¹¶æ­é… preprocessor å¯ä»¥ä¿è¯å¯¹äºæ¯ä¸ªæºæ–‡ä»¶ï¼Œéƒ½å¯ä»¥é€šè¿‡ function prototype å¯¹å‡½æ•°è°ƒç”¨è¿›è¡Œå‚æ•°ä¸ªæ•°ã€ç±»å‹æ£€æŸ¥ï¼Œå› ä¸º #include è¯­å¥ä½äºæºæ–‡ä»¶èµ·å§‹å¤„ï¼Œå¹¶ä¸”æ­¤æ—¶ C è¯­è¨€ç¨‹åºçš„ç¼–è¯‘è¿‡ç¨‹æ”¹å˜äº†: å¯¹å•ä¸€æºæ–‡ä»¶è¿›è¡Œé¢„å¤„ç†ã€ç¼–è¯‘ï¼Œç„¶åå†å¯¹å¾—åˆ°çš„ç›®æ ‡æ–‡ä»¶è¿›è¡Œé“¾æ¥ã€‚æ‰€ä»¥æ­¤æ—¶é€è¿‡ preprocessor å¯ä»¥ä¿è¯ function prototype ä½äºå‡½æ•°è°ƒç”¨ä¹‹å‰ï¼Œå¯ä»¥è¿›è¡Œä¸¥æ ¼åœ°æ£€æŸ¥ã€‚ ","date":"2024-03-15","objectID":"/posts/c-function/:1:0","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"ç¼–ç¨‹è¯­è¨€çš„ function C è¯­è¨€ä¸å…è®¸ nested function ä»¥ç®€åŒ–ç¼–è¯‘å™¨çš„è®¾è®¡ (å½“ç„¶ç°åœ¨çš„ gcc æä¾› nested funtion çš„æ‰©å±•)ï¼Œå³ C è¯­è¨€çš„ function æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Œä½äºè¯­æ³•æœ€é¡¶å±‚ (top-level)ï¼Œå› ä¸ºæ”¯æŒ nested function éœ€è¦ staic link æœºåˆ¶æ¥ç¡®è®¤å¤–å±‚å‡½æ•°ã€‚ ç¼–ç¨‹è¯­è¨€ä¸­çš„å‡½æ•°ï¼Œä¸æ•°å­¦çš„å‡½æ•°ä¸å®Œå…¨ä¸€è‡´ï¼Œç¼–ç¨‹è¯­è¨€çš„å‡½æ•°éšå«äº†çŠ¶æ€æœºçš„è½¬æ¢è¿‡ç¨‹ (å³æœ‰ side effect)ï¼Œåªæœ‰æ‹¥æœ‰ Referential Transparency ç‰¹æ€§çš„å‡½æ•°ï¼Œæ‰èƒ½å’Œæ•°å­¦ä¸Šçš„å‡½æ•°ç­‰ä»·ã€‚ ","date":"2024-03-15","objectID":"/posts/c-function/:2:0","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"Process ä¸ C ç¨‹åº ç¨‹åºå­˜æ”¾åœ¨ç£ç›˜æ—¶å« Programï¼ŒåŠ è½½åˆ°å†…å­˜åå« â€œProcessâ€ Wikipedia: Application binary interface In computer software, an application binary interface (ABI) is an interface between two binary program modules. Often, one of these modules is a library or operating system facility, and the other is a program that is being run by a user. åœ¨ Intel x86 æ¶æ„ä¸­ï¼Œå½“è¿”å›å€¼å¯ä»¥æ”¾åœ¨å¯„å­˜å™¨æ—¶å°±æ”¾åœ¨å¯„å­˜å™¨ä¸­è¿”å›ï¼Œä»¥æé«˜æ•ˆèƒ½ï¼Œå¦‚æœæ”¾ä¸ä¸‹ï¼Œåˆ™å°†è¿”å›å€¼çš„èµ·å§‹åœ°å€æ”¾åœ¨å¯„å­˜å™¨ä¸­è¿”å›ã€‚ ","date":"2024-03-15","objectID":"/posts/c-function/:3:0","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"stack ","date":"2024-03-15","objectID":"/posts/c-function/:4:0","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"Layout System V Application Binary Interface AMD64 Architecture Processor Supplement [PDF] ","date":"2024-03-15","objectID":"/posts/c-function/:4:1","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"PEDA å®éªŒéœ€è¦ä½¿ç”¨åˆ° GDB çš„ PEDA æ‰©å±•: Enhance the display of gdb: colorize and display disassembly codes, registers, memory information during debugging. $ git clone https://github.com/longld/peda.git ~/peda $ echo \"source ~/peda/peda.py\" \u003e\u003e ~/.gdbinit æŠ€å·§ åŠ¨æ€è¿½è¸ª Stack å®éªŒçš„ call funcA å¯ä»¥é€šè¿‡ GDB æŒ‡ä»¤ stepi æˆ– si æ¥å®ç° ","date":"2024-03-15","objectID":"/posts/c-function/:4:2","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"ä»é€’å½’è§‚å¯Ÿå‡½æ•°è°ƒç”¨ int func(int x) { static int count = 0; int y = x; // local var return ++count \u0026\u0026 func(x++); } int main() { return func(0); } func å‡½æ•°åœ¨è°ƒç”¨æ—¶ï¼Œä¸€ä¸ªæ ˆå¸§çš„å†…å®¹åŒ…æ‹¬: x (parameter), y (local variable), return addressã€‚è¿™äº›æ•°æ®çš„ç±»å‹éƒ½æ˜¯ intï¼Œå³å æ®ç©ºé—´ç›¸åŒï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè®¡æ—¶å™¨ count çš„å˜åŒ–å¤§è‡´å‘ˆç° $x : \\frac{x}{2} : \\frac{x}{3}$ çš„æ¯”ä¾‹ã€‚ ","date":"2024-03-15","objectID":"/posts/c-function/:5:0","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"stack-based buffer overflow CVE-2015-7547 / è§£è¯´ vulnerability in glibcâ€™s DNS client-side resolver that is used to translate human-readable domain names, like google.com, into a network IP address. Wikipedia: Buffer overflow int evil() { system(\"/bin/sh\"); } int main() { char input[10]; puts(\"Input:\"); gets(input); puts(input); } éœ€è¦å‘ gcc æŒ‡å®š -fno-stack-protector å‚æ•°æ¥å…³é—­æ ˆå†…å­˜ä¿æŠ¤æœºåˆ¶ï¼Œè¦ä¸ç„¶æ— æ³•å®ç°æ ˆæº¢å‡ºæ”»å‡»: $ gcc -o bof -fno-stack-protector -g -no-pie bof.c è¯¥å®éªŒæœ¬è´¨ä¸Šæ˜¯åˆ©ç”¨äº†å‡½æ•°å†…å®šä¹‰çš„æ•°ç»„ï¼Œæ˜¯å­˜å‚¨åœ¨ stack ä¸Šï¼Œå¹¶ä¸”æ•°ç»„ä¸‹æ ‡å’Œå­˜å‚¨åœ°å€çš„å¯¹åº”å…³ç³»æ˜¯ã€Œå°/ä½ -\u003e å¤§/é«˜ã€å³ä¸‹æ ‡å°çš„æ•°ç»„å…ƒç´ ä½äºä½åœ°å€å¤„ï¼Œæ‰€ä»¥æ•°ç»„çš„å…ƒç´ æ˜¯ä»ä½åœ°å€å¾€é«˜åœ°å€å­˜å‚¨çš„ï¼Œè¿™å’Œ sp çš„æ–¹å‘åˆšå¥½ç›¸åï¼Œå¹¶ä¸”å¦‚æœä½¿ç”¨çš„æ˜¯ gets è¿™ç§ä¸å®‰å…¨å‡½æ•°ï¼Œå½“æ¥æ”¶çš„è¾“å…¥è¶…è¿‡å®šä¹‰çš„æ•°ç»„çš„é•¿åº¦æ—¶ï¼Œä¼šè¦†ç›–ä¸å±äºå®šä¹‰çš„æ•°ç»„ï¼Œå¹¶ä¸”æ¯”æ•°ç»„æ›´é«˜åœ°å€éƒ¨åˆ†çš„å†…å®¹ï¼Œè¿™å¯èƒ½ä¼šæ”¹å†™å½“å‰å‡½æ•°çš„è¿”å›åœ°å€ï¼Œä»è€Œå¯¼è‡´æ®µé”™è¯¯ã€‚ å› ä¸ºå¯ä»¥é€šè¿‡è¾“å…¥æ¥æ”¹å†™å½“å‰å‡½æ•°çš„è¿”å›åœ°å€ï¼Œé‚£ä¹ˆå°±å¯ä»¥æ„é€ ä¸€ä¸ªè¾“å…¥ä½¿å¾—å½“å‰ main ä¼šè¿”å›åˆ° evil å‡½æ•°ï¼Œè¿™éƒ¨åˆ†æ ¹æ®åŸæ–‡å®Œæˆå®éªŒå³å¯ã€‚ ","date":"2024-03-15","objectID":"/posts/c-function/:6:0","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"ROP ","date":"2024-03-15","objectID":"/posts/c-function/:7:0","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"heap ä½¿ç”¨ malloc æ—¶æ“ä½œç³»ç»Ÿå¯èƒ½ä¼š overcommitï¼Œè€Œæ­£å› ä¸ºè¿™ä¸ª overcommit çš„ç‰¹æ€§ï¼Œmalloc è¿”å›æœ‰æ•ˆåœ°å€ä¹Ÿä¸è§å¾—æ˜¯å®‰å…¨çš„ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œå› ä¸º overcommitï¼Œä½¿ç”¨ malloc åç«‹å³æ­é…ä½¿ç”¨ memset ä»£ä»·ä¹Ÿå¾ˆé«˜ (å› ä¸ºæ“ä½œç³»ç»Ÿ overcommit å¯èƒ½ä¼šå…ˆåˆ†é…ä¸€ä¸ªå°ç©ºé—´è€Œä¸æ˜¯ä¸€ä¸‹å­åˆ†é…å…¨éƒ¨ï¼Œå› ä¸ºå®ƒä¼˜å…ˆé‡å¤ä½¿ç”¨ä¹‹å‰å·²ä½¿ç”¨è¿‡çš„å°å—ç©ºé—´)ï¼Œå¹¶ä¸”å¦‚æœæ˜¯è®¾ç½®ä¸º 0ï¼Œåˆ™æœ‰å¯èƒ½ä¼šå¯¹åŸæœ¬ä¸º 0 çš„ç©ºé—´è¿›è¡Œé‡å¤è®¾ç½®ï¼Œé™ä½æ•ˆèƒ½ã€‚æ­¤æ—¶å¯ä»¥åº”è¯¥å–„ç”¨ callocï¼Œè™½ç„¶ä¹Ÿä¼š overcommitï¼Œä½†æ˜¯ä¼šä¿è¯åˆ†é…ç©ºé—´çš„å‰é¢éƒ½æ˜¯ 0 (å› ä¸ºä¼˜å…ˆåˆ†é…çš„æ˜¯éœ€è¦æ“ä½œç³»ç»Ÿå‚ä¸çš„å¤§å—ç©ºé—´)ï¼Œæ— éœ€ä½¿ç”¨ memset è¿™ç±»æ“ä½œè€Œé™ä½æ•ˆèƒ½ã€‚ ","date":"2024-03-15","objectID":"/posts/c-function/:8:0","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"malloc / free ","date":"2024-03-15","objectID":"/posts/c-function/:8:1","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"RAII ","date":"2024-03-15","objectID":"/posts/c-function/:9:0","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["C","Linux Kernel Internals"],"content":"setjmp \u0026 longjmp setjmp(3) â€” Linux manual page The functions described on this page are used for performing â€œnonlocal gotosâ€: transferring execution from one function to a predetermined location in another function. The setjmp() function dynamically establishes the target to which control will later be transferred, and longjmp() performs the transfer of execution. å…·ä½“è§£è¯´å¯ä»¥é˜…è¯» lab0-c çš„ã€Œè‡ªå‹•æ¸¬è©¦ç¨‹å¼ã€éƒ¨åˆ† ","date":"2024-03-15","objectID":"/posts/c-function/:10:0","tags":["Sysprog","C","Function"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°è°ƒç”¨ç¯‡","uri":"/posts/c-function/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":" å¤šåŸ·è¡Œç·’ç’°å¢ƒä¸‹ï¼Œç¨‹å¼æœƒå‡ºå•é¡Œï¼Œå¾€å¾€åœ¨æ–¼åŸ·è¡Œé †åºçš„ä¸ç¢ºå®šæ€§ã€‚ä¸€æ—¦é¡§åŠåˆ†æ•£å¼ç³»çµ± (distributed systems)ï¼ŒåŸ·è¡Œé †åºå’Œè¡ç”Ÿçš„æ™‚åº (timing) å•é¡Œæ›´åŠ è¤‡é›œã€‚ æˆ‘å€‘å°‡å¾å¦‚ä½•å®šç¾©ç¨‹å¼åŸ·è¡Œçš„é †åºé–‹å§‹èªªèµ·ï¼Œç‚ºäº†ç°¡å–®èµ·è¦‹ï¼Œæˆ‘å€‘å…ˆå¾å–®åŸ·è¡Œç·’çš„è§€é»ä¾†çœ‹åŸ·è¡Œé †åºé€™ä»¶äº‹ï¼Œå…¶ä¸­æœ€é—œéµçŸ¥è­˜å°±æ˜¯ Sequenced-beforeï¼Œä½ å°‡æœƒç™¼ç¾å°±é€£å–®åŸ·è¡Œç·’çš„ç¨‹å¼ï¼Œä¹Ÿå¯èƒ½æœƒç”¢ç”Ÿä¸ç¢ºå®šçš„åŸ·è¡Œé †åºã€‚ åŸæ–‡åœ°å€ ","date":"2024-03-11","objectID":"/posts/concurrency-ordering/:0:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº","uri":"/posts/concurrency-ordering/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Evaluation æ‰€è¬‚æ±‚å€¼ (Evaluation)ï¼Œå…¶å¯¦æŒ‡äºŒä»¶äº‹æƒ…ï¼Œä¸€æ˜¯ value computationsï¼Œå°ä¸€ä¸²é‹ç®—å¼è¨ˆç®—çš„çµæœï¼›å¦ä¸€æ˜¯ side effectï¼Œäº¦å³ä¿®æ”¹ç‰©ä»¶ç‹€æ…‹ï¼Œåƒæ˜¯ä¿®æ”¹è¨˜æ†¶é«”å…§è®Šæ•¸çš„å€¼ã€å‘¼å«å‡½å¼åº«çš„ I/O è™•ç†å‡½å¼ä¹‹é¡çš„æ“ä½œã€‚ ","date":"2024-03-11","objectID":"/posts/concurrency-ordering/:1:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº","uri":"/posts/concurrency-ordering/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Sequenced-before sequenced-before æ˜¯ç¨®å° åŒä¸€å€‹åŸ·è¡Œç·’ ä¸‹ï¼Œæ±‚å€¼é †åºé—œä¿‚çš„æè¿°ã€‚ è‹¥ A is sequenced-before Bï¼Œä»£è¡¨ A çš„æ±‚å€¼æœƒå…ˆå®Œæˆï¼Œæ‰é€²è¡Œå° B çš„æ±‚å€¼ è‹¥ A is not sequenced before B è€Œä¸” B is sequenced before Aï¼Œä»£è¡¨ B çš„æ±‚å€¼æœƒå…ˆå®Œæˆï¼Œæ‰é–‹å§‹å° A çš„æ±‚å€¼ã€‚ è‹¥ A is not sequenced before B è€Œä¸” B is not sequenced before Aï¼Œä»£è¡¨å…©ç¨®å¯èƒ½ï¼Œä¸€ç¨®æ˜¯é †åºä¸å®šï¼Œç”šè‡³é€™å…©è€…çš„æ±‚å€¼éç¨‹å¯èƒ½æœƒé‡ç–Šï¼ˆå› ç‚º CPU é‡æ’æŒ‡ä»¤äº¤éŒ¯çš„é—œä¿‚ï¼‰æˆ–ä¸é‡ç–Šã€‚ è€Œç¨‹å¼èªè¨€çš„å·¥ä½œï¼Œå°±æ˜¯å®šç¾©ä¸€é€£ä¸²é—œæ–¼ sequenced-before çš„è¦ç¯„ï¼Œèˆ‰ä¾‹ä¾†èªªï¼š ä»¥ä¸‹æåˆ°çš„å…ˆæ–¼ã€å…ˆé€²è¡Œä¹‹é¡çš„ç”¨è©ï¼Œå…¨éƒ¨çš„æ„æ€éƒ½æ˜¯ sequenced-beforeï¼Œä¹Ÿå°±æ˜¯ã€Œå…ˆå®Œæˆä¹‹å¾Œæ‰é–‹å§‹é€²è¡Œã€ i++ é€™é¡çš„å¾Œç½®é‹ç®—å­ï¼Œvalue computation æœƒå…ˆæ–¼ side effect å°æ–¼ assignment operator è€Œè¨€ (=, +=, -= ä¸€é¡)ï¼Œæœƒå…ˆé€²è¡Œé‹ç®—å…ƒçš„ value computationï¼Œä¹‹å¾Œæ‰æ˜¯ assignment çš„ side effectï¼Œæœ€å¾Œæ˜¯æ•´å€‹ assignment expression çš„ value computationã€‚ è™½ç„¶è§„æ ¼ä¹¦å®šä¹‰äº†å…³äº sequenced-before çš„è§„èŒƒï¼Œä½†ä¸å¯èƒ½é¢é¢ä¿±åˆ°ï¼Œè¿˜æ˜¯å­˜åœ¨æœ‰äº›æ‰§è¡Œé¡ºåºæ˜¯æœªå®šä¹‰çš„ï¼Œä¾‹å¦‚ f1() + f2() + f3()ï¼Œè§„æ ¼ä¹¦åªè§„å®šäº† + æ“ä½œæ˜¯åœ¨å¯¹ f1(), f2(), f3() æ±‚å€¼ä¹‹åè¿›è¡Œçš„ï¼Œä½†æ˜¯å¯¹äºæ±‚å€¼æ—¶çš„ f1() è¿™ç±»å‡½æ•°å‘¼å«ï¼Œå¹¶æ²¡æœ‰è§„å®šå“ªä¸ªå‡½æ•°å…ˆè¿›è¡Œè°ƒç”¨æ±‚å€¼ï¼Œæ‰€ä»¥åœ¨æ±‚å€¼æ—¶ç¬¬ä¸€ä¸ªè°ƒç”¨çš„å¯èƒ½æ˜¯ f1() æˆ– f2() æˆ– f3()ã€‚ sequenced-before çš„è§„èŒƒç¼ºå¤±å¯¼è‡´äº† partial order åœºæ™¯çš„å‡ºç°ï¼ŒäºŒè¿™å¯èƒ½ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼Œä¾‹å¦‚ç»å…¸çš„å¤´è„‘ä½“æ“ i = i++ï¼š å‡ºç°è¿™ä¸ªæœªå®šä¹‰è¡Œä¸ºçš„åŸå› æ˜¯ï¼Œi++ çš„ side effect ä¸ = ä¹‹é—´ä¸å­˜åœ¨ sequenced-bofore å…³ç³» (å› ä¸º partial order)ï¼Œè€Œè¿™ä¼šå¯¼è‡´è¯¥è¯­å¥çš„æ‰§è¡Œç»“æœæ˜¯ä¸ç¡®å®šçš„ (æ²¡æƒ³åˆ°å§ï¼Œå•çº¿ç¨‹çš„ç¨‹åºä½ ä¹Ÿæœ‰å¯èƒ½ä¸ç¡®å®šæ‰§è¡Œé¡ºåº ğŸ¤£) è­¦å‘Š æ³¨æ„: åœ¨ C++17 å¾Œï¼Œä¸Šæ–¹æ•˜è¿°ä¸æ˜¯æœªå®šç¾©è¡Œç‚º å‡è¨­ i åˆå§‹å€¼ç‚º 0ï¼Œç”±æ–¼ = åœ¨ C++17 å¾Œç‚º sequencedï¼Œå› æ­¤ i++ çš„è¨ˆç®—èˆ‡ side effect éƒ½æœƒå…ˆå®Œæˆï¼Œæ‰€ä»¥ i++ å¾—åˆ° 0ï¼Œéš¨å¾Œ side-effect å°è‡´ i éå¢ 1ï¼Œå› æ­¤æ­¤æ™‚ i ç‚º 1ï¼›ä¹‹å¾ŒåŸ·è¡Œ i = é€™é‚Šï¼Œæ‰€ä»¥åˆ©ç”¨å³å´è¡¨é”å¼çš„å€¼ä¾†æŒ‡å®šæ•¸å€¼ï¼Œäº¦å³å‰›æ‰çš„ 0ï¼Œå› æ­¤ i æœ€å¾Œçµæœç‚º 0ã€‚ æ‰€ä»¥ i å€¼è½‰è®Šçš„é †åºç‚º $0 \\rightarrow 1 \\rightarrow 0$ï¼Œç¬¬ä¸€å€‹ç®­é ­ç‚º side effect é€ æˆçš„çµæœï¼Œç¬¬äºŒå€‹å‰‡æ˜¯ = é€ æˆçš„çµæœã€‚ C++ sequenced-before graphs Order of evaluation from cppreference What are sequence points, and how do they relate to undefined behavior? ","date":"2024-03-11","objectID":"/posts/concurrency-ordering/:2:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº","uri":"/posts/concurrency-ordering/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Happens-before çŸ­ç‰‡: Happened Before Relationship Happened Before Relation (cont) ä»ä¸Šå›¾å¯ä»¥çœ‹å‡º happens-before å…¶å®å°±æ˜¯åœ¨ sequenced-before åŸºç¡€ä¸Šå¢åŠ äº†å¤šæ‰§è¡Œç»ª communication æƒ…å½¢ï¼Œå¯ä»¥ç†è§£ä¸º happens-before å°† sequenced-before æ‰©å¤§åˆ°æ¶µç›–å¤šæ‰§è¡Œç»ªçš„æƒ…å½¢äº†ï¼Œå³æ‰§è¡Œé¡ºåºæœ‰å…ˆåæ¬¡åº (æ‰§è¡Œé¡ºåºå…¶å®ä¸å¤ªå‡†ç¡®ï¼Œæ‰§è¡Œç»“æœæ˜¾ç° çš„å…ˆåæ¬¡åºæ›´åŠ å‡†ç¡® ğŸ¤£) å›¾ä¸­çš„ concurrent events å…¶å®å°±æ˜¯å¤šæ‰§è¡Œç»ªä¸‹æ²¡æœ‰å…ˆåæ¬¡åºçš„æƒ…å½¢ Java è§„æ ¼ä¹¦ 17.4.5. Happens-before Order ä¹Ÿèƒ½ä½è¯æˆ‘ä»¬çš„è§‚ç‚¹: If one action happens-before another, then the first is visible to and ordered before the second. å¼•ç”¨ æ›è¨€ä¹‹ï¼Œè‹¥æœ›æ–‡ç”Ÿç¾©èªª â€œHappens-Beforeâ€ æ˜¯ã€Œå…ˆè¡Œç™¼ç”Ÿã€ï¼Œé‚£å°±å—è½…åŒ—è½ã€‚Happens-Before ä¸¦éèªªå‰ä¸€æ“ä½œç™¼ç”Ÿåœ¨å¾ŒçºŒæ“ä½œçš„å‰é¢ï¼Œå®ƒçœŸæ­£è¦è¡¨é”çš„æ˜¯ï¼šã€Œå‰é¢ä¸€å€‹æ“ä½œçš„æ•ˆæœå°å¾ŒçºŒæ“ä½œæ˜¯ å¯è¦‹ã€ã€‚ é€™è£¡çš„é—œéµæ˜¯ï¼ŒHappens-before å¼·èª¿ visibleï¼Œè€Œéå¯¦éš›åŸ·è¡Œçš„é †åºã€‚ å¯¦éš›ç¨‹å¼åœ¨åŸ·è¡Œæ™‚ï¼Œåªéœ€è¦ã€Œçœ‹èµ·ä¾†æœ‰é€™æ¨£çš„æ•ˆæœã€å³å¯ï¼Œç·¨è­¯å™¨æœ‰å¾ˆå¤§çš„ç©ºé–“å¯èª¿æ•´ç¨‹å¼åŸ·è¡Œé †åºï¼Œäº¦å³ compile-time memory orderingã€‚ å› æ­¤æˆ‘å€‘å¾—çŸ¥ä¸€å€‹é—œéµæ¦‚å¿µ: A happens-before B ä¸ä»£è¡¨å¯¦éš›ä¸Š A happening before B (æ³¨æ„æ™‚æ…‹ï¼Œå¾Œè€…å¼·èª¿é€²è¡Œä¸­ï¼Œå‰è€…å‰‡æ˜¯å¾çµæœä¾†çœ‹)ï¼Œäº¦å³åªè¦ A çš„æ•ˆæœåœ¨ B åŸ·è¡Œä¹‹å‰ï¼Œå°æ–¼ B æ˜¯ visible å³å¯ï¼Œå¯¦éš›çš„åŸ·è¡Œé †åºä¸ç”¨ç´°ç©¶ã€‚ C11 æ­£å¼å°†å¹¶è¡Œå’Œ memory order ç›¸å…³çš„è§„èŒƒå¼•å…¥åˆ°è¯­è¨€çš„æ ‡å‡†: 5.1.2.4 Multi-threaded executions and data races All modifications to a particular atomic object M occur in some particular total order, called the modification order of M. If A and B are modifications of an atomic object M, and A happens before B, then A shall precede B in the modification order of M, which is defined below. cppreference std::memory_order Regardless of threads, evaluation A happens-before evaluation B if any of the following is true: A is sequenced-before B A inter-thread happens before B å¼•ç”¨ é€šå¸¸ç¨‹å¼é–‹ç™¼è€…é€è¡Œæ’°å¯«ç¨‹å¼ï¼ŒæœŸæœ›å‰ä¸€è¡Œçš„æ•ˆæœæœƒå½±éŸ¿åˆ°å¾Œä¸€è¡Œçš„ç¨‹å¼ç¢¼ã€‚ç¨æ—©å·²è§£é‡‹ä½•è¬‚ Sequenced-beforeï¼Œç¾åœ¨å¯æ³¨æ„åˆ°ï¼ŒSequenced-before å¯¦éš›å°±æ˜¯åŒä¸€å€‹åŸ·è¡Œç·’å…§çš„ happens-before é—œä¿‚ã€‚ åœ¨å¤šæ‰§è¡Œç»ªæƒ…å†µä¸‹ï¼Œå¦‚æœæ²¡æ³•ç¡®ä¿ happens-before å…³ç³»ï¼Œç¨‹åºå¾€å¾€ä¼šäº§ç”Ÿæ„æ–™ä¹‹å¤–çš„ç»“æœï¼Œä¾‹å¦‚: int counter = 0; å¦‚æœç°åœ¨æœ‰ä¸¤ä¸ªæ‰§è¡Œç»ªåœ¨åŒæ—¶æ‰§è¡Œï¼Œæ‰§è¡Œç»ª A æ‰§è¡Œ counter++ï¼Œæ‰§è¡Œç»ª B å°† counter çš„å€¼æ‰“å°å‡ºæ¥ã€‚å› ä¸º A å’Œ B ä¸¤ä¸ªæ‰§è¡Œç»ªä¸å…·å¤‡ happens-before å…³ç³»ï¼Œæ²¡æœ‰ä¿è¯ counter++ åçš„æ•ˆæœå¯¹æ‰“å° counter æ˜¯å¯è§çš„ï¼Œå¯¼è‡´æ‰“å°å‡ºæ¥çš„å¯èƒ½æ˜¯ 1 ä¹Ÿå¯èƒ½æ˜¯ 0ï¼Œè¿™ä¸ªä¹Ÿå°±æ˜¯å›¾ä¸­çš„ concurrent events å…³ç³»ã€‚ å¼•ç”¨ å› æ­¤ï¼Œç¨‹å¼èªè¨€å¿…é ˆæä¾›é©ç•¶çš„æ‰‹æ®µï¼Œè®“ç¨‹å¼é–‹ç™¼è€…å¾—ä»¥å»ºç«‹è·¨è¶ŠåŸ·è¡Œç·’é–“çš„ happens-before çš„é—œä¿‚ï¼Œå¦‚æ­¤ä¸€ä¾†æ‰èƒ½ç¢ºä¿ç¨‹å¼åŸ·è¡Œçš„çµæœæ­£ç¢ºã€‚ ","date":"2024-03-11","objectID":"/posts/concurrency-ordering/:3:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº","uri":"/posts/concurrency-ordering/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"The Happens-Before Relation The Happens-Before Relation Let A and B represent operations performed by a multithreaded process. If A happens-before B, then the memory effects of A effectively become visible to the thread performing B before B is performed. No matter which programming language you use, they all have one thing in common: If operations A and B are performed by the same thread, and Aâ€™s statement comes before Bâ€™s statement in program order, then A happens-before B. Happens-Before Does Not Imply Happening Before In this case, though, the store to A doesnâ€™t actually influence the store to B. (2) still behaves the same as it would have even if the effects of (1) had been visible, which is effectively the same as (1)â€™s effects being visible. Therefore, this doesnâ€™t count as a violation of the happens-before rule. Happening Before Does Not Imply Happens-Before The happens-before relationship only exists where the language standards say it exists. And since these are plain loads and stores, the C++11 standard has no rule which introduces a happens-before relation between (2) and (3), even when (3) reads the value written by (2). è¿™é‡Œè¯´çš„ happens-before å…³ç³»å¿…é¡»è¦åœ¨è¯­è¨€æ ‡å‡†ä¸­æœ‰è§„å®šçš„æ‰ç®—ï¼Œå•æ‰§è¡Œç»ªçš„æƒ…å†µè‡ªç„¶åœ¨æ ‡å‡†å†…ï¼Œå¤šæ‰§è¡Œç»ªçš„æƒ…å†µï¼Œæ ‡å‡†ä¸€èˆ¬ä¼šåˆ¶å®šç›¸å…³çš„åŒæ­¥åŸè¯­ä¹‹é—´çš„ happens-before å…³ç³»ï¼Œä¾‹å¦‚å¯¹ mutex çš„è¿ç»­ä¸¤ä¸ªæ“ä½œå¿…ç„¶æ˜¯ happens-before å…³ç³»ï¼Œæ›´å¤šçš„ä¾‹å­è§åé¢çš„ synchronized-with éƒ¨åˆ†ã€‚ ","date":"2024-03-11","objectID":"/posts/concurrency-ordering/:3:1","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº","uri":"/posts/concurrency-ordering/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Synchronized-with å¼•ç”¨ synchronized-with æ˜¯å€‹ç™¼ç”Ÿåœ¨äºŒå€‹ä¸åŒåŸ·è¡Œç·’é–“çš„åŒæ­¥è¡Œç‚ºï¼Œç•¶ A synchronized-with B æ™‚ï¼Œä»£è¡¨ A å°è¨˜æ†¶é«”æ“ä½œçš„æ•ˆæœï¼Œå°æ–¼ B æ˜¯å¯è¦‹çš„ã€‚è€Œ A å’Œ B æ˜¯äºŒå€‹ä¸åŒçš„åŸ·è¡Œç·’çš„æŸå€‹æ“ä½œã€‚ ä¸é›£ç™¼ç¾ï¼Œå…¶å¯¦ synchronized-with å°±æ˜¯è·¨è¶Šå¤šå€‹åŸ·è¡Œç·’ç‰ˆæœ¬çš„ happens-beforeã€‚ ","date":"2024-03-11","objectID":"/posts/concurrency-ordering/:4:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº","uri":"/posts/concurrency-ordering/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"ä» Java åˆ‡å…¥ synchronized å…³é”®å­— å¼•ç”¨ Mutual Exclusive å°åŒä¸€å€‹ç‰©ä»¶è€Œè¨€ï¼Œä¸å¯èƒ½æœ‰äºŒå€‹å‰ç¶´ synchronized çš„æ–¹æ³•åŒæ™‚äº¤éŒ¯åŸ·è¡Œï¼Œç•¶ä¸€å€‹åŸ·è¡Œç·’æ­£åœ¨åŸ·è¡Œå‰ç¶´ synchronized çš„æ–¹æ³•æ™‚ï¼Œå…¶ä»–æƒ³åŸ·è¡Œ synchronized æ–¹æ³•çš„åŸ·è¡Œç·’æœƒè¢«é˜»æ“‹ (block)ã€‚ ç¢ºç«‹ Happens-before é—œä¿‚ å°åŒä¸€å€‹ç‰©ä»¶è€Œè¨€ï¼Œç•¶ä¸€å€‹åŸ·è¡Œç·’é›¢é–‹ synchronized æ–¹æ³•æ™‚ï¼Œæœƒè‡ªå‹•å°æ¥ä¸‹ä¾†å‘¼å« synchronized æ–¹æ³•çš„åŸ·è¡Œç·’å»ºç«‹ä¸€å€‹ Happens-before é—œä¿‚ï¼Œå‰ä¸€å€‹ synchronized çš„æ–¹æ³•å°è©²ç‰©ä»¶æ‰€åšçš„ä¿®æ”¹ï¼Œä¿è­‰å°æ¥ä¸‹ä¾†é€²å…¥ synchronized æ–¹æ³•çš„åŸ·è¡Œç·’å¯è¦‹ã€‚ volatile å…³é”®å­— å¼•ç”¨ A write to a volatile field happens-before every subsequent read of that same volatile thread create/join ","date":"2024-03-11","objectID":"/posts/concurrency-ordering/:4:1","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº","uri":"/posts/concurrency-ordering/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"C++ çš„è§‚ç‚¹ The library defines a number of atomic operations and operations on mutexes that are specially identified as synchronization operations. These operations play a special role in making assignments in one thread visible to another. åˆæ˜¯ visible è¯´æ˜å¼ºè°ƒçš„è¿˜æ˜¯ happens-before è¿™ä¸€å…³ç³» ğŸ¤£ #include \u003ciostream\u003e // std::cout #include \u003cthread\u003e // std::thread #include \u003cmutex\u003e // std::mutex std::mutex mtx; // mutex for critical section int count = 0; void print_thread_id (int id) { // critical section (exclusive access to std::cout signaled by locking mtx): mtx.lock(); std::cout \u003c\u003c \"thread #\" \u003c\u003c id \u003c\u003c \" count:\" \u003c\u003c count \u003c\u003c '\\n'; count++; mtx.unlock(); } int main () { std::thread threads[10]; // spawn 10 threads: for (int i=0; i\u003c10; ++i) threads[i] = std::thread(print_thread_id,i+1); for (auto\u0026 th : threads) th.join(); return 0; } è¿™æ®µç¨‹åºé‡Œæ¯ä¸ªæ‰§è¡Œçš„ thread ä¹‹é—´éƒ½æ˜¯ happens-before / synchronized-with å…³ç³»ï¼Œå› ä¸ºå®ƒä»¬çš„æ‰§è¡Œä½“éƒ½è¢« mutex åŒ…è£¹äº†ï¼Œè€Œå¯¹ mutex çš„æ“ä½œæ˜¯ happens-before å…³ç³»çš„ã€‚å¦‚æœæ²¡æœ‰ä½¿ç”¨ mutexï¼Œé‚£ä¹ˆ thread ä¹‹é—´ä¸å­˜åœ¨ happens-before å…³ç³»ï¼Œæ‰“å°å‡ºæ¥çš„å†…å®¹ä¹Ÿæ˜¯ä¹±ä¸ƒå…«ç³Ÿçš„ã€‚ cppreference std::mutex cplusplus std::mutex::lock ","date":"2024-03-11","objectID":"/posts/concurrency-ordering/:4:2","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº","uri":"/posts/concurrency-ordering/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"æ·±å…¥ Synchronizes-with The Synchronizes-With Relation ","date":"2024-03-11","objectID":"/posts/concurrency-ordering/:4:3","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº","uri":"/posts/concurrency-ordering/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Memory Consistency Models æŠ€å·§ ç›¸å…³è®ºæ–‡ / æŠ€æœ¯æŠ¥å‘Š (å¯ä»¥ç”¨æ¥å‚è€ƒç†è§£): Shared Memory Consistency Models: A Tutorial 1995 Sarita V. Adve, Kourosh Gharachorloo é€™æ¨£çš„å¹»è±¡è¦æˆç«‹ï¼Œåœ¨æ–¼ç¨‹å¼è¨­è¨ˆå¸«å’Œè©²ç³»çµ±ï¼ˆç¡¬é«”ã€ç·¨è­¯å™¨ç­‰ç”¢ç”Ÿã€åŸ·è¡Œç¨‹å¼çš„å¹³å°ï¼‰é”æˆä¸€è‡´çš„å”å®šï¼Œç³»çµ±ä¿è­‰ç¨‹å¼è¨­è¨ˆå¸«åªè¦ç…§è‘—è¦å‰‡èµ°ï¼Œç¨‹å¼åŸ·è¡Œçµæœæœƒæ˜¯æ­£ç¢ºçš„ã€‚ ä½†ä»€æ¨£å«åšæ­£ç¢ºï¼Ÿæ­£ç¢ºçš„æ„æ€ä¸æ˜¯ä¿è­‰åªæœƒç™¼ç”Ÿä¸€ç¨®åŸ·è¡Œçµæœï¼Œè€Œæ˜¯å®šç¾©åœ¨æ‰€æœ‰å¯èƒ½ç™¼ç”Ÿçš„åŸ·è¡Œçµæœä¸­ï¼Œå“ªäº›æ˜¯å…è¨±çš„ã€‚æˆ‘å€‘æŠŠé€™æ¨£çš„ç´„å®šç¨±ç‚º Memory Consistency Modelsï¼Œç³»çµ±è¦æƒ³è¾¦æ³•åœ¨ä¿è­‰æ­£ç¢ºçš„æƒ…æ³ä¸‹ï¼Œç›¡å¯èƒ½çš„æœ€ä½³åŒ–ï¼Œè®“ç¨‹å¼è·‘çš„åˆå¿«åˆå¥½ã€‚ ç¨‹åºæ•ˆèƒ½æé«˜çš„ä»£ä»·æ˜¯å†™ç¨‹åºå˜å¾—å›°éš¾ï¼Œå› ä¸ºéœ€è¦éµå®ˆä¸Šé¢æ‰€è°“çš„è§„åˆ™ ","date":"2024-03-11","objectID":"/posts/concurrency-ordering/:5:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº","uri":"/posts/concurrency-ordering/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Sequential Consistency Leslie Lamport A multiprocessor system is sequentially consistent if the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program. å¯¹äºæ¯ä¸ªç‹¬ç«‹çš„å¤„ç†å•å…ƒï¼Œæ‰§è¡Œæ—¶éƒ½ç»´æŒç¨‹åºçš„é¡ºåº (Program Order) æ•´ä¸ªç¨‹åºä»¥æŸç§é¡ºåºåœ¨æ‰€æœ‰å¤„ç†å™¨ä¸Šæ‰§è¡Œ Lamport çš„å®šç¾©ç›¸ç•¶æ´—éŠï¼šç¬¬ä¸€é»è¨€æ˜ç¨‹å¼åœ¨è™•ç†å™¨å…§æœƒç…§é †åºåŸ·è¡Œï¼Œç¬¬äºŒé»å‰‡èªªæ‰€æœ‰è™•ç†å™¨æœƒä»¥æŸç¨®é †åºåŸ·è¡Œç¨‹å¼ã€‚çœ‹ä¼¼å¹³å¯¦çš„è©±èªï¼Œä½†çœŸå¯¦ä¸–ç•Œå»å¯èƒ½ä¸æ˜¯é€™æ¨£ã€‚ ","date":"2024-03-11","objectID":"/posts/concurrency-ordering/:5:1","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº","uri":"/posts/concurrency-ordering/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Weak Memory Model vs. Strong Memory Model","date":"2024-03-11","objectID":"/posts/concurrency-ordering/:5:2","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ‰§è¡Œé¡ºåº","uri":"/posts/concurrency-ordering/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":" é€è¿‡å»ºç«‹ Concurrency å’Œ Parallelismã€Mutex ä¸ Semaphore çš„åŸºæœ¬æ¦‚å¿µï¼Œæœ¬è®²åº§å°†é€è¿‡ POSIX Tread æ¢è®¨ thread pool, Lock-Free Programming, lock-free ä½¿ç”¨çš„ atomic æ“ä½œ, memory ordering, M:N threading model ç­‰è¿›é˜¶è®®é¢˜ã€‚ åŸæ–‡åœ°å€ ","date":"2024-03-08","objectID":"/posts/concurrency-concepts/:0:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ¦‚å¿µ","uri":"/posts/concurrency-concepts/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Mutex ä¸ Semaphore Mutex å’Œ Semaphore åœ¨å®ä½œä¸Šå¯èƒ½æ˜¯æ²¡æœ‰å·®å¼‚çš„ (ä¾‹å¦‚æ—©æœŸçš„ Linux)ï¼Œä½†æ˜¯ Mutex ä¸ Semaphore åœ¨ä½¿ç”¨ä¸Šæ˜¯æœ‰æ˜¾è‘—å·®å¼‚çš„: process ä½¿ç”¨ Mutex å°±åƒä½¿ç”¨ä¸€æŠŠé”ï¼Œè°å…ˆè·‘å¾—å¿«å°±èƒ½å…ˆè·å¾—é”ï¼Œé‡Šæ”¾é” â€œè§£é“ƒè¿˜é¡»ç³»é“ƒäººâ€ï¼Œå¹¶ä¸”é‡Šæ”¾é”åä¸ä¸€å®šèƒ½ç«‹å³è°ƒåº¦åˆ°ç­‰å¾…é”çš„ process (å¦‚æœæƒ³ç«‹å³è°ƒåº¦åˆ°ç­‰å¾…é”çš„ process éœ€è¦è¿›è¡Œæ˜¾å¼è°ƒåº¦) process ä½¿ç”¨ Semaphore å°±å¦‚åŒå®ƒçš„åå­—ç±»ä¼¼ â€œä¿¡å·æªâ€ï¼Œprocess è¦ä¹ˆæ˜¯ç­‰å¾…ä¿¡å·çš„é€‰æ‰‹ï¼Œè¦ä¹ˆæ˜¯å‘å‡ºä¿¡å·çš„è£åˆ¤ï¼Œå¹¶ä¸”è£åˆ¤åœ¨å‘å‡ºä¿¡å·åï¼Œé€‰æ‰‹å¯ä»¥ç«‹å³æ”¶åˆ°ä¿¡å·å¹¶è°ƒåº¦ (æ— éœ€æ˜¾å¼è°ƒåº¦)ã€‚å¹¶ä¸æ˜¯ä½ è·‘å¾—å¿«å°±å¯ä»¥å…ˆè·å¾—ï¼Œå¦‚æœä½ æ˜¯é€‰æ‰‹ï¼Œè·‘å¾—å¿«ä½ ä¹Ÿå¾—åœä¸‹æ¥ç­‰è£åˆ¤åˆ°åœºå‘å‡ºä¿¡å· ğŸ¤£ æ³¨æ„ å…³äº Mutex ä¸ Semphore åœ¨ä½¿ç”¨æ‰‹æ³•ä¸Šçš„å·®å¼‚ï¼Œå¯ä»¥å‚è€ƒæˆ‘ä½¿ç”¨ Rust å®ç°çš„ Channelï¼Œé‡Œé¢çš„ Share\u003cT\u003e ç»“æ„ä½“åŒ…å«äº† Mutex å’Œ Semphoreï¼ŒæŸ¥çœ‹ç›¸å…³æ–¹æ³• (send å’Œ recv) æ¥ç ”ç©¶å®ƒä»¬åœ¨ä½¿ç”¨æ‰‹æ³•çš„å·®å¼‚ã€‚ é™¤æ­¤ä¹‹å¤–ï¼ŒSemaphore çš„é€‰æ‰‹å’Œè£åˆ¤çš„æ•°é‡æ¯”ä¾‹ä¸ä¸€å®šæ˜¯ $1:1$ï¼Œå¯ä»¥æ˜¯ $m:n$ ","date":"2024-03-08","objectID":"/posts/concurrency-concepts/:1:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ¦‚å¿µ","uri":"/posts/concurrency-concepts/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"CTSS Fernando J. Corbato: 1963 Timesharing: A Solution to Computer Bottlenecks ","date":"2024-03-08","objectID":"/posts/concurrency-concepts/:2:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ¦‚å¿µ","uri":"/posts/concurrency-concepts/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"å¯é‡å…¥æ€§ (Reentrancy) ä¸€å€‹å¯å†é€²å…¥ (reentrancy) çš„å‡½å¼æ˜¯å¯è¢«å¤šå€‹å·¥ä½œåŒæ™‚å‘¼å«ï¼Œè€Œä¸æœƒæœ‰è³‡æ–™ä¸ä¸€è‡´çš„å•é¡Œã€‚ç°¡å–®ä¾†èªªï¼Œä¸€å€‹å¯å†é€²å…¥çš„å‡½å¼ï¼Œæœƒé¿å…åœ¨å‡½å¼ä¸­ä½¿ç”¨ä»»ä½•å…±äº«è¨˜æ†¶å€ (global memory)ï¼Œæ‰€æœ‰çš„è®Šæ•¸èˆ‡è³‡æ–™å‡å­˜åœ¨å‘¼å«è€…çš„è³‡æ–™å€æˆ–å‡½å¼æœ¬èº«çš„å †ç–Šå€ (stack memory)ã€‚ ","date":"2024-03-08","objectID":"/posts/concurrency-concepts/:3:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ¦‚å¿µ","uri":"/posts/concurrency-concepts/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"ç»å…¸çš„ Fork-join æ¨¡å‹ $\\rightarrow$ $\\rightarrow$ $\\rightarrow$ Fork-join Parallelism Fork/join model ä»å›¾ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œè®¾å®šä¸€ä¸ª join ç‚¹æ˜¯éå¸¸å¿…è¦çš„ (é€šå¸¸æ˜¯ç”±ä¸»æ‰§è¡Œç»ªå¯¹ join ç‚¹è¿›è¡Œè®¾ç½®)ï¼Œå› ä¸º fork ä¹‹åæ–°å¢çš„æ‰§è¡Œç»ªæœ‰å¯èƒ½ç«‹åˆ»å°±æ‰§è¡Œå®Œæ¯•äº†ï¼Œç„¶åå½“ä¸»æ‰§è¡Œç»ªåˆ°è¾¾ join ç‚¹æ—¶ï¼Œå³å¯ join æ“ä½œè¿›è¡Œä¸‹ä¸€æ­¥ï¼Œä¹Ÿæœ‰å¯èƒ½ fork ä¹‹åæ–°å¢çš„æ‰§è¡Œç»ªæ˜¯æƒ°æ€§çš„ï¼Œå®ƒä»¬åªæœ‰å½“ä¸»æ‰§è¡Œç»ªåˆ°è¾¾ join ç‚¹æ—¶ï¼Œæ‰ä¼šå¼€å§‹æ‰§è¡Œç›´åˆ°å®Œæ¯•ï¼Œå³ä¸»æ‰§è¡Œç»ªå…ˆæŠµè¾¾ join ç‚¹ç­‰å¾…å…¶å®ƒæ‰§è¡Œç»ªå®Œæˆæ‰§è¡Œï¼Œä»è€Œå®Œæˆ join æ“ä½œæ¥ç€è¿›è¡Œä¸‹ä¸€æ­¥ã€‚ å› ä¸º fork æ“ä½œæ—¶åˆ†å‰å¤„çš„æ‰§è¡Œç»ªçš„æ‰§è¡Œæµç¨‹ï¼Œå¯¹äºä¸»æ‰§è¡Œç»ªæ˜¯æ— æ³•é¢„æµ‹çš„ (ç«‹åˆ»æ‰§è¡Œã€æƒ°æ€§æ‰§è¡Œã€â€¦)ï¼Œæ‰€ä»¥è®¾å®šä¸€ä¸ª join ç‚¹å¯ä»¥ä¿è¯åœ¨è¿™ä¸ª join ç‚¹æ—¶ä¸»æ‰§è¡Œç»ªå’Œå…¶å®ƒåˆ†å‰çš„æ‰§è¡Œç»ªçš„æ‰§è¡Œé¢„æœŸè¡Œä¸ºä¸€è‡´ï¼Œå³åœ¨è¿™ä¸ª join ç‚¹ï¼Œä¸ç®¡æ˜¯ä¸»æ‰§è¡Œç»ªè¿˜æ˜¯åˆ†å‰æ‰§è¡Œç»ªéƒ½å®Œæˆäº†ç›¸åº”çš„æ‰§è¡Œæµç¨‹ã€‚ ","date":"2024-03-08","objectID":"/posts/concurrency-concepts/:4:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ¦‚å¿µ","uri":"/posts/concurrency-concepts/"},{"categories":["Concurrency","Linux Kernel Internals"],"content":"Concurrency å’Œ Parallelism Rob Pike: Concurrency Is Not Parallelism / slides Stack Overflow ä¸Šçš„ç›¸å…³è®¨è®º Concurrency æ˜¯æŒ‡ç¨‹å¼æ¶æ§‹ï¼Œå°‡ç¨‹å¼æ‹†é–‹æˆå¤šå€‹å¯ç¨ç«‹é‹ä½œçš„å·¥ä½œã€‚æ¡ˆä¾‹: è£ç½®é©…å‹•ç¨‹å¼ï¼Œå¯ç¨ç«‹é‹ä½œï¼Œä½†ä¸éœ€è¦å¹³è¡ŒåŒ–ã€‚ Parallelism æ˜¯æŒ‡ç¨‹å¼åŸ·è¡Œï¼ŒåŒæ™‚åŸ·è¡Œå¤šå€‹ç¨‹å¼ã€‚Concurrency å¯èƒ½æœƒç”¨åˆ° parallelismï¼Œä½†ä¸ä¸€å®šè¦ç”¨ parallelism æ‰èƒ½å¯¦ç¾ concurrencyã€‚æ¡ˆä¾‹: å‘é‡å…§ç©è¨ˆç®— Concurrent, non-parallel execution Concurrent, parallel execution Tim Mattson (Intel): Introduction to OpenMP [YouTube] ","date":"2024-03-08","objectID":"/posts/concurrency-concepts/:5:0","tags":["Sysprog","Linux","Concurrency"],"title":"å¹¶è¡Œç¨‹åºè®¾è®¡: æ¦‚å¿µ","uri":"/posts/concurrency-concepts/"},{"categories":["RISC-V"],"content":" æœ¬æ–‡å¯¹é€šè¿‡ QEMU ä»¿çœŸ RISC-V ç¯å¢ƒå¹¶å¯åŠ¨ OpenEuler RISC-V ç³»ç»Ÿçš„æµç¨‹è¿›è¡Œè¯¦ç»†ä»‹ç»ï¼Œä»¥åŠä»‹ç»å¦‚ä½•é€šè¿‡ mugen æµ‹è¯•æ¡†æ¶æ¥å¯¹ RISC-V ç‰ˆæœ¬çš„ openEuler è¿›è¡Œç³»ç»Ÿã€è½¯ä»¶ç­‰æ–¹é¢æµ‹è¯•ï¼Œå¹¶æ ¹æ®æµ‹è¯•æ—¥å¿—å¯¹é”™è¯¯åŸå› è¿›è¡Œåˆ†æã€‚ ","date":"2024-03-07","objectID":"/posts/openeuler-riscv-qemu/:0:0","tags":["RISC-V","openEuler","QEMU","Mugen"],"title":"openEuler RISC-V ç³»ç»Ÿ: QEMU ä»¿çœŸ","uri":"/posts/openeuler-riscv-qemu/"},{"categories":["RISC-V"],"content":"å®éªŒç¯å¢ƒ æ“ä½œç³»ç»Ÿ: deepin 20.9 ","date":"2024-03-07","objectID":"/posts/openeuler-riscv-qemu/:1:0","tags":["RISC-V","openEuler","QEMU","Mugen"],"title":"openEuler RISC-V ç³»ç»Ÿ: QEMU ä»¿çœŸ","uri":"/posts/openeuler-riscv-qemu/"},{"categories":["RISC-V"],"content":"å®‰è£…æ”¯æŒ RISC-V æ¶æ„çš„ QEMU æ¨¡æ‹Ÿå™¨ $ sudo apt install qemu-system-misc $ qemu-system-riscv64 --version QEMU emulator version 5.2.0 (Debian 1:5.2+dfsg-11+deb11u1) Copyright (c) 2003-2020 Fabrice Bellard and the QEMU Project developers è™½ç„¶ deepin ä»“åº“æä¾›çš„ QEMU è½¯ä»¶åŒ…ç‰ˆæœ¬æ¯”è¾ƒä½ (5.2.0)ï¼Œä½†æ˜¯æ ¹æ®ã€Œå¼•ç”¨æ–‡æ¡£ã€çš„è¯´æ˜ï¼Œä¸ä½äº 5.0 å³å¯ é€šè¿‡ä¸Šé¢å®‰è£…çš„ QEMU ç‰ˆæœ¬è¿‡ä½ï¼Œæ— æ³•æ”¯æŒ VGA è¿™ç±»è™šæ‹Ÿå¤–è®¾ (virtio)ï¼Œéœ€è¦æ‰‹åŠ¨ç¼–è¯‘å®‰è£…: å¦‚æœä¹‹å‰é€šè¿‡ apt å®‰è£…äº† QEMU çš„å¯ä»¥å…ˆè¿›è¡Œå¸è½½: $ sudo apt remove qemu-system-risc $ sudo apt autoremove å®‰è£…å¿…è¦çš„æ„å»ºå·¥å…·: $ sudo apt install build-essential git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev ninja-build libslirp-dev ä¸‹è½½ QEMU æºç åŒ… (æ­¤å¤„ä»¥ 7.2 ç‰ˆæœ¬ä¸ºä¾‹): $ wget https://download.qemu.org/qemu-7.2.0.tar.xz è§£å‹æºç åŒ…ã€ä¿®æ”¹åç§°: $ tar xvJf qemu-7.2.0.tar.xz $ mv qemu-7.2.0 qemu è¿›å…¥ qemu å¯¹åº”ç›®å½•å¹¶é…ç½®ç¼–è¯‘é€‰é¡¹: $./configure ç¼–è¯‘å®‰è£…: $ sudo make -j$(nproc) åœ¨ ~/.bashrc ä¸­æ·»åŠ ç¯å¢ƒå˜é‡: export PATH=$PATH:/path/to/qemu/build åˆ·æ–°ä¸€ä¸‹ ~/.bashrc (æˆ–æ–°å¼€ä¸€ä¸ªç»ˆç«¯) æŸ¥çœ‹ä¸€ä¸‹ QEMU æ˜¯å¦å®‰è£…æˆåŠŸ: $ source ~/.bashrc $ qemu-system-riscv64 --version QEMU emulator version 7.2.0 Copyright (c) 2003-2022 Fabrice Bellard and the QEMU Project developers ","date":"2024-03-07","objectID":"/posts/openeuler-riscv-qemu/:2:0","tags":["RISC-V","openEuler","QEMU","Mugen"],"title":"openEuler RISC-V ç³»ç»Ÿ: QEMU ä»¿çœŸ","uri":"/posts/openeuler-riscv-qemu/"},{"categories":["RISC-V"],"content":"ä¸‹è½½ openEuler RISC-V ç³»ç»Ÿé•œåƒ å®éªŒæŒ‡å®šçš„æµ‹è¯•é•œåƒ (å½“ç„¶å¦‚æœä¸æ˜¯å®éªŒæŒ‡å®šçš„è¯ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨å…¶ä»–çš„é•œåƒ): https://repo.tarsier-infra.com/openEuler-RISC-V/preview/openEuler-23.09-V1-riscv64/QEMU/ ç”±äºæˆ‘æ˜¯ç›´æ¥ä½¿ç”¨ ssh è¿æ¥ openEuler RISC-V çš„ QEMU è™šæ‹Ÿæœºï¼Œæ‰€ä»¥åªä¸‹è½½äº†: fw_payload_oe_uboot_2304.bin å¯åŠ¨ç”¨å†…æ ¸ openEuler-23.09-V1-base-qemu-preview.qcow2.zst ä¸å¸¦æœ‰æ¡Œé¢é•œåƒçš„æ ¹æ–‡ä»¶ç³»ç»Ÿ start_vm.sh å¯åŠ¨ä¸å¸¦æœ‰æ¡Œé¢é•œåƒçš„æ ¹æ–‡ä»¶ç³»ç»Ÿç”¨è„šæœ¬ $ wget https://repo.tarsier-infra.com/openEuler-RISC-V/preview/openEuler-23.09-V1-riscv64/QEMU/fw_payload_oe_uboot_2304.bin $ wget https://repo.tarsier-infra.com/openEuler-RISC-V/preview/openEuler-23.09-V1-riscv64/QEMU/openEuler-23.09-V1-base-qemu-preview.qcow2.zst $ wget https://repo.tarsier-infra.com/openEuler-RISC-V/preview/openEuler-23.09-V1-riscv64/QEMU/start_vm.sh è§£å‹ç¼©æ ¹æ–‡ä»¶ç³»ç»Ÿçš„ç£ç›˜æ˜ åƒ: # install unzip tool zstd for zst $ sudo apt install zstd $ unzstd openEuler-23.09-V1-base-qemu-preview.qcow2.zst ","date":"2024-03-07","objectID":"/posts/openeuler-riscv-qemu/:3:0","tags":["RISC-V","openEuler","QEMU","Mugen"],"title":"openEuler RISC-V ç³»ç»Ÿ: QEMU ä»¿çœŸ","uri":"/posts/openeuler-riscv-qemu/"},{"categories":["RISC-V"],"content":"å¯åŠ¨ openEuler RISC-V ç³»ç»Ÿå¹¶è¿æ¥ ç¡®è®¤å½“å‰åœ¨åˆšåˆšä¸‹è½½äº†å†…æ ¸ã€æ ¹æ–‡ä»¶ç³»ç»Ÿã€å¯åŠ¨è„šæœ¬çš„ç›®å½•ï¼Œç„¶ååœ¨ä¸€ä¸ªç»ˆç«¯ä¸Šæ‰§è¡Œå¯åŠ¨è„šæœ¬: $ bash start_vm.sh å®‰å¿ƒç­‰å¾…è¾“å‡ºå®Œæ¯•å‡ºç°æç¤ºç™»å½•ç•Œé¢ (æ—¶é—´å¯èƒ½ä¼šæœ‰ç‚¹é•¿)ï¼Œç„¶åè¾“å…¥è´¦å·å’Œå¯†ç è¿›è¡Œç™»å½•å³å¯ æˆ–è€…å¯åŠ¨ QEMU è™šæ‹Ÿæœºåï¼Œæ–°å¼€ä¸€ä¸ªç»ˆç«¯é€šè¿‡ ssh è¿›è¡Œç™»å½•: $ ssh -p 12055 root@localhost $ ssh -p 12055 openeuler@localhost é€šè¿‡ exit å‘½ä»¤å¯ä»¥é€€å‡ºå½“å‰ç™»å½•è´¦å·ï¼Œé€šè¿‡å¿«æ·é”® Ctrl + A, X å¯ä»¥å…³é—­ QEMU è™šæ‹Ÿæœº (æœ¬è´¨ä¸Šæ˜¯ä¿¡å· signal å¤„ç† ğŸ¤£) å»ºè®®ç™»å½•åä¿®æ”¹è´¦å·çš„å¯†ç  (ç›¸å…³å‘½ä»¤: passwd) ","date":"2024-03-07","objectID":"/posts/openeuler-riscv-qemu/:4:0","tags":["RISC-V","openEuler","QEMU","Mugen"],"title":"openEuler RISC-V ç³»ç»Ÿ: QEMU ä»¿çœŸ","uri":"/posts/openeuler-riscv-qemu/"},{"categories":["RISC-V"],"content":"Mugen æµ‹è¯•æ¡†æ¶ æ ¹æ® ã€Œmugenã€ README çš„ä½¿ç”¨æ•™ç¨‹ï¼Œåœ¨æŒ‡å®šæµ‹è¯•é•œåƒä¸Šå®Œæˆ ã€Œå®‰è£…ä¾èµ–è½¯ä»¶ã€ã€Œé…ç½®æµ‹è¯•å¥—ç¯å¢ƒå˜é‡ã€ã€Œç”¨ä¾‹æ‰§è¡Œã€è¿™ä¸‰ä¸ªéƒ¨åˆ†ï¼Œå¹¶ç»™å‡ºå®éªŒæ€»ç»“ ","date":"2024-03-07","objectID":"/posts/openeuler-riscv-qemu/:5:0","tags":["RISC-V","openEuler","QEMU","Mugen"],"title":"openEuler RISC-V ç³»ç»Ÿ: QEMU ä»¿çœŸ","uri":"/posts/openeuler-riscv-qemu/"},{"categories":["RISC-V"],"content":"å®‰è£… git \u0026 å…‹éš† mugen ä»“åº“ ç™»å½•æ™®é€šç”¨æˆ· openeuler ç„¶åå‘ç°æ­¤æ—¶æ²¡æœ‰å®‰è£… git æ— æ³•å…‹éš† mugen ä»“åº“ï¼Œå…ˆå®‰è£… git: $ sudo dnf install git $ git clone https://gitee.com/openeuler/mugen.git åŸå§‹è®¾å®šçš„ vim é…ç½®ä¸å¤ªä¼˜é›…ï¼Œæˆ‘æ ¹æ®æˆ‘çš„ vim é…ç½®è¿›è¡Œäº†è®¾ç½®ï¼Œå…·ä½“è§ ã€ŒVim é…ç½®ã€ ","date":"2024-03-07","objectID":"/posts/openeuler-riscv-qemu/:5:1","tags":["RISC-V","openEuler","QEMU","Mugen"],"title":"openEuler RISC-V ç³»ç»Ÿ: QEMU ä»¿çœŸ","uri":"/posts/openeuler-riscv-qemu/"},{"categories":["RISC-V"],"content":"å®‰è£…ä¾èµ–è½¯ä»¶ è¿›å…¥ mugen ç›®å½•æ‰§è¡Œå®‰è£…ä¾èµ–è½¯ä»¶è„šæœ¬ (å› ä¸ºæˆ‘ä½¿ç”¨çš„æ˜¯æ™®é€šç”¨æˆ·ï¼Œéœ€è¦ä½¿ç”¨ sudo æé«˜æƒçº§): $ sudo bash dep_install.sh ... Complete! ","date":"2024-03-07","objectID":"/posts/openeuler-riscv-qemu/:5:2","tags":["RISC-V","openEuler","QEMU","Mugen"],"title":"openEuler RISC-V ç³»ç»Ÿ: QEMU ä»¿çœŸ","uri":"/posts/openeuler-riscv-qemu/"},{"categories":["RISC-V"],"content":"é…ç½®æµ‹è¯•å¥—ç¯å¢ƒå˜é‡ $ sudo bash mugen.sh -c --ip $ip --password $passwd --user $user --port $port è¿™éƒ¨åˆ†ä»“åº“çš„æ–‡æ¡£å¯¹äºæœ¬æœºæµ‹è¯•æ²¡æœ‰å¾ˆæ¸…æ¥šåœ°è¯´æ˜ï¼Œå‚è€ƒæ–‡ç«  ã€ŒåŸºäºopenEulerè™šæ‹Ÿæœºæœ¬åœ°æ‰§è¡Œmugenæµ‹è¯•è„šæœ¬ã€å®Œæˆé…ç½® æ‰§è¡Œå®Œæˆåä¼šå¤šå‡ºä¸€ä¸ªç¯å¢ƒå˜é‡æ–‡ä»¶ ./conf/env.json ","date":"2024-03-07","objectID":"/posts/openeuler-riscv-qemu/:5:3","tags":["RISC-V","openEuler","QEMU","Mugen"],"title":"openEuler RISC-V ç³»ç»Ÿ: QEMU ä»¿çœŸ","uri":"/posts/openeuler-riscv-qemu/"},{"categories":["RISC-V"],"content":"ç”¨ä¾‹æ‰§è¡Œ \u0026 ç»“æœåˆ†æ æˆ‘å¯¹äº openEuler RISC-V æ˜¯å¦æ”¯æŒäº† binutils æ¯”è¾ƒæ„Ÿå…´è¶£ï¼Œä¾¿è¿›è¡Œäº†æµ‹è¯•: $ sudo bash mugen.sh -f binutils -x ... INFO - A total of 8 use cases were executed, with 8 successes 0 failures and 0 skips. æ‰§è¡Œç»“æœæ˜¾ç¤ºå·²æ­£ç¡®æ”¯æŒ binutils æ¥ä¸‹æ¥å¯¹ç¨‹åºé™æ€åˆ†æå·¥å…· cppcheck çš„æ”¯æŒè¿›è¡Œæµ‹è¯•: $ sudo bash mugen.sh -f cppcheck -x ... INFO - A total of 2 use cases were executed, with 1 successes 1 failures and 0 skips. æ ¹æ®æ–‡æ¡£ suite2cases ä¸­ jsonæ–‡ä»¶çš„å†™æ³• çš„è§£é‡Šï¼Œåˆ†æåˆšåˆšæ‰§è¡Œçš„æµ‹è¯•å¥— suit2cases/cppcheck.jsonï¼Œæ˜¯æµ‹è¯•ç”¨ä¾‹ oe_test_cppcheck å¤±è´¥äº†ã€‚ è§‚å¯Ÿè¯¥ç”¨ä¾‹å¯¹åº”çš„è„šæœ¬ testcases/cli-test/cppcheck/oe_test_cppcheck/oe_test_cppcheck.shï¼Œå¹¶æ‰“å¼€å¯¹åº”çš„æ—¥å¿— logs/cppcheck/oe_test_cppcheck/$(date).log åœ¨é‡Œé¢æ£€ç´¢ LOG_ERRORï¼Œæ‰¾åˆ°ä¸¤å¤„ç›¸å…³é”™è¯¯: + LOG_ERROR 'oe_test_cppcheck.sh line 70' + LOG_ERROR 'oe_test_cppcheck.sh line 95' æ¯”ç…§ç”¨ä¾‹è„šæœ¬ï¼Œå¯¹åº”çš„æµ‹è¯•é€»è¾‘æ˜¯: cppcheck --std=c99 --std=posix test.cpp 70--\u003e CHECK_RESULT $? if [ $VERSION_ID != \"22.03\" ]; then cppcheck -DA --force file.c | grep \"A=1\" 95--\u003e CHECK_RESULT $? 1 else cppcheck -DA --force file.c | grep \"A=1\" CHECK_RESULT $? fi Cppcheck manual P11 The flag -D tells Cppcheck that a name is defined. There will be no Cppcheck analysis without this define. The flag â€“force and â€“max-configs is used to control how many combinations are checked. When -D is used, Cppcheck will only check 1 configuration unless these are used. è¿™é‡Œé¢ CHECK_RESULT æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰çš„ shell å‡½æ•°ï¼Œæ‰«ä¸€ä¸‹ mugen çš„åº“ç›®å½• libsï¼Œåœ¨ locallibs/common_lib.sh é‡Œæ‰¾åˆ°è¯¥å‡½æ•°çš„å®šä¹‰ï¼Œå®ƒçš„é€»è¾‘æ¯”è¾ƒå¥½æ‡‚ (ç±»ä¼¼äº assert)ï¼Œä½†æ˜¯å‡½æ•°å¼€å¤´çš„å˜é‡å®šä¹‰è®©æˆ‘æœ‰äº›è¿·ç³Šï¼Œäºæ˜¯æ±‚æ•™äº GPT: actual_result=$1 expect_result=${2-0} mode=${3-0} error_log=$4 GPT: actual_result å˜é‡è¢«èµ‹å€¼ä¸ºç¬¬ä¸€ä¸ªå‚æ•°çš„å€¼ã€‚ expect_result å˜é‡è¢«èµ‹å€¼ä¸ºç¬¬äºŒä¸ªå‚æ•°çš„å€¼ï¼Œå¦‚æœç¬¬äºŒä¸ªå‚æ•°ä¸å­˜åœ¨ï¼Œåˆ™é»˜è®¤ä¸º 0ã€‚ mode å˜é‡è¢«èµ‹å€¼ä¸ºç¬¬ä¸‰ä¸ªå‚æ•°çš„å€¼ï¼Œå¦‚æœç¬¬ä¸‰ä¸ªå‚æ•°ä¸å­˜åœ¨ï¼Œåˆ™é»˜è®¤ä¸º 0ã€‚ error_log å˜é‡è¢«èµ‹å€¼ä¸ºç¬¬å››ä¸ªå‚æ•°çš„å€¼ã€‚ æ‰€ä»¥ï¼Œæ¶‰åŠé”™è¯¯çš„ä¸¤ä¸ªæµ‹è¯•é€»è¾‘éƒ½å¾ˆå¥½ç†è§£äº†: CHECK_RESULT $? è¡¨ç¤ºä¸Šä¸€æ¡å‘½ä»¤è¿”å›å€¼çš„é¢„æœŸæ˜¯ 0 CHECK_RESULT $? 1 è¡¨ç¤ºä¸Šä¸€æ¡å‘½ä»¤è¿”å›å€¼çš„é¢„æœŸæ˜¯ 1 æ¥ä¸‹æ¥æˆ‘ä»¬å°±å®é™…æµ‹è¯•ä¸€ä¸‹è¿™ä¸¤ä¸ªç”¨ä¾‹: å®‰è£… cppcheck: $ sudo dnf install cppcheck æ‰§è¡Œæµ‹è¯•è„šæœ¬ 70 è¡Œå¯¹åº”çš„ä¸Šä¸€æ¡å‘½ä»¤: $ cppcheck --std=c99 --std=posix test.cpp cppcheck: error: unknown --std value 'posix' $ echo $? 1 æµ‹è¯•å¤±è´¥åŸå› æ˜¯ cppcheck risc-v ç‰ˆæœ¬ä¸æ”¯æŒæŒ‡å®š C/C++ æ ‡å‡†ä¸º posix (åŒæ—¶æŸ¥è¯¢äº†ä¸‹ ã€Œcppcheck manualã€ç›®å‰ cppcheck æ”¯æŒçš„æ ‡å‡†é‡Œå¹¶æœªåŒ…æ‹¬ posix) æ‰§è¡Œæµ‹è¯•è„šæœ¬ 95 è¡Œå¯¹åº”çš„ä¸Šä¸€æ¡å‘½ä»¤: $ cppcheck -DA --force file.c | grep \"A=1\" Checking file.c: A=1... file.c:5:6: error: Array 'a[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds] a[10] = 0; ^ $ echo $? 0 æµ‹è¯•å¤±è´¥åŸå› æ˜¯ grep åœ¨ä¹‹å‰çš„ cppcheck çš„è¾“å‡ºé‡ŒåŒ¹é…åˆ° A=1ï¼Œæ‰€ä»¥å¯¼è‡´è¿”å›å€¼ä¸º 0ã€‚è¿™éƒ¨åˆ†æµ‹è¯•çš„é€»è¾‘æ˜¯: ä»…å¯¹äº 22.03 ç‰ˆæœ¬ openEuler ä¸Šçš„ cppcheck åœ¨ä»¥å‚æ•° -DA æ‰§è¡Œæ—¶æ‰ä¼šè¾“å‡ºåŒ…å« A=1 çš„ä¿¡æ¯ï¼Œä½†æ˜¯ä¸ªäººçŒœæµ‹æ˜¯åœ¨æ¯” 22.03 åŠæ›´é«˜ç‰ˆæœ¬çš„ openEuler ä¸Šä½¿ç”¨ cppcheck æ­é… -DA éƒ½å¯ä»¥è¾“å‡ºåŒ…å« A=1 çš„ä¿¡æ¯ ","date":"2024-03-07","objectID":"/posts/openeuler-riscv-qemu/:5:4","tags":["RISC-V","openEuler","QEMU","Mugen"],"title":"openEuler RISC-V ç³»ç»Ÿ: QEMU ä»¿çœŸ","uri":"/posts/openeuler-riscv-qemu/"},{"categories":["RISC-V"],"content":"å®éªŒæ€»ç»“å’Œè®¨è®º åˆæ­¥ä½“éªŒäº†ä½¿ç”¨ QEMU æ„å»º openEuler RISC-V ç³»ç»Ÿè™šæ‹Ÿæœºçš„æµç¨‹ï¼Œä»¥åŠä½¿ç”¨ ssh è¿æ¥ QEMU è™šæ‹Ÿæœºçš„æŠ€å·§ã€‚å®éªŒè¿‡ç¨‹ä¸­æœ€å¤§æ„Ÿè§¦æ˜¯ mugen çš„æ–‡æ¡£ï¼Œç›¸å¯¹äº cppcheck è¿™ç±»äº§å“çš„æ–‡æ¡£ï¼Œä¸å¤Ÿè¯¦ç»†ï¼Œå¾ˆå¤šå†…å®¹éœ€è¦é˜…è¯»æºç æ¥ç†è§£ (å¥½å¤„æ˜¯ç²¾è¿›äº†æˆ‘å¯¹ shell è„šæœ¬ç¼–ç¨‹çš„ç†è§£ ğŸ¤£)ã€‚ æˆ‘ä¸ªäººæ¯”è¾ƒæœŸå¾… RISC-V é…åˆ nommu åœ¨åµŒå…¥å¼è¿™ç±»ä½åŠŸè€—é¢†åŸŸçš„å‘å±•ï¼ŒåŒæ—¶ä¹Ÿå¯¹ RISC-V Hypervisor Extension åœ¨è™šæ‹ŸåŒ–æ–¹é¢çš„å‘å±•æ„Ÿå…´è¶£ã€‚ ","date":"2024-03-07","objectID":"/posts/openeuler-riscv-qemu/:5:5","tags":["RISC-V","openEuler","QEMU","Mugen"],"title":"openEuler RISC-V ç³»ç»Ÿ: QEMU ä»¿çœŸ","uri":"/posts/openeuler-riscv-qemu/"},{"categories":["RISC-V"],"content":"References openEuler RISC-V: é€šè¿‡ QEMU ä»¿çœŸ RISC-V ç¯å¢ƒå¹¶å¯åŠ¨ OpenEuler RISC-V ç³»ç»Ÿ openEuler RISC-V: ä½¿ç”¨ QEMU å®‰è£… openEuler RISC-V 23.03 Ariel Heleneto: é€šè¿‡ QEMU ä»¿çœŸ RISC-V ç¯å¢ƒå¹¶å¯åŠ¨ OpenEuler RISC-V ç³»ç»Ÿ openEuler: mugen openEuler Docs: ä½¿ç”¨ DNF ç®¡ç†è½¯ä»¶åŒ… åŸºäº openEuler è™šæ‹Ÿæœºæœ¬åœ°æ‰§è¡Œ mugen æµ‹è¯•è„šæœ¬ Video: Mugen æ¡†æ¶çš„ä½¿ç”¨ https://openbuildservice.org/help/manuals/obs-user-guide/ https://gitee.com/openEuler/RISC-V#/openeuler/RISC-V/ https://gitee.com/zxs-un/doc-port2riscv64-openEuler ","date":"2024-03-07","objectID":"/posts/openeuler-riscv-qemu/:6:0","tags":["RISC-V","openEuler","QEMU","Mugen"],"title":"openEuler RISC-V ç³»ç»Ÿ: QEMU ä»¿çœŸ","uri":"/posts/openeuler-riscv-qemu/"},{"categories":["C","Linux Kernel Internals"],"content":" å€Ÿç”±é˜…è¯» C è¯­è¨€æ ‡å‡†ç†è§£è§„èŒƒæ˜¯ç ”ç©¶ç³»ç»Ÿå®‰å…¨æœ€åŸºç¡€çš„æ­¥éª¤ï¼Œä½†å¾ˆå¤šäººéƒ½å¿½ç•¥é˜…è¯»è§„èŒƒè¿™ç‚¹ï¼Œè€Œæ­£å› å¯¹äºè§„èŒƒçš„ä¸äº†è§£ã€æ’°å†™ç¨‹åºçš„ä¸ä¸¥è°¨ï¼Œå¯¼è‡´æ¼æ´çš„äº§ç”Ÿçš„æ¡ˆä¾‹æ¯”æ¯”çš†æ˜¯ï¼Œä¾‹å¦‚ 2014 å¹´çš„ OpenSSL Heartbleed Attack1 ä¾¿æ˜¯ä¾¿æ˜¯å› ä¸ºä½¿ç”¨ memcpy ä¹‹é™…ç¼ºä¹å¯¹åº”å†…å­˜èŒƒå›´æ£€æŸ¥ï¼Œé€ æˆç›¸å½“å¤§çš„å±å®³ã€‚æœ¬æ–‡é‡æ–°æ¢³ç† C è¯­è¨€ç¨‹åºè®¾è®¡çš„ç»†èŠ‚ï¼Œå¹¶å€Ÿç”±è°ƒè¯•å™¨å¸®åŠ©ç†è§£ç¨‹åºçš„è¿ä½œã€‚ åŸæ–‡åœ°å€ ","date":"2024-03-05","objectID":"/posts/c-std-security/:0:0","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["C","Linux Kernel Internals"],"content":"ç›®æ ‡ å€Ÿç”±ç ”è¯»æ¼æ´ç¨‹åºåŠ C è¯­è¨€æ ‡å‡†ï¼Œè®¨è®ºç³»ç»Ÿç¨‹åºçš„å®‰å…¨è®®é¢˜ é€šè¿‡è°ƒè¯•å™¨è¿½è¸ªç¨‹åºå®é™…è¿è¡Œçš„çŠ¶å†µï¼Œäº†è§£å…¶è¿ä½œåŸç† å–æè‡ª dangling pointer, CWE-416 Use After Free, CVE-2017-16943 ä»¥åŠ integer overflow çš„è®®é¢˜ ","date":"2024-03-05","objectID":"/posts/c-std-security/:1:0","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["C","Linux Kernel Internals"],"content":"å®éªŒç¯å¢ƒ ç¼–è¯‘å™¨ç‰ˆæœ¬: gcc 11 è°ƒè¯•å™¨: GDB æ“ä½œç³»ç»Ÿ: Ubuntu Linux 22.04 ","date":"2024-03-05","objectID":"/posts/c-std-security/:2:0","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["C","Linux Kernel Internals"],"content":"ä¸»é¢˜ (ä¸€): Integer type èµ„æ–™å¤„ç† ","date":"2024-03-05","objectID":"/posts/c-std-security/:3:0","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["C","Linux Kernel Internals"],"content":"I. Integer Conversion \u0026 Integer Promotion #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e unsigned int ui = 0; unsigned short us = 0; signed int si = -1; int main() { int64_t r1 = ui + si; int64_t r2 = us + si; printf(\"%lld %lld\\n\", r1, r2); } ä¸Šè¿°ç¨‹å¼ç æ‰§è¡Œç»“æœä¸º: r1 è¾“å‡ºä¸ºåè¿›åˆ¶çš„ 4294967295ï¼Œr2 è¾“å‡ºä¸ºåè¿›åˆ¶çš„ -1ã€‚è¿™ä¸ªç»“æœå’Œ C11 è§„æ ¼ä¹¦ä¸­æåˆ°çš„ Integer çš„ä¸¤ä¸ªç‰¹æ€§æœ‰å…³: Integer Conversion å’Œ Integer Promotionã€‚ (1) Integer Conversion C11 6.3.1.1 Boolean, characters, and integers Every integer type has an integer conversion rank defined as follows: No two signed integer types shall have the same rank, even if they hav e the same representation. The rank of a signed integer type shall be greater than the rank of any signed integer type with less precision. The rank of long long int shall be greater than the rank of long int, which shall be greater than the rank of int, which shall be greater than the rank of short int, which shall be greater than the rank of signed char. The rank of any unsigned integer type shall equal the rank of the corresponding signed integer type, if any. The rank of any standard integer type shall be greater than the rank of any extended integer type with the same width. The rank of any extended signed integer type relative to another extended signed integer type with the same precision is implementation-defined, but still subject to the other rules for determining the integer conversion rank. ä¾æ®ä¸Šè¿°æ ‡å‡†å¯æ’å‡º integer çš„ rank: long long int \u003e long int \u003e int \u003e short int \u003e signed char unsigned int == signed int, if they are both in same precision and same size (2) Integer Promotion å½“ integer è¿›è¡Œé€šå¸¸çš„ç®—æ•°è¿ç®— (Usual arithmetic) æ—¶ï¼Œä¼šå…ˆè¿›è¡Œ integer promotions è½¬æ¢æˆ int æˆ– unsigned int æˆ–è€…ä¿æŒä¸å˜ (è½¬æ¢åçš„è¿ç®—å­è¢«ç§°ä¸º promoted operands)ï¼Œç„¶å promoted operands å†æ ¹æ®è‡ªèº«ç±»å‹ä»¥åŠå¯¹åº”çš„ rank è¿›è¡Œ arithmetic conversionsï¼Œæœ€ç»ˆå¾—åˆ°ç»“æœçš„ç±»å‹ã€‚ C11 6.3.1.1 Boolean, characters, and integers If an int can represent all values of the original type (as restricted by the width, for a bit-field), the value is converted to an int; otherwise, it is converted to an unsigned int. These are called the integer promotions. All other types are unchanged by the integer promotions. C11 6.3.1.8 Usual arithmetic conversions Otherwise, the integer promotions are performed on both operands. Then the following rules are applied to the promoted operands: If both operands have the same type, then no further conversion is needed. Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank. Otherwise, if the operand that has unsigned integer type has rank greater or equal to the rank of the type of the other operand, then the operand with signed integer type is converted to the type of the operand with unsigned integer type. Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, then the operand with unsigned integer type is converted to the type of the operand with signed integer type. Otherwise, both operands are converted to the unsigned integer type corresponding to the type of the operand with signed integer type. /* In the case that the rank is smaller than int */ char c1, c2; // Both of them are char c1 = c1 + c2; // Both are promoted to int, thus result of c1 becomes to integer /* In the case that the rank is same as int */ signed int si = -1; /* si \u0026 ui are at the same rank both are unchanged by the integer promotions */ unsigned int ui = 0; int result = si + ui; // si is converted to unsigned int, result is unsigned ","date":"2024-03-05","objectID":"/posts/c-std-security/:3:1","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["C","Linux Kernel Internals"],"content":"II. è¡ç”Ÿçš„å®‰å…¨è®®é¢˜: Integer Overflow Stack Overflow: What is an integer overflow error? ","date":"2024-03-05","objectID":"/posts/c-std-security/:3:2","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["C","Linux Kernel Internals"],"content":"ä¸»é¢˜ (äºŒ): Object çš„ç”Ÿå‘½å‘¨æœŸ ","date":"2024-03-05","objectID":"/posts/c-std-security/:4:0","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["C","Linux Kernel Internals"],"content":"I. Dangling Pointer C11 6.2.4 Storage durations of objects (2) The lifetime of an object is the portion of program execution during which storage is guaranteed to be reserved for it. An object exists, has a constant address, and retains its last-stored value throughout its lifetime. If an object is referred to outside of its lifetime, the behavior is undefined. The value of a pointer becomes indeterminate when the object it points to (or just past) reaches the end of its lifetime. Stack Overflow: What is a dangling pointer? When a pointer is pointing at the memory address of a variable but after some time that variable is deleted from that memory location while the pointer is still pointing to it, then such a pointer is known as a dangling pointer and this problem is known as the dangling pointer problem. æ‰€ä»¥åœ¨ object çš„ç”Ÿå‘½å‘¨æœŸç»“æŸåï¼Œåº”å°†æŒ‡å‘ object åŸæœ¬å¤„äºçš„å†…å­˜ç©ºé—´çš„æŒ‡é’ˆç½®ä¸º NULLï¼Œé¿å… dangling pointerã€‚ ","date":"2024-03-05","objectID":"/posts/c-std-security/:4:1","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["C","Linux Kernel Internals"],"content":"II. CWE-416 Use After Free OWASP: Using freed memory Referencing memory after it has been freed can cause a program to crash. The use of heap allocated memory after it has been freed or deleted leads to undefined system behavior and, in many cases, to a write-what-where condition. ","date":"2024-03-05","objectID":"/posts/c-std-security/:4:2","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["C","Linux Kernel Internals"],"content":"III. æ¡ˆä¾‹æ¢è®¨: CVE-2017-16943 Abusing UAF leads to Exim RCE Road to Exim RCE - Abusing Unsafe Memory Allocator in the Most Popular MTA ","date":"2024-03-05","objectID":"/posts/c-std-security/:4:3","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["C","Linux Kernel Internals"],"content":"å®éªŒç»“æœä¸éªŒè¯ Source ","date":"2024-03-05","objectID":"/posts/c-std-security/:5:0","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["C","Linux Kernel Internals"],"content":"(ã„§) Integer Promotion éªŒè¯ æµ‹è¯•ç¨‹å¼ç : #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e unsigned int ui = 0; unsigned short us = 0; signed int si = -1; int main() { int64_t r1 = ui + si; int64_t r2 = us + si; printf(\"%lld %lld\\n\", r1, r2); } éªŒè¯ç»“æœ: $ gcc -g -o integer-promotion.o integer-promotion.c $ ./integer-promotion.o 4294967295 -1 ","date":"2024-03-05","objectID":"/posts/c-std-security/:5:1","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["C","Linux Kernel Internals"],"content":"(äºŒ) Object ç”Ÿå‘½å‘¨æœŸ æµ‹è¯•ç¨‹å¼ç : #include \u003cinttypes.h\u003e #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(int argc, char *argv[]) { char *p, *q; uintptr_t pv, qv; { char a = 3; p = \u0026a; pv = (uintptr_t) p; } { char b = 4; q = \u0026b; qv = (uintptr_t) q; } if (p != q) { printf(\"%p is different from %p\\n\", (void *) p, (void *) q); printf(\"%\" PRIxPTR \" is not the same as %\" PRIxPTR \"\\n\", pv, qv); } else { printf(\"Surprise!\\n\"); } return 0; } éªŒè¯ç»“æœ: $ gcc -g -o uaf.o uaf.c $ ./uaf.o Surprise! $ gcc -g -o uaf.o uaf.c -fsanitize-address-use-after-scope $ ./uaf.o 0x7ffca405c596 is different from 0x7ffca405c597 7ffca405c596 is not the same as 7ffca405c597 $ clang -g -o uaf.o uaf.c $ ./uaf.o 0x7fff86b298ff is different from 0x7fff86b298fe 7fff86b298ff is not the same as 7fff86b298fe gcc å¯ä»¥é€šè¿‡æ˜¾å¼æŒ‡å®šå‚æ•° -fsanitize-address-use-after-scope æ¥é¿å… Use-After-Scope çš„é—®é¢˜ï¼Œå¦åˆ™åœ¨ scope ç»“æŸåï¼Œæ¥ä¸‹æ¥çš„å…¶ä»– scope ä¼šä½¿ç”¨ä¹‹å‰å·²ç»“æŸçš„ scope çš„å†…å­˜ç©ºé—´ï¼Œä»è€Œé€ æˆ Use-After-Scope é—®é¢˜ (ä½¿ç”¨ GDB åœ¨ä¸Šé¢ä¸¤ç§ä¸åŒçš„æƒ…å†µä¸‹ï¼ŒæŸ¥çœ‹å˜é‡ a, b æ‰€åœ¨çš„åœ°å€)ï¼Œè€Œ clang åˆ™æ˜¯é»˜è®¤å¼€å¯ç›¸å…³ä¿æŠ¤ã€‚ â€œOpenSSL Heartbleedâ€, SynopsysÂ â†©ï¸ ","date":"2024-03-05","objectID":"/posts/c-std-security/:5:2","tags":["Sysprog","C","Security"],"title":"åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜","uri":"/posts/c-std-security/"},{"categories":["Rust"],"content":" In this Crust of Rust episode, we implement some common sorting algorithms in Rust. This episode doesn't aim to explain any single concept, but rather showcase what writing â€œnormalâ€ Rust code is like, and explaining various â€œodd bitsâ€ we come across along the way. The thinking here is that sorting algorithms are both familiar and easy to compare across languages, so this might serve as a good bridge into Rust if you are familiar with other languages. æ•´ç†è‡ª John Gjengset çš„å½±ç‰‡ é—®é¢˜ You may note that the url of this posy is â€œorstâ€. Why was it given this name? Since â€œsortâ€ when sorted becomes â€œorstâ€. ğŸ¤£ ","date":"2024-03-04","objectID":"/posts/orst/:0:0","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"å½±ç‰‡æ³¨è§£ ","date":"2024-03-04","objectID":"/posts/orst/:1:0","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"Total order vs Partial order Wikipedia: Total order Wikipedia: Partial order Stack Overflow: What does it mean by â€œpartial orderingâ€ and â€œtotal orderingâ€ in the discussion of Lamport's synchronization Algorithm? This definition says that in a total order any two things are comparable. Wheras in a partial order a thing needs neither to be â€œsmallerâ€ than an other nor the other way around, in a total order each thing is either â€œsmallerâ€ than an other or the other way around. ç®€å•æ¥è¯´ï¼Œåœ¨ total order ä¸­ä»»æ„ä¸¤ä¸ªå…ƒç´ éƒ½å¯ä»¥è¿›è¡Œæ¯”è¾ƒï¼Œè€Œåœ¨ partial order ä¸­åˆ™ä¸ä¸€å®šæ»¡è¶³ã€‚ä¾‹å¦‚å¯¹äºé›†åˆ $$ S = \\{a,\\ b,\\ c\\} $$ åœ¨ total order ä¸­ï¼Œ$a, b, c$ ä»»æ„ä¸¤ä¸ªå…ƒç´ ä¹‹é—´éƒ½å¿…é¡»èƒ½è¿›è¡Œæ¯”è¾ƒï¼Œè€Œåœ¨ partial order ä¸­æ²¡æœ‰æ€ä¹ˆä¸¥æ ¼çš„è¦æ±‚ï¼Œå¯èƒ½åªæœ‰ $a \u003c b, b \u003c c$ è¿™ä¸¤æ¡æ¯”è¾ƒè§„åˆ™ã€‚ åœ¨ Rust ä¸­ï¼Œæµ®ç‚¹æ•° (f32, f64) åªå®ç°äº† PartialOrd è¿™ä¸ª Trait è€Œæ²¡æœ‰å®ç° Ordï¼Œå› ä¸ºæ ¹æ® IEEE 754ï¼Œæµ®ç‚¹æ•°ä¸­å­˜åœ¨ä¸€äº›ç‰¹æ®Šå€¼ï¼Œä¾‹å¦‚ NaNï¼Œå®ƒä»¬æ˜¯æ²¡æ³•è¿›è¡Œæ¯”è¾ƒçš„ã€‚å‡ºäºç›¸åŒåŸå› ï¼Œæµ®ç‚¹æ•°ä¹Ÿåªå®ç°äº† PartialEq è€Œæ²¡æœ‰å®ç° Eq traitã€‚ ","date":"2024-03-04","objectID":"/posts/orst/:1:1","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"Trait \u0026 Generic pub fn sort\u003cT, S\u003e(slice: \u0026mut [T]) where T: Ord, S: Sorter\u003cT\u003e, { S::sort(slice); } sort::\u003c_, StdSorter\u003e(\u0026mut things); è¿™æ®µä»£ç å·§å¦™åœ°åˆ©ç”¨æ³›å‹ (generic) æ¥ä¼ é€’äº†\"å‚æ•°\"ï¼Œå½“ç„¶è¿™ç§æŠ€å·§åªé™äºå¯ä»¥é€šè¿‡ç±»å‹æ¥è°ƒç”¨æ–¹æ³•çš„æƒ…å†µ (ä¸Šé¢ä»£ç æ®µçš„ S::sort(...) ä»¥åŠ sort::\u003c_, StdSorter\u003e(...) ç‰‡æ®µ)ã€‚ æ€è€ƒä»¥ä¸‹ä»£ç è¡¨ç¤ºçš„æ„ä¹‰: pub trait Sorter\u003cT\u003e { fn sort(slice: \u0026mut [T]) where T: Ord; } pub trait Sorter { fn sort\u003cT\u003e(slice: \u0026mut [T]) where T: Ord; } ç¬¬ä¸€ä¸ªè¡¨ç¤ºçš„æ˜¯æœ‰å¤šä¸ª taitï¼Œä¾‹å¦‚ Sorter\u003ci32\u003e, Sorter\u003ci64\u003e ç­‰ï¼Œç¬¬äºŒä¸ªè¡¨ç¤ºåªæœ‰ä¸€ä¸ª trait Sorterï¼Œä½†æ˜¯å®ç°è¿™ä¸ª trait éœ€è¦å®ç°å¤šä¸ªæ–¹æ³•ï¼Œä¾‹å¦‚ sort\u003ci32\u003e, sort\u003ci64\u003e ç­‰ï¼Œæ‰€ä»¥ç¬¬ä¸€ç§å†™æ³•æ›´åŠ æ™®é€‚å’Œä½¿ç”¨ (å› ä¸ºæœªå¿…èƒ½å®Œå…¨å®ç°ç¬¬äºŒç§ trait è¦æ±‚çš„æ‰€æœ‰æ–¹æ³•)ã€‚ ","date":"2024-03-04","objectID":"/posts/orst/:1:2","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"Bubble sort Wikipedia: Bubble sort n := length(A) repeat swapped := false for i := 1 to n-1 inclusive do { if this pair is out of order } if A[i-1] \u003e A[i] then { swap them and remember something changed } swap(A[i-1], A[i]) swapped := true end if end for until not swapped ","date":"2024-03-04","objectID":"/posts/orst/:1:3","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"Insertion sort Wikipedia: Insertion sort i â† 1 while i \u003c length(A) j â† i while j \u003e 0 and A[j-1] \u003e A[j] swap A[j] and A[j-1] j â† j - 1 end while i â† i + 1 end while ä½¿ç”¨ Binary search algorithm å¯ä»¥å°† insertion sort çš„ comparsion æ¬¡æ•°é™åˆ° $O(nlogn)$ï¼Œä½†æ˜¯ swap æ¬¡æ•°ä»ç„¶æ˜¯ $O(n^2)$ ğŸ¤£ // use binary search to find index // then use .insert to splice in i let i = match slice[..unsorted].binary_search(\u0026slice[unsorted]) { // [ a, c, e].binary_search(c) =\u003e Ok(1) Ok(i) =\u003e i, // [ a, c, e].binary_search(b) =\u003e Err(1) Err(i) =\u003e i, }; slice[i..=unsorted].rotate_right(1); match çš„å†…éƒ¨é€»è¾‘ä¹Ÿå¯ä»¥æ”¹å†™ä¸º OK(i) | Err(i) =\u003e i ","date":"2024-03-04","objectID":"/posts/orst/:1:4","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"Selection sort Wikipedia: Selection sort å¼•ç”¨ There are many different ways to sort the cards. Hereâ€™s a simple one, called selection sort, possibly similar to how you sorted the cards above: Find the smallest card. Swap it with the first card. Find the second-smallest card. Swap it with the second card. Find the third-smallest card. Swap it with the third card. Repeat finding the next-smallest card, and swapping it into the correct position until the array is sorted. source ä½¿ç”¨å‡½æ•°å¼ç¼–ç¨‹å¯ä»¥å†™æˆç›¸å½“ readable çš„ç¨‹å¼ç ï¼Œä»¥ä¸‹ä¸ºè·å– slice æœ€å°å€¼å¯¹åº”çš„ index: let smallest_in_rest = slice[unsorted..] .iter() .enumerate() .min_by_key(|\u0026(_, v)| v) .map(|(i, _)| unsorted + i) .expect(\"slice is not empty\"); ","date":"2024-03-04","objectID":"/posts/orst/:1:5","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"Quicksort Wikipedia: Quicksort å¯ä»¥é€šè¿‡ extra allocation å’Œ in-place ä¸¤ç§æ–¹å¼æ¥å®ç° quicksortï¼Œå…¶ä¸­ extra allocation æ¯”è¾ƒå¥½ç†è§£ï¼Œin-place æ–¹å¼çš„ pseudocode å¦‚ä¸‹: Quicksort(A,p,r) { if (p \u003c r) { q \u003c- Partition(A,p,r) Quicksort(A,p,q) Quicksort(A,q+1,r) } } Partition(A,p,r) x \u003c- A[p] i \u003c- p-1 j \u003c- r+1 while (True) { repeat { j \u003c- j-1 } until (A[j] \u003c= x) repeat { i \u003c- i+1 } until (A[i] \u003e= x) if (i \u003c j) swap(A[i], A[j]) else return(j) } } source method slice::split_at_mut å®ç° Quick sort æ—¶ä½¿ç”¨äº† split_at_mut æ¥ç»•å¼€å¼•ç”¨æ£€æŸ¥ï¼Œå› ä¸ºå¦‚æœä½ æ­¤æ—¶æ‹¥æœ‰ä¸€ä¸ªæŒ‡å‘ pivot çš„ä¸å¯å˜å¼•ç”¨ï¼Œå°±æ— æ³•å¯¹ slice å‰©ä½™çš„éƒ¨åˆ†ä½¿ç”¨å¯å˜å¼•ç”¨ï¼Œè€Œ split_at_mut åˆ™ä½¿å¾—åŸæœ¬çš„ slice è¢«åˆ†ä¸ºä¸¤ä¸ªå¯å˜å¼•ç”¨ï¼Œä»è€Œç»•å¼€äº†ä¹‹å‰çš„å•ä¸€å¼•ç”¨æ£€æŸ¥ã€‚ åé¢å‘ç°å¯ä»¥ä½¿ç”¨æ›´ç¬¦åˆè¯­ä¹‰çš„ split_first_mutï¼Œå½“ç„¶æ€è·¯è¿˜æ˜¯ä¸€æ ·çš„ æ³¨æ„ æˆ‘ä¸ªäººè®¤ä¸ºå®ç° Quick sort çš„å…³é”®åœ¨äºæŠŠæ¡ä»¥ä¸‹ä¸¤ä¸ª invariants: left: current checking index for element which is equal or less than the pivot right: current checking index for element which is greater than the pivot å³è¿™ä¸¤ä¸ªä¸‹æ ‡å¯¹åº”çš„å…ƒç´ åªæ˜¯å½“å‰å‡†å¤‡æ£€æŸ¥çš„ï¼Œä¸ä¸€å®šç¬¦åˆå…ƒç´ çš„æ’åˆ—è§„èŒƒï¼Œå¦‚ä¸‹å›¾æ‰€ç¤º: [ \u003c= pivot ] [ ] [ ... ] [ ] [ \u003e pivot ] ^ ^ | | left right æ‰€ä»¥å½“ left == right æ—¶ä¸¤è¾¹éƒ½æ²¡æœ‰å¯¹æ‰€æŒ‡å‘çš„å…ƒç´ è¿›è¡Œæ£€æŸ¥ï¼Œåˆ†æƒ…å†µè®¨è®º (è¯¥å…ƒç´ æ˜¯ $\u003c= pivot$ æˆ– $\u003e pivot$) å¯ä»¥å¾—å‡º: å½“ left \u003e right æ—¶ï¼Œright æŒ‡å‘çš„æ˜¯ $\u003c= pivot$ çš„å…ƒç´ ï¼Œå°†å…¶ä¸ pivot è¿›è¡Œ swap å³å¯å®ç° partition æ“ä½œã€‚(å…¶å®æ­¤æ—¶ left æŒ‡å‘çš„æ˜¯ $\u003e pivot$ éƒ¨åˆ†çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œright æŒ‡å‘çš„æ˜¯ $\u003c= pivot$ éƒ¨åˆ†çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„ rest ä¸ slice ä¹‹é—´çš„ä¸‹æ ‡è½¬æ¢) ","date":"2024-03-04","objectID":"/posts/orst/:1:6","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"Benchmark é€šè¿‡å°è£…ç±»å‹ SortEvaluator åŠå®ç° trait PartialEq, Eq, PartialOrd, Ord æ¥ç»Ÿè®¡æ’åºè¿‡ç¨‹ä¸­çš„æ¯”è¾ƒæ“ä½œ (eq, partial_cmp, cmp) çš„æ¬¡æ•°ã€‚ Stack Overflow: Why can't the Ord trait provide default implementations for the required methods from the inherited traits using the cmp function? ","date":"2024-03-04","objectID":"/posts/orst/:1:7","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"R and ggplot2 # install R $ sudo apt install r-base # install ggplot2 by R $ R \u003e install.packages(\"ggplot2\") Are there Unix-like binaries for R? https://ggplot2.tidyverse.org/ é—®é¢˜ deepin è½¯ä»¶æºä¸‹è½½çš„ R è¯­è¨€åŒ…å¯èƒ½ç‰ˆæœ¬è¿‡ä½ (3.5)ï¼Œå¯ä»¥é€šè¿‡æ·»åŠ åº“æºçš„æ–¹å¼æ¥ä¸‹è½½é«˜ç‰ˆæœ¬çš„ R è¯­è¨€åŒ…: 1.æ·»åŠ  Debian buster (oldstable) åº“æºåˆ° /etc/apt/sourcelist é‡Œ: # https://mirrors.tuna.tsinghua.edu.cn/CRAN/ deb http://cloud.r-project.org/bin/linux/debian buster-cran40/ 2.æ›´æ–°è½¯ä»¶ï¼Œå¯èƒ½ä¼šé‡åˆ°æ²¡æœ‰å…¬é’¥çš„é—®é¢˜ (å³å‡ºç°ä¸‹æ–¹çš„ NO_PUBKEY): $ sudo apt update ... NO_PUBKEY XXXXXX ... æ­¤æ—¶å¯ä»¥ NO_PUBKEY åçš„ XXXXXX å°±æ˜¯å…¬é’¥ï¼Œæˆ‘ä»¬åªéœ€è¦å°†å…¶æ·»åŠ ä¸€ä¸‹å³å¯: $ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys XXXXXX æ·»åŠ å®Œå…¬é’¥åå†é‡æ–°æ›´æ–°ä¸€æ¬¡è½¯ä»¶æº 3.é€šè¿‡æŒ‡å®šåº“æºçš„æ–¹å¼æ¥å®‰è£… R (å¦‚æœæœªæŒ‡å®šåº“æºåˆ™è¿˜æ˜¯ä»é»˜è®¤æºè¿›è¡Œä¸‹è½½ 3.5 ç‰ˆæœ¬): $ sudo apt install buster-cran40 r-base $ R --version R version 4.3.3 (2024-02-29) å¤§åŠŸå‘Šæˆï¼ŒæŒ‰ç…§ä¸Šé¢å®‰è£… ggplot2 å³å¯ ","date":"2024-03-04","objectID":"/posts/orst/:1:8","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"Homework ä¿¡æ¯ å®ä½œè¯´æ˜: æ·»åŠ æ ‡å‡†åº“çš„ sort_unstable è¿›å…¥åŸºå‡†æµ‹è¯• å°†äº¤æ¢æ“ä½œ (swap) çº³å…¥åŸºå‡†æµ‹è¯• å°è¯•å®ç° Merge sort å°è¯•å®ç° Heapsort å‚è€ƒèµ„æ–™: Wikipedia: Merge sort Wikipedia: Heapsort ","date":"2024-03-04","objectID":"/posts/orst/:2:0","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-03-04","objectID":"/posts/orst/:3:0","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"Crate std å¯ä»¥ä½¿ç”¨è¿™é‡Œæä¾›çš„æœç´ æ è¿›è¡Œæœç´¢ (BTW ä¸è¦æµªè´¹æ—¶é—´åœ¨ Google æœå¯»ä¸Šï¼) Module std::cmp Trait std::cmp::Ord Trait std::cmp::PartialOrd Trait std::cmp::Eq Trait std::cmp::PartialEq Primitive Type slice method slice::sort method slice::sort_unstable method slice::sort_by method slice::sort_by_key method slice::swap method slice::binary_search method slice::rotate_right method slice::split_at_mut method slice::split_first_mut method slice::to_vec Trait std::iter::Iterator method std::iter::Iterator::min method std::iter::Iterator::min_by_key method std::iter::Iterator::enumerate Enum std::option::Option method std::option::Option::expect method std::option::Option::map Enum std::result::Result method std::result::Result::expect method std::result::Result::map Module std::time method std::time::Instant::now method std::time::Instant::elapsed method std::time::Duration::as_secs_f64 ","date":"2024-03-04","objectID":"/posts/orst/:3:1","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"Crate rand Function rand::thread_rng method rand::seq::SliceRandom::shuffle ","date":"2024-03-04","objectID":"/posts/orst/:3:2","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Rust"],"content":"References orst [Github] Sorting algorithm [Wikipedia] Timsort [Wikipedia] Difference between Benchmarking and Profiling [Stack Overflow] ","date":"2024-03-04","objectID":"/posts/orst/:4:0","tags":["Rust","Sort","Algorithm"],"title":"Crust of Rust: Sorting Algorithms","uri":"/posts/orst/"},{"categories":["Linux","Linux Kernel Internals"],"content":" æœ¬è¬›åº§å°‡ä»¥ Thorsten Leemhuis åœ¨ FOSDEM 2020 é–‹å ´æ¼”èªª â€œLinux kernel â€“ Solving big problems in small steps for more than 20 yearsâ€ (slides) ç‚ºä¸»è»¸ï¼Œå˜—è©¦æ­¸ç´è‡ª 21 ä¸–ç´€ç¬¬ä¸€å¹´é–‹å§‹çš„ Linux æ ¸å¿ƒ 2.4 ç‰ˆåˆ°å¦‚ä»Šçš„ 5.x ç‰ˆï¼Œä¸­é–“æ ¸å¿ƒé–‹ç™¼è€…å¦‚ä½•å…‹æœ SMP (Symmetric multiprocessing), scalability, åŠå„å¼ç¡¬é«”æ¶æ§‹å’Œå‘¨é‚Šè£ç½®æ”¯æ´ç­‰é›£é¡Œï¼Œéç¨‹ä¸­æå‡ºå…¨é¢ç§»é™¤ BKL (Big kernel lock)ã€å¯¦ä½œè™›æ“¬åŒ–æŠ€è¡“ (å¦‚ Xen å’Œ KVM)ã€æå‡º namespace å’Œ cgroups å¾è€Œç¢ºç«‹å®¹å™¨åŒ– (container) çš„èƒ½åŠ›ï¼Œå†ä¾†æ˜¯æ ¸å¿ƒç™¼å±•çš„æ˜æ˜ŸæŠ€è¡“ eBPF æœƒåœ¨æ—¢æœ‰çš„åŸºç¤ä¹‹ä¸Šï¼Œå¸¶ä¾† XDP å’Œå“ªäº›ä»¤äººé©šè±”çš„æ©Ÿåˆ¶å‘¢ï¼Ÿåˆï¼ŒLinux æ ¸å¿ƒçµ‚æ–¼æ­£å¼ç´å…¥ç™¼å±•åé¤˜å¹´çš„ PREEMPT_RTï¼Œä½¿å¾— Linux æ ¸å¿ƒå¾—ä»¥æˆç‚ºç¡¬å³æ™‚çš„ä½œæ¥­ç³»çµ±ï¼Œå°å…§éƒ¨è¨­è¨ˆæœ‰å“ªäº›è¡æ“Šï¼ŸAIO å¾Œç¹¼çš„ io_uring è®“ Linux æœ‰æ›´å„ªé›…ä¸”é«˜æ•ˆçš„éåŒæ­¥ I/O å­˜å–ï¼Œæˆ‘å€‘è©²å¦‚ä½•çœ‹å¾…ï¼Ÿ åŸæ–‡åœ°å€ ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:0:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"å¼€ç¯‡ç‚¹é¢˜ å‰ç½®çŸ¥è¯†: Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ FOSDEM 2020, T. Leemhuis: YouTube: Linux kernel â€“ Solving big problems in small steps for more than 20 years slides (è¿™ä¸ªæŠ•å½±ç‰‡å…±æœ‰ 248 é¡µï¼Œæ‰€ä»¥åŠ è½½æ—¶å¯èƒ½ä¼šæ¯”è¾ƒæ…¢ ğŸ¤£) ä»¥ä¸Šé¢çš„è®²åº§ä¸ºä¸»è½´ï¼Œå›é¡¾ Linux çš„å‘å±•åŠ¨æ€ï¼Œç”±æ­¤å±•æœ› Linux æœªæ¥çš„å‘å±•æ–¹å‘ã€‚ SMP (Symmetric multiprocessing) scalability BKL (Big kernel lock) Xen, KVM namespace, cgroups, container - äº‘æœåŠ¡ eBPF, XDP - ç½‘ç»œå°åŒ…çš„é«˜æ•ˆè¿‡æ»¤ (åœ¨å†…æ ¸å³å¯å¤„ç†å°åŒ…çš„è¿‡æ»¤ï¼Œæ— éœ€åœ¨ç”¨æˆ·æ€åˆ¶å®šè§„åˆ™) PREEMPT_RT - ç¡¬å³æ—¶æ“ä½œç³»ç»Ÿ (hard real time os) io_uring - é«˜æ•ˆçš„éåŒæ­¥ I/O (Linux å¤§éƒ¨åˆ†ç³»ç»Ÿè°ƒç”¨éƒ½æ˜¯éåŒæ­¥çš„) nommu - ç”¨äºåµŒå…¥å¼é™ä½åŠŸè€— Linux ç›¸å…³äººç‰© (å¯åœ¨ YouTube ä¸Šæ‰¾åˆ°ä»–ä»¬çš„ä¸€äº›æ¼”è®²): Jonathan Corbet ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:1:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"Linux 2.4 Version 2.4 of the LINUX KERNELâ€“Why Should a System Administrator Upgrade? è‡ª 2004 å¹´é–‹å§‹ï¼Œé‡‹å‡ºéç¨‹ç™¼ç”Ÿè®ŠåŒ–ï¼Œæ–°æ ¸å¿ƒæ¯éš” 2-3 å€‹æœˆå®šæœŸé‡‹å‡ºï¼Œç·¨è™Ÿç‚º 2.6.0, 2.6.1ï¼Œç›´åˆ° 2.6.39 è¿™ä»¶äº‹å¯¹äºæ“ä½œç³»ç»Ÿçš„å¼€å‘æœ‰å¾ˆå¤§çš„å½±å“ï¼Œæ˜¯ä¸€ä¸ªå·¨å¤§çš„å˜é©ã€‚é€è¿‡è¿™ç§å‘è¡Œæœºåˆ¶ï¼ŒCPU å‚å•†å¯ä»¥ç›´æ¥åœ¨æœ€æ–°çš„ Linux kernel ä¸Šé€‚é…æ­£åœ¨å¼€å‘çš„ CPU åŠç›¸å…³ç¡¬ä½“ï¼Œè€Œæ— éœ€æ‹¿åˆ°çœŸæ­£çš„ CPU ç¡¬ä½“å†è¿›è¡Œç›¸åº”çš„å¼€å‘ï¼Œè¿™ä½¿å¾— Linux è·å¾—äº†æ›´å¤šå‚å•†çš„æ”¯æŒå’ŒæŠ•å…¥ï¼Œè¿›è€Œè¿›å…¥äº†é£é€Ÿå‘å±•æœŸã€‚ LInux æ ¸å¿ƒçš„é“è·¯: åªæä¾›æœºåˆ¶ä¸æä¾›ç­–ç•¥ã€‚ä¾‹å¦‚ khttp (in-kernel httpd) çš„å¼ƒç”¨ï¼Œé€šè¿‡æä¾›æ›´é«˜æ•ˆçš„ç³»ç»Ÿè°ƒç”¨æ¥æé«˜ç½‘é¡µæœåŠ¡å™¨çš„æ•ˆèƒ½ï¼Œè€Œä¸æ˜¯åƒ Windows NT ä¸€æ ·ç”¨æˆ·æ€æ€§èƒ½ä¸å¤Ÿå°±æŠŠç¨‹å¼æ¬è¿› kernel ğŸ¤£ ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:2:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"SMP æ”¯æ´ ç›¸å…³æ•…äº‹: Digital Domain and TITANIC (æ³°å¦å°¼å…‹å·) Red Hat Sinks Titanic Linux Helps Bring Titanic to Life Digital Domain: TITANIC Industrial Light and Magic MaterialX Joins the Academy Software Foundation as a Hosted Project åˆ¶ä½œã€Šæ³°å¦å°¼å…‹å·ã€‹çš„ç‰¹æ•ˆæ—¶ï¼Œä½¿ç”¨äº†å®‰è£… Linux æ“ä½œç³»ç»Ÿçš„ Alpha å¤„ç†å™¨ï¼Œè€Œ Alpha æ˜¯å¤šæ ¸å¤„ç†å™¨ï¼Œæ‰€ä»¥å½“å¹´å°† Linux å®‰è£…åˆ° Alpha ä¸Šéœ€è¦æ”¯æ´ SMPï¼Œç”±æ­¤å»¶ä¼¸å‡ºäº† BLK (Big kernel lock)ã€‚ Linux 2.4 åœ¨ SMP çš„æ•ˆç‡é—®é¢˜ä¹Ÿæ­£æ˜¯ BLK æ‰€å¼•èµ·çš„: BLK ç”¨äºé”å®šæ•´ä¸ª Linux kernelï¼Œè€Œæ•´ä¸ª Linux kernel åªæœ‰ä¸€ä¸ª BLK å®ä½œæœºåˆ¶: åœ¨æ‰§è¡Œ schedule æ—¶å½“å‰æŒæœ‰ BLK çš„ process éœ€è¦é‡Šæ”¾ BLK ä»¥è®©å…¶ä»– process å¯ä»¥è·å¾— BLKï¼Œå½“è½®åˆ°è¯¥ process æ‰§è¡Œæ—¶ï¼Œå¯ä»¥é‡æ–°è·å¾— BLK ä»ä¸Šé¢çš„å®ä½œæœºåˆ¶å¯ä»¥çœ‹å‡ºï¼Œè¿™æ ·çš„æœºåˆ¶æ•ˆç‡æ˜¯å¾ˆä½çš„ï¼Œè™½ç„¶æœ‰å¤šæ ¸ (core)ï¼Œä½†æ˜¯å½“ä¸€ä¸ª process è·å¾— BLK æ—¶ï¼Œåªæœ‰è¯¥ process æ‰€åœ¨çš„ core å¯ä»¥æ‰§è¡Œï¼Œå…¶ä»– core åªèƒ½ç­‰å¾… BLK å·²äº v.6.39 ç‰ˆæœ¬ä¸­è¢«å½»åº•å»é™¤ Linux 5.5â€™s Scheduler Sees A Load Balancing Rework For Better Perf But Risks Regressions âœ… When testing on a dual quad-core ARM64 system they found the performance ranged from less than 1% to upwards of 10% for the Hackbench scheduler test. With a 224-core ARM64 server, the performance ranged from less than 1% improvements to 12% better performance with Hackbench and up to 33% better performance with Dbench. More numbers and details via the v4 patch revision. ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:3:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"è™šæ‹ŸåŒ– Cloud Hypervisor Xen and the Art of Virtualization ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:4:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"DPDK (Data Plane Development Kit) ä¸€è¨€ä»¥è”½ä¹‹: Kernel-bypass networkingï¼Œå³ç•¥è¿‡ kernel ç›´æ¥è®© User programs å¤„ç†ç½‘ç»œå°åŒ…ï¼Œä»¥æå‡æ•ˆèƒ½ã€‚ä¸€èˆ¬å®ä½œäºé«˜é¢‘äº¤æ˜“çš„åœºæ™¯ã€‚ YouTube: Kernel-bypass networking for fun and profit Stack Overflowâ€œzero copy networkingâ€ vs â€œkernel bypassâ€? ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:5:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"XDP: eXpress Data Path å¸¸å’Œ eBPF é…åˆå®ç°åœ¨ kernel è¿›è¡Œå®šåˆ¶åŒ–çš„å°åŒ…è¿‡æ»¤ï¼Œä»è€Œå‡å°‘ cop to/from kernel/user è¿™ç±»æ“ä½œçš„æ•ˆèƒ½æŸå¤±ã€‚ LPC2018 - Path to DPDK speeds for AF XDP / slides ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:6:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"AIO Synchronous / Asynchronous I/Oï¼šåœ¨å¾/å‘æ ¸å¿ƒç©ºé–“è®€å–/å¯«å…¥è³‡æ–™ (i.e. å¯¦éš›é€²è¡Œ I/O æ“ä½œ) çš„éç¨‹ï¼Œä½¿ç”¨è€…å±¤ç´šçš„è¡Œç¨‹æ˜¯å¦æœƒè¢« blockedã€‚ AIO åœ¨æŸäº›æƒ…æ™¯ä¸‹å¤„ç†ä¸å½“ï¼Œæ€§èƒ½ç”šè‡³ä½äº blocked çš„ I/O æ–¹æ³•ï¼Œè¿™ä¹Ÿå¼•å¯¼å‡ºäº† io_uring æŠ€å·§ UNIX å“²å­¦: Everything is a file. Linux ä¸æˆæ–‡è§„èŒƒ: Everything is a file descriptor. Kernel Recipes 2019 - Faster IO through io_uring / slides io_uring ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:7:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"Container Container æ„å»ºåœ¨ Linux æ ¸å¿ƒçš„åŸºç¡€å»ºè®¾ä¸Š: namespace, cgroups, capabilities, seccomp +----------------------+ | +------------------+ | | | cgroup | | | | namespace | | | | union-capable fs | | | | | | | | Container | | | +------------------+ | | | | +------------------+ | | | Container | | | +------------------+ | | | | +------------------+ | | | Container | | | +------------------+ | | | | Linux kernel (host) | +----------------------+ YouTube: Containers: cgroups, Linux kernel namespaces, ufs, Docker, and intro to Kubernetes pods Stack Overflow: difference between cgroups and namespaces cgroup: Control Groups provide a mechanism for aggregating/partitioning sets of tasks, and all their future children, into hierarchical groups with specialized behaviour. namespace: wraps a global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource. Wikipedia: UnionFS Wikipedia: Microservices ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:8:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"BPF/cBPF/eBPF æŠ€å·§ run small programs in kernel mode 20 years ago, this idea would likely have been shot down immediately Netflix talks about Extended BPF - A new software type / slides ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:9:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"Real-Time Linux æ ¸å¿ƒè®¾è®¡: PREEMPT_RT ä½œä¸ºè¿ˆå‘ç¡¬å³æ—¶æ“ä½œç³»ç»Ÿçš„æœºåˆ¶ ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:10:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"printk Why printk() is so complicated (and how to fix it) ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:11:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"ZFS, BtrFS, RAID ZFS versus RAID: Eight Ironwolf disks, two filesystems, one winner ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:12:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["Linux","Linux Kernel Internals"],"content":"Rust Linux æ ¸å¿ƒé‡‡çº³ Rust çš„çŠ¶å†µ ","date":"2024-03-03","objectID":"/posts/linux-dev-review/:13:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: å‘å±•åŠ¨æ€å›é¡¾","uri":"/posts/linux-dev-review/"},{"categories":["RISC-V"],"content":" The intention is to give specific actionable optimization recommendations for software developers writing code for RISC-V application processors. è¿‘æ—¥ RISE åŸºé‡‘ä¼šå‘å¸ƒäº†ä¸€ç‰ˆ ã€ŠRISC-V Optimization Guideã€‹ï¼Œå…¶ç›®çš„æ˜¯ä¸ºç»™ RISC-V åº”ç”¨å¤„ç†å™¨ç¼–å†™ä»£ç çš„è½¯ä»¶å¼€å‘äººå‘˜æä¾›å…·ä½“å¯è¡Œçš„ä¼˜åŒ–å»ºè®®ã€‚æœ¬æ¬¡æ´»åŠ¨çš„ä¸»è¦å†…å®¹æ˜¯è§£è¯»å’Œè®¨è®ºè¯¥æ–‡æ¡£å†…å®¹ã€‚ åŸæ–‡åœ°å€ åŸæ–‡ PDF è§£è¯´å½•å½± ","date":"2024-02-29","objectID":"/posts/riscv-optimization-guide/:0:0","tags":["RISC-V","Optimization","Architecture"],"title":"RISC-V Optimization Guide é‡ç‚¹æç¤º","uri":"/posts/riscv-optimization-guide/"},{"categories":["RISC-V"],"content":"ç›¸å…³çŸ¥è¯† RISC-V ISA è§„æ ¼ä¹¦: https://riscv.org/technical/specifications/ æ¨èå‚è€ƒ ä½“ç³»ç»“æ„å¦‚ä½•ä½œç”¨äºç¼–è¯‘å™¨åç«¯-é‚±å‰ [bilibili] è¿™ä¸ªè®²åº§æ˜¯å…³äºå¾®æ¶æ„ã€æŒ‡ä»¤é›†æ˜¯æ€æ ·å’Œç¼–è¯‘å™¨ã€è½¯ä»¶ç›¸äº’åä½œã€ç›¸äº’å½±å“çš„ Overview è¿™ä¸ªè®²åº§ä»‹ç»çš„æ˜¯é€šç”¨ CPU å¹¶ä¸ä»…é™äº RISC-V ä¸Š ","date":"2024-02-29","objectID":"/posts/riscv-optimization-guide/:1:0","tags":["RISC-V","Optimization","Architecture"],"title":"RISC-V Optimization Guide é‡ç‚¹æç¤º","uri":"/posts/riscv-optimization-guide/"},{"categories":["RISC-V"],"content":"Detecting RISC-V Extensions on Linux å‚è€ƒä»¥ä¸‹æ–‡ç« æ„å»º Linux RISC-V ç„¶åè¿›è¡ŒåŸæ–‡çš„ riscv_hwprobe ç³»ç»Ÿè°ƒç”¨å®éªŒ: How To Set Up The Environment for RISCV-64 Linux Kernel Development In Ubuntu 20.04 Running 64- and 32-bit RISC-V Linux on QEMU ","date":"2024-02-29","objectID":"/posts/riscv-optimization-guide/:2:0","tags":["RISC-V","Optimization","Architecture"],"title":"RISC-V Optimization Guide é‡ç‚¹æç¤º","uri":"/posts/riscv-optimization-guide/"},{"categories":["RISC-V"],"content":"Multi-versioning æœ€æ–°è¿›å±•: https://reviews.llvm.org/D151730 ç›¸å…³ä»‹ç»: https://maskray.me/blog/2023-02-05-function-multi-versioning ","date":"2024-02-29","objectID":"/posts/riscv-optimization-guide/:2:1","tags":["RISC-V","Optimization","Architecture"],"title":"RISC-V Optimization Guide é‡ç‚¹æç¤º","uri":"/posts/riscv-optimization-guide/"},{"categories":["RISC-V"],"content":"Optimizing Scalar Integer ","date":"2024-02-29","objectID":"/posts/riscv-optimization-guide/:3:0","tags":["RISC-V","Optimization","Architecture"],"title":"RISC-V Optimization Guide é‡ç‚¹æç¤º","uri":"/posts/riscv-optimization-guide/"},{"categories":["RISC-V"],"content":"Materializing Constants RV64I 5.2 Integer Computational Instructions Additional instruction variants are provided to manipulate 32-bit values in RV64I, indicated by a â€˜Wâ€™ suffix to the opcode. These â€œ*Wâ€ instructions ignore the upper 32 bits of their inputs and always produce 32-bit signed values, i.e. bits XLEN-1 through 31 are equal. ADDIW is an RV64I instruction that adds the sign-extended 12-bit immediate to register rs1 and produces the proper sign-extension of a 32-bit result in rd. åŸæ–‡ Prefer idiomatic LUI/ADDI sequence for 32 bit constants éƒ¨åˆ†ä½¿ç”¨ lui å’Œ addiw æ„å»º 0x1fffff çš„è¯´æ˜æ¯”è¾ƒæ™¦æ¶©éš¾æ‡‚ (è¯´å®è¯æˆ‘æ²¡çœ‹æ‡‚åŸæ–‡çš„ addiw ä¸ºä»€ä¹ˆéœ€è¦å‡å» 4096 ğŸ˜‡) æ³¨æ„ æ ¹æ®ä¸‹é¢çš„å‚è€ƒæ–‡ç« ï¼Œå¦‚æœ addiw çš„ç«‹å³æ•°çš„ MSB è¢«ç½®ä¸º 1 æ—¶ï¼Œåªéœ€åœ¨ lui æ—¶å¤šåŠ ä¸€ä¸ª 1 å³å¯æ„å»ºæˆ‘ä»¬æƒ³è¦çš„ 32-bit æ•°å€¼ã€‚è€ŒåŸæ–‡ä¸­é™¤äº†å¯¹ lui åŠ  1 å¤–ï¼Œè¿˜å¯¹ addiw è¿›è¡Œå‡å» 4096 çš„æ“ä½œ: addiw a0, a0, (0xfff - 4096) ; addiw a0, a0, -1 è¿™ä¹ä¸€çœ‹ä¸çŸ¥é“ä¸ºä½•éœ€è¦å‡å» 4096ï¼Œå…¶å®æœ¬è´¨å¾ˆç®€å•ï¼Œæ ¹æ®ä¸Šé¢çš„ ISA manual addiw çš„ç«‹å³æ•°æ˜¯ 12-bit çš„ signed numberï¼Œå³åº”è¯¥ä¼ å…¥çš„æ˜¯æ•°å€¼ã€‚ä½†æ˜¯ç›´æ¥ä½¿ç”¨ 0xfff è¡¨ç¤ºä¼ å…¥çš„ä»…ä»…æ˜¯ 0xfff è¿™ä¸ªç¼–ç å¯¹åº”çš„æ•°å€¼ (å¯ä»¥è¡¨ç¤º 12-bit signed ä¸‹çš„æ•°å€¼ -1ï¼Œä¹Ÿå¯ä»¥è¡¨ç¤º unsigned ç¼–ç ä¸‹ 0xfff å¯¹åº”çš„æ•°å€¼ 4095ï¼Œåœ¨ 12-bit signed ä¸‹ integer overflow)ï¼Œä¸ºäº†ä¿è¯ addiw çš„ç«‹å³æ•°çš„æ•°å€¼ç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸ (å³ 0xfff åœ¨ 12-bit signed ä¸‹æ•°å€¼æ˜¯ -1) ä»¥åŠé¿å… integer overflowï¼Œæ‰€ä»¥éœ€è¦å°† 0xfff - 4096 å¾—åˆ° 12-bit signed æ•°å€¼ -1 (è™½ç„¶è¿™ä¸ªç¼–ç å’Œ 0xfff æ˜¯ä¸€æ ·çš„â€¦)ã€‚ addiw a0, a0, -1 ; right addiw a0, a0, 4095 ; integer overflow è§£è¯»è®¡ç®—æœºç¼–ç  C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡ RV32G ä¸‹ lui/auipc å’Œ addi ç»“åˆåŠ è½½ç«‹å³æ•°æ—¶çš„è¡¥å€¼é—®é¢˜ [zhihu] RISC-V build 32-bit constants with LUI and ADDI [Stack Overflow] åŸæ–‡ Fold immediates into consuming instructions where possible éƒ¨åˆ†ï¼Œç›¸å…³çš„ RISC-V çš„ imm ä¼˜åŒ–: Craig Topper: 2022 LLVM Dev Mtg: RISC-V Sign Extension Optimizations æ”¹è¿›RISC-Vçš„ä»£ç ç”Ÿæˆ-å»–æ˜¥ç‰ [bilibili] ","date":"2024-02-29","objectID":"/posts/riscv-optimization-guide/:3:1","tags":["RISC-V","Optimization","Architecture"],"title":"RISC-V Optimization Guide é‡ç‚¹æç¤º","uri":"/posts/riscv-optimization-guide/"},{"categories":["RISC-V"],"content":"Avoid branches using conditional moves Zicond extension æä¾›äº†æˆ‘ä»¬åœ¨ RISC-V ä¸Šå®ä½œå¸¸æ•°æ—¶é—´å‡½æ•° (contant-time function) çš„èƒ½åŠ›ï¼Œç”¨äºé¿å…åˆ†æ”¯é¢„æµ‹ï¼Œä»è€Œå‡å°‘å› åˆ†æ”¯é¢„æµ‹å¤±è´¥å¸¦æ¥çš„é«˜æ˜‚ä»£ä»·ã€‚ $$ a0 = \\begin{cases} constant1 \u0026 \\text{if } x \\neq 0 \\newline constant2 \u0026 \\text{if } x = 0 \\end{cases} $$ åŸæ–‡ä½¿ç”¨äº† CZERO.NEZï¼Œä¸‹é¢æˆ‘ä»¬ä½¿ç”¨ CZERO.EQZ æ¥å®ä½œåŸæ–‡çš„ä¾‹å­: li t2, constant2 li t3, (constant1 - constant2) CZERO.EQZ t3, t3, a0 add a0, t3, t2 åŸæ–‡ä¹Ÿä»‹ç»äº†å¦‚ä½•ä½¿ç”¨ seqz æ¥å®ä½œ constant-time functionï¼Œä¸‹é¢ä½¿ç”¨ snez æ¥å®ä½œåŸæ–‡çš„ä¾‹å­: li t2, constant1 li t3, constant2 snez t0, a0 addi t0, t0, -1 xor t1, t2, t3 and t1, t1, t0 xor a0, t1, t2 å¦‚æœæœ‰ \\â€˜M\\â€™ æ‰©å±•å¯ä»¥é€šè¿‡ mul æŒ‡ä»¤è¿›è¡Œç®€åŒ– (é€šè¿‡ snez æ¥å®ä½œåŸæ–‡ä¾‹å­): li t2, constant1 li t3, constant2 xor t1, t2, t3 snez t0, a0 mul t1, t1, t0 xor a0, t1, t3 ","date":"2024-02-29","objectID":"/posts/riscv-optimization-guide/:3:2","tags":["RISC-V","Optimization","Architecture"],"title":"RISC-V Optimization Guide é‡ç‚¹æç¤º","uri":"/posts/riscv-optimization-guide/"},{"categories":["RISC-V"],"content":"Padding Use canonical NOPs, NOP ( ADDI X0, X0, 0 ) and C.NOP ( C.ADDI X0, 0 ), to add padding within a function. Use the canonical illegal instruction ( either 2 or 4 bytes of zeros depending on whether the C extension is supported ) to add padding between functions. å› ä¸ºåœ¨å‡½æ•°å†…éƒ¨çš„æ‰§è¡Œé¢‘ç‡é«˜ï¼Œä½¿ç”¨åˆæ³•çš„ NOPs è¿›è¡Œå¯¹é½ paddingï¼Œé˜²æ­¢åœ¨ä¹±åºæ‰§è¡Œæ—¶ï¼Œæµæ°´çº¿åœ¨é‡è§éæ³•æŒ‡ä»¤åå°±ä¸å†æ‰§è¡Œåç»­æŒ‡ä»¤ï¼Œé€ æˆæ•ˆèƒ½æŸå¤± å¦‚æœæ§åˆ¶æµè¢«ä¼ é€’åˆ°ä¸¤ä¸ªå‡½æ•°ä¹‹é—´ï¼Œé‚£ä¹ˆåŠ å¤§å¯èƒ½æ˜¯ç¨‹åºæ‰§è¡Œå‡ºé”™äº†ï¼Œä½¿ç”¨éæ³•çš„æŒ‡ä»¤è¿›è¡Œå¯¹é½ padding å¯ä»¥å¸®åŠ©æˆ‘ä»¬æ›´å¥½æ›´å¿«åœ° debug ","date":"2024-02-29","objectID":"/posts/riscv-optimization-guide/:3:3","tags":["RISC-V","Optimization","Architecture"],"title":"RISC-V Optimization Guide é‡ç‚¹æç¤º","uri":"/posts/riscv-optimization-guide/"},{"categories":["RISC-V"],"content":"Align char array to greater alignment Why use wider load/store usage for memory copy? C è¯­è¨€: å†…å­˜ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§ ","date":"2024-02-29","objectID":"/posts/riscv-optimization-guide/:3:4","tags":["RISC-V","Optimization","Architecture"],"title":"RISC-V Optimization Guide é‡ç‚¹æç¤º","uri":"/posts/riscv-optimization-guide/"},{"categories":["RISC-V"],"content":"Use shifts to clear leading/trailing bits å®ä½œ 64-bit ç‰ˆæœ¬çš„åŸæ–‡ä¾‹å­ (retain the highest 12 bits): slli x6, x5, 52 slri x7, x5, 52 RV64I 5.2 Integer Computational Instructions LUI (load upper immediate) uses the same opcode as RV32I. LUI places the 20-bit U-immediate into bits 31â€“12 of register rd and places zero in the lowest 12 bits. The 32-bit result is sign-extended to 64 bits. ","date":"2024-02-29","objectID":"/posts/riscv-optimization-guide/:3:5","tags":["RISC-V","Optimization","Architecture"],"title":"RISC-V Optimization Guide é‡ç‚¹æç¤º","uri":"/posts/riscv-optimization-guide/"},{"categories":["RISC-V"],"content":"Optimizing Scalar Floating Point ","date":"2024-02-29","objectID":"/posts/riscv-optimization-guide/:4:0","tags":["RISC-V","Optimization","Architecture"],"title":"RISC-V Optimization Guide é‡ç‚¹æç¤º","uri":"/posts/riscv-optimization-guide/"},{"categories":["RISC-V"],"content":"Optimizing Vector What about vector instructions? YouTube: Introduction to SIMD Introduction to the RISC-V Vector Extension [PDF] 2020 RISC-V Summit: Tutorial: RISC-V Vector Extension Demystified ","date":"2024-02-29","objectID":"/posts/riscv-optimization-guide/:5:0","tags":["RISC-V","Optimization","Architecture"],"title":"RISC-V Optimization Guide é‡ç‚¹æç¤º","uri":"/posts/riscv-optimization-guide/"},{"categories":["Rust"],"content":" In this (fifth) Crust of Rust video, we cover multi-produce/single-consumer (mpsc) channels, by re-implementing some of the std::sync::mpsc types from the standard library. As part of that, we cover what channels are used for, how they work at a high level, different common channel variants, and common channel implementations. In the process, we go over some common Rust concurrency primitives like Mutex and Condvar. æ•´ç†è‡ª John Gjengset çš„å½±ç‰‡ ","date":"2024-02-29","objectID":"/posts/channels/:0:0","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"Channel Wikipedia: Channel å¼•ç”¨ In computing, a channel is a model for interprocess communication and synchronization via message passing. A message may be sent over a channel, and another process or thread is able to receive messages sent over a channel it has a reference to, as a stream. YouTube: Channels in Rust Source ","date":"2024-02-29","objectID":"/posts/channels/:1:0","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"Concurrency vs Parallelism What is the difference between concurrency and parallelism? Concurrency vs. Parallelism â€” A brief view ","date":"2024-02-29","objectID":"/posts/channels/:1:1","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"å½±ç‰‡æ³¨è§£ ","date":"2024-02-29","objectID":"/posts/channels/:2:0","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"Sender \u0026 Receiver multi-produce/single-consumer (mpsc) Why does the recevier type need to have an arc protected by mutex if the channel may only have a single consumer thread? Because a send and a recevie might happen at the same time, and they need to be mutually exclusive to each other as well. Why not use a boolean semaphore over the implementation in mutex? A boolean semaphore is basically a boolean flag that you check and atomically update. The problem there is if the flag is currently set (someone else is in the critical section), with a boolean semaphore, you have to spin, you have to repeatedly check it. Whereas with a mutex, the operating system can put the thread to sleep and wake it back up when the mutex is available, which is generally more efficient although adds a little bit of latency. ","date":"2024-02-29","objectID":"/posts/channels/:2:1","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"Condition Variable method std::sync::Condvar::wait This function will atomically unlock the mutex specified (represented by guard) and block the current thread. This means that any calls to notify_one or notify_all which happen logically after the mutex is unlocked are candidates to wake this thread up. When this function call returns, the lock specified will have been re-acquired. method std::sync::Condvar::notify_one If there is a blocked thread on this condition variable, then it will be woken up from its call to wait or wait_timeout. Calls to notify_one are not buffered in any way. wait \u0026 notify ","date":"2024-02-29","objectID":"/posts/channels/:2:2","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"Clone å¯¹ struct Sender\u003cT\u003e æ ‡æ³¨å±æ€§å® #[derive(clone)] ä¼šå®ç°ä»¥ä¸‹çš„ triat: impl\u003cT: Clone\u003e Clone for Sender\u003cT\u003e { ... } ä½†æ˜¯å¯¹äº Sender\u003cT\u003e çš„æˆå‘˜ Arc\u003cInner\u003cT\u003e\u003e æ¥è¯´ï¼ŒArc å¯ä»¥ clone æ— è®ºå†…éƒ¨ç±»å‹ T æ˜¯å¦å®ç°äº† Clone è¿™ä¸ª traitï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨å®ç° Clone è¿™ä¸ª traitã€‚è¿™ä¹Ÿæ˜¯ #[derive(clone)] å’Œæ‰‹åŠ¨å®ç° impl Clone çš„ä¸€ä¸ªç»†å°å·®åˆ«ã€‚ impl\u003cT\u003e Clone for Sender\u003cT\u003e { ... } ä¸ºäº†é˜²æ­¢è°ƒç”¨ clone äº§ç”Ÿçš„äºŒä¹‰æ€§ (å› ä¸ºç¼–è¯‘å™¨ä¼šè‡ªåŠ¨è§£å¼•ç”¨)ï¼Œå»ºè®®ä½¿ç”¨ explict æ–¹å¼æ¥è°ƒç”¨ Arc::clone()ï¼Œè¿™æ ·ç¼–è¯‘å™¨å°±ä¼šçŸ¥é“è°ƒç”¨çš„æ˜¯ Arc çš„ clone æ–¹æ³•ï¼Œè€Œä¸æ˜¯ Arc å†…éƒ¨ object çš„ clone æ–¹æ³•ã€‚ let inner = Arc\u003cInner\u003cT\u003e\u003e; inner.clone(); // Inner\u003cT\u003e's clone method? or Arc::clone method? Arc::clone(\u0026inner); // explict Arc::clone ! ","date":"2024-02-29","objectID":"/posts/channels/:2:3","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"dbg Macro std::dbg å¼•ç”¨ Prints and returns the value of a given expression for quick and dirty debugging. let a = 2; let b = dbg!(a * 2) + 1; // ^-- prints: [src/main.rs:2] a * 2 = 4 assert_eq!(b, 5); The macro works by using the Debug implementation of the type of the given expression to print the value to stderr along with the source location of the macro invocation as well as the source code of the expression. è°ƒè¯•çš„å¤§æ€å™¨ï¼Œä½œç”¨ç±»ä¼¼äº kernel ä¸­çš„ debugk å® ğŸ¤£ å¸¸ç”¨äºæ£€æµ‹ç¨‹åºè¿è¡Œæ—¶æ˜¯å¦æ‰§è¡Œäº†æŸäº›è¯­å¥ï¼Œä»¥åŠè¿™äº›è¯­å¥çš„å€¼å¦‚ä½•ã€‚ ","date":"2024-02-29","objectID":"/posts/channels/:2:4","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"Performance optimization Every operation takes the lock and that's fine if you have a channel that is not very high performance, but if you wanted like super high performance, like you have a lot of sends that compete with each other, then you might not want the sends to contend with one another. Image that you have 10 threads are trying to send at the same time, you could perhaps write an implementation that allows them to do that. The only thing that really needs to be synchronized is the senders with the receivers, as opposed to the senders with one another, whereas we're actually locking all of them. ä½¿ç”¨ VecDeque ä½œä¸ºç¼“å†²åŒºï¼Œä¼šå¯¼è‡´ send æ—¶çš„æ•ˆèƒ½é—®é¢˜ã€‚å› ä¸º send æ˜¯ä½¿ç”¨ push_back æ–¹æ³•æ¥å°† object åŠ å…¥åˆ° VecDeque ä¸­ï¼Œè¿™ä¸ªè¿‡ç¨‹ VecDeque å¯èƒ½ä¼šå‘ç”Ÿ resize æ“ä½œï¼Œè¿™ä¼šèŠ±è´¹è¾ƒé•¿æ—¶é—´å¹¶ä¸”åœ¨è¿™ä¸ªè¿‡ç¨‹æ—¶ sender ä»ç„¶æŒæœ‰ Mutexï¼Œæ‰€ä»¥å¯¼è‡´å…¶ä»– sender å’Œ recevier å¹¶ä¸èƒ½ä½¿ç”¨ VecDequeï¼Œæ‰€ä»¥åœ¨å®ä½œä¸­å¹¶ä¸ä½¿ç”¨ VecDeque ä»¥é¿å…ç›¸åº”çš„æ•ˆèƒ½æŸå¤±ã€‚ å› ä¸ºåªæœ‰ä¸€ä¸ª receiverï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡ç¼“å†²åŒºæ¥æé«˜æ•ˆèƒ½ï¼Œä¸€æ¬¡æ€§æ¥å—å¤§æ‰¹æ•°æ®å¹¶è¿›è¡Œç¼“å­˜ï¼Œè€Œä¸æ˜¯æ¯æ¬¡åªæ¥æ”¶ä¸€ä¸ªæ•°æ®å°±æ”¾å¼ƒ Mutex (Batch recv optimization)ã€‚å½“ç„¶è¿™ä¸ªå¦‚æœä½¿ç”¨ VecDeque ä¾ç„¶ä¼šåœ¨ recv æ—¶å‡ºç°ä¸Šé¢çš„ resize æ•ˆèƒ½é—®é¢˜ã€‚ ","date":"2024-02-29","objectID":"/posts/channels/:2:5","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"Synchronous channels Module std::sync::mpsc These channels come in two flavors: An asynchronous, infinitely buffered channel. The channel function will return a (Sender, Receiver) tuple where all sends will be asynchronous (they never block). The channel conceptually has an infinite buffer. A synchronous, bounded channel. The sync_channel function will return a (SyncSender, Receiver) tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be synchronous by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a â€œrendezvousâ€ channel where each sender atomically hands off a message to a receiver. ","date":"2024-02-29","objectID":"/posts/channels/:2:6","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"Channel flavors Synchronous channels: Channel where send() can block. Limited capacity. Mutex + Condvar + VecDeque Atomic VecDeque (atomic queue) + thread::park + thread::Thread::notify Asynchronous channels: Channel where send() cannot block. Unbounded. Mutex + Condvar + VecDeque Mutex + Condvar + LinkedList Atomic linked list, linked list of T Atomic block linked list, linked list of atomic VecDeque Rendezvous channels: Synchronous with capacity = 0. Used for thread synchronization. Oneshot channels: Any capacity. In practice, only one call to send(). ","date":"2024-02-29","objectID":"/posts/channels/:2:7","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"async/await Module std::future Keyword async Keyword await ","date":"2024-02-29","objectID":"/posts/channels/:2:8","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"Homework ä¿¡æ¯ å®ä½œè¯´æ˜: å°è¯•å®ç° Synchronous channels ä½¿ç”¨ Atomic å­˜å‚¨ senders ä»¥æé«˜æ•ˆèƒ½ ä½¿ç”¨ä¸¤ä¸ª ConVar æ¥æŒ‡ç¤º sender å’Œ receiver è¿›è¡Œ block å’Œ wake up receiver è¢« drop æ—¶éœ€è¦é€šçŸ¥æ‰€æœ‰ senders ä»¥é‡Šæ”¾èµ„æº ä½¿ç”¨ linked list æ¥å–ä»£ VecDeque ä»¥é¿å… resize çš„æ•ˆèƒ½æŸå¤± å°è¯•é˜…è¯» std ä¸­ mpsc çš„å®ç° Module std::sync::mpsc å¯¹æ¯”é˜…è¯»å…¶ä»–åº“å…³äº channel çš„å®ç°: crossbeam, flume å‚è€ƒèµ„æ–™: Module std::sync::atomic Module std::sync::mpsc Crate crossbeam Crate flume ","date":"2024-02-29","objectID":"/posts/channels/:3:0","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-02-29","objectID":"/posts/channels/:4:0","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"Crate std å¯ä»¥ä½¿ç”¨è¿™é‡Œæä¾›çš„æœç´ æ è¿›è¡Œæœç´¢ (BTW ä¸è¦æµªè´¹æ—¶é—´åœ¨ Google æœå¯»ä¸Šï¼) Module std::sync::mpsc Function std::sync::mpsc::channel Struct std::sync::mpsc::Sender Struct std::sync::mpsc::Receiver Module std::sync Struct std::sync::Arc Struct std::sync::Mutex Struct std::sync::Condvar method std::sync::Condvar::wait method std::sync::Condvar::notify_one Module std::sync::atomic Trait std::marker::Send Struct std::collections::VecDeque Function std::mem::take Function std::mem::swap Macro std::dbg ","date":"2024-02-29","objectID":"/posts/channels/:4:1","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["Rust"],"content":"References Go è¯­è¨€ä¹Ÿæœ‰ channel: è§£è¯´ Go channel åº•å±‚åŸç† [bilibili] å¯èƒ½ä¸æ˜¯ä½ çœ‹è¿‡æœ€æ— èŠçš„ Rust å…¥é—¨å–œå‰§ 102 (3) å¤šçº¿ç¨‹å¹¶å‘ [bilibili] ","date":"2024-02-29","objectID":"/posts/channels/:5:0","tags":["Rust","Channel"],"title":"Crust of Rust: Channels","uri":"/posts/channels/"},{"categories":["C","Linux Kernel Internals"],"content":" Linux æ ¸å¿ƒä½œä¸ºä¸–ç•Œä¸Šæœ€æˆåŠŸçš„å¼€æ”¾åŸå§‹ç è®¡åˆ’ï¼Œä¹Ÿæ˜¯ C è¯­è¨€åœ¨å·¥ç¨‹é¢†åŸŸçš„ç‘°å®ï¼Œé‡Œå¤´å……æ–¥åˆ™å„ç§â€œè‰ºæœ¯â€ï¼Œå¾€å¾€ä¼šå“åˆ°åˆæ¬¡æ¥è§¦çš„äººä»¬ï¼Œä½†æ€»æ˜¯èƒ½å¤Ÿä½¿ç”¨ C è¯­è¨€æ ‡å‡†å’Œå¼€å‘å·¥å…·æä¾›çš„æ‰©å±• (ä¸»è¦æ˜¯æ¥è‡ª gcc çš„ GNU extensions) æ¥è§£é‡Šã€‚ å·¥æ¬²å–„å…¶äº‹ï¼Œå¿…å…ˆåˆ©å…¶å™¨ åŸæ–‡åœ°å€ If I had eight hours to chop down a tree, Iâ€™d spend six hours sharpening my axe. â€”â€” Abraham Lincoln è¯­è¨€è§„æ ¼: C89/C90 -\u003e C99 -\u003e C11 -\u003e C17/C18 -\u003e C2x ","date":"2024-02-28","objectID":"/posts/c-standards/:0:0","tags":["Sysprog","C","Standard"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å¼€å‘å·¥å…·å’Œè§„æ ¼æ ‡å‡†","uri":"/posts/c-standards/"},{"categories":["C","Linux Kernel Internals"],"content":"C vs C++ C is quirky, flawed, and an enormous success. Although accidents of history surely helped, it evidently satisfied a need for a system implementation language efficient enough to displace assembly language, yet sufficiently abstract and fluent to describe algorithms and interactions in a wide variety of environments. â€”â€” Dennis M. Ritchie David Brailsford: Why C is so Influential - Computerphile Linus Torvalds: c++ in linux kernel And I really do dislike C++. Itâ€™s a really bad language, in my opinion. It tries to solve all the wrong problems, and does not tackle the right ones. The things C++ â€œsolvesâ€ are trivial things, almost purely syntactic extensions to C rather than fixing some true deep problem. Bjarne Stroustrup: Learning Standard C++ as a New Language [PDF] C++ æ ‡å‡†æ›´æ–°é£å¿«: C++11, C++14, C++17, â€¦ ä» C99, C++98 å¼€å§‹ï¼ŒC è¯­è¨€å’Œ C++ åˆ†é“æ‰¬é•³ in C, everything is a representation (unsigned char [sizeof(TYPE)]). â€”â€” Rich Rogers ç¬¬ä¸€å€‹ C èªè¨€ç·¨è­¯å™¨æ˜¯æ€æ¨£ç·¨å¯«çš„ï¼Ÿ ä»‹ç»äº†è‡ªä¸¾ (sel-hosting/compiling) ä»¥åŠ C0, C1, C2, C3, â€¦ ç­‰çš„æ¼”åŒ–è¿‡ç¨‹ ","date":"2024-02-28","objectID":"/posts/c-standards/:1:0","tags":["Sysprog","C","Standard"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å¼€å‘å·¥å…·å’Œè§„æ ¼æ ‡å‡†","uri":"/posts/c-standards/"},{"categories":["C","Linux Kernel Internals"],"content":"C è¯­è¨€è§„æ ¼ä¹¦ ","date":"2024-02-28","objectID":"/posts/c-standards/:2:0","tags":["Sysprog","C","Standard"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å¼€å‘å·¥å…·å’Œè§„æ ¼æ ‡å‡†","uri":"/posts/c-standards/"},{"categories":["C","Linux Kernel Internals"],"content":"main é˜…è¯» C è¯­è¨€è§„æ ¼ä¹¦å¯ä»¥è®©ä½ æ´å¯Ÿæœ¬è´¨ï¼Œä¸åœ¨æ²¡æ„ä¹‰çš„äº‹æƒ…ä¸Šæµªè´¹æ—¶é—´ï¼Œä¾‹å¦‚åœ¨æŸä¹å¤§è‚†è®¨è®ºçš„ void main() å’Œ int main() é—®é¢˜ ğŸ¤£ C99/C11 5.1.2.2.1 Program startup The function called at program startup is named main. The implementation declares no prototype for this function. It shall be defined with a return type of int and with no parameters: int main(void) { /* ... */ } or with two parameters (referred to here as argc and argv, though any names may be used, as they are local to the function in which they are declared): int main(int argc, char *argv[]) { /* ... */ } or equivalent; or in some other implementation-defined manner. Thus, int can be replaced by a typedef name defined as int, or the type of argv can be written as char ** argv, and so on. ","date":"2024-02-28","objectID":"/posts/c-standards/:2:1","tags":["Sysprog","C","Standard"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å¼€å‘å·¥å…·å’Œè§„æ ¼æ ‡å‡†","uri":"/posts/c-standards/"},{"categories":["C","Linux Kernel Internals"],"content":"incomplete type C99 6.2.5 Types incomplete types (types that describe objects but lack information needed to determine their sizes). ä¾‹å¦‚æŒ‡é’ˆç±»å‹æš—ç¤ºçš„å°±æ˜¯ incomplete typeï¼Œé€šè¿‡ struct data * è¿™ä¸ªæŒ‡é’ˆç±»å‹æ— æ³•å¾—çŸ¥ struct data è¿™ä¸ªå‹æ€æ‰€éœ€è¦å ç”¨çš„ç©ºé—´å¤§å°ã€‚ ","date":"2024-02-28","objectID":"/posts/c-standards/:2:2","tags":["Sysprog","C","Standard"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å¼€å‘å·¥å…·å’Œè§„æ ¼æ ‡å‡†","uri":"/posts/c-standards/"},{"categories":["C","Linux Kernel Internals"],"content":"è§„æ ¼ä¸ä»…è¦çœ‹æœ€æ–°çš„ï¼Œè¿‡å¾€çš„ä¹Ÿè¦ç†Ÿæ‚‰ å› ä¸ºå¾ˆå¤š (åµŒå…¥å¼) è®¾å¤‡ä¸Šè¿è¡Œçš„ Linux å¯èƒ½æ˜¯å¾ˆæ—§çš„ç‰ˆæœ¬ï¼Œé‚£æ—¶ Linux ä½¿ç”¨çš„æ˜¯æ›´æ—§çš„ C è¯­è¨€è§„æ ¼ã€‚ä¾‹å¦‚ç©ºä¸­å·´å£« 330 å®¢æœºçš„å¨±ä¹ç³»ç»Ÿé‡Œæ‰§è¡Œçš„æ˜¯åå‡ å¹´å‰çš„ Red Hat Linuxï¼Œæ€»æœ‰äººè¦ä¸ºè¿™äº›â€œå¤è‘£â€è´Ÿè´£ ğŸ¤£ ","date":"2024-02-28","objectID":"/posts/c-standards/:2:3","tags":["Sysprog","C","Standard"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å¼€å‘å·¥å…·å’Œè§„æ ¼æ ‡å‡†","uri":"/posts/c-standards/"},{"categories":["C","Linux Kernel Internals"],"content":"GDB ä½¿ç”¨ GDB è¿™ç±»è°ƒè¯•å·¥å…·å¯ä»¥å¤§å¹…åº¦æå‡æˆ‘ä»¬ç¼–å†™ä»£ç ã€é™¤é”™çš„èƒ½åŠ› ğŸ¶ video: Linux basic anti-debug video: C Programming, Disassembly, Debugging, Linux, GDB rr (Record and Replay Framework) video: Quick demo video: Record and replay debugging with â€œrrâ€ ","date":"2024-02-28","objectID":"/posts/c-standards/:3:0","tags":["Sysprog","C","Standard"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å¼€å‘å·¥å…·å’Œè§„æ ¼æ ‡å‡†","uri":"/posts/c-standards/"},{"categories":["C","Linux Kernel Internals"],"content":"C23 ä¸Šä¸€ä¸ª C è¯­è¨€æ ‡å‡†æ˜¯ C17ï¼Œæ­£å¼åç§°ä¸º ISO/IEC 9899:2018ï¼Œæ˜¯ 2017 å¹´å‡†å¤‡ï¼Œ2018å¹´æ­£å¼å‘å¸ƒçš„æ ‡å‡†è§„èŒƒã€‚C23 åˆ™æ˜¯ç›®å‰æ­£åœ¨å¼€å‘çš„è§„æ ¼ï¼Œå…¶é¢„è®¡æ–°å¢ç‰¹æ€§å¦‚ä¸‹: typeof: ç”± GNU extension è½¬æ­£ï¼Œç”¨äºå®ä½œ container_of å® call_once: ä¿è¯åœ¨ concurrent ç¯å¢ƒä¸­ï¼ŒæŸæ®µç¨‹å¼ç åªä¼šæ‰§è¡Œ 1 æ¬¡ char8_t: Unicode friendly u8\"ğŸ’£\"[0] unreachable(): ç”± GNU extension è½¬æ­£ï¼Œæç¤ºå…è®¸ç¼–è¯‘å™¨å¯¹æŸæ®µç¨‹å¼ç è¿›è¡Œæ›´æ¿€è¿›çš„æœ€ä½³åŒ– = {}: å–ä»£ memset å‡½æ•°è°ƒç”¨ ISO/IEC 60559:2020: æœ€æ–°çš„ IEEE 754 æµ®ç‚¹æ•°è¿ç®—æ ‡å‡† _Static_assert: æ‰©å…… C11 å…è®¸å•ä¸€å‚æ•° å¸æ”¶ C++11 é£æ ¼çš„ attribute è¯­æ³•ï¼Œä¾‹å¦‚ nodiscard, maybe_unused, deprecated, fallthrough æ–°çš„å‡½æ•°: memccpy(), strdup(), strndup() â€”â€”â€” ç±»ä¼¼äº POSIXã€SVIDä¸­ C å‡½æ•°åº“çš„æ‰©å…… å¼ºåˆ¶è§„èŒƒä½¿ç”¨äºŒè¡¥æ•°è¡¨ç¤ºæ•´æ•° ä¸æ”¯æ´ K\u0026R é£æ ¼çš„å‡½æ•°å®šä¹‰ äºŒè¿›åˆ¶è¡¨ç¤ºæ³•: 0b10101010 ä»¥åŠå¯¹åº” printf() çš„ %b (åœ¨æ­¤ä¹‹å‰ C è¯­è¨€æ˜¯ä¸æ”¯æ´äºŒè¿›åˆ¶è¡¨ç¤ºæ³•çš„ ğŸ¤£) Type generic functions for performing checked integer arithmetic (Integer overflow) _BitInt(N) and UnsignedBitInt(N) types for bit-precise integers #elifdef and #elifndef æ”¯æŒåœ¨æ•°å€¼ä¸­é—´åŠ å…¥åˆ†éš”ç¬¦ï¼Œæ˜“äºé˜…è¯»ï¼Œä¾‹å¦‚ 0xFFFF'FFFF ä¿¡æ¯ Ever Closer - C23 Draws Nearer C23 is Finished: Here is What is on the Menu ","date":"2024-02-28","objectID":"/posts/c-standards/:4:0","tags":["Sysprog","C","Standard"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å¼€å‘å·¥å…·å’Œè§„æ ¼æ ‡å‡†","uri":"/posts/c-standards/"},{"categories":["C","Linux Kernel Internals"],"content":" ä¸å°‘ C/C++ å¼€å‘è€…å¬è¿‡ â€œå†…å­˜å¯¹é½â€ (memory alignment)ï¼Œä½†ä¸æ˜“æŒæ¡æ¦‚å¿µåŠè§„åˆ™ï¼Œé‘è®ºå…¶åœ¨æ‰§è¡Œæ—¶æœŸçš„å†²å‡»ã€‚å†…å­˜ç®¡ç†åƒæ˜¯ malloc/free å‡½æ•°çš„ä½¿ç”¨ï¼Œæ˜¯æ¯ä¸ª C è¯­è¨€ç¨‹åºè®¾è®¡å¼€å‘è€…éƒ½ä¼šæ¥è§¦åˆ°ï¼Œä½†å´éš¾ä¿å……åˆ†æ’é™¤é”™è¯¯çš„éš¾é¢˜ã€‚æœ¬è®²åº§å°è¯•ä»ç¡¬ä½“çš„è¡Œä¸ºå¼€å§‹æ¢è®¨ï¼Œå¸Œæœ›æ¶ˆé™¤è§‚ä¼—å¯¹äº alignment, padding, memory allocator çš„è¯¯è§£ï¼Œå¹¶ä¸”æ¢è®¨é«˜æ•ˆèƒ½ memory pool çš„è®¾è®¡ï¼Œå¦‚ä½•æ”¹å–„æ•´ä½“ç¨‹åºçš„æ•ˆèƒ½å’Œå¯é åº¦ã€‚ä¹Ÿä¼šæ¢è®¨ C11 æ ‡å‡†çš„ aligned_allocã€‚ åŸæ–‡åœ°å€ ","date":"2024-02-27","objectID":"/posts/c-memory/:0:0","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"èƒŒæ™¯çŸ¥è¯† ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡ C99/C11 6.2.5 Types (28) A pointer to void shall have the same representation and alignment requirements as a pointer to a character type. C99/C11 6.3.2.3 Pointers (1) A pointer to void may be converted to or from a pointer to any object type. A pointer to any object type may be converted to a pointer to void and back again; the result shall compare equal to the original pointer. ä½¿ç”¨ void * å¿…é¡»é€šè¿‡ explict (æ˜¾å¼) æˆ–å¼ºåˆ¶è½¬å‹ï¼Œæ‰èƒ½å­˜å–æœ€ç»ˆçš„ objectï¼Œå› ä¸º void æ— æ³•åˆ¤æ–­ object çš„å¤§å°ä¿¡æ¯ã€‚ ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: å‡½æ•°å‘¼å«ç¯‡ glibc æä¾›äº† malloc_stats() å’Œ malloc_info() è¿™ä¸¤ä¸ªå‡½æ•°ï¼Œå¯ä»¥æŸ¥è¯¢ process çš„ heap ç©ºé—´ä½¿ç”¨æƒ…å†µä¿¡æ¯ã€‚ ","date":"2024-02-27","objectID":"/posts/c-memory/:1:0","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"Memory é‡‘å­—å¡” è¿™ä¸ªé‡‘å­—å¡”çš„å±‚çº§å›¾æç¤ºæˆ‘ä»¬ï¼Œå–„ç”¨ Cache locality å¯ä»¥æœ‰æ•ˆæé«˜ç¨‹å¼æ•ˆèƒ½ã€‚ æŠ€å·§ What a C programmer should know about memory (ç®€è®°) ","date":"2024-02-27","objectID":"/posts/c-memory/:2:0","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"Understanding virtual memory - the plot thickens The virtual memory allocator (VMA) may give you a memory it doesnâ€™t have, all in a vain hope that youâ€™re not going to use it. Just like banks today è™šæ‹Ÿå†…å­˜çš„ç®¡ç†ç±»ä¼¼äºé“¶è¡Œï¼Œè¿”å›çš„åˆ†é…ç©ºé—´æœªå¿…å¯ä»¥ç«‹å³ä½¿ç”¨ã€‚memory allocator å’Œé“¶è¡Œç±»ä¼¼ï¼Œå¯ç”¨ç©ºé—´å°±ç±»ä¼¼äºé“¶è¡Œçš„ç°é‡‘å‚¨å¤‡é‡‘ï¼Œé“¶è¡Œå¯ä»¥å¼€å¾ˆå¤šæ”¯ç¥¨ï¼Œä½†æ˜¯è¿™äº›æ”¯ç¥¨å¯ä»¥å…‘ç°çš„å‰ææ˜¯è¿™äº›æ”¯ç¥¨ä¸ä¼šåœ¨åŒä¸€æ—¶é—´æ¥å…‘ç°ï¼Œè™šæ‹Ÿå†…å­˜ç®¡ç†ä¹Ÿç±»ä¼¼ï¼Œåˆ†é…ç©ºé—´ä¹ŸæœŸæœ›ç”¨æˆ·ä¸ä¼šç«‹å³å…¨éƒ¨ä½¿ç”¨ã€‚ ","date":"2024-02-27","objectID":"/posts/c-memory/:2:1","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"Understanding stack allocation This is how variable-length arrays (VLA), and also alloca() work, with one difference - VLA validity is limited by the scope, allocaâ€™d memory persists until the current function returns (or unwinds if youâ€™re feeling sophisticated). VLA å’Œ alloca åˆ†é…çš„éƒ½æ˜¯æ ˆ (stack) ç©ºé—´ï¼Œåªéœ€å°†æ ˆæŒ‡é’ˆ (sp) æŒ‰éœ€æ±‚åŠ å‡ä¸€ä¸‹å³å¯å®ç°ç©ºé—´åˆ†é…ã€‚å› ä¸º stack ç©ºé—´æ˜¯æœ‰é™çš„ï¼Œæ‰€ä»¥ Linux æ ¸å¿ƒä¸­ç¦æ­¢ä½¿ç”¨ VLAï¼Œé˜²æ­¢ Stack Overflow ğŸ¤£ ","date":"2024-02-27","objectID":"/posts/c-memory/:2:2","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"Slab allocator The principle of slab allocation was described by Bonwick for a kernel object cache, but it applies for the user-space as well. Oh-kay, weâ€™re not interested in pinning slabs to CPUs, but back to the gist â€” you ask the allocator for a slab of memory, letâ€™s say a whole page, and you cut it into many fixed-size pieces. Presuming each piece can hold at least a pointer or an integer, you can link them into a list, where the list head points to the first free element. åœ¨ä½¿ç”¨ alloc çš„å†…å­˜ç©ºé—´æ—¶ï¼Œè¿™äº›ç©ºé—´å¾ˆæœ‰å¯èƒ½æ˜¯ä¸è¿ç»­çš„ã€‚æ‰€ä»¥æ­¤æ—¶å¯¹äºç³»ç»Ÿå°±ä¼šå­˜åœ¨ä¸€äº›é—®é¢˜ï¼Œä¸€ä¸ªæ˜¯å†…å­˜ç©ºé—´ç¢ç‰‡ fragmentï¼Œå› ä¸ºåˆ†é…çš„ç©ºé—´æœªå¿…ä¼šå…¨éƒ¨ä½¿ç”¨åˆ°ï¼Œå¦ä¸€ä¸ªæ˜¯å› ä¸ºä¸è¿ç»­ï¼Œæ‰€ä»¥æ— æ³•åˆ©ç”¨ Cache locality æ¥æå‡æ•ˆèƒ½ã€‚ ","date":"2024-02-27","objectID":"/posts/c-memory/:2:3","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"Demand paging explained Linux ç³»ç»Ÿä¼šæä¾›ä¸€äº›å†…å­˜ç®¡ç†çš„ API å’Œæœºåˆ¶: mlock() - lock/unlock memory ç¦æ­¢æŸä¸ªåŒºåŸŸçš„å†…å­˜è¢« swapped out åˆ°ç£ç›˜ (åªæ˜¯å‘ OS å»ºè®®ï¼ŒOS å¯èƒ½ä¸ä¼šç†ä¼š) madvise() - give advice about use of memory (åŒæ ·åªæ˜¯å‘ OS å»ºè®®ï¼ŒOS å¯èƒ½ä¸ä¼šç†ä¼š) lazy loading - åˆ©ç”¨ç¼ºé¡µå¼‚å¸¸ (page-fault) æ¥å®ç° copy on write ä¿¡æ¯ ç¾ä»£è™•ç†å™¨è¨­è¨ˆ: Cache åŸç†å’Œå¯¦éš›å½±éŸ¿ Cache åŸç†å’Œå¯¦éš›å½±éŸ¿: é€²è¡Œ CPU caches ä¸­æ–‡é‡é»æç¤ºä¸¦ä¸”é‡ç¾å°æ‡‰çš„å¯¦é©— é‡å°å¤šåŸ·è¡Œç·’ç’°å¢ƒè¨­è¨ˆçš„ Memory allocator rpmalloc æ¢è¨ ","date":"2024-02-27","objectID":"/posts/c-memory/:2:4","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"å † Heap Stack Overflow: Why are two different concepts both called â€œheapâ€? Several authors began about 1975 to call the pool of available memory a â€œheap.â€ ","date":"2024-02-27","objectID":"/posts/c-memory/:3:0","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"Data alignment ä¸€ä¸ª data object å…·æœ‰ä¸¤ä¸ªç‰¹æ€§: value storage location (address) ","date":"2024-02-27","objectID":"/posts/c-memory/:4:0","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"alignment vs unalignment å‡è®¾ç¡¬ä½“è¦æ±‚ 4 Bytes alignmentï¼ŒCPU å­˜å–æ•°æ®æ—¶çš„æ“ä½œå¦‚ä¸‹: alignment unalignment Source é™¤æ­¤ä¹‹å¤–ï¼Œunalignment ä¹Ÿå¯èƒ½ä¼šæ— æ³•å……åˆ†åˆ©ç”¨ cache æ•ˆèƒ½ï¼Œå³å­˜å–çš„æ•°æ®ä¸€éƒ¨åˆ† cache hitï¼Œå¦ä¸€éƒ¨åˆ† cache missã€‚å½“ç„¶å¯¹äºè¿™ç§æƒ…å†µï¼Œcache ä¹Ÿæ˜¯é‡‡ç”¨ç±»ä¼¼ä¸Šé¢çš„ merge æœºåˆ¶æ¥è¿›è¡Œå­˜å–ï¼Œåªæ˜¯æ•ˆèƒ½ä½ä¸‹ã€‚ GCC: 6.60.8 Structure-Packing Pragmas The n value below always is required to be a small power of two and specifies the new alignment in bytes. #pragma pack(push[,n]) pushes the current alignment setting on an internal stack and then optionally sets the new alignment. #pragma pack(pop) restores the alignment setting to the one saved at the top of the internal stack (and removes that stack entry). Note that #pragma pack([n]) does not influence this internal stack; thus it is possible to have #pragma pack(push) followed by multiple #pragma pack(n) instances and finalized by a single #pragma pack(pop). alignment ä¸ unalignment çš„æ•ˆèƒ½åˆ†å¸ƒ: ","date":"2024-02-27","objectID":"/posts/c-memory/:4:1","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"malloc malloc åˆ†é…çš„ç©ºé—´æ˜¯ alignment çš„: man malloc The malloc() and calloc() functions return a pointer to the allocated memory, which is suitably aligned for any built-in type. The GNU C Library - Malloc Example The block that malloc gives you is guaranteed to be aligned so that it can hold any type of data. On GNU systems, the address is always a multiple of eight on 32-bit systems, and a multiple of 16 on 64-bit systems. ä½¿ç”¨ GDB è¿›è¡Œæµ‹è¯•ï¼Œç¡®å®šåœ¨ Linux x86_64 ä¸Š malloc åˆ†é…çš„å†…å­˜ä»¥ 16 Bytes å¯¹é½ï¼Œå³åœ°å€ä»¥ 16 è¿›åˆ¶æ˜¾ç¤ºæ—¶æœ€åä¸€ä¸ªæ•°ä¸º 0ã€‚ ","date":"2024-02-27","objectID":"/posts/c-memory/:4:2","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"unalignment get \u0026 set å¦‚ä¸Šé¢æ‰€è¿°ï¼Œåœ¨ 32-bit æ¶æ„ä¸Šè¿›è¡Œ 8 bytes å¯¹é½çš„å­˜å–æ•ˆèƒ½æ¯”è¾ƒé«˜ (è¿œæ¯”å•çº¯è®¿é—®ä¸€ä¸ª byte é«˜)ï¼Œæ‰€ä»¥åŸæ–‡åˆ©ç”¨è¿™ä¸€ç‰¹æ€§å®ä½œäº† unaligned_get8 è¿™ä¸€å‡½æ•°ã€‚ csrc \u0026 0xfffffffc å‘ä¸‹å–æ•´åˆ°æœ€è¿‘çš„ 8 bytes alignment çš„åœ°å€ v \u003e\u003e (((uint32_t) csrc \u0026 0x3) * 8) å°†è·å–çš„ alignment çš„ 32-bit è¿›è¡Œä½ç§»ä»¥è·å–æˆ‘ä»¬æƒ³è¦çš„é‚£ä¸ªå­—èŠ‚ è€Œåœ¨ ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡ ä¸­å®ä½œçš„ 16-bit integer åœ¨ unalignment æƒ…å†µä¸‹çš„å­˜å–ï¼Œå¹¶æ²¡æœ‰è€ƒè™‘åˆ°ä¸Šé¢åˆ©ç”¨ alignment æ¥æå‡æ•ˆèƒ½ã€‚ åŸæ–‡ 32 ä½æ¶æ„çš„ unalignment å­˜å–æœ‰äº›é—®é¢˜ï¼Œä¿®æ­£å¹¶è¡¥å……æ³¨é‡Šå¦‚ä¸‹: uint8_t unaligned_get8(void *src) { uintptr_t csrc = (uintptr_t) src; uint32_t v = *(uint32_t *) (csrc \u0026 0xfffffffc); // align 4-bytes v = (v \u003e\u003e (((uint32_t) csrc \u0026 0x3) * 8)) \u0026 0x000000ff; // get byte return v; } void unaligned_set8(void *dest, uint8_t value) { uintptr_t cdest = (uintptr_t) dest; uintptr_t ptr = cdest \u0026 0xfffffffc; // align 4-bytes for (int n = 0; n \u003c 4; n++) { uint32_t v; if (n == (cdest \u0026 0x3)) v = value; else v = unaligned_get8((void *) ptr); v = v \u003c\u003c (n * 8); d = d | v; ptr++; } *(uint32_t *) (cdest \u0026 0xfffffffc) = v; } å®ä½œ 64-bit integer (64 ä½æ¶æ„) çš„ get \u0026 set: uint8_t unaligned_get8(void *src) { uintptr_t csrc = (uintptr_t) src; uint32_t v = *(uint32_t *) (csrc \u0026 0xfffffff0); // align 4-bytes v = (v \u003e\u003e (((uint32_t) csrc \u0026 0x3) * 8)) \u0026 0x000000ff; // get byte return v; } void unaligned_set8(void *dest, uint8_t value) { uintptr_t cdest = (uintptr_t) dest; uintptr_t ptr = cdest \u0026 0xfffffff0; // align 4-bytes for (int n = 0; n \u003c 8; n++) { uint32_t v; if (n == (cdest \u0026 0x3)) v = value; else v = unaligned_get8((void *) ptr); v = v \u003c\u003c (n * 8); d = d | v; ptr++; } *(uint32_t *) (cdest \u0026 0xfffffff0) = v; } å…¶å®ƒé€»è¾‘å’Œ 32 ä½æœºå™¨ä¸Šç±»ä¼¼ Data Alignment Linux kernel: Unaligned Memory Accesses ","date":"2024-02-27","objectID":"/posts/c-memory/:4:3","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"concurrent-II ä¿¡æ¯ æºç : concurrent-ll è®ºæ–‡: A Pragmatic Implementation of Non-Blocking Linked Lists ä½¿ç”¨ CAS æ— æ³•ç¡®ä¿é“¾è¡¨æ’å…¥å’Œåˆ é™¤åŒæ—¶å‘ç”Ÿæ—¶çš„æ­£ç¡®æ€§ï¼Œå› ä¸º CAS è™½ç„¶ä¿è¯äº†åŸå­æ“ä½œï¼Œä½†æ˜¯åœ¨è¿›è¡ŒåŸå­æ“ä½œä¹‹å‰ï¼Œéœ€è¦åœ¨é“¾è¡¨ä¸­é”šå®šèŠ‚ç‚¹ä»¥è¿›è¡Œåç»­çš„æ’å…¥ã€åˆ é™¤ (è¿™é‡Œæ˜¯é€šè¿‡ CAS æ“ä½œ)ã€‚å¦‚æœå…ˆå‘ç”Ÿæ’å…¥ï¼Œé‚£ä¹ˆå¹¶ä¸ä¼šå½±å“åé¢çš„æ“ä½œ (æ’å…¥æˆ–åˆ é™¤)ï¼Œå› ä¸ºæ’å…¥çš„èŠ‚ç‚¹å¹¶ä¸ä¼šå½±å“åé¢æ“ä½œé”šå®šçš„èŠ‚ç‚¹ã€‚ä½†å¦‚æœå…ˆå‘ç”Ÿåˆ é™¤ï¼Œé‚£ä¹ˆè¿™ä¸ªåˆ é™¤æ“ä½œå¾ˆæœ‰å¯èƒ½å°±æŠŠåé¢æ“ä½œ (æ’å…¥æˆ–åˆ é™¤) å·²ç»é”šå®šçš„èŠ‚ç‚¹ä»é“¾è¡¨ä¸­åˆ æ‰äº†ï¼Œè¿™å°±å¯¼è‡´äº†åç»­æ“ä½œçš„ä¸æ­£ç¡®ç»“æœã€‚æ‰€ä»¥éœ€è¦ä¸€ä¸ªæ–¹æ³•æ¥æ ‡è¯†ã€Œä¸éœ€è¦çš„èŠ‚ç‚¹ã€ï¼Œç„¶åå†è¿›è¡ŒåŸå­æ“ä½œã€‚ é—®é¢˜ åªä½¿ç”¨ä½è¿ç®—å³å¯å®ç°é€»è¾‘ä¸Šåˆ é™¤èŠ‚ç‚¹ (å³é€šè¿‡ä½è¿ç®—æ ‡è®°èŠ‚ç‚¹)ï¼Ÿ C99 6.7.2.1 Structure and union specifiers Each non-bit-field member of a structure or union object is aligned in an implementation defined manner appropriate to its type. Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. There may be unnamed padding within a structure object, but not at its beginning. æ‰€ä»¥ C è¯­è¨€ä¸­ç»“æ„ä½“çš„ padding æ˜¯ implementation defined çš„ï¼Œä½†æ˜¯ä¿è¯è¿™äº› padding ä¸ä¼šå‡ºç°åœ¨ç»“æ„ä½“çš„èµ·å§‹å¤„ã€‚ GCC 4.9 Structures, Unions, Enumerations, and Bit-Fields The alignment of non-bit-field members of structures (C90 6.5.2.1, C99 and C11 6.7.2.1). Determined by ABI. C99 7.18.1.4 Integer types capable of holding object pointers The following type designates a signed integer type with the property that any valid pointer to void can be converted to this type, then converted back to pointer to void, and the result will compare equal to the original pointer: intptr_t x86_64 ABI Aggregates and Unions Structures and unions assume the alignment of their most strictly aligned compo- nent. Each member is assigned to the lowest available offset with the appropriate alignment. The size of any object is always a multiple of the objectâ€˜s alignment. An array uses the same alignment as its elements, except that a local or global array variable of length at least 16 bytes or a C99 variable-length array variable always has alignment of at least 16 bytes. 4 Structure and union objects can require padding to meet size and alignment constraints. The contents of any padding is undefined. æ‰€ä»¥å¯¹äºé“¾è¡¨èŠ‚ç‚¹å¯¹åº”çš„ç»“æ„ä½“: typedef intptr_t val_t; typedef struct node { val_t data; struct node *next; } node_t; å› ä¸º data alignment çš„ç¼˜æ•…ï¼Œå®ƒçš„åœ°å€çš„æœ€åä¸€ä¸ª bit å¿…ç„¶æ˜¯ 0 (æˆå‘˜éƒ½æ˜¯ 4-bytes çš„å€æ•°ä»¥åŠå¿…é¡»å¯¹é½)ï¼ŒåŒç†å…¶æˆå‘˜ next ä¹Ÿæ»¡è¶³è¿™ä¸ªæ€§è´¨ (å› ä¸ºè¿™ä¸ªæˆå‘˜è¡¨ç¤ºä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„åœ°å€)ã€‚æ‰€ä»¥åˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œå¯ä»¥å°† next çš„æœ€åä¸€ä¸ª bit è®¾ç½®ä¸º 1ï¼Œè¡¨ç¤ºå½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å·²ç»è¢«â€œé€»è¾‘ä¸Šâ€åˆ é™¤äº†ã€‚ æœ€åå½“æ²¡æœ‰æ’å…¥æˆ–åˆ é™¤æ“ä½œæ˜¯ï¼Œé“¾è¡¨å†å¯¹æ ‡è¯†ä¸ºâ€œåˆ é™¤â€çš„èŠ‚ç‚¹è¿›è¡Œç§»é™¤ï¼Œè¿™ä¸ªæœºåˆ¶æœ‰ç‚¹ç±»ä¼¼äº GC ","date":"2024-02-27","objectID":"/posts/c-memory/:5:0","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":"glibc çš„ malloc/free å®ä½œ èƒŒæ™¯è€ƒé‡: Deterministic Memory Allocation for Mission-Critical Linux Main arena vs Thread arena : multiple heap Thread arena : ","date":"2024-02-27","objectID":"/posts/c-memory/:6:0","tags":["Sysprog","C","Memory"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§","uri":"/posts/c-memory/"},{"categories":["C","Linux Kernel Internals"],"content":" Linux æ ¸å¿ƒåŸå§‹ç¨‹å¼ç å­˜åœ¨å¤§é‡ bit(-wise) operations (ç®€ç§° bitops)ï¼Œé¢‡å¤šä¹çœ‹åƒæ˜¯é­”æ³•çš„ C ç¨‹å¼ç å°±æ˜¯ bitops çš„ç»„åˆã€‚ åŸæ–‡åœ°å€ ","date":"2024-02-23","objectID":"/posts/c-bitwise/:0:0","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"å¤ä¹ æ•°å€¼ç³»ç»Ÿ YouTube: åè¿›åˆ¶ï¼ŒåäºŒè¿›åˆ¶ï¼Œå…­åè¿›åˆ¶ä»ä½•è€Œæ¥ï¼Ÿé˜¿æ‹‰ä¼¯äººæˆå°±äº†æ–‡è‰ºå¤å…´ï¼Ÿ[æ•°å­¦å¤§å¸ˆ] ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿ è§£è¯»è®¡ç®—æœºç¼–ç  ","date":"2024-02-23","objectID":"/posts/c-bitwise/:1:0","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"ä½å…ƒç»„åˆ ä¸€äº›ä½å…ƒç»„åˆè¡¨ç¤ºç‰¹å®šçš„æ„ä¹‰ï¼Œè€Œä¸æ˜¯è¡¨ç¤ºæ•°å€¼ï¼Œè¿™äº›ç»„åˆè¢«ç§°ä¸º trap representation C11 6.2.6.2 Integer types For unsigned integer types other than unsigned char, the bits of the object representation shall be divided into two groups: value bits and padding bits (there need not be any of the latter). If there are N value bits, each bit shall represent a different power of 2 between 1 and 2Nâˆ’1, so that objects of that type shall be capable of representing values from 0 to 2Nâˆ’1 using a pure binary representation; this shall be known as the value representation. The values of any padding bits are unspecified. uintN_t å’Œ intN_t ä¿è¯æ²¡æœ‰å¡«å……ä½å…ƒ (padding bits)ï¼Œä¸” intN_t æ˜¯äºŒè¡¥æ•°ç¼–ç ï¼Œæ‰€ä»¥å¯¹è¿™ä¸¤ç§ç±»å‹è¿›è¡Œä½æ“ä½œæ˜¯å®‰å…¨çš„ã€‚ C99 7.18.1.1 Exact-width integer types The typedef name intN_t designates a signed integer type with width N, no padding bits, and a twoâ€™s complement representation. ä¿¡æ¯ æœ‰ç¬¦å·æ•´æ•°ä¸Šä¹Ÿæœ‰å¯èƒ½äº§ç”Ÿé™·é˜±è¡¨ç¤ºæ³• (trap representation) è¡¥å……èµ„è®¯: CS:APP Web Aside DATA:TMIN: Writing TMin in C ","date":"2024-02-23","objectID":"/posts/c-bitwise/:1:1","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"ä½ç§»è¿ç®— ä½ç§»è¿ç®—çš„æœªå®šä¹‰æƒ…å†µ: C99 6.5.7 Bitwise shift operators å·¦ç§»è¶…è¿‡å˜é‡é•¿åº¦ï¼Œåˆ™è¿ç®—ç»“æœæœªå®šä¹‰ If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined. å¯¹ä¸€ä¸ªè´Ÿæ•°è¿›è¡Œå³ç§»ï¼ŒC è¯­è¨€è§„æ ¼æœªå®šä¹‰ï¼Œä½œä¸º implementation-definedï¼ŒGCC å®ä½œä¸ºç®—æœ¯ä½ç§» (arithmetic shift) If E1 has a signed type and a negative value, the resulting value is implementation-defined. ","date":"2024-02-23","objectID":"/posts/c-bitwise/:1:2","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"Signed \u0026 Unsigned å½“ Unsigned å’Œ Signed æ··åˆåœ¨åŒä¸€è¡¨è¾¾å¼æ—¶ï¼ŒSigned ä¼šè¢«è½¬æ¢æˆ Unsignedï¼Œè¿ç®—ç»“æœå¯èƒ½ä¸ç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸ (è¿™é‡Œå¤§èµ Rustï¼Œè¿™ç§æƒ…å†µä¼šç¼–è¯‘å¤±è´¥ğŸ¤£)ã€‚æ¡ˆä¾‹è¯·å‚è€ƒåŸæ–‡ï¼Œè¿™é‡Œä¸¾ä¸€ä¸ªæ¯”è¾ƒå¸¸è§çš„ä¾‹å­: int n = 10; for (int i = n - 1 ; i - sizeof(char) \u003e= 0; i--) printf(\"i: 0x%x\\n\",i); è¿™æ®µç¨‹å¼ç ä¼šå¯¼è‡´æ— é™å¾ªç¯ï¼Œå› ä¸ºæ¡ä»¶åˆ¤æ–­è¯­å¥ i - sizeof(char) \u003e= 0 æ’ä¸ºçœŸ (å˜é‡ i è¢«è½¬æ¢æˆ Unsigned äº†)ã€‚ 6.5.3.4 The sizeof operator The value of the result is implementation-defined, and its type (an unsigned integer type) is size_t, defined in \u003cstddef.h\u003e (and other headers). 7.17 Common definitions \u003cstddef.h\u003e size_t which is the unsigned integer type of the result of the sizeof operator ","date":"2024-02-23","objectID":"/posts/c-bitwise/:1:3","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"Sign Extension å°† w bit signed integer æ‰©å±•ä¸º w+k bit signed integerï¼Œåªéœ€å°† sign bit è¡¥å……è‡³æ‰©å±•çš„ bitsã€‚ æ•°å€¼ç­‰ä»·æ€§æ¨å¯¼: positive: æ˜¾ç„¶æ˜¯æ­£ç¡®çš„ï¼Œsign bit ä¸º 0ï¼Œæ‰©å±•åæ•°å€¼ä»ç­‰äºåŸæ•°å€¼ negitive: å°† w bit æƒ…å½¢æ—¶çš„é™¤å¼€ sign bit çš„æ•°å€¼è®¾ä¸º Uï¼Œåˆ™åŸæ•°å€¼ä¸º $2^{-(w-1)} + U$ï¼Œåˆ™æ‰©å±•ä¸º w+k bit åæ•°å€¼ä¸º $2^{-(w+k-1)} + 2^{w+k-2} + â€¦ + 2^{-(w-1)} + U$ï¼Œå› ä¸º $2^{-(w+k-1)} + 2^{w+k-2} + â€¦ + 2^{w-1} = 2^{-(w-1)}$ï¼Œæ‰€ä»¥æ•°å€¼ä¾ç„¶ç­‰ä»·ã€‚ $2^{-(w+k-1)} + 2^{w+k-2} + â€¦ + 2^{w-1}$ å¯ä»¥è€ƒè™‘ä»å·¦å¾€å³çš„è¿ç®—ï¼Œæ¯æ¬¡éƒ½æ˜¯å°†åŸå…ˆçš„æ•°å€¼å‡åŠï¼Œæ‰€ä»¥æœ€åçš„æ•°å€¼ä¸º $2^{-(w+k-1)}$ æ‰€ä»¥å¦‚æœ n æ˜¯ signed 32-bitï¼Œåˆ™ n \u003e\u003e 31 ç­‰ä»·äº n == 0 ? 0 : -1ã€‚åœ¨è¿™ä¸ªçš„åŸºç¡€ä¸Šï¼Œè¯·é‡æ–°é˜…è¯» è§£è¯»è®¡ç®—æœºç¼–ç  ä¸­çš„ abs å’Œ min/max çš„å¸¸æ•°æ—¶é—´å®ä½œã€‚ ","date":"2024-02-23","objectID":"/posts/c-bitwise/:1:4","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"Bitwise Operator Bitwise Operators Quiz Answers Practice with bit operations Bitwise Practice Each lowercase letter is 32 + uppercase equivalent. This means simply flipping the bit at position 5 (counting from least significant bit at position 0) inverts the case of a letter. The gdb print command (shortened p) defaults to decimal format. Use p/format to instead select other formats such as x for hex, t for binary, and c for char. // unsigned integer `mine`, `yours` remove yours from mine mine = mine \u0026 ~yours test if mine has both of two lowest bits on (mine \u0026 0x3) == 0x3 n least significant bits on, all others off (1 \u003c\u003c n) - 1 k most significant bits on, all others off (~0 \u003c\u003c (32 - k)) or ~(~0U \u003e\u003e k) // unsigned integer `x`, `y` (right-shift: arithmetic shift) x \u0026= (x - 1) clears lowest \"on\" bit in x (x ^ y) \u003c 0 true if x and y have opposite signs ç¨‹åºè¯­è¨€åªæä¾›æœ€å°ç²’åº¦ä¸º Byte çš„æ“ä½œï¼Œä½†æ˜¯ä¸ç›´æ¥æä¾› Bit ç²’åº¦çš„æ“ä½œï¼Œè¿™ä¸å­—èŠ‚é¡ºåºç›¸å…³ã€‚å‡è®¾æä¾›ä»¥ Bit ä¸ºç²’åº¦çš„æ“ä½œï¼Œè¿™å°±éœ€è¦åœ¨ç¼–ç¨‹æ—¶è€ƒè™‘ å¤§ç«¯/å°ç«¯æ¨¡å¼ï¼Œæå…¶ç¹çã€‚ ","date":"2024-02-23","objectID":"/posts/c-bitwise/:2:0","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"bitwise \u0026 logical ä½è¿ç®—æ»¡è¶³äº¤æ¢å¾‹ï¼Œä½†é€»è¾‘è¿ç®—å¹¶ä¸æ»¡è¶³äº¤æ¢å¾‹ï¼Œå› ä¸ºçŸ­è·¯æœºåˆ¶ã€‚è€ƒè™‘ Linked list ä¸­çš„æƒ…å½¢: // list_head *head if (!head || list_empty(head)) if (list_empty(head) || !head) ç¬¬äºŒæ¡è¯­å¥åœ¨æ‰§è¡Œæ—¶ä¼šæŠ¥é”™ï¼Œå› ä¸º list_empty è¦æ±‚ä¼ å…¥çš„å‚æ•°ä¸ä¸º NULLã€‚ é€»è¾‘è¿ç®—ç¬¦ ! ç›¸å½“æœ‰æ•ˆï¼ŒC99 å¹¶æ²¡æœ‰å®Œå…¨æ”¯æŒ bool ç±»å‹ï¼Œå¯¹äºæ•´æ•°ï¼Œå®ƒæ˜¯å°†éé›¶æ•´æ•°è§†ä¸º trueï¼Œé›¶è§†ä¸º falseã€‚æ‰€ä»¥å¦‚æœä½ éœ€è¦ä¿è¯æŸä¸€è¡¨è¾¾å¼çš„ç»“æœä¸ä»…æ˜¯ true of falseï¼Œè¿˜è¦æ±‚å¯¹åº” 0 or 1 æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ !!(expr) æ¥å®ç°ã€‚ C99 6.5.3.3 Unary arithmetic operators The result of the logical negation operator ! is 0 if the value of its operand compares unequal to 0, 1 if the value of its operand compares equal to 0. The result has type int. The expression !E is equivalent to (0==E). æ‰€ä»¥ !!(expr) çš„ç»“æœä¸º int å¹¶ä¸”æ•°å€¼åªæœ‰ 0 æˆ– 1ã€‚ ","date":"2024-02-23","objectID":"/posts/c-bitwise/:2:1","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"Right Shifts å¯¹äº Unsigned æˆ– positive sign integer åšå³ç§»è¿ç®—æ—¶ x \u003e\u003e nï¼Œå…¶æœ€ç»ˆç»“æœå€¼ä¸º $\\lfloor x / 2^n \\rfloor$ã€‚ å› ä¸ºè¿™ç§æƒ…å†µçš„å³ç§»æ“ä½œç›¸å½“äºå¯¹æ¯ä¸ª bit è¡¨ç¤ºçš„ power åŠ ä¸Š $-n$ï¼Œå†è€ƒè™‘æœ‰äº› bit è¡¨ç¤ºçš„ power åŠ ä¸Š $-n$ åä¼šå°äº 0ï¼Œæ­¤æ—¶ç›´æ¥å°†è¿™äº› bit æ‰€è¡¨ç¤ºçš„å€¼å»é™¤å³å¯ (å› ä¸ºåœ¨ integer ä¸­ bit çš„ power æœ€å°ä¸º 0ï¼Œå¦‚æœ power å°äº 0 è¡¨ç¤ºçš„æ˜¯å°æ•°å€¼)ï¼Œè¿™ä¸ªæ“ä½œå¯¹åº”äºå‘ä¸‹å–æ•´ã€‚ 00010111 \u003e\u003e 2 (23 \u003e\u003e 4) -\u003e 000101.11 (5.75) -\u003e 000101 (5) ","date":"2024-02-23","objectID":"/posts/c-bitwise/:2:2","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"bitwise å®ä½œ Vi/Vim ä¸ºä»€ä¹ˆä½¿ç”¨ hjkl ä½œä¸ºç§»åŠ¨å­—ç¬¦? ç•¶æˆ‘å€‘å›é¡§ 1967 å¹´ ASCII çš„ç·¨ç¢¼è¦ç¯„ï¼Œå¯ç™¼ç¾å‰ 32 å€‹å­—å…ƒéƒ½æ˜¯æ§åˆ¶ç¢¼ï¼Œè®“äººå€‘å¾—ä»¥é€éé€™äº›ç‰¹åˆ¥å­—å…ƒä¾†æ§åˆ¶ç•«é¢å’Œç›¸é—œ I/Oï¼Œæ—©æœŸéµç›¤çš„ â€œcontrolâ€ æŒ‰éµå°±æ­é…é€™äº›ç‰¹åˆ¥å­—å…ƒä½¿ç”¨ã€‚â€œcontrolâ€ çµ„åˆæŒ‰éµæœƒå°‡åŸæœ¬å­—å…ƒçš„ç¬¬ 1 å€‹ bit é€²è¡Œ XORï¼Œæ–¼æ˜¯ H å­—å…ƒå°æ‡‰ ASCII ç·¨ç¢¼ç‚º 100_1000 (éå»åƒ…ç”¨ 7 bit ç·¨ç¢¼)ï¼Œçµ„åˆ â€œcontrolâ€ å¾Œ (å³ Ctrl+H) æœƒå¾—åˆ° 000_1000ï¼Œä¹Ÿå°±æ˜¯ backspace çš„ç·¨ç¢¼ï¼Œé€™ä¹Ÿæ˜¯ç‚ºä½•åœ¨æŸäº›ç¨‹å¼ä¸­æŒ‰ä¸‹ backspace æŒ‰éµæœƒå¾—åˆ° ^H è¼¸å‡ºçš„åŸå› ã€‚ç›¸ä¼¼åœ°ï¼Œç•¶æŒ‰ä¸‹ Ctrl+J æ™‚æœƒå¾—åˆ° 000_1010ï¼Œå³ linefeed æ³¨æ„ where n is the bit number, and 0 is the least significant bit Source ","date":"2024-02-23","objectID":"/posts/c-bitwise/:3:0","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"Set a bit unsigned char a |= (1 \u003c\u003c n); ","date":"2024-02-23","objectID":"/posts/c-bitwise/:3:1","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"Clear a bit unsigned char a \u0026= ~(1 \u003c\u003c n); ","date":"2024-02-23","objectID":"/posts/c-bitwise/:3:2","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"Toggle a bit unsigned char a ^= (1 \u003c\u003c n); ","date":"2024-02-23","objectID":"/posts/c-bitwise/:3:3","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"Test a bit bool a = (val \u0026 (1 \u003c\u003c n)) \u003e 0; ","date":"2024-02-23","objectID":"/posts/c-bitwise/:3:4","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"The right/left most byte // assuming 16 bit, 2-byte short integer unsigned short right = val \u0026 0xff; /* right most (least significant) byte */ unsigned short left = (val \u003e\u003e 8) \u0026 0xff; /* left most (most significant) byte */ // assuming 32 bit, 4-byte int integer unsigned int right = val \u0026 0xff; /* right most (least significant) byte */ unsigned int left = (val \u003e\u003e 24) \u0026 0xff; /* left most (most significant) byte */ ","date":"2024-02-23","objectID":"/posts/c-bitwise/:3:5","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"Sign bit // assuming 16 bit, 2-byte short integer, two's complement bool sign = val \u0026 0x8000; // assuming 32 bit, 4-byte int integer, two's complement bool sign = val \u0026 0x80000000; ","date":"2024-02-23","objectID":"/posts/c-bitwise/:3:6","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"Uses of Bitwise Operations or Why to Study Bits Compression Set operations Encryption æœ€å¸¸è§çš„å°±æ˜¯ä½å›¾ (bitmap)ï¼Œå¸¸ç”¨äºæ–‡ä»¶ç³»ç»Ÿ (file system)ï¼Œå¯ä»¥èŠ‚çœç©ºé—´ (æ¯ä¸ªå…ƒç´ åªç”¨ä¸€ä¸ª bit æ¥è¡¨ç¤º)ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿çš„è¿›è¡Œé›†åˆæ“ä½œ (é€šè¿‡ bitwise operator)ã€‚ x ^ y = (~x \u0026 y) | (x \u0026 ~y) ","date":"2024-02-23","objectID":"/posts/c-bitwise/:3:7","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"å½±åƒå¤„ç† Stack Overflow: what (r+1 + (r Â» 8)) Â» 8 does? åœ¨å›¾å½¢å¼•æ“ä¸­å°†é™¤æ³•è¿ç®— x / 255 ç”¨ä½è¿ç®— (x+1 + (x \u003e\u003e 8)) \u003e\u003e 8 æ¥å®ä½œï¼Œå¯ä»¥å¤§å¹…åº¦æå‡è®¡ç®—æ•ˆèƒ½ã€‚ ","date":"2024-02-23","objectID":"/posts/c-bitwise/:4:0","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"æ¡ˆä¾‹åˆ†æ å®ä½œç¨‹å¼ç : RGBAtoBW ç»™å®šæ¯ä¸ª pixel ä¸º 32-bit çš„ RGBA çš„ bitmapï¼Œæå‡æ•ˆèƒ½çš„æ–¹æ¡ˆ: å»ºç«‹è¡¨æ ¼åŠ é€Ÿæµ®ç‚¹è¿ç®— å‡å°‘ä½è¿ç®—: å¯ä»¥ä½¿ç”¨ pointer çš„ offset å–ä»£åŸæœ¬å¤æ‚çš„ bitwise operation bwPixel = table[rgbPixel \u0026 0x00ffffff] + rgbPixel \u0026 0xff000000; åªéœ€å¯¹ RGB éƒ¨åˆ†å»ºç«‹æµ®ç‚¹æ•°è¡¨ï¼Œå› ä¸º rgbPixel \u0026 0xff00000 è·å–çš„æ˜¯ Aï¼Œæ— éœ€å‚ä¸æµ®ç‚¹è¿ç®—ã€‚è¿™æ ·å»ºç«‹çš„è¡¨æœ€å¤§ä¸‹æ ‡åº”ä¸º 0x00ffffffï¼Œæ‰€ä»¥è¿™ä¸ªè¡¨å ç”¨ $2^{24} Bytes = 16MB$ï¼Œæ˜¾ç„¶è¿™ä¸ªè¡¨å¤ªå¤§äº† not cache friendly bw = (uint32_t) mul_299[r] + (uint32_t) mul_587[g] + (uint32_t) mul_144[b]; bwPixel = (a \u003c\u003c 24) + (bw \u003c\u003c 16) + (bw \u003c\u003c 8) + bw; åˆ†åˆ«å¯¹ R, G, B å»ºç«‹å¯¹åº”çš„æµ®ç‚¹æ•°è¡¨ï¼Œåˆ™è¿™ä¸‰ä¸ªè¡¨æ€»å…±å ç”¨ $3 \\times 2^8 Bytes \u003c 32KB$ cache friendly ","date":"2024-02-23","objectID":"/posts/c-bitwise/:4:1","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"æ¡ˆä¾‹æ¢è®¨ ä¿¡æ¯ ä½å…ƒæ—‹è½¬å®ä½œå’Œ Linux æ ¸å¿ƒæ¡ˆä¾‹ reverse bit åŸç†å’Œæ¡ˆä¾‹åˆ†æ ","date":"2024-02-23","objectID":"/posts/c-bitwise/:5:0","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"ç±»ç¥ç»ç½‘ç»œçš„ ReLU æå…¶å¸¸æ•°æ—¶é—´å¤æ‚åº¦å®ä½œ åŸæ–‡åœ°å€ ReLU å®šä¹‰å¦‚ä¸‹: $$ ReLU(x) = \\begin{cases} x \u0026 \\text{if } x \\geq 0 \\newline 0 \u0026 \\text{if } x \\lt 0 \\end{cases} $$ æ˜¾ç„¶å¦‚æœ $x$ æ˜¯ 32-bit çš„äºŒè¡¥æ•°ï¼Œå¯ä»¥ä½¿ç”¨ä¸Šé¢æåˆ°çš„ x \u003e\u003e 31 çš„æŠ€å·§æ¥å®ä½œ constant-time function: int32_t ReLU(int32_t x) { return ~(x \u003e\u003e 31) \u0026 x; } ä½†æ˜¯åœ¨æ·±åº¦å­¦ä¹ ä¸­ï¼Œæµ®ç‚¹æ•°ä½¿ç”¨æ›´åŠ å¸¸è§ï¼Œå¯¹äºæµ®ç‚¹æ•°è¿›è¡Œä½ç§»è¿ç®—æ˜¯ä¸å…è®¸çš„ C99 6.5.7 Bitwise shift operators Each of the operands shall have integer type. æ‰€ä»¥è¿™é‡Œä»¥ 32-bit float æµ®ç‚¹æ•°ç±»å‹ä¸ºä¾‹ï¼Œåˆ©ç”¨ 32-bit äºŒè¡¥æ•°å’Œ 32-bit float çš„ MSB éƒ½æ˜¯ sign bitï¼Œä»¥åŠ C è¯­è¨€ç±»å‹ union çš„ç‰¹æ€§ C99 6.5.2.3 (82) If the member used to access the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called â€œtype punningâ€). This might be a trap representation. å³ union æ‰€æœ‰æˆå‘˜æ˜¯å…±ç”¨ä¸€å—å†…å­˜çš„ï¼Œæ‰€ä»¥è®¿é—®æˆå‘˜æ—¶ä¼šå°†è¿™å—å†…å­˜å­˜å‚¨çš„ object æŒ‰ç…§æˆå‘˜çš„ç±»å‹è¿›è¡Œè§£é‡Šã€‚åˆ©ç”¨ int32_t å’Œ float çš„ MSB éƒ½æ˜¯ sign bit çš„ç‰¹æ€§ï¼Œå¯ä»¥å·§å¦™ç»•å¼€å¯¹æµ®ç‚¹æ•°è¿›è¡Œä½ç§»è¿ç®—çš„é™åˆ¶ï¼Œå¹¶ä¸”å› ä¸º union æˆå‘˜å†…å­˜çš„å…±ç”¨æ€§è´¨ï¼Œä¿è¯ç»“æœçš„æ•°å€¼ç¬¦åˆé¢„æœŸã€‚ float ReLU(float x) { union { float f; int32_t i; } u = {.f = x}; u.i \u0026= ~(u.i \u003e\u003e 31); return u.f; } åŒç†å¯ä»¥å®Œæˆ 64-bit æµ®ç‚¹æ•°çš„ ReLU å¸¸æ•°æ—¶é—´å®ä½œã€‚ double ReLU(float x) { union { double f; int64_t i; } u = {.f = x}; u.i \u0026= ~(u.i \u003e\u003e 63); return u.f; } ","date":"2024-02-23","objectID":"/posts/c-bitwise/:6:0","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"ä» $\\sqrt 2$ çš„å­˜åœ¨è°ˆå¼€å¹³æ–¹æ ¹çš„å¿«é€Ÿè¿ç®— åŸæ–‡åœ°å€ æ³¨æ„ è¿™ä¸€éƒ¨åˆ†éœ€è¦å­¦å‘˜å¯¹ç°ä»£æ•°å­¦è§‚ç‚¹æœ‰ä¸€äº›äº†è§£ï¼Œå¼ºçƒˆæ¨èä¿®å°å¤§é½éœ‡å®‡è€å¸ˆçš„ã€Œæ•°å­¦æ½œæ°´è‰‡/æ–°ç”Ÿè¥æ¼”è®²ã€ï¼Œé½è€å¸ˆçš„è¿™äº›è®²åº§éš¾åº¦å’Œå¹¿åº¦å¤§è‡´ç›¸å½“äºå…¶å®ƒé™¢æ ¡å¼€è®¾çš„ã€Œæ•°å­¦å¯¼è®ºã€ä¸€è¯¾ã€‚ ","date":"2024-02-23","objectID":"/posts/c-bitwise/:7:0","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"$\\sqrt 2$ çš„ç¼˜èµ·å’Œè®¡ç®— YouTube: ç¬¬ä¸€æ¬¡æ•°å­¦å±æœºï¼Œå¤©æ‰æ˜¯æ€ä¹ˆè¢«æ‰¼æ€çš„ï¼Ÿ å¯ä»¥é€šè¿‡ã€Œååˆ†é€¼è¿‘æ³•ã€æ¥æ±‚å¾—è¿‘ä¼¼ç²¾ç¡®çš„ $\\sqrt 2$ çš„æ•°å€¼ï¼Œè¿™ä¹Ÿæ˜¯ã€Œæ•°å€¼è®¡ç®—/åˆ†æã€é¢†åŸŸçš„ä¸€ä¸ªåº”ç”¨ï¼Œé™¤æ­¤ä¹‹å¤–è¿˜å¯ä»¥ä½¿ç”¨ã€ŒäºŒåˆ†é€¼è¿‘æ³•ã€è¿›è¡Œæ±‚å€¼ã€‚ååˆ†é€¼è¿‘æ³•å’ŒäºŒåˆ†é€¼è¿‘æ³•çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼šååˆ†é€¼è¿‘æ³•çš„æ”¶æ•›é€Ÿåº¦æ¯”äºŒåˆ†é€¼è¿‘æ³•å¿«å¾ˆå¤šï¼Œå³ä¼šæ›´å¿«æ±‚å¾—ç†æƒ³èŒƒå›´ç²¾åº¦å¯¹åº”çš„æ•°å€¼ã€‚ åœ¨æ•°ç»„æ–¹æ³•çš„åˆ†æä¸­ï¼Œä¸»è¦å…³å¿ƒä¸¤ä»¶äº‹: æ”¶æ•›é€Ÿåº¦ è¯¯å·®åˆ†æ ç”±é€¼è¿‘æ³•çš„è¿‡ç¨‹ä¸éš¾çœ‹å‡ºï¼Œå®ƒä»¬éå¸¸é€‚åˆä½¿ç”¨é€’å½’æ¥å®ä½œ: YouTube: äºŒåˆ†é€¼è¿‘æ³•å’Œååˆ†é€¼è¿‘æ³•æ±‚å¹³æ–¹æ ¹ ","date":"2024-02-23","objectID":"/posts/c-bitwise/:7:1","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"å›ºå®šç‚¹å’Œç‰›é¡¿æ³• å›ºå®šç‚¹å®šç†ç›¸å…³çš„è¯æ˜æŒºæœ‰æ„æ€çš„ (å‰ææ˜¯ä½ ä¿®è¿‡æ•°å­¦å¯¼è®ºè¿™ç±»å…·å¤‡ç°ä»£æ•°å­¦è§‚ç‚¹å’Œæ€ç»´çš„è¯¾ ğŸ¤£): å­˜åœ¨æ€§ (åˆ†ç±»è®¨è®º) å”¯ä¸€æ€§ (åè¯æ³•) å›ºå®šç‚¹å®šç† (é€»è¾‘æ¨ç†) å¯ä»¥å°†æ±‚æ–¹ç¨‹çš„æ ¹è½¬æ¢æˆæ±‚å›ºå®šç‚¹çš„é—®é¢˜ï¼Œç„¶ååˆ©ç”¨æ”¶æ•›æ•°åˆ—è¿›è¡Œæ±‚è§£: $f(x) = 0$ $g(x) = p - f(x)$ and $g(p) = p$ ç‰›é¡¿æ³•å…¬å¼: $$ p \\approx p_0 -\\dfrac{f(p_0)}{fâ€™(p_0)} $$ åé¢åˆ©ç”¨ $f(x) = x^2 - N = 0$ æ±‚å¹³æ–¹æ ¹çš„å…¬å¼å¯ä»¥æ ¹æ®è¿™ä¸ªæ¨å¯¼è€Œæ¥çš„ï¼Œå›¾å½¢åŒ–è§£é‡Š (åˆ‡çº¿) ä¹Ÿç¬¦åˆè¿™ä¸ªå…¬å¼ï¼Œè‡ªè¡Œæ¨å¯¼: $$ \\begin{split} f(x) \u0026= x^2-N = 0 \\\\ b \u0026= a - \\frac{f(a)}{f'(a)} = a - \\frac{a^2 - N}{2a} \\\\ \u0026= \\frac{a^2+N}{2a} = (a+\\frac{N}{a}) \\div 2 \\end{split} $$ int mySqrt(int n) { if (n == 0) return 0; if (n \u003c 4) return 1; unsigned int ans = n / 2; if (ans \u003e 65535) // 65535 = 2^16 - 1 ans = 65535; while (ans * ans \u003e n || (ans + 1) * (ans + 1) \u003c= n) ans = (ans + n / ans) / 2; return ans; } è¿™ä¸ªæ–¹æ³•çš„æµç¨‹æ˜¯ï¼Œé€‰å®šä¸€ä¸ªä¸å°äºç›®æ ‡å€¼ $x$ çš„åˆå§‹å€¼ $a$ï¼Œè¿™æ ·ä¾æ®ç‰›é¡¿æ³•ï¼Œ$a_i,\\ a_{i-1},\\ â€¦$ ä¼šé€’å‡é€¼è¿‘ $x$ã€‚å› ä¸ºæ˜¯é€’å‡çš„ï¼Œæ‰€ä»¥é˜²æ­¢ç¬¬ 12 è¡Œçš„ä¹˜æ³•æº¢å‡ºåªéœ€è¦è€ƒè™‘åˆå§‹å€¼ $a$ å³å¯ï¼Œè¿™ä¹Ÿæ˜¯ç¬¬ 9~10 è¡Œçš„é€»è¾‘ã€‚é‚£ä¹ˆåªå‰©ä¸‹ä¸€ä¸ªé—®é¢˜ï¼šå¦‚ä½•ä¿è¯åˆå§‹å€¼ $a$ ä¸å°äºç›®æ ‡å€¼ $x$ å‘¢ï¼Ÿå…¶å®å¾ˆç®€å•ï¼Œåªéœ€è¦æ ¹æ®å½“ $n \\geq 2$ æ—¶æ»¡è¶³ $n=x^2 \\geq 2x$ï¼Œå³ $\\frac{n}{2} \\geq x$ï¼Œä¾¿å¯æ¨æ–­å‡º $\\frac{n}{2}$ åœ¨ $n \\geq 2$ æ—¶å¿…ç„¶æ˜¯æ»¡è¶³å¤§ç­‰äºç›®æ ‡å€¼ $x$ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨å…¶ä½œä¸ºåˆå§‹å€¼ $a$ï¼Œè¿™ä¹Ÿæ˜¯ç¬¬ 8 è¡Œçš„é€»è¾‘ã€‚ å› ä¸ºæ±‚è§£çš„ç›®æ ‡ç²¾åº¦æ˜¯æ•´æ•°ï¼Œæ‰€ä»¥ç¬¬ 12 è¡Œçš„åˆ¤æ–­æ˜¯å¦æ±‚å¾—å¹³æ–¹æ ¹çš„é€»è¾‘æ˜¯åˆç†çš„ (ç»“åˆä¸­é—´å€¼ $a_i$ é€’å‡çš„ç‰¹æ€§æ€è€ƒ)ã€‚ LeetCode 69. Sqrt(x) ","date":"2024-02-23","objectID":"/posts/c-bitwise/:7:2","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"äºŒè¿›ä½çš„å¹³æ–¹æ ¹ åœ¨ä½¿ç”¨ä½è¿ç®—è®¡ç®—å¹³æ–¹æ ¹çš„ç¨‹å¼ç ä¸­ï¼Œæˆ‘ä»¬åˆè§åˆ°äº†çš„ union å’Œ do {...} whil (0) çš„è¿ç”¨ã€‚ä½è¿ç®—æ±‚è§£å¹³æ–¹æ ¹çš„æ ¸å¿ƒåœ¨äº: $n$ å¯ä»¥æ ¹æ® IEEE 754 è¡¨ç¤ºä¸º $S\\times1.Frac\\times2^{127+E}$ï¼Œè¿™ç§è¡¨ç¤ºæ³•ä¸‹æ±‚è§£å¹³æ–¹æ ¹åªéœ€è®¡ç®— $\\sqrt{1.Frac}$ å’Œ $\\sqrt{2^{(127+E)}}$ ä¸¤éƒ¨åˆ† (åªè€ƒè™‘éè´Ÿæ•°çš„å¹³æ–¹æ ¹)ã€‚è™½ç„¶æè¿°èµ·æ¥ç®€å•ï¼Œä½†ç”±äº IEEE 754 ç¼–ç çš„å¤æ‚æ€§ï¼Œéœ€è¦è€ƒè™‘å¾ˆå¤šæƒ…å†µï¼Œä¾‹å¦‚ $E$ å…¨ 0 æˆ–å…¨ 1ï¼Œå› ä¸ºæ­¤æ—¶å¯¹åº”çš„æ•°å€¼å°±ä¸æ˜¯ä¹‹å‰è¡¨ç¤ºçš„é‚£æ ·äº† (æŒ‡ $S\\times1.Frac\\times2^{127+E}$)ï¼Œéœ€è¦é¢å¤–è€ƒé‡ã€‚ sign: 1 bit 0x80000000 exponent: 8 bits 0x7f800000 fraction: 23 bits 0x007fffff åŸæ–‡ç»™å‡ºçš„ç¨‹å¼ç æ˜¯ç”¨äºè®¡ç®— $n$ åœ¨ IEEE 754 ç¼–ç ä¸‹çš„æŒ‡æ•°éƒ¨åˆ†åœ¨å¹³æ–¹æ ¹çš„ç»“æœï¼Œè™½ç„¶çœ‹èµ·æ¥åªéœ€è¦é™¤ä»¥ 2 å³å³ç§» 1 ä½å³å¯ï¼Œä½†å…¶å®ä¸ç„¶ï¼Œä¾‹å¦‚ä¸Šé¢æ‰€è¯´çš„è€ƒè™‘æŒ‡æ•°éƒ¨åˆ†å…¨ä¸º 0 çš„æƒ…å†µï¼Œæ‰€ä»¥è¿™ä¸ªç¨‹å¼ç æ˜¯ç²¾å¿ƒè®¾è®¡ç”¨äºé€šç”¨è®¡ç®—çš„ã€‚ åœ¨åŸå§‹ç¨‹å¼ç çš„åŸºç¡€ä¸Šï¼ŒåŠ ä¸Šå¯¹ ix0 (å¯¹åº” $1.Frac$) ä½¿ç”¨ç‰›é¡¿æ³•æ±‚å¹³æ–¹æ ¹çš„é€»è¾‘ï¼Œå³å¯å®Œæˆå¯¹ n çš„å¹³æ–¹æ ¹çš„æ±‚è§£ã€‚ å½“ç„¶è¿™é‡Œè¦æ±‚å’Œä¹‹å‰ä¸€æ ·ï¼Œå¹³æ–¹æ ¹åªéœ€è¦æ•´æ•°ç²¾åº¦å³å¯ï¼Œæ‰€ä»¥åªéœ€æ±‚å‡ºæŒ‡æ•°éƒ¨åˆ†çš„å¹³æ–¹æ ¹ï¼Œç„¶åé€šè¿‡äºŒåˆ†æ³•è¿›è¡Œé€¼è¿‘å³å¯æ»¡è¶³è¦æ±‚ (å› ä¸ºå‰©ä½™éƒ¨åˆ†æ˜¯ $1.Frac$ å¹¶ä¸å½±å“å¹³æ–¹æ ¹çš„æ•´æ•°ç²¾åº¦ï¼Œä½†æ˜¯ä¼šå¯¼è‡´ä¸€å®šè¯¯å·®ï¼Œæ‰€ä»¥éœ€è¦å¯¹æŒ‡æ•°éƒ¨åˆ†è¿›è¡ŒäºŒåˆ†é€¼è¿‘æ±‚å€¼)ã€‚ å…ˆæ±‚å‡ºæ•´æ•¸ n é–‹æ ¹è™Ÿå¾Œçµæœçš„ $1.FRACTION \\times 2^{EXPONENT}$ çš„ $EXPONENT$ éƒ¨ä»½ï¼Œå‰‡æˆ‘å€‘çŸ¥é“ n é–‹æ ¹è™Ÿå¾Œçš„çµæœ $k$ æ‡‰æ»¿è¶³ $2^{EXPONENT} \\leq k \u003c 2^{EXPONENT+1}$ï¼Œå› æ­¤å¾ŒçºŒå¯ä»¥ç”¨äºŒåˆ†æœå°‹æ³•æ‰¾å‡ºçµæœã€‚ æ³¨æ„ è¿™æ®µç¨‹å¼ç å¯ä»¥å†ä¸€æ¬¡çœ‹åˆ° æšä¸¾ union å’Œ å® do {...} while (0) çš„åº”ç”¨ä¹‹å¤–ï¼Œä¸»è¦æ˜¯æ ¹æ® IEEE 754 ç¼–ç è§„èŒƒè¿›è¡Œæ±‚è§£ï¼Œæ‰€ä»¥éœ€è¦å¯¹æµ®ç‚¹æ•°çš„ç¼–ç æ ¼å¼æœ‰ä¸€å®šè®¤çŸ¥ï¼Œå¯ä»¥å‚è€ƒé˜…è¯»: ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æµ®ç‚¹æ•°è¿ç®—ã€‚ ","date":"2024-02-23","objectID":"/posts/c-bitwise/:7:3","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"Fast Inverse Square Root (å¹³æ–¹æ ¹å€’æ•°) ä¸‹é¢çš„å½•å½±è§£è¯´äº†ç¨‹å¼ç ä¸­çš„é»‘é­”æ³• 0x5f3759df çš„åŸç†ï¼Œæœ¬è´¨ä¹Ÿæ˜¯ç‰›é¡¿æ³•ï¼Œåªä¸è¿‡æ˜¯ é€‰æ‹©ä¸€ä¸ªæ¥è¿‘ç›®æ ‡å€¼çš„åˆå§‹å€¼ï¼Œä»è€Œåªéœ€è¦ä¸€æ¬¡ç‰›é¡¿æ³•å³å¯æ±‚è§£å‡ºç›¸å¯¹é«˜ç²¾åº¦çš„ç›®æ ‡å¹³æ–¹æ ¹ (ä¾‹å¦‚å°† $1.4$ ä½œä¸ºç‰›é¡¿æ³•æ±‚ $\\sqrt 2$ çš„åˆå§‹å€¼ï¼Œåªéœ€ä¸€æ¬¡è¿­ä»£æ±‚è§£å‡ºçš„ç²¾åº¦å·²ç»ç›¸å½“æƒŠäººäº†)ï¼Œé™¤æ­¤ä¹‹å¤–è¿˜è¿ç”¨åˆ°äº†å¯¹æ•°æ±‚å¹³æ–¹æ ¹å€’æ•°çš„æŠ€å·§: YouTube: æ²¡æœ‰æ˜¾å¡çš„å¹´ä»£ï¼Œè¿™ç¾¤ç¨‹åºå‘˜ç”¨4è¡Œä»£ç ä¼˜åŒ–æ¸¸æˆ ä½¿ç”¨ IEEE 754 è¡¨ç¤ºä»»æ„å•ç²¾åº¦æµ®ç‚¹æ•°ä¸º: $x = (1 + \\frac{M}{2^{23}}) \\times 2^{E-127}$ï¼Œåˆ™è¯¥ $x$ å¯¹åº”çš„å¯¹æ•°ä¸º $$ \\begin{split} \\log x \u0026= \\log{(1 + \\frac{M}{2^{23}}) \\times 2^{E-127}} \\\\ \u0026= \\log{(1 + \\frac{M}{2^{23}})} + \\log{2^{E-127}} \\\\ \u0026= \\frac{M}{2^{23}} + E - 127 \\\\ \u0026 = \\frac{1}{2^{23}}(2^{23} \\times E + M) - 127 \\\\ \u0026 = \\frac{1}{2^{23}}X - 127 \\end{split} $$ æ³¨æ„ä¸Šé¢å¤„ç† $\\log{(1 + \\frac{M}{2^{23}})}$ éƒ¨åˆ†æ—¶ä½¿ç”¨è¿‘ä¼¼å‡½æ•° $f(x) = x$ ä»£æ›¿äº†ï¼Œå½“ç„¶ä¼šæœ‰ä¸€äº›è¯¯å·®ï¼Œä½†ç”±äºæˆ‘ä»¬åé¢è®¡ç®—çš„æ˜¯å¹³æ–¹æ ¹å€’æ•°çš„è¿‘ä¼¼å€¼ï¼Œæ‰€ä»¥æœ‰ä¸€äº›è¯¯å·®æ²¡æœ‰å…³ç³»ã€‚æœ€åçš„ $2^{23} \\times E + M$ éƒ¨åˆ†åªå’Œæµ®ç‚¹æ•°çš„è¡¨ç¤ºåŸŸç›¸å…³ï¼Œå¹¶ä¸” è¿™ä¸ªè¿ç®—çš„ç»“æœå€¼å’Œä»¥äºŒè¡¥æ•°ç¼–ç è§£é‡Šæµ®ç‚¹æ•°çš„æ•°å€¼ç›¸åŒ (å‚è€ƒä¸Šé¢çš„ IEEE 754 æµ®ç‚¹æ•°ç»“æ„å›¾ï¼Œä»¥åŠäºŒè¡¥æ•°çš„æ•°å€¼è®¡ç®—è§„åˆ™)ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªå¤§å†™æ ‡è¯† $X$ æ¥æ ‡è®°å…¶åªä¸æµ®ç‚¹æ•°ç¼–ç ç›¸å…³ï¼Œå¹¶ä¸”å¯¹åº”äºŒè¡¥æ•°ç¼–ç ä¸‹çš„æ•°å€¼ã€‚ æ¨å¯¼å‡ºå¯¹æ•°çš„é€šç”¨å…¬å¼åï¼Œæ¥ä¸‹æ¥å°±å¯ä»¥æ¨å¯¼ å¹³æ–¹æ ¹å€’æ•°çš„è¿‘ä¼¼å€¼ äº†ï¼Œå³æ±‚å¾—å¯¹åº”æ•°å€¼çš„ $-\\frac{1}{2}$ æ¬¡æ–¹ã€‚å‡è®¾ $a$ æ˜¯ $y$ çš„å¹³æ–¹æ ¹å€’æ•°ï¼Œåˆ™æœ‰ç­‰å¼: $$ \\begin{split} \\log a \u0026= \\log{y^{-\\frac{1}{2}}} \\\\ \\log a \u0026= -\\frac{1}{2} \\log y \\\\ -\\frac{1}{2^{23}}A - 127 \u0026= -\\frac{1}{2}(-\\frac{1}{2^{23}} - 127) \\\\ A \u0026= 381 \\times 2^{22} - \\frac{1}{2} Y \\end{split} $$ ä¸­é—´å°†æ•°å€¼ç”±æµ®ç‚¹æ•°è½¬æ¢æˆäºŒè¡¥æ•°ç¼–ç è¡¨ç¤ºï¼Œå¹¶æ±‚å¾—æœ€ç»ˆçš„æµ®ç‚¹æ•°è¡¨ç¤ºä¸º $381 \\times 2^{22} - \\frac{1}{2} Y$ï¼Œå…¶ä¸­çš„ $381 \\times 2^{22}$ å¯¹åº”çš„ 16 è¿›åˆ¶æ°å¥½ä¸º 0x5f400000ï¼Œè¿™å·²ç»å¾ˆæ¥è¿‘æˆ‘ä»¬çœ‹åˆ°çš„é­”æ•°äº†ï¼Œä½†è¿˜æœ‰ä¸€ç‚¹åå·®ã€‚ è¿™æ˜¯å› ä¸ºåœ¨è®¡ç®— $\\log{(1 + \\frac{M}{2^{23}})}$ æ—¶ç›´æ¥ä½¿ç”¨ $f(x) = x$ å¯¼è‡´çš„æ€»ä½“è¯¯å·®è¿˜æ˜¯è¾ƒå¤§ï¼Œä½†æ˜¯åªéœ€è¦å°†å…¶ç¨å¾®å¾€ $y$ è½´æ­£æ–¹å‘åç§»ä¸€äº›å°±å¯ä»¥å‡å°‘æ€»ä½“è¯¯å·® (æœºå™¨å­¦ä¹ ä¸­å¸¸ç”¨çš„æŠ€å·§ ğŸ¤£)ï¼Œæ‰€ä»¥ä½¿ç”¨ $\\frac{M}{2^{23}} + \\lambda$ ä»£æ›¿åŸå…ˆçš„ $\\frac{M}{2^{23}}$ ($\\lambda$ ä¸ºä¿®æ­£çš„è¯¯å·®ä¸” $\\lambda \u003e 0$)ï¼Œè¿™ä¼šå¯¼è‡´æœ€ç»ˆç»“æœçš„ 381 å‘ç”Ÿç¨å¾®ä¸€äº›å˜åŒ– (å› ä¸ºäºŒè¡¥æ•°ç¼–ç è§£é‡Šæµ®ç‚¹æ•°æ ¼å¼éƒ¨åˆ† $X$ ä¸èƒ½åŠ¨ï¼Œåªèƒ½å½±å“å¸¸æ•° $127$ï¼Œè€Œå¸¸æ•° $127$ åˆç›´æ¥å½±å“æœ€ç»ˆç»“æœçš„ $381$ è¿™ç±»å¸¸æ•°éƒ¨åˆ†)ï¼Œè¿›è€Œäº§ç”Ÿé­”æ•° 0x5f3759dfã€‚ float InvSqrt(float x) { float xhalf = 0.5f * x; int i = *(int *) \u0026x; i = 0x5f3759df - (i \u003e\u003e 1); x = *(float *) \u0026i; x = x * (1.5f - xhalf * x * x); // only once newton iteration return x; } ","date":"2024-02-23","objectID":"/posts/c-bitwise/:7:4","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"C è¯­è¨€çš„ bit-field åŸæ–‡åœ°å€ #include \u003cstdbool.h\u003e #include \u003cstdio.h\u003e bool is_one(int i) { return i == 1; } int main() { struct { signed int a : 1; } obj = { .a = 1 }; puts(is_one(obj.a) ? \"one\" : \"not one\"); return 0; } C99 6.7.2.1 Structure and union specifiers A bit-field shall have a type that is a qualified or unqualified version of _Bool, signed int, unsigned int, or some other implementation-defined type. A bit-field is interpreted as a signed or unsigned integer type consisting of the specified number of bits. å°† a è¿™ä¸ª 1-bit çš„ä½åŸŸ (bit-field) å£°æ˜æˆ signed intï¼Œå³å°† a è§†ä¸ºä¸€ä¸ª 1-bit çš„äºŒè¡¥æ•°ï¼Œæ‰€ä»¥ a çš„æ•°å€¼åªæœ‰ 0ï¼Œ-1ã€‚æ¥ä¸‹æ¥å°† 1 èµ‹å€¼ç»™ a ä¼šä½¿å¾— a çš„æ•°å€¼ä¸º -1ï¼Œç„¶åå°† a ä½œä¸ºå‚æ•°ä¼ å…¥ is_one æ—¶ä¼šè¿›è¡Œç¬¦å·æ‰©å±• (sign extension) ä¸º 32-bit çš„äºŒè¡¥æ•° (å‡è®¾ç¼–è¯‘å™¨ä¼šå°† int è§†ä¸º signed int)ï¼Œæ‰€ä»¥æ•°å€¼ä»ç„¶ä¸º -1ã€‚å› æ­¤æœ€ç»ˆä¼šè¾“å‡º â€œnot oneâ€. ","date":"2024-02-23","objectID":"/posts/c-bitwise/:8:0","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["C","Linux Kernel Internals"],"content":"Linux æ ¸å¿ƒ: BUILD_BUG_ON_ZERO() /* * Force a compilation error if condition is true, but also produce a * result (of value 0 and type size_t), so the expression can be used * e.g. in a structure initializer (or where-ever else comma expressions * aren't permitted). */ #define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:(-!!(e)); })) è¿™ä¸ªå®è¿ç”¨äº†ä¸Šé¢æ‰€è¯´çš„ !! æŠ€å·§å°† -!!(e) çš„æ•°å€¼é™å®šåœ¨ 0 å’Œ -1ã€‚ è¿™ä¸ªå®çš„åŠŸèƒ½æ˜¯: å½“ e ä¸º true æ—¶ï¼Œ-!!(e) ä¸º -1ï¼Œå³ bit-field çš„ size ä¸ºè´Ÿæ•° å½“ e ä¸º false æ—¶ï¼Œ-!!(e) ä¸º 0ï¼Œå³ bit-field çš„ size ä¸º 0 C99 6.7.2.1 Structure and union specifiers The expression that specifies the width of a bit-field shall be an integer constant expression with a nonnegative value that does not exceed the width of an object of the type that would be specified were the colon and expression omitted. If the value is zero, the declaration shall have no declarator. A bit-field declaration with no declarator, but only a colon and a width, indicates an unnamed bit-field. As a special case, a bit-field structure member with a width of 0 indicates that no further bit-field is to be packed into the unit in which the previous bitfield, if any, was placed. (108) An unnamed bit-field structure member is useful for padding to conform to externally imposed layouts. æ ¹æ®ä¸Šé¢ C99 æ ‡å‡†çš„è¯´æ˜ï¼Œå½“ bit-feild çš„ size ä¸ºè´Ÿæ•°æ—¶ä¼šç¼–è¯‘å¤±è´¥ (åªå…è®¸ integer constant expression with a nonnegative value)ï¼Œå½“ bit-field ä¸º 0 æ—¶ï¼Œä¼šè¿›è¡Œ alignment (ä»¥ä¹‹å‰çš„ bit-field æˆå‘˜æ‰€åœ¨çš„ unit ä¸ºå•ä½)ã€‚ struct foo { int a : 3; int b : 2; int : 0; /* Force alignment to next boundary */ int c : 4; int d : 3; }; int main() { int i = 0xFFFF; struct foo *f = (struct foo *) \u0026i; printf(\"a=%d\\nb=%d\\nc=%d\\nd=%d\\n\", f-\u003ea, f-\u003eb, f-\u003ec, f-\u003ed); return 0; } è¿™é‡Œä½¿ç”¨äº† size ä¸º 0 çš„ bit-fieldï¼Œå…¶å†…å­˜å¸ƒå±€å¦‚ä¸‹: i = 1111 1111 1111 1111 X stand for unknown value assume little endian padding \u0026 start from here â†“ 1111 1111 1111 1111XXXX XXXX XXXX XXXX b baaa ddd cccc |â† int 32 bits â†’||â† int 32 bits â†’| zero size bit-field ä½¿å¾—è¿™é‡Œåœ¨ a, b å’Œ c, d ä¹‹é—´è¿›è¡Œ sizeof(int) çš„ alignmentï¼Œæ‰€ä»¥ c, d ä½äº i è¿™ä¸ª object èŒƒå›´ä¹‹å¤–ï¼Œå› æ­¤ c, d æ¯æ¬¡æ‰§è¡Œæ—¶çš„æ•°å€¼æ˜¯ä¸ç¡®å®šçš„ï¼Œå½“ç„¶è¿™ä¹Ÿä¾èµ–äºç¼–è¯‘å™¨ï¼Œå¯ä»¥ä½¿ç”¨ gcc å’Œ clang è¿›è¡Œæµ‹è¯• ğŸ¤£ C11 3.14 1 memory location (NOTE 2) A bit-field and an adjacent non-bit-field member are in separate memory locations. The same applies to two bit-fields, if one is declared inside a nested structure declaration and the other is not, or if the two are separated by a zero-length bit-field declaration, or if they are separated by a non-bit-field member declaration. It is not safe to concurrently update two non-atomic bit-fields in the same structure if all members declared between them are also (non-zero-length) bit-fields, no matter what the sizes of those intervening bit-fields happen to be. æ‰€ä»¥ BUILD_BUG_ON_ZERO å®ç›¸å½“äºç¼–è¯‘æ—¶æœŸçš„ assertï¼Œå› ä¸º assert æ˜¯åœ¨æ‰§è¡Œæ—¶æœŸæ‰ä¼šè§¦å‘çš„ï¼Œå¯¹äº Linux æ ¸å¿ƒæ¥è¯´ä»£ä»·å¤ªå¤§äº† (æƒ³è±¡ä¸€ä¸‹æ ¸å¿ƒè¿è¡Œç€çªç„¶è§¦å‘ä¸€ä¸ª assert å¯¼è‡´å½“æ‰ ğŸ¤£)ï¼Œæ‰€ä»¥é‡‡ç”¨äº† BUILD_BUG_ON_ZERO å®åœ¨ç¼–è¯‘æ—¶æœŸå°±è¿›è¡Œæ£€æŸ¥ (è«åæœ‰ä¸€ç§ Rust çš„é£æ ¼ ğŸ¤£) å¯¹äº BUILD_BUG_ON_ZERO è¿™ä¸ªå®ï¼ŒC11 æä¾›äº† _Static_assert è¯­æ³•è¾¾åˆ°ç›¸åŒæ•ˆæœï¼Œä½†æ˜¯ Linux kernel è‡ªå·±ç»´æŠ¤äº†ä¸€å¥—ç¼–è¯‘å·¥å…·é“¾ (è¿™ä¸ªå·¥å…·é“¾ gcc ç‰ˆæœ¬å¯èƒ½è¿˜æ²¡æ¥çº³ C11 ğŸ¤£)ï¼Œæ‰€ä»¥è¿˜æ˜¯ä½¿ç”¨è‡ªå·±ç¼–å†™çš„ BUILD_BUG_ON_ZERO å®ã€‚ ","date":"2024-02-23","objectID":"/posts/c-bitwise/:8:1","tags":["Sysprog","C","Bitwise"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: bitwise æ“ä½œ","uri":"/posts/c-bitwise/"},{"categories":["Rust"],"content":" In this fourth Crust of Rust video, we cover smart pointers and interior mutability, by re-implementing the Cell, RefCell, and Rc types from the standard library. As part of that, we cover when those types are useful, how they work, and what the equivalent thread-safe versions of these types are. In the process, we go over some of the finer details of Rust's ownership model, and the UnsafeCell type. We also dive briefly into the Drop Check rabbit hole (https://doc.rust-lang.org/nightly/nomicon/dropck.html) before coming back up for air. æ•´ç†è‡ª John Gjengset çš„å½±ç‰‡ ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:0:0","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"å½±ç‰‡æ³¨è§£ ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:1:0","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"Interior Mutability Module std::cell Rust memory safety is based on this rule: Given an object T, it is only possible to have one of the following: Having several immutable references (\u0026T) to the object (also known as aliasing). Having one mutable reference (\u0026mut T) to the object (also known as mutability). Values of the Cell\u003cT\u003e, RefCell\u003cT\u003e, and OnceCell\u003cT\u003e types may be mutated through shared references (i.e. the common \u0026T type), whereas most Rust types can only be mutated through unique (\u0026mut T) references. We say these cell types provide â€˜interior mutabilityâ€™ (mutable via \u0026T), in contrast with typical Rust types that exhibit â€˜inherited mutabilityâ€™ (mutable only via \u0026mut T). We can use (several) immutable references of a cell to mutate the thing inside of the cell. There is (virtually) no way for you to get a reference to the thing inside of a cell. Because if no one else has a pointer to it (the thing inside of a cell), the changing it is fine. Struct std::cell::UnsafeCell If you have a reference \u0026T, then normally in Rust the compiler performs optimizations based on the knowledge that \u0026T points to immutable data. Mutating that data, for example through an alias or by transmuting an \u0026T into an \u0026mut T, is considered undefined behavior. UnsafeCell\u003cT\u003e opts-out of the immutability guarantee for \u0026T: a shared reference \u0026UnsafeCell\u003cT\u003e may point to data that is being mutated. This is called â€œinterior mutabilityâ€. The UnsafeCell API itself is technically very simple: .get() gives you a raw pointer *mut T to its contents. It is up to you as the abstraction designer to use that raw pointer correctly. ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:1:1","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"Cell Module std::cell Cell\u003cT\u003e Cell\u003cT\u003e implements interior mutability by moving values in and out of the cell. That is, an \u0026mut T to the inner value can never be obtained, and the value itself cannot be directly obtained without replacing it with something else. Both of these rules ensure that there is never more than one reference pointing to the inner value. This type provides the following methods: Cell åœ¨ Rust ä¸­å¯¹ä¸€ä¸ªå˜é‡ (T)ï¼Œåœ¨å·²å­˜åœ¨å…¶ immutable references (\u0026T) æ—¶ä½¿ç”¨ mutable reference (\u0026mut T) æ˜¯ç¦æ­¢çš„ï¼Œå› ä¸ºè¿™æ ·ä¼šå› ä¸ºç¼–è¯‘å™¨ä¼˜åŒ–è€Œå¯¼è‡´ç¨‹åºçš„è¡Œä¸ºä¸ä¸€å®šç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸã€‚è€ƒè™‘ä»¥ä¸‹çš„ä»£ç : let x = 3; let r1 = \u0026x, r2 = \u0026x; let r3 = \u0026mut x; println!(\"{}\", r1); r3 = 5; println!(\"{}\", r2); å‡è®¾ä»¥ä¸Šçš„ä»£ç å¯ä»¥é€šè¿‡ç¼–è¯‘ï¼Œé‚£ä¹ˆç¨‹åºæ‰§è¡Œåˆ°ç¬¬ 6 è¡Œæ‰“å°å‡ºæ¥çš„å¯èƒ½æ˜¯ 3 è€Œä¸æ˜¯æˆ‘ä»¬é¢„æœŸçš„ 5ï¼Œè¿™æ˜¯å› ä¸ºç¼–è¯‘å™¨ä¼šå¯¹ immtuable references è¿›è¡Œæ¿€è¿›çš„ä¼˜åŒ–ï¼Œä¾‹å¦‚è¿›è¡Œé¢„å–ï¼Œæ‰€ä»¥åœ¨ç¬¬ 6 è¡Œæ—¶å¯¹äº r2 ä½¿ç”¨çš„è¿˜æ˜¯å…ˆå‰é¢„å–çš„å€¼ 3 è€Œä¸æ˜¯å†…å­˜ä¸­æœ€æ–°çš„å€¼ 5ã€‚è¿™ä¹Ÿæ˜¯ Rust åˆ¶å®šå¯¹ immutable reference å’Œ mutable reference çš„è§„åˆ™çš„åŸå› ä¹‹ä¸€ã€‚ ä¸ºäº†è¾¾åˆ°æˆ‘ä»¬çš„é¢„æœŸè¡Œä¸ºï¼Œå¯ä»¥ä½¿ç”¨ UnsafeCell æ¥å®ç°: let x = 3; let uc = UnsafeCell::new(x); let r1 = \u0026uc, r2 = \u0026ucï¼Œ r3 = \u0026uc; unsafe { println!(\"{}\", *uc.get()); } unsafe { *uc.get() = 5; } unsafe { println!(\"{}\", *uc.get()); } ä¸Šé¢çš„ä»£ç å¯ä»¥é€šè¿‡ç¼–è¯‘ï¼Œå¹¶ä¸”åœ¨ç¬¬ 6 è¡Œæ—¶æ‰“å°å‡ºæ¥çš„æ˜¯é¢„æœŸçš„ 5ã€‚è¿™æ˜¯å› ä¸ºç¼–è¯‘å™¨ä¼šå¯¹ UnsafeCell è¿›è¡Œç‰¹åˆ¤ï¼Œè€Œé¿å…è¿›è¡Œä¸€äº›æ¿€è¿›çš„ä¼˜åŒ– (ä¾‹å¦‚é¢„å–)ï¼Œä»è€Œä½¿ç¨‹åºè¡Œä¸ºç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸã€‚å¹¶ä¸” UnsafeCell çš„ get() æ–¹æ³•åªéœ€è¦æ¥å— \u0026self å‚æ•°ï¼Œæ‰€ä»¥å¯ä»¥å¯¹ UnsafeCell è¿›è¡Œå¤šä¸ª immutable referencesï¼Œè¿™å¹¶ä¸è¿å Rust çš„å†…å­˜å®‰å…¨å‡†åˆ™ã€‚åŒæ—¶æ¯ä¸ªå¯¹äº UnsafeCel çš„ immutable references éƒ½å¯ä»¥é€šè¿‡æ‰€å¼•ç”¨çš„ UnsafeCell æ¥å®ç°å†…éƒ¨å¯å˜æ€§ (interior mutability)ã€‚ ä¸Šè¿°ä»£ç ç‰‡æ®µå­˜åœ¨å¤§é‡çš„ unsafe ç‰‡æ®µ (å› ä¸º UnsafeCell)ï¼Œå°†è¿™äº› unsafe æ“ä½œå°è£…ä¸€ä¸‹å°±å®ç°äº† Cellã€‚ä½†æ˜¯å› ä¸º Cell çš„æ–¹æ³• get() å’Œ set() éƒ½éœ€è¦è½¬ç§»æ‰€æœ‰æƒï¼Œæ‰€ä»¥ Cell åªèƒ½ç”¨äºå®ç°äº† Copy trait çš„ç±»å‹çš„å†…éƒ¨å¯å˜æ€§ã€‚ä½†æ˜¯å¯¹äº concurrent æƒ…å½¢ï¼ŒUnsafeCell å°±æ˜¯ä¸€ä¸ªä¸´ç•ŒåŒºï¼Œæ— æ³•ä¿è¯å†…éƒ¨ä¿®æ”¹æ˜¯åŒæ­¥çš„ï¼Œæ‰€ä»¥ Cell ä¸æ˜¯ thread safe çš„ã€‚ Cell is typically used for more simple types where copying or moving values isnâ€™t too resource intensive (e.g. numbers) æ³¨æ„ Cell æä¾›äº†è¿™æ ·ä¸€ä¸ªâ€œå†…éƒ¨å¯å˜æ€§â€æœºåˆ¶: åœ¨æ‹¥æœ‰å¯¹ä¸€ä¸ª object å¤šä¸ªå¼•ç”¨æ—¶ï¼Œå¯ä»¥é€šè¿‡ä»»æ„ä¸€ä¸ªå¼•ç”¨å¯¹ object è¿›è¡Œå†…éƒ¨å¯å˜ï¼Œå¹¶ä¿è¯åœ¨æ­¤ä¹‹åå…¶ä»–å¼•ç”¨å¯¹äºè¯¥ object çš„ä¿¡æ¯æ˜¯æœ€æ–°çš„ã€‚ ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:1:2","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"RefCell Module std::cell RefCell\u003cT\u003e RefCell\u003cT\u003e uses Rust\\â€™s lifetimes to implement â€œdynamic borrowingâ€, a process whereby one can claim temporary, exclusive, mutable access to the inner value. Borrows for RefCell\u003cT\u003e\\s are tracked at runtime, unlike Rustâ€™s native reference types which are entirely tracked statically, at compile time. Runtime Borrow Check RefCell RefCell ä¹Ÿæä¾›äº†ä¹‹å‰æ‰€æçš„â€œå†…éƒ¨å¯å˜æ€§â€æœºåˆ¶ï¼Œä½†æ˜¯æ˜¯é€šè¿‡æä¾› å¼•ç”¨ è€Œä¸æ˜¯è½¬ç§»æ‰€æœ‰æƒæ¥å®ç°ã€‚æ‰€ä»¥å®ƒå¸¸ç”¨äº Tree, Graph è¿™ç±»æ•°æ®ç»“æ„ï¼Œå› ä¸ºè¿™äº›æ•°æ®ç»“æ„çš„èŠ‚ç‚¹ â€œå¾ˆå¤§â€ï¼Œä¸å¤§å¯èƒ½å®ç° Copy çš„ Trait (å› ä¸ºå¼€é”€å¤ªå¤§äº†)ï¼Œæ‰€ä»¥ä¸€èˆ¬ä½¿ç”¨ RefCell æ¥å®ç°èŠ‚ç‚¹çš„ç›¸äº’å¼•ç”¨å…³ç³»ã€‚ ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:1:3","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"Rc method std::boxed::Box::into_raw After calling this function, the caller is responsible for the memory previously managed by the Box. In particular, the caller should properly destroy T and release the memory, taking into account the memory layout used by Box. The easiest way to do this is to convert the raw pointer back into a Box with the Box::from_raw function, allowing the Box destructor to perform the cleanup. Rc ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:1:4","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"Raw pointers vs references * mut and * const are not references, they are raw pointers. In Rust, there are a bunch of semantics you have to follow when you using references. Like if you use \u0026 symbol, an \u0026 alone means a shared reference, and you have to guarantee that there are no exclusive references to that thing. And similarly, if you have a \u0026mut, a exclusive reference, you know that there are not shared references. The * version of these, like * mut and * const, do not have these guarantees. If you have a * mut, there may be other * muts to the same thing. There might be * const to the same thing. You have no guarantee, but you also cann't do much with a *. If you have a raw pointer, the only thing you can really do to it is use an unsafe block to dereference it and turn it into reference. But that is unsafe, you need to document wht it is safe. You're not able to go from a const pointer to an exclusive reference. But you can go from a mutable pointer to an exclusive reference. To guarantee that you have to follow onwership semantics in Rust. ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:1:5","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"PhantomData \u0026 Drop check The Rustonomicon: Drop Check Medium: Rust Notes: PhantomData struct Foo\u003c'a, T: Default\u003e { v: \u0026'a mut T, } impl\u003cT\u003e Drop for Foo\u003c'_, T: Default\u003e { fn drop(\u0026mut self) { let _ = std::mem::replace(self.v, T::default()); } } fn main() { let mut t = String::from(\"hello\"); let foo = Foo { v: \u0026mut t }; drop(t); drop(foo); } æœ€åçš„ 2 è¡Œ drop è¯­å¥ä¼šå¯¼è‡´ç¼–è¯‘å¤±è´¥ï¼Œå› ä¸ºç¼–è¯‘å™¨çŸ¥é“ foo å¼•ç”¨äº† tï¼Œæ‰€ä»¥ä¼šè¿›è¡Œ drop checkï¼Œä¿è¯ t çš„ lifetime è‡³å°‘å’Œ foo ä¸€æ ·é•¿ï¼Œå› ä¸º drop æ—¶ä¼šæŒ‰ç…§ä»å†…åˆ°å¤–çš„é¡ºåºå¯¹ç»“æ„ä½“çš„æˆå‘˜åŠå…¶æœ¬èº«è¿›è¡Œ dropã€‚ä½†æ˜¯å¯¹äºæˆ‘ä»¬å®ç°çš„ Rc ä½¿ç”¨çš„æ˜¯ raw pointerï¼Œå¦‚æœä¸åŠ  PhantomDataï¼Œé‚£ä¹ˆåœ¨å¯¹ Rc è¿›è¡Œ drop æ—¶å¹¶ä¸ä¼šæ£€æŸ¥ raw pointer æ‰€æŒ‡å‘çš„ RcInner çš„ lifetime æ˜¯å¦æ»¡è¶³è¦æ±‚ï¼Œå³åœ¨ drop Rc ä¹‹å‰ drop RcInner å¹¶ä¸ä¼šå¯¼è‡´ç¼–è¯‘å¤±è´¥ã€‚ç®€å•æ¥è¯´ï¼ŒPhantomData å°±æ˜¯è®©ç¼–è¯‘å™¨ä»¥ä¸º Rc æ‹¥æœ‰ RcInner çš„æ‰€æœ‰æƒæˆ–å¼•ç”¨ï¼Œç”±æ­¤è¿›è¡ŒæœŸæœ›çš„ drop check è¡Œä¸ºã€‚ ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:1:6","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"Thread Safety Cell Because even though you're not giving out references to things, having two threads modify the same value at the same time is just not okay. There actually is o thread-safe version of Cell. (Think it as pointer in C ğŸ¤£) RefCell You could totally implement a thread-safe version of RefCell, one that uses an atomic counter instead of Cell for these numbers. So it turns out that the CPU has built-in instructions that can, in a thread-safe way, increment and decrement counters. Rc The thread-safe version of Rc is Arc, or Atomic Reference Count. ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:1:7","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"Copy-on-Write (COW) Struct std::borrow::Cow The type Cow is a smart pointer providing clone-on-write functionality: it can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required. The type is designed to work with general borrowed data via the Borrow trait. ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:1:8","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"Homework ä¿¡æ¯ å®ä½œè¯´æ˜: å°è¯•ä½¿ç”¨ RefCell å’Œ Rc æ¥å®ç° Linux kernel é£æ ¼çš„ linked list æ•°æ®ç»“æ„ä¸º circular doubly linked list å®ç° insert_head, remove_head æ–¹æ³• å®ç° insert_tail, remove_tail æ–¹æ³• å®ç° list_size, list_empty, list_is_singular æ–¹æ³• å®ç°è¿­ä»£å™¨ (Iterator)ï¼Œæ”¯æŒåŒå‘è¿­ä»£ (DoubleEndedIterator) å‚è€ƒèµ„æ–™: sysprog21/linux-list linux/list.h ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:2:0","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:3:0","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"Crate std å¯ä»¥ä½¿ç”¨è¿™é‡Œæä¾›çš„æœç´ æ è¿›è¡Œæœç´¢ (BTW ä¸è¦æµªè´¹æ—¶é—´åœ¨ Google æœå¯»ä¸Šï¼) Module std::cell Struct std::cell::UnsafeCell Struct std::cell::Cell Struct std::cell::RefCell Module std::rc Module std::sync Struct std::sync::Mutex Struct std::sync::RwLock Struct std::sync::Arc Struct std::boxed::Box method std::boxed::Box::into_raw method std::boxed::Box::from_raw Struct std::ptr::NonNull method std::ptr::NonNull::new_unchecked method std::ptr::NonNull::as_ref method std::ptr::NonNull::as_ptr Struct std::marker::PhantomData Struct std::borrow::Cow Trait std::ops::Drop Trait std::ops::Deref Trait std::ops::DerefMut Trait std::marker::Sized Function std::thread::spawn Function std::mem::replace Function std::mem::drop ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:3:1","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["Rust"],"content":"References å¯èƒ½ä¸æ˜¯ä½ çœ‹è¿‡æœ€æ— èŠçš„ Rust å…¥é—¨å–œå‰§102 (2) æ™ºèƒ½æŒ‡é’ˆ [bilibili] ","date":"2024-02-20","objectID":"/posts/smart-pointers-and-interior-mutability/:4:0","tags":["Rust","Smart pointer","Interior Mutability"],"title":"Crust of Rust: Smart Pointers and Interior Mutability","uri":"/posts/smart-pointers-and-interior-mutability/"},{"categories":["C","Linux Kernel Internals"],"content":" å°½ç®¡æ•°å€¼ç³»ç»Ÿå¹¶é C è¯­è¨€æ‰€æŒæœ‰ï¼Œä½†åœ¨ Linux æ ¸å¿ƒå¤§é‡å­˜åœ¨ u8/u16/u32/u64 è¿™æ ·é€šè¿‡ typedef æ‰€å®šä¹‰çš„ç±»å‹ï¼Œä¼´éšç€å„ç§ alignment å­˜å–ï¼Œå¦‚æœå¯¹æ•°å€¼ç³»ç»Ÿçš„è®¤çŸ¥ä¸å¤Ÿå……åˆ†ï¼Œå¯èƒ½ç«‹å³å°±è¢«é˜»æ‹¦åœ¨æ¢ç´¢ Linux æ ¸å¿ƒä¹‹å¤–â€”â€”æ¯•ç«Ÿä½ å®Œå…¨æä¸æ¸…æ¥šï¼Œä¸ºä½• Linux æ ¸å¿ƒå­˜å–ç‰¹å®šèµ„æ–™éœ€è¦ç»•ä¸€å¤§åœˆã€‚ åŸæ–‡åœ°å€ ","date":"2024-02-20","objectID":"/posts/c-numerics/:0:0","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"Balanced ternary balanced ternary ä¸‰è¿›åˆ¶ä¸­ -, 0, + åœ¨æ•°å­¦ä¸Šå…·å¤‡å¯¹ç§°æ€§è´¨ã€‚å®ƒç›¸å¯¹äºäºŒè¿›åˆ¶ç¼–ç çš„ä¼˜åŠ¿åœ¨äºï¼Œå…¶æœ¬èº«å°±å¯ä»¥è¡¨ç¤ºæ­£è´Ÿæ•° (é€šè¿‡ +-, 0, +)ï¼Œè€ŒäºŒè¿›åˆ¶éœ€è¦è€ƒè™‘ unsigned å’Œ signed çš„æƒ…å†µï¼Œä»è€Œå†³å®šæœ€é«˜ä½æ‰€è¡¨ç¤ºçš„æ•°å€¼ã€‚ ç›¸å…³çš„è¿ç®—è§„åˆ™: + add - = 0 0 add + = + 0 add - = - ä»¥ä¸Šè¿ç®—è§„åˆ™éƒ½æ¯”è¾ƒç›´è§‚ï¼Œè¿™ä¹Ÿå†³å®šäº† balanced ternary åœ¨ç¼–ç ä¸Šçš„å¯¹ç§°æ€§ (å‡æ³•ç­‰ä»·äºåŠ ä¸Šé€†å…ƒï¼Œé€†å…ƒéå¸¸å®¹æ˜“è·å¾—)ã€‚ä½†æ˜¯éœ€è¦æ³¨æ„ï¼Œä¸Šé¢çš„è¿ç®—è§„åˆ™å¹¶æ²¡æœ‰æ¶‰åŠåˆ°ç›¸åŒä½è¿ç®—çš„è§„åˆ™ï¼Œä¾‹å¦‚ $+\\ (add)\\ +$ï¼Œè¿™ç§è¿ç®—ä¹Ÿæ˜¯ balanced ternary ç›¸å¯¹äºäºŒè¿›åˆ¶ç¼–ç çš„åŠ£åŠ¿ï¼Œå¯ä»¥è‡ªè¡Œæ¨å¯¼ä¸€ä¸‹è¿™ç§è¿ç®—çš„è§„åˆ™ã€‚ The Balanced Ternary Machines of Soviet Russia ","date":"2024-02-20","objectID":"/posts/c-numerics/:1:0","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"æ•°å€¼ç¼–ç ä¸é˜¿è´å°”ç¾¤ é˜¿è´å°”ç¾¤ä¹Ÿç”¨äºæŒ‡ç¤ºä¸ºä»€ä¹ˆä½¿ç”¨äºŒè¡¥æ•°ç¼–ç æ¥è¡¨ç¤ºæ•´æ•°: å­˜åœ¨å”¯ä¸€çš„å•ä½å…ƒ (äºŒè¡¥æ•°ä¸­å•ä½å…ƒ 0 çš„ç¼–ç æ˜¯å”¯ä¸€çš„) æ¯ä¸ªå…ƒç´ éƒ½æœ‰é€†å…ƒ (åœ¨äºŒè¡¥æ•°ä¸­å‡ ä¹æ¯ä¸ªæ•°éƒ½æœ‰é€†å…ƒ) æµ®ç‚¹æ•° IEEE 754: An example of a layout for 32-bit floating point is ConversiÃ³n de un nÃºmero binario a formato IEEE 754 å•ç²¾åº¦æµ®ç‚¹æ•°ç›¸å¯¹äºæ•´æ•° åœ¨æŸäº›æƒ…æ³ä¸‹ä¸æ»¡è¶³çµåˆå¾‹å’Œäº¤æ¢å¾‹ï¼Œæ‰€ä»¥ä¸æ„æˆ é˜¿è´å°”ç¾¤ï¼Œåœ¨ç¼–å†™ç¨‹åºæ—¶éœ€è¦æ³¨æ„è¿™ä¸€ç‚¹ã€‚å³ä½¿ç¼–å†™ç¨‹åºæ—¶è°¨æ…å¤„ç†äº†å•ç²¾åº¦æµ®ç‚¹æ•°è¿ç®—ï¼Œä½†æ˜¯ç¼–è¯‘å™¨ä¼˜åŒ–å¯èƒ½ä¼šå°†æˆ‘ä»¬çš„å¤„ç†ç ´åˆ’æ‰ã€‚æ‰€ä»¥æ¶‰åŠåˆ°å•ç²¾åº¦æµ®ç‚¹æ•°ï¼Œéƒ½éœ€è¦æ³¨æ„å…¶è¿ç®—ã€‚ ä¿¡æ¯ ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æµ®ç‚¹æ•°è¿ç®— ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç¼–è¯‘å™¨å’Œæœ€ä½³åŒ–åŸç†ç¯‡ ","date":"2024-02-20","objectID":"/posts/c-numerics/:2:0","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"Integer Overflow ","date":"2024-02-20","objectID":"/posts/c-numerics/:3:0","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"2002 å¹´ FreeBSD [53] #define KSIZE 1024 char kbuf[KSIZE]; int copy_from_kernel(void *user_dest, int maxlen) { int len = KSIZE \u003c maxlen ? KSIZE : maxlen; memcpy(user_dest, kbuf, len); return len; } å‡è®¾å°†â€œè´Ÿâ€çš„æ•°å€¼å¸¦å…¥ maxlenï¼Œé‚£ä¹ˆåœ¨ä¸Šè¿°çš„ç¨‹å¼ç ç¬¬ 4 è¡Œæ—¶ len ä¼šè¢«èµ‹å€¼ä¸º maxlenï¼Œåœ¨ç¬¬ 5 è¡Œä¸­ï¼Œæ ¹æ® memcpy çš„åŸå‹å£°æ˜ void *memcpy(void *dest, const void *src, size_t n); ä¼šå°† len (=maxlen) è§£é‡Šä¸º size_t ç±»å‹ï¼Œå…³äº size_t ç±»å‹ C99 [7.17 Common definitions \u003cstddef.h\u003e] size_t which is the unsigned integer type of the result of the sizeof operator; æ‰€ä»¥åœ¨ 5 è¡Œä¸­ memcpy ä¼šå°† len è¿™ä¸ªâ€œè´Ÿâ€œçš„æ•°å€¼æŒ‰ç…§æ— ç¬¦å·æ•°çš„ç¼–ç è¿›è¡Œè§£é‡Šï¼Œè¿™ä¼šå¯¼è‡´å°† len è§£é‡Šä¸ºä¸€ä¸ªè¶…çº§å¤§çš„æ— ç¬¦å·æ•°ï¼Œå¯èƒ½è¿œæ¯” KSIZE è¿™ä¸ªé™åˆ¶å¤§ã€‚copy_from_kernel è¿™ä¸ªå‡½æ•°æ˜¯è¿è¡Œåœ¨ kernel ä¸­çš„ï¼Œè¿™æ ·å¯èƒ½ä¼šé€ æˆæ½œåœ¨çš„ kernel ä¿¡æ¯æ•°æ®æ³„éœ²é—®é¢˜ã€‚ ","date":"2024-02-20","objectID":"/posts/c-numerics/:3:1","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"2002 å¹´ External data representation (XDR) [62] void *copy_elements(void *ele_src[], int ele_cnt, int ele_size) { void *result = malloc(ele_cnt * ele_size); if (result==NULL) return NULL; void *next = result; for (int i = 0; i \u003c ele_cnt; i++) { memcpy(next, ele_src[i], ele_size); next += ele_size; } return result; } å‡è®¾å°† ele_cnt = $2^{20}+1$, ele_size=$2^{12}$ ä»£å…¥ï¼Œæ˜¾ç„¶åœ¨ç¬¬ 2 è¡Œçš„ ele_cnt * ele_size ä¼šè¶…å‡º 32 ä½æ•´æ•°è¡¨ç¤ºçš„æœ€å¤§å€¼ï¼Œå¯¼è‡´ overflowã€‚åˆå› ä¸º malloc çš„åŸå‹å£°æ˜ void *malloc(size_t size); malloc ä¼šå°† ele_cnt * ele_size æº¢å‡ºåä¿ç•™çš„å€¼è§£é‡Šä¸º size_tï¼Œè¿™ä¼šå¯¼è‡´ malloc åˆ†é…çš„å†…å­˜ç©ºé—´è¿œå°äº ele_cnt * ele_size Bytes (è¿™æ˜¯ malloc æˆåŠŸçš„æƒ…å†µï¼Œmalloc ä¹Ÿæœ‰å¯èƒ½ä¼šå¤±è´¥ï¼Œè¿”å› NULL)ã€‚ å› ä¸º malloc æˆåŠŸåˆ†é…ç©ºé—´ï¼Œæ‰€ä»¥ä¼šé€šè¿‡ç¬¬ 3 è¡Œçš„æµ‹è¯•ã€‚åœ¨ç¬¬ 5~8 è¡Œçš„ for å¾ªç¯ï¼Œæ ¹æ® ele_cnt å’Œ ele_size çš„å€¼è¿›è¡Œ memcpyï¼Œä½†æ˜¯å› ä¸ºåˆ†é…çš„ç©ºé—´è¿œè¿œå°äº ele_cnt * ele_sizeï¼Œæ‰€ä»¥è¿™æ ·ä¼šè¦†å†™è¢«åˆ†é…ç©ºé—´å¤–çš„å†…å­˜åŒºåŸŸï¼Œå¯èƒ½ä¼šé€ æˆ kernel çš„ä¿¡æ¯æ•°æ®è¢«è¦†ç›–ã€‚ ","date":"2024-02-20","objectID":"/posts/c-numerics/:3:2","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"Bitwise 3Blue1Brown: How to count to 1000 on two hands [YouTube] æœ¬è´¨ä¸Šæ˜¯ä½¿ç”¨æ— ç¬¦å·æ•°çš„äºŒè¿›åˆ¶ç¼–ç æ¥è¿›è¡Œè®¡æ•°ï¼Œå°†æ‰‹æŒ‡/è„šè¶¾è§†ä¸ºæ•°å€¼çš„ bit ä¿¡æ¯ è§£è¯»è®¡ç®—æœºç¼–ç  ","date":"2024-02-20","objectID":"/posts/c-numerics/:4:0","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"Power of two é€šè¿‡ä»¥ä¸‹ç¨‹å¼ç å¯ä»¥åˆ¤æ–­ x æ˜¯å¦ä¸º 2 çš„æ¬¡æ–¹ x \u0026 (x - 1) == 0 é€šè¿‡å€¼ä¸º 1 çš„æœ€ä½ä½æ¥è¿›è¡Œå½’çº³æ³•è¯æ˜ï¼Œä¾‹å¦‚ï¼Œå¯¹ 0b00000001, 0b00000010, 0b00000100, â€¦ æ¥è¿›è¡Œå½’çº³è¯æ˜ (è¿˜éœ€è¦è¯æ˜ x ä¸­åªèƒ½æœ‰ä¸€ä¸ª bit ä¸ºå€¼ 1ï¼Œä¸è¿‡è¿™ä¸ªæ¯”è¾ƒç®€å•)ã€‚å¦ä¸€ç§æ€è·¯ï¼Œé€šè¿‡ LSBO ä»¥åŠ $X$ å’Œ $-X$ çš„ç‰¹æ€§æ¥è¯æ˜ã€‚ LSBO: Least Significant bit of value One $-X = ~(X - 1)$ $-X$ çš„ç¼–ç ç­‰ä»·äº $X$ çš„ç¼–ç ä¸­æ¯” LSBO æ›´é«˜çš„ bits è¿›è¡Œåè½¬ï¼ŒLSBO åŠæ›´ä½çš„ bits ä¿æŒä¸å˜ ","date":"2024-02-20","objectID":"/posts/c-numerics/:4:1","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"ASCII table é€šè¿‡ ASCII table ä¸­å¯¹ ASCII ç¼–ç çš„åˆ†å¸ƒè§„å¾‹ï¼Œå¯ä»¥å®ç°å¤§å°å†™è½¬æ¢çš„ constant-time function ä¹Ÿå¯ä»¥é€šè¿‡å‘½ä»¤ man ascii æ¥è¾“å‡ºç²¾ç¾çš„ ASCII table // å­—ç¬¦è½¬å°å†™ (x | ' ') // å­—ç¬¦è½¬å¤§å†™ (x \u0026 ' ') // å¤§å°å†™äº’è½¬ (x ^ ' ') Each lowercase letter is 32 + uppercase equivalent. This means simply flipping the bit at position 5 (counting from least significant bit at position 0) inverts the case of a letter. ","date":"2024-02-20","objectID":"/posts/c-numerics/:4:2","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"XOR swap é€šè¿‡ xor è¿ç®—ç¬¦å¯ä»¥å®ç°æ— éœ€ä¸´æ—¶å˜é‡çš„ï¼Œäº¤æ¢ä¸¤ä¸ªæ•°å€¼çš„ç¨‹å¼ç  void xorSwap(int *x, int *y) { *x ^= *y; *y ^= *x; *x ^= *y; } ç¬¬ 3 è¡Œçš„ *y ^= *x çš„ç»“æœç­‰ä»·äº *y ^ *x ^ *yï¼Œæ•´æ•°æ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼Œæ‰€ä»¥ç»“æœä¸º *x ç¬¬ 4 è¡Œçš„ *x ^= *y çš„ç»“æœç­‰ä»·äº *x ^ *y ^ *xï¼Œæ•´æ•°æ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼Œæ‰€ä»¥ç»“æœä¸º *y è¿™ä¸ªå®ä½œæ–¹æ³•å¸¸ç”¨äºæ²¡æœ‰é¢å¤–ç©ºé—´çš„æƒ…å½¢ï¼Œä¾‹å¦‚ Bootloader ","date":"2024-02-20","objectID":"/posts/c-numerics/:4:3","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"é¿å… overflow æ•´æ•°è¿ç®— (x + y) / 2 å¯èƒ½ä¼šå¯¼è‡´ overflow (å¦‚æœ x, y æ•°å€¼éƒ½æ¥è¿‘ UINT32_MAX)ï¼Œå¯ä»¥æ”¹å†™ä¸ºä»¥ä¸‹ä¸ä¼šå¯¼è‡´ overflow çš„ç¨‹å¼ç  (x \u0026 y) + (x ^ y) \u003e\u003e 1 ä½¿ç”¨åŠ æ³•å™¨æ¥æ€è€ƒ: å¯¹äº x + yï¼Œx \u0026 y è¡¨ç¤ºè¿›ä½ï¼Œx ^ y è¡¨ç¤ºä½å…ƒå’Œï¼Œæ‰€ä»¥ x + y ç­‰ä»·äº (x \u0026 y) \u003c\u003c 1 + (x ^ y) è¿™ä¸ªè¿ç®—ä¸ä¼šå¯¼è‡´ overflow (å› ä¸ºä½¿ç”¨äº† bitwise è¿ç®—)ã€‚å› æ­¤ (x + y) / 2 ç­‰ä»·äº ((x \u0026 y) \u003c\u003c 1 + (x ^ y)) \u003e\u003e 1 = ((x \u0026 y) \u003c\u003c 1) \u003e\u003e 1 + (x ^ y) \u003e\u003e 1 = (x \u0026 y) + (x ^ y) \u003e\u003e 1 æ•´æ•°æ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ ","date":"2024-02-20","objectID":"/posts/c-numerics/:4:4","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"macro DIRECT #if LONG_MAX == 2147483647L #define DETECT(X) \\ (((X) - 0x01010101) \u0026 ~(X) \u0026 0x80808080) #else #if LONG_MAX == 9223372036854775807L #define DETECT(X) \\ (((X) - 0x0101010101010101) \u0026 ~(X) \u0026 0x8080808080808080) #else #error long int is not a 32bit or 64bit type. #endif #endif DIRECT å®çš„ä½œç”¨æ˜¯ä¾¦æµ‹ 32bit/64bit ä¸­æ˜¯å¦å­˜åœ¨ä¸€ä¸ª Byte ä¸º NULLã€‚æˆ‘ä»¬ä»¥æœ€ç®€å•çš„æƒ…å†µ 1 ä¸ª Byte æ—¶æ¥æ€è€ƒè¿™ä¸ªå®ä½œçš„æœ¬è´¨ï¼š ((X) - 0x01) \u0026 ~(X) \u0026 0x80 = ~(~((X) - 0x01) | X) \u0026 0x80 ~((X) - 0x01) æ˜¯ X çš„å–è´Ÿå€¼ç¼–ç ï¼Œå³ -Xï¼Œæ ¹æ®äºŒè¡¥æ•°ç¼–ç ä¸­ -X å’Œ X çš„ç‰¹æ€§ï¼Œå¯å¾— (~((X) - 0x01) | X) ä¸º: X äºŒè¡¥æ•°ç¼–ç ä¸­å€¼ä¸º 1 çš„æœ€ä½ä½ (åç»­ç§°ä¹‹ä¸º LSBO) åŠæ›´ä½ä½ä¿æŒä¸å˜ï¼ŒLSBO æ›´é«˜ä½å‡ä¸º 1ã€‚åˆ™ ~(~((X) - 0x01) | X) ä¸º: X äºŒè¡¥æ•°ç¼–ç ä¸­å€¼ä¸º 1 çš„æœ€ä½ä½ (åç»­ç§°ä¹‹ä¸º LSBO) çš„æ›´ä½ä½ç¿»è½¬ï¼ŒLSBO åŠæ›´é«˜ä½å‡ä¸º 0ã€‚ LSBO: Least Significant Bit with value of One X = 0x0080 (X) - 0x01 = 0xff80 ~((X) - 0x01) = 0x007f ~(~((X) - 0x01) | X) \u0026 0x80 = 0 å¯ä»¥è‡ªè¡Œå½’çº³æ¨å¯¼å‡º: å¯¹äºä»»æ„ä¸ä¸º 0 çš„æ•°å€¼ï¼Œä¸Šè¿°æµç¨‹æ¨å¯¼çš„æœ€ç»ˆå€¼éƒ½ä¸º 0ï¼Œä½†å¯¹äºå€¼ä¸º 0 çš„æ•°å€¼ï¼Œæœ€ç»ˆå€¼ä¸º 0x80ã€‚ç”±æ­¤å¯ä»¥æ¨å¯¼å‡ºæœ€å¼€å§‹çš„å®ä½œ DIRECT å®ã€‚ è¿™ä¸ª DIRECT å®ç›¸å½“å®ç”¨ï¼Œå¸¸ç”¨äºåŠ é€Ÿå­—ç¬¦ä¸²æ“ä½œï¼Œå°†åŸå…ˆçš„ä»¥ 1-byte ä¸ºå•å…ƒçš„æ“ä½œåŠ é€Ÿä¸ºä»¥ 32bit/64bit ä¸ºå•ä½çš„æ“ä½œã€‚å¯ä»¥é˜…è¯»ç›¸å…³å®ä½œå¹¶å¯»æ‰¾å…¶ä¸­çš„é€»è¾‘: newlib çš„ strlen newlib çš„ strcpy ","date":"2024-02-20","objectID":"/posts/c-numerics/:4:5","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"Count Leading Zero è®¡ç®— $\\log_2N$ å¯ä»¥é€šè¿‡è®¡ç®—æ•°å€¼å¯¹åº”çš„ç¼–ç ï¼Œé«˜ä½æœ‰å¤šå°‘è¿ç»­çš„ 0â€™bitsï¼Œå†ç”¨ 31 å‡å»å³å¯ã€‚å¯ä»¥é€šè¿‡ 0x0001, 0x0010, 0x0002, â€¦ ç­‰ç¼–ç æ¥è¿›è¡Œå½’çº³æ¨å¯¼å‡ºè¯¥ç»“è®ºã€‚ iteration version int clz(uint32_t x) { int n = 32, c = 16; do { uint32_t y = x \u003e\u003e c; if (y) { n -= c; x = y; } c \u003e\u003e= 1; } while (c); return (n - x); } binary search technique int clz(uint32_t x) { if (x == 0) return 32; int n = 0; if (x \u003c= 0x0000FFFF) { n += 16; x \u003c\u003c= 16; } if (x \u003c= 0x00FFFFFF) { n += 8; x \u003c\u003c= 8; } if (x \u003c= 0x0FFFFFFF) { n += 4; x \u003c\u003c= 4; } if (x \u003c= 0x3FFFFFFF) { n += 2; x \u003c\u003c= 2; } if (x \u003c= 0x7FFFFFFF) { n += 1; x \u003c\u003c= 1; } return n; } byte-shift version int clz(uint32_t x) { if (x == 0) return 32; int n = 1; if ((x \u003e\u003e 16) == 0) { n += 16; x \u003c\u003c= 16; } if ((x \u003e\u003e 24) == 0) { n += 8; x \u003c\u003c= 8; } if ((x \u003e\u003e 28) == 0) { n += 4; x \u003c\u003c= 4; } if ((x \u003e\u003e 30) == 0) { n += 2; x \u003c\u003c= 2; } n = n - (x \u003e\u003e 31); return n; } åœ¨è¿™äº›å®ä½œä¸­ï¼Œå¾ªç¯æ˜¯æ¯”è¾ƒç›´è§‚çš„ï¼Œä½†æ˜¯æ¯”è¾ƒä½æ•ˆï¼›å¯ä»¥åˆ©ç”¨ç¼–ç çš„ç‰¹æ€§ï¼Œä½¿ç”¨äºŒåˆ†æ³•æˆ–ä½è¿ç®—æ¥åŠ é€Ÿå®ä½œã€‚ ","date":"2024-02-20","objectID":"/posts/c-numerics/:5:0","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"é¿å…å¾ªç¯ int func(unsigned int x) { int val = 0; int i = 0; for (i = 0; i \u003c 32; i++) { val = (val \u003c\u003c 1) | (x \u0026 0x1); x \u003e\u003e= 1; } return val; } è¿™æ®µç¨‹å¼ç çš„ä½œç”¨æ˜¯ï¼Œå¯¹ä¸€ä¸ª 32bit çš„æ•°å€¼è¿›è¡Œé€ä½å…ƒåè½¬ã€‚è¿™ä¸ªé€ä½å…ƒåè½¬åŠŸèƒ½éå¸¸å®ç”¨ï¼Œå¸¸å®ä½œäºåŠ å¯†ç®—æ³•ï¼Œä¾‹å¦‚ DESã€AESã€‚ ä½†æ˜¯ä¸ä¸Šé¢çš„ Count Leading Zero ç±»ä¼¼ï¼Œä¸Šé¢ç¨‹å¼ç ä½¿ç”¨äº†å¾ªç¯ï¼Œéå¸¸ä½æ•ˆï¼Œå¯ä»¥é€šè¿‡ä½è¿ç®—æ¥åŠ é€Ÿã€‚ int func(unsigned int x) { int val = 0; val = num; val = ((val \u0026 0xffff0000) \u003e\u003e 16) | ((val \u0026 0x0000ffff) \u003c\u003c 16); val = ((val \u0026 0xff00ff00) \u003e\u003e 8) | ((val \u0026 0x00ff00ff) \u003c\u003c 8); val = ((val \u0026 0xf0f0f0f0) \u003e\u003e 4) | ((val \u0026 0x0f0f0f0f) \u003c\u003c 4); val = ((val \u0026 0xcccccccc) \u003e\u003e 2) | ((val \u0026 0x33333333) \u003c\u003c 2); val = ((val \u0026 0xaaaaaaaa) \u003e\u003e 1) | ((val \u0026 0x55555555) \u003c\u003c 1); return val; } Reverse integer bitwise without using loop [Stack Overflow] æŠ€å·§ Bits Twiddling Hacks è§£æ: (ä¸€), (äºŒ), (ä¸‰) ","date":"2024-02-20","objectID":"/posts/c-numerics/:6:0","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["C","Linux Kernel Internals"],"content":"åŠ è§£å¯†çš„åº”ç”¨ å‡è¨­æœ‰ä¸€å¼µé»‘ç™½çš„ç›¸ç‰‡æ˜¯ç”±å¾ˆå¤šå€‹0 ~255 çš„ pixel çµ„æˆ (0 æ˜¯é»‘è‰²ï¼Œ255 æ˜¯ç™½è‰²)ï¼Œé€™æ™‚å€™å¯ä»¥ç”¨ä»»æ„çš„ KEY (000000002 - 111111112) è·ŸåŸæœ¬çš„æ¯å€‹ pixel åšé‹ç®—ï¼Œå¦‚æœä½¿ç”¨ AND (æ¯å€‹ bit æœ‰ 75% æ©Ÿç‡æœƒè®Šæˆ 0)ï¼Œæ‰€ä»¥åœ–æœƒè®Šæš—ã€‚å¦‚æœä½¿ç”¨ OR (æ¯å€‹ bit æœ‰ 75% æ©Ÿç‡æœƒè®Š 1)ï¼Œåœ–å°±æœƒè®Šäº®ã€‚é€™å…©ç¨®å¹¾ä¹éƒ½é‚„æ˜¯çœ‹çš„å‡ºåŸæœ¬çš„åœ–ç‰‡ï¼Œä½†è‹¥æ˜¯ç”¨ XOR çš„è©±ï¼Œæ¯å€‹ bit è®Šæˆ 0 æˆ– 1 çš„æ©Ÿç‡éƒ½æ˜¯ 50%ï¼Œæ‰€ä»¥åœ–ç‰‡å°±æœƒè®Šæˆçœ‹ä¸å‡ºæ±è¥¿çš„é›œè¨Šã€‚ ä¸Šåœ–å·¦ 1 æ˜¯åŸåœ–ï¼Œå·¦ 2 æ˜¯ç”¨ AND åšé‹ç®—ä¹‹å¾Œï¼Œå³ 2 æ˜¯ç”¨ OR åšé‹ç®—ä¹‹å¾Œï¼Œå³ 1 æ˜¯ç”¨ XORï¼Œå¯è¦‹ä½¿ç”¨ XOR çš„åŠ å¯†æ•ˆæœæœ€å¥½ã€‚ è¿™å°±æ˜¯åœ¨å¯†ç å­¦é¢†åŸŸåçˆ± XOR çš„åŸå› ä¹‹ä¸€ã€‚é™¤æ­¤ä¹‹å¤–ï¼ŒXOR åœ¨æ¦‚ç‡ç»Ÿè®¡ä¸Šçš„ä¼˜å¼‚ç‰¹æ€§ä¹Ÿæ˜¯å¦ä¸€ä¸ªåŸå› ï¼Œå…·ä½“è¯æ˜æ¨å¯¼è¯·æŸ¥çœ‹åŸæ–‡çš„è¯´æ˜ã€‚ ","date":"2024-02-20","objectID":"/posts/c-numerics/:7:0","tags":["Sysprog","C","Numerics"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æ•°å€¼ç³»ç»Ÿç¯‡","uri":"/posts/c-numerics/"},{"categories":["Linux Kernel Internals"],"content":" é¢„æœŸç›®æ ‡ C è¯­è¨€ç¨‹åºè®¾è®¡ è®®é¢˜ï¼Œå¦‚ ä¸å®šä¸ªå‚æ•°çš„å¤„ç†ï¼Œsignalï¼Œsetjmp/longjmp å­¦ä¹  GNU/Linux å¼€å‘å·¥å…·: Cppcheck: é™æ€ ç¨‹åºåˆ†æå·¥å…·ï¼Œå³æ— éœ€è¿è¡Œç¨‹åºå°±å¯ä»¥åˆ†æå‡ºç¨‹åºæ½œåœ¨çš„é—®é¢˜ï¼Œå½“ç„¶ä¼šæœ‰ä¸€å®šçš„è¯¯å·®ï¼Œç±»ä¼¼çš„å·¥å…·æœ‰ cargo-check Valgrind: åŠ¨æ€ ç¨‹åºåˆ†æå·¥å…·ï¼Œå³éœ€è¦å°†ç¨‹åºè¿è¡Œèµ·æ¥å†è¿›è¡Œåˆ†æï¼Œé€šå¸¸ç”¨äºæ£€æµ‹å†…å­˜æ³„æ¼ (memory leak) å­¦ä¹ ä½¿ç”¨ Git ä¸ GitHub æ ‘ç«‹ä¸€è‡´ä¸”æ˜“äºåä½œçš„ç¨‹åºå¼€å‘è§„èŒƒ ç ”ç©¶è‡ªåŠ¨æµ‹è¯•æœºåˆ¶ æ¥è§¦ Linux Programming INterface ç†è§£ç”µè„‘ä¹±æ•°åŸç†ã€åº”ç”¨åœºæ™¯ï¼Œå’Œç›¸å…³çš„éªŒè¯ ç ”ç©¶ Linux æ ¸å¿ƒé“¾è¡¨çš„å®ä½œæœºåˆ¶ï¼ŒåŠå…¶é«˜æ•ˆçš„æ’åºå®ä½œ åŸæ–‡åœ°å€ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:0:0","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"æ”¹å†™è‡ª CMU è®¡ç®—æœºç³»ç»Ÿæ¦‚è®ºçš„ä½œä¸š lab0-c æ”¹å†™è‡ª CMU çš„ 15-213/15-513 Introduction to Computer Systems (ICS) è¯¾ç¨‹çš„ C Programming Lab: Assessing Your C Programming Skillsï¼Œç”¨äºæ£€éªŒå­¦ç”Ÿå¯¹äº C è¯­è¨€ç¨‹åºè®¾è®¡è®¤çŸ¥ã€‚ LeetCode 2095. Delete the Middle Node of a Linked List LeetCode 82. Remove Duplicates from Sorted List II LeetCode 24. Swap Nodes in Pairs LeetCode 25. Reverse Nodes in k-Group LeetCode 2487. Remove Nodes From Linked List / å‚è€ƒé¢˜è§£ LeetCode 23. Merge k Sorted Lists Linked List Sort ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:0","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"æ•°æ®ç»“æ„ å¤´æ–‡ä»¶ list.h ä¾æ® Linux æ ¸å¿ƒé£æ ¼å®ä½œäº†ç›¸åº”çš„ linked list å¸¸ç”¨æ“ä½œçš„å®ï¼Œè¿™ä¸ªæ–‡ä»¶å¯¹äºæœ¬æ¬¡å®éªŒå¾ˆé‡è¦ï¼Œéœ€è¦ä»”ç»†é˜…è¯»å¹¶åœ¨å®éªŒè¿‡ç¨‹ä¸­ä½¿ç”¨è¿™äº›å®æ¥ç®€åŒ–ç¨‹å¼ç ã€‚ å¤´æ–‡ä»¶ queue.h é‡Œåˆ™å®šä¹‰äº†é˜Ÿåˆ—å…ƒç´  element_t å’Œé˜Ÿåˆ—ä¸Šä¸‹æ–‡ q_context_t çš„ç»“æ„ã€‚ list_head element_t é˜Ÿåˆ—èŠ‚ç‚¹ä¸­çš„æˆå‘˜ value æŒ‡å‘çš„å­—ç¬¦ä¸²ä¹Ÿæ˜¯åŠ¨æ€åˆ†é…çš„ queue_context_t queue_context_t ä¸­çš„æˆå‘˜ q çš„ä½œç”¨æ˜¯æŒ‡å‘å°†é˜Ÿåˆ—èŠ‚ç‚¹ element_t è¿æ¥èµ·æ¥çš„å¤´èŠ‚ç‚¹ï¼Œè€Œæˆå‘˜ chain çš„ä½œç”¨æ˜¯å°†å„ä¸ªé˜Ÿåˆ— queue_context_t è¿æ¥èµ·æ¥ã€‚ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:1","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_size /** * q_size() - Get the size of the queue * @head: header of queue * * Return: the number of elements in queue, zero if queue is NULL or empty */ int q_size(struct list_head *head) { if (!head) return 0; int len = 0; struct list_head *node; list_for_each (node, head) len++; return len; } ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:2","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_new /** * q_new() - Create an empty queue whose next and prev pointer point to itself * * Return: NULL for allocation failed */ struct list_head *q_new() { struct list_head *head = malloc(sizeof(struct list_head)); if (!head) return NULL; INIT_LIST_HEAD(head); return head; } ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:3","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_free /** * q_free() - Free all storage used by queue, no effect if header is NULL * @head: header of queue */ void q_free(struct list_head *l) { struct list_head *head = l, *node, *safe; if (!head) return; list_for_each_safe (node, safe, head) { list_del(node); element_t *elem = list_entry(node, element_t, list); q_release_element(elem); } free(head); } è¿™é‡Œä½¿ç”¨ list_for_each_safe è€Œä¸æ˜¯ list_for_each_entry_safe æ¥éå†é“¾è¡¨ï¼Œå¯ä»¥æ ¹æ®è¿™ä¸¤ä¸ªå®çš„å®šä¹‰ï¼Œä»¥åŠæ€è€ƒé“¾è¡¨åªæœ‰ä¸€ä¸ªå…ƒç´ æ—¶çš„æƒ…å†µã€‚å¯ä»¥å‘ç° list_for_each_entry_safe è®¤ä¸º list_head éƒ½è¢«åŒ…è£¹åœ¨ entry ä¸­ï¼Œä½†æ˜¯ q_free çš„å‚æ•°é“¾è¡¨å¤´èŠ‚ç‚¹ l å¯èƒ½å¹¶æ²¡æœ‰è¢«åŒ…è£¹åœ¨ entry ä¸­ï¼Œè€ƒè™‘åˆ°è¿™ç§æƒ…å†µæ‰€ä»¥ä½¿ç”¨ list_for_each_safe å®ã€‚æœ€åéœ€è¦é‡Šæ”¾å¤´èŠ‚ç‚¹çš„ç©ºé—´ï¼Œå› ä¸ºè¿™ä¸ªç©ºé—´æ˜¯åœ¨ q_new æ—¶åŠ¨æ€åˆ†é…çš„ã€‚ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:4","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_insert /** * q_insert_head() - Insert an element in the head * @head: header of queue * @s: string would be inserted * * Argument s points to the string to be stored. * The function must explicitly allocate space and copy the string into it. * * Return: true for success, false for allocation failed or queue is NULL */ bool q_insert_head(struct list_head *head, char *s) { if (!head) return false; element_t *elem = malloc(sizeof(element_t)); if (!elem) return false; elem-\u003evalue = strdup(s); if (!elem-\u003evalue) { free(elem); return false; } list_add(\u0026elem-\u003elist, head); return true; } ä½¿ç”¨ strdup è¿›è¡ŒåŠ¨æ€åˆ†é…ç©ºé—´å¹¶æ‹·è´å­—ç¬¦ä¸²çš„å†…å®¹ï¼Œå¯ä» harness[.h][.c] æ–‡ä»¶ (å› ä¸ºè¯¥éƒ¨åˆ†æ˜¯è´Ÿè´£å®šåˆ¶åŒ–æœ¬å®éªŒçš„åŠ¨æ€åˆ†é…åŠŸèƒ½) ä¸­è·å¾—å¯å‘ï¼Œè¯¥å‡½æ•°å…·ä½“ç”¨æ³•å¯ä»¥å‚è€ƒ man strdupã€‚å› ä¸º strdup æœ¬è´¨ä¸Šä¹Ÿæ˜¯è°ƒç”¨äº† malloc åŠ¨æ€åˆ†é… (å…·ä½“è§ harness.c ä¸­çš„ test_strdup å®šä¹‰)ï¼Œæ‰€ä»¥ä¹Ÿéœ€è¦å¯¹ stdup çš„è¿”å›å€¼åˆ¤æ–­åŠ¨æ€åˆ†é…é‡Šæ˜¯å¦æˆåŠŸã€‚ q_insert_tail çš„å®ç°ç±»ä¼¼ï¼Œåªéœ€ä½¿ç”¨ list_add_tail å³å¯: /** * q_insert_tail() - Insert an element at the tail * @head: header of queue * @s: string would be inserted * * Argument s points to the string to be stored. * The function must explicitly allocate space and copy the string into it. * * Return: true for success, false for allocation failed or queue is NULL */ /* Insert an element at tail of queue */ bool q_insert_tail(struct list_head *head, char *s) { if (!head) return false; element_t *elem = malloc(sizeof(element_t)); if (!elem) return false; elem-\u003evalue = strdup(s); if (!elem-\u003evalue) { free(elem); return false; } list_add_tail(\u0026elem-\u003elist, head); return true; } ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:5","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_remove /** * q_remove_head() - Remove the element from head of queue * @head: header of queue * @sp: string would be inserted * @bufsize: size of the string * * If sp is non-NULL and an element is removed, copy the removed string to *sp * (up to a maximum of bufsize-1 characters, plus a null terminator.) * * NOTE: \"remove\" is different from \"delete\" * The space used by the list element and the string should not be freed. * The only thing \"remove\" need to do is unlink it. * * Reference: * https://english.stackexchange.com/questions/52508/difference-between-delete-and-remove * * Return: the pointer to element, %NULL if queue is NULL or empty. */ element_t *q_remove_head(struct list_head *head, char *sp, size_t bufsize) { if (!head || list_empty(head)) return NULL; element_t *elem = list_first_entry(head, element_t, list); list_del_init(\u0026elem-\u003elist); if (sp) { memcpy(sp, elem-\u003evalue, bufsize - 1); sp[bufsize - 1] = '\\0'; } return elem; } ä½¿ç”¨ list_first_entry æ¥è·å–é˜Ÿåˆ—çš„å¤´å…ƒç´ ï¼ŒåŒç†å¯ä»¥ä½¿ç”¨ list_last_entry æ¥è·å–é˜Ÿåˆ—çš„å°¾å…ƒç´ : /** * q_remove_tail() - Remove the element from tail of queue * @head: header of queue * @sp: string would be inserted * @bufsize: size of the string * * Return: the pointer to element, %NULL if queue is NULL or empty. */ element_t *q_remove_tail(struct list_head *head, char *sp, size_t bufsize) { if (!head || list_empty(head)) return NULL; element_t *elem = list_last_entry(head, element_t, list); list_del_init(\u0026elem-\u003elist); if (sp) { memcpy(sp, elem-\u003evalue, bufsize - 1); sp[bufsize - 1] = '\\0'; } return elem; } ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:6","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_delete_mid /** * q_delete_mid() - Delete the middle node in queue * @head: header of queue * * The middle node of a linked list of size n is the * âŒŠn / 2âŒ‹th node from the start using 0-based indexing. * If there're six elements, the third member should be returned. * * Reference: * https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/ * * Return: true for success, false if list is NULL or empty. */ bool q_delete_mid(struct list_head *head) { // https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/ if (!head || list_empty(head)) return false; struct list_head *p = head-\u003enext; struct list_head *q = head-\u003eprev; while (!(p == q || p-\u003enext == q)) { p = p-\u003enext; q = q-\u003eprev; } list_del_init(q); element_t *elem = list_entry(q, element_t, list); q_release_element(elem); return true; } ä½¿ç”¨åŒæŒ‡é’ˆåˆ†åˆ«ä»é˜Ÿåˆ—çš„é¦–å°¾è¿›è¡Œè¿­ä»£ï¼Œä»è€Œè·å–ä¸­é—´èŠ‚ç‚¹ã€‚æ³¨æ„éœ€è¦å…ˆå¯¹è·å–çš„ä¸­é—´èŠ‚ç‚¹è¿›è¡Œç§»é™¤ remove åœ¨è¿›è¡Œé‡Šæ”¾ freeã€‚ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:7","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_delete_dup /** * q_delete_dup() - Delete all nodes that have duplicate string, * leaving only distinct strings from the original queue. * @head: header of queue * * Reference: * https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ * * Return: true for success, false if list is NULL. */ bool q_delete_dup(struct list_head *head) { // https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ if (!head) return false; struct list_head *node, *safe, *temp; list_for_each_safe (node, safe, head) { element_t *e_node = list_entry(node, element_t, list); while (!(safe == head)) { element_t *e_safe = list_entry(safe, element_t, list); if (strcmp(e_node-\u003evalue, e_safe-\u003evalue)) break; safe = safe-\u003enext; list_del(\u0026e_safe-\u003elist); q_release_element(e_safe); } if (temp != safe) { list_del(node); q_release_element(e_node); } } return true; } åœ¨æœ‰åºé˜Ÿåˆ—ä¸­ï¼Œå¯¹é˜Ÿåˆ—çš„æ¯ä¸ªå…ƒç´ è¿›è¡Œè¿­ä»£æ£€æŸ¥ï¼Œéœ€è¦é¢å¤–æ³¨æ„ safe == head çš„æƒ…å½¢ï¼Œå¦åˆ™ä½¿ç”¨ list_entry å¯èƒ½ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸º UBã€‚éœ€è¦æ³¨æ„ä¿ç•™ä¸‹æ¥çš„èŠ‚ç‚¹æœç‹¬ç‰¹ (distinct) çš„èŠ‚ç‚¹ï¼Œå³å‡¡æ˜¯å‡ºç°é‡å¤çš„èŠ‚ç‚¹éƒ½éœ€è¦è¢«å…¨éƒ¨åˆ é™¤æ‰ï¼Œè€Œä¸æ˜¯åˆ é™¤åˆ°ä»…å‰©ä¸€ä¸ªã€‚ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:8","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_swap /** * q_swap() - Swap every two adjacent nodes * @head: header of queue * * Reference: * https://leetcode.com/problems/swap-nodes-in-pairs/ */ void q_swap(struct list_head *head) { // https://leetcode.com/problems/swap-nodes-in-pairs/ if (!head) return; struct list_head *node, *safe, *prev, *next; list_for_each_safe (node, safe, head) { if (safe == head) break; prev = node-\u003eprev; next = safe-\u003enext; node-\u003eprev = safe; safe-\u003enext = node; node-\u003enext = next; safe-\u003eprev = prev; prev-\u003enext = safe; next-\u003eprev = node; safe = next; } } ä»¥ä¸¤ä¸ªèŠ‚ç‚¹ä¸ºå•ä½è¿›è¡Œäº¤æ¢æ“ä½œï¼Œç„¶åä¸é”šç‚¹è®¾å®šç›¸åº”çš„å…³ç³»ï¼Œä¾æ¬¡é€ä¸ªå•ä½ (ä¸¤ä¸ªèŠ‚ç‚¹) è¿›è¡Œå¤„ç†: before swap after swap ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:9","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_reverse /** * q_reverse() - Reverse elements in queue * @head: header of queue * * No effect if queue is NULL or empty. * This function should not allocate or free any list elements * (e.g., by calling q_insert_head, q_insert_tail, or q_remove_head). * It should rearrange the existing ones. */ void q_reverse(struct list_head *head) { if (!head) return; struct list_head *node, *safe, *prev; list_for_each_safe (node, safe, head) { prev = node-\u003eprev; node-\u003eprev = safe; node-\u003enext = prev; } prev = head-\u003eprev; head-\u003eprev = head-\u003enext; head-\u003enext = prev; } å¯¹é˜Ÿåˆ—çš„æ¯ä¸ªèŠ‚ç‚¹ä¾æ¬¡è¿›è¡Œå¦‚ä¸‹èŠ‚ç‚¹ list_head 1 çš„å¤„ç†ï¼Œå³åè½¬æŒ‡é’ˆ prev å’Œ next çš„æŒ‡å‘ (å®å¿ƒç®­å¤´è¡¨ç¤ºçš„æ˜¯ list_head 1 çš„æŒ‡é’ˆæˆå‘˜): before reverse after reverse è‡³äºé˜Ÿåˆ—å¤´èŠ‚ç‚¹ head åˆ™ä¸éœ€è¦ç‰¹åˆ«è€ƒè™‘ï¼Œæœ€åå°†å…¶çš„ prev å’Œ next æˆå‘˜çš„æŒ‡å‘è¿›è¡Œåè½¬å³å¯ã€‚ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:10","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_reverseK /** * q_reverseK() - Given the head of a linked list, reverse the nodes of the list * k at a time. * @head: header of queue * @k: is a positive integer and is less than or equal to the length of the * linked list. * * No effect if queue is NULL or empty. If there has only one element, do * nothing. * * Reference: * https://leetcode.com/problems/reverse-nodes-in-k-group/ */ void q_reverseK(struct list_head *head, int k) { // https://leetcode.com/problems/reverse-nodes-in-k-group/ if (!head) return; struct list_head *node, *safe, *prev, *next; list_for_each_safe (node, safe, head) { // get prev and next nodes around K nodes prev = node-\u003eprev; next = node; int cnt = 0; while (cnt \u003c k \u0026\u0026 next != head) { cnt++; next = next-\u003enext; } if (cnt \u003c k) break; safe = next-\u003eprev; // reverse K nodes struct list_head *p = node, *q; while (p != next) { q = p-\u003enext; p-\u003enext = p-\u003eprev; p-\u003eprev = q; p = q; } // setup node, safe, prev, next node-\u003enext = next; next-\u003eprev = node; safe-\u003eprev = prev; prev-\u003enext = safe; safe = next; } } q_reverseK ç›¸å½“äº q_swap çš„å¢å¼ºç‰ˆï¼Œè§£å†³çš„æ€è·¯ä¹Ÿæ˜¯æ¯”è¾ƒç±»ä¼¼ï¼Œå…ˆç¡®è®¤ K ä¸ªèŠ‚ç‚¹çš„åè½¬åŒºåŸŸä»¥åŠç›¸åº”çš„å‰åé”šç‚¹: prev å’Œ nextï¼Œæ¥ä¸‹æ¥å¯¹åè½¬åŒºåŸŸçš„ K ä¸ªèŠ‚ç‚¹è¿›è¡Œåè½¬ï¼Œè¿™éƒ¨åˆ†çš„æ“ä½œå’Œ q_reverse ç›¸åŒï¼Œéƒ½æ˜¯é€ä¸ªèŠ‚ç‚¹è¿›è¡Œæˆå‘˜æŒ‡é’ˆåè½¬ï¼Œåè½¬ç»“æŸåï¼Œå’Œ q_swap ç±»ä¼¼ï¼Œè®¾å®šä¸é”šç‚¹ç›¸åº”çš„ä½ç½®å…³ç³»ï¼Œä¾æ¬¡é€åŒºåŸŸ (K ä¸ªèŠ‚ç‚¹) è¿›è¡Œå¤„ç†ã€‚è¯¥è¿‡ç¨‹å›¾ç¤ºå¦‚ä¸‹: æ³¨æ„è§‚å¯ŸæŒ‡é’ˆ prev, next çš„å˜åŒ– before reverse after reverse after setup prev, node, safe, next ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:11","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_sort Linked List Sort /** * q_sort() - Sort elements of queue in ascending/descending order * @head: header of queue * @descend: whether or not to sort in descending order * * No effect if queue is NULL or empty. If there has only one element, do * nothing. */ void q_sort(struct list_head *head, bool descend); Bubble sort ä¸»è¦æ˜¯é€šè¿‡äº¤æ¢ (swap) æ¥å®ç°æ ¸å¿ƒçš„å†’æ³¡ï¼Œæ€è·¯æ˜¯å°†èŠ‚ç‚¹ safe å¯¹åº”å­—ç¬¦ä¸²ä¸ node å¯¹åº”çš„å­—ç¬¦ä¸²æ¯”è¾ƒï¼Œä»è€Œå†³å®šæ˜¯å¦è¿›è¡Œäº¤æ¢æ“ä½œï¼Œè¿™é‡Œå®ç°çš„æ˜¯ stable çš„æ’åºç®—æ³•ï¼Œæ‰€ä»¥æ¯”è¾ƒã€äº¤æ¢æ—¶ä¸è€ƒè™‘ç›¸ç­‰çš„æƒ…å†µã€‚éœ€è¦çš„æ˜¯æ³¨æ„ï¼Œè™½ç„¶ swap éƒ¨åˆ†å’Œ q_swap å‡ ä¹ä¸€æ ·ï¼Œä½†æ˜¯æœ€åè®¾å®šä¸‹ä¸€ä¸ªèŠ‚ç‚¹ safe æ—¶ä¸ç›¸åŒï¼Œå› ä¸ºè¿™é‡Œéœ€è¦æ¯ä¸ªèŠ‚ç‚¹ä¹‹é—´éƒ½éœ€è¦è¿›è¡Œæ¯”è¾ƒï¼Œè€Œä¸æ˜¯ä»¥æ¯ä¸¤ä¸ªèŠ‚ç‚¹ä¸ºå•ä½è¿›è¡Œäº¤æ¢ã€‚ å¸ƒå°”è¡¨è¾¾å¼ (descend \u0026\u0026 cmp \u003c 0) || (!descend \u0026\u0026 cmp \u003e 0) è¡¨ç¤ºä¸æ»¡è¶³é¢„æœŸçš„ node -\u003e safe çš„é¡ºåºå…³ç³»ï¼Œéœ€è¦è°ƒæ•´æˆ safe node é¡ºåºæ‰æ»¡è¶³ã€‚ static void q_bubble_sort(struct list_head *head, bool descend) { if (!head) return; bool swapped = true; struct list_head *node, *safe, *prev, *next; while (swapped) { swapped = false; list_for_each_safe (node, safe, head) { if (safe == head) break; element_t *e_node = list_entry(node, element_t, list); element_t *e_safe = list_entry(safe, element_t, list); int cmp = strcmp(e_node-\u003evalue, e_safe-\u003evalue); if ((descend \u0026\u0026 cmp \u003c 0) || (!descend \u0026\u0026 cmp \u003e 0)) { swapped = true; // swap prev = node-\u003eprev; next = safe-\u003enext; node-\u003eprev = safe; safe-\u003enext = node; node-\u003enext = next; safe-\u003eprev = prev; prev-\u003enext = safe; next-\u003eprev = node; // set next node safe = node; } } } } Insertion sort æ ¸å¿ƒæ˜¯é€šè¿‡æ’å…¥ (insertion) æ“ä½œï¼Œåœ¨å·¦è¾¹å·²æ’åºçš„èŠ‚ç‚¹ä¸­å¯»æ‰¾åˆé€‚çš„ä½ç½®è¿›è¡Œæ’å…¥ï¼Œé“¾è¡¨çš„ä»»æ„ä½ç½®æ’å…¥æ“ä½œæ˜¯æ¯”è¾ƒç›´è§‚çš„ï¼Œç§»é™¤ååœ¨å¯¹åº”çš„ä½ç½®é€šè¿‡é”šç‚¹æ’å…¥å›ºå®šã€‚ static void q_insertion_sort(struct list_head *head, bool descend) { if (!head) return; struct list_head *node, *safe; list_for_each_safe (node, safe, head) { struct list_head *prev = node-\u003eprev, *next; // one node is already sorted if (prev == head) continue; // remove list_del(node); element_t *e_node = list_entry(node, element_t, list); element_t *e_prev = list_entry(prev, element_t, list); // find position int cmp = strcmp(e_prev-\u003evalue, e_node-\u003evalue); while ((descend \u0026\u0026 cmp \u003c 0) || (!descend \u0026\u0026 cmp \u003e 0)) { prev = prev-\u003eprev; if (prev == head) break; e_prev = list_entry(prev, element_t, list); cmp = strcmp(e_prev-\u003evalue, e_node-\u003evalue); } // insertion next = prev-\u003enext; prev-\u003enext = node; node-\u003eprev = prev; node-\u003enext = next; next-\u003eprev = node; } } Selection sort è¿™é‡Œé‡‡ç”¨çš„æ˜¯ stable çš„æ’åºç®—æ³•ï¼Œæ‰€ä»¥å¹¶æ²¡æœ‰é‡‡ç”¨äº¤æ¢ç­–ç•¥ (äº¤æ¢é€‰æ‹©èŠ‚ç‚¹å’Œå½“å‰èŠ‚ç‚¹) /* Selection sort */ static void q_selection_sort(struct list_head *head, bool descend) { if (!head) return; struct list_head *node, *safe, *prev = head; list_for_each_safe (node, safe, head) { struct list_head *temp = node-\u003enext, *sele = node; // selection while (temp != head) { element_t *e_sele = list_entry(sele, element_t, list); element_t *e_temp = list_entry(temp, element_t, list); int cmp = strcmp(e_sele-\u003evalue, e_temp-\u003evalue); if ((descend \u0026\u0026 cmp \u003c 0) || (!descend \u0026\u0026 cmp \u003e 0)) { sele = temp; } temp = temp-\u003enext; } // insertion list_del(sele); prev-\u003enext-\u003eprev = sele; sele-\u003enext = prev-\u003enext; prev-\u003enext = sele; sele-\u003eprev = prev; // set next node prev = sele; safe = sele-\u003enext; } } Merge sort å°†é˜Ÿåˆ—çš„åŒç«¯é“¾è¡¨è§†ä¸ºæ™®é€šçš„å•é“¾è¡¨ï¼Œç„¶åé€šè¿‡ã€Œå¿«æ…¢æŒ‡é’ˆã€æ¥è·å–ä¸­é—´èŠ‚ç‚¹ (å› ä¸ºä½¿ç”¨çš„æ˜¯å•é“¾è¡¨ï¼Œæ²¡æ³•ä¿è¯ prev æŒ‡å‘çš„æ­£ç¡®æ€§)ï¼Œé€šè¿‡ä¸­é—´èŠ‚ç‚¹åˆ‡åˆ†æˆä¸¤ä¸ªæ™®é€šçš„å•é“¾è¡¨ï¼Œåˆ†åˆ«è¿›è¡Œå½’å¹¶æ’åºï¼Œæœ€åè¿›è¡Œå•é“¾è¡¨çš„å½’å¹¶æ“ä½œã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿‡ç¨‹ä¸­ä½¿ç”¨çš„å•é“¾è¡¨å¹¶ä¸å…·å¤‡ä¸€ä¸ªä»…åšä¸ºå¤´èŠ‚ç‚¹ä½¿ç”¨çš„èŠ‚ç‚¹ (å³ q_new ä¸­åˆ†é…çš„å¤´èŠ‚ç‚¹)ï¼Œå¹¶ä¸”ä½¿ç”¨çš„æ˜¯ indirect pointer ä½œä¸ºå‚æ•°ï¼Œè¿™æ ·æ’åºå®Œæˆå head èŠ‚ç‚¹çš„ next æŒ‡å‘çš„å°±æ˜¯æ­£ç¡®é¡ºåºçš„é“¾è¡¨ï¼Œæœ€åå†æ ¹æ®è¯¥é¡ºåºè¡¥å…… prev å…³ç³»å³å¯ã€‚é…åˆä»¥ä¸‹å›¾ç¤ºè¿›è¡Œç†è§£: origin queue convert to singly linked list split into two lists indirect pointers /* Merge two linked list */ static void merge(struct list_head **l1, struct list_head **const l2, bool descend) { struct list_head **temp = l1; struct list_head *node1 = *l1; struct list_head *node2 = *l2; while (node1 \u0026\u0026 node2) { element_t *elem1 = list_entry(node1, element_t, list); element_t *elem2 = list_entry(node2, element_t, list); int cmp = strcmp(elem1-\u003evalue, elem2-\u003evalue); if ((descend \u0026\u0026 cmp \u003c 0) || (!descend \u0026\u0026 cmp \u003e 0)) { *temp = node2; node2 = node2-\u003enext; } else { *temp = node1; node1 = node1-\u003enext; } temp = \u0026(*temp)-\u003enext; } *temp = node1 ? node1 : node2; } /* Merge sort */ static void q_merge_sort(struct list_head **head, bool descend) { if (!(*head) || !(*head)-\u003enext) return; // get the middle node by","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:12","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_ascend \u0026 q_descend ascend ç»“æœçš„èŠ‚ç‚¹å¤§å°é¡ºåº: $$node 0 \u003c node 1 \u003c node 2 \u003c node 3$$ descend ç»“æœçš„èŠ‚ç‚¹å¤§å°é¡ºåº: $$node 0 \u003e node 1 \u003e node 2 \u003e node 3$$ ä¾æ®è¿™ä¸ªç‰¹æ€§ï¼Œå°†é“¾è¡¨è¿›è¡Œåè½¬åè¿›è¡Œæ“ä½œæ¯”è¾ƒç›´è§‚ï¼Œå‚è€ƒ è¿™ä¸ªé¢˜è§£ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œå¯¹èŠ‚ç‚¹çš„æ“ä½œæ˜¯åˆ é™¤ (delete) è€Œä¸åªæ˜¯ç§»é™¤ (remove)ï¼Œæ‰€ä»¥è®°å¾—ç§»é™¤ (remove) ä¹‹ååŠæ—¶é‡Šæ”¾ (free)ã€‚ /** * q_ascend() - Remove every node which has a node with a strictly less * value anywhere to the right side of it. * @head: header of queue * * No effect if queue is NULL or empty. If there has only one element, do * nothing. * * Reference: * https://leetcode.com/problems/remove-nodes-from-linked-list/ * * Return: the number of elements in queue after performing operation */ int q_ascend(struct list_head *head) { // https://leetcode.com/problems/remove-nodes-from-linked-list/ if (!head) return 0; q_reverse(head); struct list_head *node, *safe; list_for_each_safe (node, safe, head) { if (safe == head) break; element_t *e_node = list_entry(node, element_t, list); element_t *e_safe = list_entry(safe, element_t, list); while (strcmp(e_node-\u003evalue, e_safe-\u003evalue) \u003c 0) { safe = safe-\u003enext; list_del(safe-\u003eprev); q_release_element(e_safe); if (safe == head) break; e_safe = list_entry(safe, element_t, list); } } q_reverse(head); return q_size(head); } /** * q_descend() - Remove every node which has a node with a strictly greater * value anywhere to the right side of it. * @head: header of queue * * No effect if queue is NULL or empty. If there has only one element, do * nothing. * * Reference: * https://leetcode.com/problems/remove-nodes-from-linked-list/ * * Return: the number of elements in queue after performing operation */ int q_descend(struct list_head *head) { // https://leetcode.com/problems/remove-nodes-from-linked-list/ if (!head) return 0; q_reverse(head); struct list_head *node, *safe; list_for_each_safe (node, safe, head) { if (safe == head) break; element_t *e_node = list_entry(node, element_t, list); element_t *e_safe = list_entry(safe, element_t, list); while (strcmp(e_node-\u003evalue, e_safe-\u003evalue) \u003e 0) { safe = safe-\u003enext; list_del(safe-\u003eprev); q_release_element(e_safe); if (safe == head) break; e_safe = list_entry(safe, element_t, list); } } q_reverse(head); return q_size(head); } ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:13","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"q_merge /** * q_merge() - Merge all the queues into one sorted queue, which is in * ascending/descending order. * @head: header of chain * @descend: whether to merge queues sorted in descending order * * This function merge the second to the last queues in the chain into the first * queue. The queues are guaranteed to be sorted before this function is called. * No effect if there is only one queue in the chain. Allocation is disallowed * in this function. There is no need to free the 'qcontext_t' and its member * 'q' since they will be released externally. However, q_merge() is responsible * for making the queues to be NULL-queue, except the first one. * * Reference: * https://leetcode.com/problems/merge-k-sorted-lists/ * * Return: the number of elements in queue after merging */ é‡‡ç”¨å½’å¹¶æ€æƒ³è¿›è¡Œæ’åºï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(m \\cdot logn)$ã€‚åˆå¹¶æ—¶éœ€è¦æ³¨æ„å°†ä¸éœ€è¦çš„é˜Ÿåˆ—çš„ q æˆå‘˜ç½®ä¸º init å§¿æ€ï¼Œå³è¡¨ç¤ºç©ºé˜Ÿåˆ—ã€‚ /* Merge two lists */ static void q_merge2(struct list_head *l1, struct list_head *l2, bool descend) { queue_contex_t *q1 = list_entry(l1, queue_contex_t, chain); queue_contex_t *q2 = list_entry(l2, queue_contex_t, chain); struct list_head *h1 = q1-\u003eq-\u003enext; struct list_head *h2 = q2-\u003eq-\u003enext; struct list_head **head = \u0026q1-\u003eq; while (h1 != q1-\u003eq \u0026\u0026 h2 != q2-\u003eq) { element_t *e1 = list_entry(h1, element_t, list); element_t *e2 = list_entry(h2, element_t, list); int cmp = strcmp(e1-\u003evalue, e2-\u003evalue); if ((descend \u0026\u0026 cmp \u003c 0) || (!descend \u0026\u0026 cmp \u003e 0)) { (*head)-\u003enext = h2; h2-\u003eprev = (*head); h2 = h2-\u003enext; } else { (*head)-\u003enext = h1; h1-\u003eprev = (*head); h1 = h1-\u003enext; } head = \u0026(*head)-\u003enext; } if (h1 != q1-\u003eq) { (*head)-\u003enext = h1; h1-\u003eprev = (*head); head = \u0026q1-\u003eq-\u003eprev; } if (h2 != q2-\u003eq) { (*head)-\u003enext = h2; h2-\u003eprev = (*head); head = \u0026q2-\u003eq-\u003eprev; } (*head)-\u003enext = q1-\u003eq; q1-\u003eq-\u003eprev = (*head); INIT_LIST_HEAD(q2-\u003eq); q1-\u003esize += q2-\u003esize; return; } /* Merge lists in region [lh, rh) */ static void q_mergeK(struct list_head *lh, struct list_head *rh, bool descend) { if (lh == rh || lh-\u003enext == rh) return; // get middle node by two pointers struct list_head *p = lh; struct list_head *q = rh-\u003eprev; while (!(p == q || p-\u003enext == q)) { p = p-\u003enext; q = q-\u003eprev; } q_mergeK(lh, q, descend); q_mergeK(q, rh, descend); q_merge2(lh, q, descend); } /* Merge all the queues into one sorted queue, which is in * ascending/descending order */ int q_merge(struct list_head *head, bool descend) { // https://leetcode.com/problems/merge-k-sorted-lists/ if (!head || list_empty(head)) return 0; q_mergeK(head-\u003enext, head, descend); return list_entry(head-\u003enext, queue_contex_t, chain)-\u003esize; } ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:14","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"å‘½ä»¤è¡Œå‚æ•° å…³äº lab0-c ç›¸å…³å‘½ä»¤çš„ä½¿ç”¨ï¼Œå¯ä»¥å‚ç…§é˜…è¯»åé¢çš„ã€Œå–å¾—ç¨‹å¼ç å¹¶è¿›è¡Œå¼€å‘ã€éƒ¨åˆ†ã€‚ $ ./qtest cmd\u003e help Commands: # ... | Display comment dedup | Delete all nodes that have duplicate string descend | Remove every node which has a node with a strictly greater value anywhere to the right side of it dm | Delete middle node in queue free | Delete queue help | Show summary ... æ³¨æ„ Difference between â€œdeleteâ€ and â€œremoveâ€ Delete and remove are defined quite similarly, but the main difference between them is that delete means erase (i.e. rendered nonexistent or nonrecoverable), while remove connotes take away and set aside (but kept in existence). In your example, if the item is existent after the removal, just say remove, but if it ceases to exist, say delete. åœ¨å®Œæˆ queue.c æ–‡ä»¶ä¸­çš„å‡½æ•°åŠŸèƒ½æ—¶ï¼Œå¯ä»¥é€šè¿‡ä½¿ç”¨è¿™ä¸ªå‘½ä»¤è¡Œå¯¹å‚æ•°å¯¹åº”çš„åŠŸèƒ½è¿›è¡Œæµ‹è¯•ï¼Œä¾‹å¦‚: # test q_size \u003e new L = [] \u003e ih a L = [a] \u003e ih b L = [b a] \u003e size 2 ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:1:15","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"å¼€å‘ç¯å¢ƒè®¾å®š $ neofetch --stdout cai@cai-RB-14II --------------- OS: Ubuntu 22.04.4 LTS x86_64 Host: RedmiBook 14 II Kernel: 6.5.0-35-generic Uptime: 1 hour, 10 mins Packages: 2047 (dpkg), 11 (snap) Shell: bash 5.1.16 Resolution: 1920x1080 DE: GNOME 42.9 WM: Mutter WM Theme: Adwaita Theme: Yaru-blue-dark [GTK2/3] Icons: Yaru-blue [GTK2/3] Terminal: gnome-terminal CPU: Intel i7-1065G7 (8) @ 3.900GHz GPU: NVIDIA GeForce MX350 GPU: Intel Iris Plus Graphics G7 Memory: 3462MiB / 15776MiB å®‰è£…å¿…è¦çš„å¼€å‘å·¥å…·åŒ…: $ sudo apt install build-essential git-core valgrind $ sudo apt install cppcheck clang-format aspell colordiff åŸºæœ¬çš„ Linux å‘½ä»¤è¡Œæ“ä½œï¼Œå¯å‚è€ƒ é¸Ÿå“¥çš„ Linux ç§æˆ¿èœçš„ ç›¸å…³ç« èŠ‚: Linux çš„æª”æ¡ˆæ¬Šé™èˆ‡ç›®éŒ„é…ç½® Linux æª”æ¡ˆèˆ‡ç›®éŒ„ç®¡ç† æª”æ¡ˆèˆ‡æª”æ¡ˆç³»çµ±çš„å£“ç¸®ã€æ‰“åŒ…èˆ‡å‚™ä»½ æˆåŠŸ â€œIf I had eight hours to chop down a tree, Iâ€™d spend six hours sharpening my axe.â€ â€“ Abraham Lincoln ã€Œå·¥æ¬²å–„å…¶äº‹ï¼Œå¿…å…ˆåˆ©å…¶å™¨ã€ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:2:0","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"å–å¾—ç¨‹å¼ç å¹¶è¿›è¡Œå¼€å‘ å»ºç«‹å¼€å‘ç›®å½•: $ cd ~ $ mkdir -p linux2023 ä» GItHub è·å– [lab-c] ç¨‹å¼ç : $ git clone git@github.com:\u003cusername\u003e/lab0-c # or $ git clone https://github.com/\u003cusername\u003e/lab0-c åˆ‡æ¢çš„ lab0-c ç›®å½•å¹¶è¿›è¡Œç¼–è¯‘: $ cd lab0-c $ make é¢„æœŸçœ‹åˆ°ä»¥ä¸‹è¾“å‡º: CC qtest.o CC report.o CC console.o CC harness.o CC queue.o CC random.o CC dudect/constant.o CC dudect/fixture.o CC dudect/ttest.o CC shannon_entropy.o CC linenoise.o CC web.o LD qtest ä¹Ÿå¯ä»¥æ¸…é™¤ç¼–è¯‘è¾“å‡ºçš„æ¡£æ¡ˆ (ä¸€èˆ¬æ˜¯å¯æ‰§è¡Œæ–‡ä»¶å’Œç›®æ ‡æ–‡ä»¶): $ make clean å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤è®¾å®šç¼–è¯‘æ—¶è¾“å‡ºçš„ç»†èŠ‚ï¼š $ make VERBOSE=1 è¿™æ ·ç¼–è¯‘æ—¶ä¼šè¾“å‡ºæ›´å¤šç»†èŠ‚: $ make gcc -o qtest.o -O1 -g -Wall -Werror -c -MMD -MF .qtest.o.d qtest.c gcc -o report.o -O1 -g -Wall -Werror -c -MMD -MF .report.o.d report.c gcc -o console.o -O1 -g -Wall -Werror -c -MMD -MF .console.o.d console.c gcc -o harness.o -O1 -g -Wall -Werror -c -MMD -MF .harness.o.d harness.c gcc -o queue.o -O1 -g -Wall -Werror -c -MMD -MF .queue.o.d queue.c gcc -o qtest qtest.o report.o console.o harness.o queue.o å³æœ€ç»ˆçš„æ‰§è¡Œæ¡£æ¡ˆä¸º qtestã€‚æ¥ä¸‹æ¥å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤æ¥æµ‹è¯• qtest: $ make check ./qtest -v 3 -f traces/trace-eg.cmd cmd\u003e cmd\u003e # Demonstration of queue testing framework cmd\u003e # Use help command to see list of commands and options cmd\u003e # Initial queue is NULL. cmd\u003e show q = NULL cmd\u003e # Create empty queue cmd\u003e new q = [] cmd\u003e # Fill it with some values. First at the head cmd\u003e ih dolphin å³å°† traces/trace-eg.cmd çš„å†…å®¹ä½œä¸ºæµ‹è¯•å‘½ä»¤æŒ‡æ´¾ç»™ qtest æ‰§è¡Œã€‚ ç”±è¾“å‡ºå¯ä»¥å¾—çŸ¥å‘½ä»¤ make check åªæ˜¯å¯¹ä¸€äº›åŸºæœ¬åŠŸèƒ½è¿›è¡Œæµ‹è¯•ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤è¿›è¡Œå…¨é¢è¦†ç›–çš„æµ‹è¯•: $ make test è¿™ä¸ªå‘½ä»¤ä¹Ÿæ˜¯æœ¬æ¬¡å®éªŒçš„è‡ªåŠ¨è¯„åˆ†ç³»ç»Ÿï¼Œå…¶å®é™…æ‰§è¡Œäº† scripts/driver.py è¿™ä¸ª Python ç¨‹åºï¼Œè¿™ä¸ªç¨‹åºçš„åŸºæœ¬é€»è¾‘å°±æ˜¯å°† traces/trace-XX-CAT.cmd è¿™ç±»å†…å®¹ä½œä¸ºæµ‹è¯•å‘½ä»¤æŒ‡æ´¾ç»™ qtest å†…éƒ¨çš„å‘½ä»¤è§£é‡Šå™¨è¿›è¡Œæ‰§è¡Œï¼Œå¹¶ä¾æ®æµ‹è¯•ç»“æœè®¡ç®—ç›¸åº”çš„åˆ†æ•°ã€‚ é€šè¿‡ä»¥ä¸‹å‘½ä»¤ä¼šå¼€å¯ AddressSanitizer ä»è€Œå¼ºåŒ–æ‰§è¡Œæ—¶æœŸçš„å†…å­˜æ£€æµ‹ï¼Œåœ¨è¿›è¡Œæµ‹è¯•æ—¶ä¼šè¾“å‡ºç›¸åº”çš„å†…å­˜æ£€æµ‹ä¿¡æ¯: $ make SANITIZER=1 $ make test # the following output as an example ==8522==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000008 (pc 0x55ea517092cb bp 0x7ffe778b4900 sp 0x7ffe778b4900 T0) ==8522==The signal is caused by a READ memory access. ==8522==Hint: address points to the zero page. #0 0x55ea517092ca in q_remove_head lab0-c/queue.c:74 #1 0x55ea51704880 in do_remove_head lab0-c/qtest.c:311 #2 0x55ea51707054 in interpret_cmda lab0-c/console.c:217 #3 0x55ea51707a58 in interpret_cmd lab0-c/console.c:240 #4 0x55ea51708725 in cmd_select lab0-c/console.c:568 #5 0x55ea51708b42 in run_console lab0-c/console.c:627 #6 0x55ea51705c7d in main lab0-c/qtest.c:700 #7 0x7facce0d8b96 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b96) #8 0x55ea51703819 in _start (lab0-c/qtest+0x5819) Address/Thread/Memory Sanitizer A look into the sanitizer family (ASAN \u0026 UBSAN) by Akul Pillai ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:3:0","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"clang-format å·¥å…·å’Œä¸€è‡´çš„ç¨‹åºæ’°å†™é£æ ¼ éœ€è¦åœ¨å½“å‰ç›®å½•æˆ–æŒ‡å®šè·¯å¾„æœ‰ .clang-format æ–‡ä»¶ï¼Œç„¶åé€šè¿‡ä»¥ä¸‹ä½¿ç”¨æ–¹å¼: $ clang-format -i *.[ch] ç›¸å…³ç¨‹åºé£æ ¼æŸ¥çœ‹åŸæ–‡å³å¯ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:3:1","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"Git Hooks è¿›è¡Œè‡ªåŠ¨ç¨‹å¼ç æ’ç‰ˆæ£€æŸ¥ ç¬¬ä¸€æ¬¡ make åï¼ŒGit pre-commit / pre-push hook å°†è¢«è‡ªåŠ¨å®‰è£…åˆ°å½“å‰çš„å·¥ä½œåŒº (workspace)ï¼Œä¹‹åæ¯æ¬¡æ‰§è¡Œ git commit æ™‚ï¼ŒGit hook éƒ½ä¼šæ£€æŸ¥ C/C++ çš„ä»£ç é£æ ¼æ˜¯å¦ä¸ .clang-format è¦æ±‚çš„ä¸€è‡´ï¼Œå¹¶åŒæ—¶é€šè¿‡ Cppcheck è¿›è¡Œé™æ€ç¨‹åºåˆ†ææ£€æŸ¥ã€‚ æŠ€å·§ tig å¯ä»¥æ›´åŠ æ–¹ä¾¿çš„æµè§ˆ git repository çš„ä¿¡æ¯: # install $ sudo apt install tig # read the manual $ tig --help # or if you have installed tldr $ tldr tig æ€ä¹ˆå†™å¥½ä¸€ä¸ª Git Commit: è‹±æ–‡åŸæ–‡: How to Write a Git Commit Message ä¸­æ–‡ç¿»è¯‘: å¦‚ä½•å¯«ä¸€å€‹ Git Commit Message The seven rules of a great Git commit message: Separate subject from body with a blank line Limit the subject line to 50 characters Capitalize the subject line Do not end the subject line with a period Use the imperative mood in the subject line Wrap the body at 72 characters Use the body to explain what and why vs. how æ³¨æ„ è«‹é¿å…ç”¨ $ git commit -mï¼Œè€Œæ˜¯é€éç·¨è¼¯å™¨èª¿æ•´ git commit messageã€‚è¨±å¤šç¶²è·¯æ•™å­¸ç‚ºäº†è¡Œæ–‡ä¾¿åˆ©ï¼Œç”¨ $ git commit -m ç¤ºç¯„ï¼Œä½†é€™æ¨£å¾ˆå®¹æ˜“è®“äººç•™ä¸‹èªç„‰ä¸è©³çš„è¨Šæ¯ï¼Œæœªèƒ½æå‡ç‚ºå¥½çš„ Git Commit Messageã€‚å› æ­¤ï¼Œå¾ä»Šä»¥å¾Œï¼Œä¸è¦ç”¨ git commit -m, æ”¹ç”¨ git commit -a (æˆ–å…¶ä»–åƒæ•¸) ä¸¦è©³ç´°æŸ¥é©—è®Šæ›´çš„æª”æ¡ˆã€‚ è®¾ç½® Git çš„é»˜è®¤ç¼–è¾‘å™¨ä¸º Vim: $ git config --global core.editor vim ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:3:2","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"GitHub Actions è®¾å®š GitHub Actions æ˜¯ GitHub æä¾›çš„ CI/CD æœå‹™ï¼ŒCI/CD ä»£è¡¨çš„æ˜¯ Continuous Integration æŒçºŒæ•´åˆèˆ‡ Continuous Deployment æŒçºŒéƒ¨ç½²ï¼Œç°¡å–®ä¾†èªªå°±æ˜¯å°‡ç¨‹å¼æµç¨‹è‡ªå‹•åŒ–ã€‚lab0-c æä¾›å¹¾é …è‡ªå‹•åŒ–æ¸¬è©¦ï¼ŒåŒ…å«ï¼šæª¢æŸ¥æ’ç‰ˆã€ç·¨è­¯çµæœå’Œè‡ªå‹•è©•åˆ†ç­‰ç­‰ã€‚é€™è£¡éœ€è¦æ³¨æ„çš„æ˜¯ fork å®Œæˆå¾Œï¼Œé è¨­æƒ…æ³ä¸‹ GitHub Action ä¸æœƒè¢«å•Ÿå‹•ï¼Œæ‰€ä»¥éœ€è¦ æ‰‹å‹•é–‹å•Ÿ GitHub Actionsï¼Œåœ¨ä½ æ‰€ fork å‡ºçš„ repository çš„ Actions å…§é»é¸ I understand my workflows, go ahead and enable them é–‹å•Ÿ GitHub Actions å¾Œï¼Œç•¶æ¯æ¬¡ push åˆ°é ç«¯æ™‚ï¼ŒGitHub å°±æœƒè‡ªå‹•æ¸¬è©¦ä½œæ¥­è¨­è¨ˆçš„æª¢æŸ¥é …ç›®ï¼Œç•¶æœ‰éŒ¯èª¤æ™‚æœƒæ”¶åˆ° CI failed çš„ email é€šçŸ¥ã€‚ åœ¨ç¾æœ‰çš„ GitHub Actions å°æ‡‰çš„æ¸¬è©¦é …ç›®ä¸­ï¼Œä¸€æ—¦æ”¶åˆ° git push çš„äº‹ä»¶ï¼Œç³»çµ±å°±æœƒè‡ªå‹•åŸ·è¡Œ make testï¼Œä¸¦åœ¨å¤±æ•—æ™‚ç™¼ä¿¡ä»¶é€šçŸ¥å­¸å“¡ã€‚ é»æ“Šä¿¡ä»¶ä¸­çš„ View workflow run å³å¯åœ¨ GitHub ç¶²ç«™ä¸­å¾—çŸ¥ GitHub Actions çš„æ¸¬è©¦ç‹€æ³ã€‚ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:3:3","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"ä»¥ Valgrind åˆ†æå†…å­˜é—®é¢˜ Valgrind is an instrumentation framework for building dynamic analysis tools. There are Valgrind tools that can automatically detect many memory management and threading bugs, and profile your programs in detail. You can also use Valgrind to build new tools. ä½¿ç”¨æ–¹å¼: $ valgrind --tool=\u003ctoolname\u003e \u003cprogram\u003e Valgrind is NOT a leak checker Valgrind is an undefined behavior checking tool first, a function and memory profiler second, a data-race detection tool third, and a leak checking tool last. å¼•ç”¨ dynamic Binary Instrumentation (DBI) è‘—é‡æ–¼äºŒé€²ä½åŸ·è¡Œæª”çš„è¿½è¹¤èˆ‡è³‡è¨Šå½™æ•´ï¼Œè€Œ dynamic Binary Analysis (DBA) å‰‡å¼·èª¿å°æ”¶é›†è³‡è¨Šçš„åˆ†æã€‚ä¸Šè¿° Valgrind æ˜¯å€‹ DBI ç³»çµ±æ¡†æ¶ï¼Œå¯å»ºæ§‹ä¸€ç³»åˆ— DBA å·¥å…·ï¼Œè—‰ç”± shadow values æŠ€è¡“ä¾†å¯¦ä½œï¼Œå¾Œè€…è¦æ±‚å°æ‰€æœ‰çš„æš«å­˜å™¨å’Œä½¿ç”¨åˆ°çš„ä¸»è¨˜æ†¶é«”åš shadow (å³è‡ªè¡Œç¶­è­·çš„å‰¯æœ¬)ï¼Œé€™ä¹Ÿä½¿å¾— Valgrind ç›¸è¼ƒå…¶ä»–åˆ†ææ–¹æ³•æœƒè¼ƒæ…¢ã€‚ å¼•ç”¨ ä¹Ÿå°±æ˜¯èªªï¼ŒValgrind ä¸»è¦çš„æ‰‹æ³•æ˜¯å°‡æš«å­˜å™¨å’Œä¸»è¨˜æ†¶é«”çš„å…§å®¹è‡ªè¡Œç¶­è­·å‰¯æœ¬ï¼Œä¸¦åœ¨ä»»ä½•æƒ…æ³ä¸‹éƒ½å¯ä»¥å®‰å…¨æ­£ç¢ºåœ°ä½¿ç”¨ï¼ŒåŒæ™‚è¨˜éŒ„ç¨‹å¼çš„æ‰€æœ‰æ“ä½œï¼Œåœ¨ä¸å½±éŸ¿ç¨‹å¼åŸ·è¡Œçµæœå‰æä¸‹ï¼Œè¼¸å‡ºæœ‰ç”¨çš„è³‡è¨Šã€‚ç‚ºäº†å¯¦ä½œåŠŸèƒ½ï¼ŒValgrind åˆ©ç”¨ dynamic binary re-compilation æŠŠæ¸¬è©¦ç¨‹å¼ (ç¨±ç‚º client ç¨‹å¼) çš„æ©Ÿæ¢°ç¢¼è§£æåˆ° VEX ä¸­é–“è¡¨ç¤ºæ³• (intermediate representationï¼Œç°¡ç¨± IRï¼Œæ˜¯ç¨®è™›æ“¬çš„æŒ‡ä»¤é›†æ¶æ§‹ï¼Œè¦ç¯„åœ¨åŸå§‹ç¨‹å¼ç¢¼ VEX/pub/libvex_ir.h)ã€‚VEX IR åœ¨ Valgrind æ¡ç”¨åŸ·è¡Œå°å‘çš„æ–¹å¼ï¼Œä»¥ just-in-time (JIT) ç·¨è­¯æŠ€è¡“å‹•æ…‹åœ°æŠŠæ©Ÿæ¢°ç¢¼è½‰ç‚º IRï¼Œå€˜è‹¥è§¸ç™¼ç‰¹å®šå·¥å…·æ„Ÿèˆˆè¶£çš„äº‹ä»¶ (å¦‚è¨˜æ†¶é«”é…ç½®)ï¼Œå°±æœƒè·³èºåˆ°å°æ‡‰çš„è™•ç†å·¥å…·ï¼Œå¾Œè€…æœƒæ’å…¥ä¸€äº›åˆ†æç¨‹å¼ç¢¼ï¼Œå†æŠŠé€™äº›ç¨‹å¼ç¢¼è½‰æ›ç‚ºæ©Ÿæ¢°ç¢¼ï¼Œå„²å­˜åˆ° code cache ä¸­ï¼Œä»¥åˆ©å¾ŒçºŒéœ€è¦æ™‚åŸ·è¡Œã€‚ Machine Code --\u003e IR --\u003e IR --\u003e Machine Code ^ ^ ^ | | | translate | | | | instrument | | translate Valgrind å¯åŠ¨åä¼šå¯¹ client ç¨‹åºè¿›è¡Œè½¬æ¢ï¼Œæ‰€ä»¥ Valgrind æ‰§è¡Œçš„æ˜¯åŠ å·¥åçš„ client ç¨‹åº: 2007 å¹´çš„è®ºæ–‡: Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation ç¹ä½“ä¸­æ–‡ç‰ˆæœ¬çš„ è®ºæ–‡å¯¼è¯» ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:4:0","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"Valgrind ä½¿ç”¨æ¡ˆä¾‹ å®‰è£…è°ƒè¯•å·¥å…·ä»¥è®© Valgrind æ›´å¥½åœ°è¿›è¡Œåˆ†æ: $ sudo apt install libc6-dbg Memory Leak å¸¸è§é”™è¯¯æœ‰: malloc äº†ä¸€ä¸ªç©ºé—´ä½†æ²¡ free å¯¼è‡´å†…å­˜æ³„éœ² memory lost: definitely lost indirectly lost possibly lost still readchable è¿è¡Œ valgrind å’Œ gdb ç±»ä¼¼ï¼Œéƒ½éœ€è¦ä½¿ç”¨ -g å‚æ•°æ¥ç¼–è¯‘ C/C++ æºç¨‹åºä»¥ç”Ÿæˆè°ƒè¯•ä¿¡æ¯ï¼Œç„¶åè¿˜å¯ä»¥é€šè¿‡ -q å‚æ•°æŒ‡ç¤º valgrind è¿›å…¥ quite æ¨¡å¼ï¼Œå‡å°‘å¯åŠ¨æ—¶ä¿¡æ¯çš„è¾“å‡ºã€‚ $ valgrind -q --leak-check=full ./case1 --leak-check=full: å¯ç”¨å…¨é¢çš„å†…å­˜æ³„æ¼æ£€æŸ¥ï¼Œvalgrind å°†ä¼šæŠ¥å‘Šæ‰€æœ‰çš„å†…å­˜æ³„æ¼æƒ…å†µï¼ŒåŒ…æ‹¬è¯¦ç»†çš„å †æ ˆè·Ÿè¸ªä¿¡æ¯ --show-possibly-lost=no: ä¸è¾“å‡º possibly lost ç›¸å…³æŠ¥å‘Š --track-fds=yes: ä¾¦æµ‹ file descriptor å¼€äº†æ²¡å…³çš„æƒ…å†µ Invalid Memory Access å¸¸è§é”™è¯¯æœ‰: malloc äº†å¹¶ free ä½†åˆå¯¹è¿™ä¸ªå·²ç»è¢« free çš„ç©ºé—´è¿›è¡Œæ“ä½œï¼Œå³ Use After Free valgrind è¾“å‡ºçš„æŠ¥å‘Š invalid write/read è¿™ç±»çš„å•ä½æ˜¯ Byteï¼Œå³ size of X (bytes) Other Conditional jump or move depends on uninitialised value(s) è¿™ä¸ªé”™è¯¯ä¸€èˆ¬æ˜¯å› ä¸ºä½¿ç”¨äº†æ²¡æœ‰ç»“æŸå­—ç¬¦ (null-terminated string) çš„å­—ç¬¦ä¸² ä¸åŒå‡½æ•°ä½¿ç”¨äº†ä¸åˆæ³•çš„æ ˆç©ºé—´ï¼Œä¾‹å¦‚å‡½æ•° A ä½¿ç”¨äº†å·²ç»è¿”å›äº†çš„å‡½æ•° B çš„æ ˆç©ºé—´ï¼Œè¿™æ ·çš„æ“ä½œæ˜¯ä¸åˆæ³•çš„ å¯¹å±€éƒ¨å˜é‡çš„å­˜å–è¶…è¿‡èŒƒå›´ä¼šå¯¼è‡´ stack corrupt (ä¸ªäººæ„Ÿè§‰ç­‰åŒ stack overflow) ç¨‹åºè¿è¡Œæ—¶çš„å†…å­˜å¸ƒå±€: Valgrind é…åˆ Massif å¯ä»¥å¯¹ç¨‹åºè¿è¡Œæ—¶çš„å†…å­˜è¡Œä¸ºè¿›è¡Œå¯è§†åŒ–: ä¿¡æ¯ Valgrind User Manual Massif: a heap profiler lab0-c ä¹Ÿå¼•å…¥äº† Valgrind æ¥ååŠ©ä¾¦æµ‹å®éªŒè¿‡ç¨‹ä¸­å¯èƒ½å‡ºç°çš„å†…å­˜ç›¸å…³é—®é¢˜ï¼Œä¾‹å¦‚ memory leak, buffer overflow, Dangling pointer ç­‰ç­‰ã€‚ä½¿ç”¨æ–¹å¼å¦‚ä¸‹: $ make valgrind ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:4:1","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"è‡ªåŠ¨æµ‹è¯•ç¨‹åº signal å¼‚å¸¸æ‰§è¡Œæµ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:5:0","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"è¿½è¸ªå†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾ Wikipedia: Hooking Wikipedia: Test harness GCC: Arrays of Length Zero The alignment of a zero-length array is the same as the alignment of its elements. C Struct Hack - Structure with variable length array ç›¸å…³æºä»£ç é˜…è¯» (harness.h, harness.c): typedef struct __block_element { struct __block_element *next, *prev; size_t payload_size; size_t magic_header; /* Marker to see if block seems legitimate */ unsigned char payload[0]; /* Also place magic number at tail of every block */ } block_element_t; /* Find header of block, given its payload. * Signal error if doesn't seem like legitimate block */ block_element_t *find_header(void *p); /* Given pointer to block, find its footer */ size_t *find_footer(block_element_t *b); /* Implementation of application functions */ void *test_malloc(size_t size); // cppcheck-suppress unusedFunction void *test_calloc(size_t nelem, size_t elsize); void test_free(void *p); ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:5:1","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"qtest å‘½ä»¤è§£é‡Šå™¨ æ–°å¢æŒ‡ä»¤ helloï¼Œç”¨äºæ‰“å° Hello, world\" çš„ä¿¡æ¯ã€‚è°ƒç”¨æµç¨‹: main â†’ run_console â†’ cmd_select â†’ interpret_cmd â†’ interpret_cmda â†’ do_hello ç›¸å…³æºä»£ç é˜…è¯» (console.h, console.c): typedef struct __cmd_element {...} cmd_element_t; /* Optionally supply function that gets invoked when parameter changes */ typedef void (*setter_func_t)(int oldval); /* Integer-valued parameters */ typedef struct __param_element {...} param_element_t; /* Initialize interpreter */ void init_cmd(); /* Add a new command */ void add_cmd(char *name, cmd_func_t operation, char *summary, char *parameter); #define ADD_COMMAND(cmd, msg, param) add_cmd(#cmd, do_##cmd, msg, param) /* Add a new parameter */ void add_param(char *name, int *valp, char *summary, setter_func_t setter); /* Execute a command that has already been split into arguments */ static bool interpret_cmda(int argc, char *argv[]) å±é™© åŸæ–‡çš„ã€Œå‘½ä»¤ç›´è¯‘å™¨çš„åˆå§‹åŒ–å‡†å¤‡ã€éƒ¨åˆ†ï¼Œç¤ºä¾‹çš„ä»£ç ç‰‡æ®µä¸æœ€æ–°çš„ä»£ç æœ‰è®¸å¤šå·®åˆ« (ç‰¹åˆ«æ˜¯ç»“æ„ä½“çš„åç§°)ï¼Œä¸€å®šè¦æ­é…é˜…è¯»æœ€æ–°çš„æºç ï¼Œå¦åˆ™ä¼šååˆ†è¿·ç³Šã€‚ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:5:2","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"Signal å¤„ç†å’Œåº”ç”¨ Linux manual page: signal(2) signal() sets the disposition of the signal signum to handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined function (a â€œsignal handlerâ€). static void q_init() { fail_count = 0; INIT_LIST_HEAD(\u0026chain.head); signal(SIGSEGV, sigsegv_handler); signal(SIGALRM, sigalrm_handler); } alarm(2) alarm() arranges for a SIGALRM signal to be delivered to the calling process in seconds seconds. If seconds is zero, any pending alarm is canceled. In any event any previously set alarm() is canceled. setjmp(3) The functions described on this page are used for performing â€œnonlocal gotosâ€: transferring execution from one function to a predetermined location in another function. The setjmp() function dynamically establishes the target to which control will later be transferred, and longjmp() performs the transfer of execution. sigsetjmp(3) setjmp() and sigsetjmp() return 0 if returning directly, and nonzero when returning from longjmp(3) or siglongjmp(3) using the saved context. Why use sigsetjmp()/siglongjmp() instead of setjmp()/longjmp()? The Linux Programming Interface The sa_mask field allows us to specify a set of signals that arenâ€™t permitted to interrupt execution of this handler. In addition, the signal that caused the handler to be invoked is automatically added to the process signal mask. This means that a signal handler wonâ€™t recursively interrupt itself if a second instance of the same signal arrives while the handler is executing. However, there is a problem with using the standard longjmp() function to exit from a signal handler. We noted earlier that, upon entry to the signal handler, the kernel automatically adds the invoking signal, as well as any signals specified in the act.sa_mask field, to the process signal mask, and then removes these signals from the mask when the handler does a normal return. What happens to the signal mask if we exit the signal handler using longjmp()? The answer depends on the genealogy of the particular UNIX implementation. å¼•ç”¨ ç°¡è¨€ä¹‹ï¼Œç•¶æŸå€‹ signal handler è¢«è§¸ç™¼æ™‚ï¼Œè©² signal æœƒåœ¨åŸ·è¡Œ signal handler æ™‚æœƒè¢«é®ç½©ä½ï¼Œä¸¦åœ¨ signal handler å›å‚³æ™‚æ¢å¾©ã€‚è€Œï¼Œåœ¨è£¡é¢ä½¿ç”¨ longjmp æ™‚ï¼Œè§£é™¤è¨Šè™Ÿé®ç½©çš„è¡Œç‚ºæœ‰å¯èƒ½ä¸æœƒç™¼ç”Ÿ(æ˜¯å¦è§£é™¤å‰‡ä¾ç…§å¯¦ä½œæ±ºå®š)ã€‚ç‚ºäº†ä¿è­‰åœ¨éå€åŸŸè·³èºå¾Œèƒ½å¤ æ¢å¾©ï¼Œæ‰€ä»¥ POSIX å¦è¡Œè¦ç¯„å¾—ä»¥åœ¨ signal handler ä¸­å‘¼å«çš„ sigsetjmp è·Ÿ siglongjmpã€‚ jmp_ready æŠ€å·§ (ç”¨äºä¿è¯åœ¨ siglongjmp() ä¹‹å‰å¿…ç„¶æ‰§è¡Œè¿‡ä¸€æ¬¡ sigsetjmp()): Because a signal can be generated at any time, it may actually occur before the target of the goto has been set up by sigsetjmp() (or setjmp()). To prevent this possibility (which would cause the handler to perform a nonlocal goto using an uninitialized env buffer), we employ a guard variable, canJump, to indicate whether the env buffer has been initialized. If canJump is false, then instead of doing a nonlocal goto, the handler simply returns. åœ¨æ‰§è¡Œ siglongjmp ä¹‹å‰æ‰§è¡Œä¸€æ¬¡ sigsetjmp æ˜¯å¿…é¡»çš„ï¼Œè¿™ç”¨äºä¿å­˜ sigsetjmp æ‰€å¤„åœ°æ–¹çš„ä¸Šä¸‹æ–‡ï¼Œè€Œ sigsetjmp æ‰€å¤„åœ°æ–¹æ­£æ˜¯ siglongjmp æ‰§è¡Œæ—¶éœ€è¦è·³è½¬åˆ°çš„åœ°æ–¹ï¼Œæ‰€ä»¥ä¸ºäº†ä¿è¯é•¿è·³è½¬åæ‰§è¡Œç¬¦åˆé¢„å–ï¼Œéœ€è¦ä¿å­˜ä¸Šä¸‹æ–‡ã€‚ void trigger_exception(char *msg) { ... if (jmp_ready) siglongjmp(env, 1); else exit(1); } bool exception_setup(bool limit_time) { if (sigsetjmp(env, 1)) { /* Got here from longjmp */ jmp_ready = false; ... } else { /* Got here from initial call */ jmp_ready = true; ... } } ç›¸å…³æºä»£ç é˜…è¯» (qtest.c, report.h, report.c, harness.h, harness.c): /* Signal handlers */ static void sigsegv_handler(int sig); static void sigalrm_handler(int sig) /* Use longjmp to return to most recent exception setup */ void trigger_exception(char *msg); /* Prepare for a risky operation using setjmp. * Function returns true for initial return, false for error return */ bool exception_setup(bool limit_time); void report_event(message_t msg, char *fmt, ...); ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:5:3","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"æ£€æµ‹éé¢„æœŸçš„å†…å­˜æ“ä½œæˆ–ç¨‹åºæ‰§è¡Œè¶…æ—¶ ç”±ä¸Šé¢å¯çŸ¥ï¼Œå½“æ”¶åˆ° SIGSEGV æˆ– SIGALRM ä¿¡å·æ—¶ï¼Œä¼šé€šè¿‡ signal handler â¡ï¸ trigger_exception â¡ï¸ exception_setup è¿™ä¸€æ¡é“¾è·¯æ‰§è¡Œã€‚é‚£ä¹ˆå½“ exception_setup å‡½æ•°è¿”å›æ—¶ä¼šè·³è½¬åˆ°å“ªé‡Œå‘¢ï¼Ÿ åœ¨ qtest.c çš„å½¢å¦‚ do_\u003coperation\u003e è¿™ç±»å‡½æ•°é‡Œé¢ï¼Œéƒ½ä¼šç›´æ¥æˆ–é—´æ¥çš„åŒ…å«ä»¥ä¸‹çš„ç¨‹å¼ç : if (exception_setup(true)) { ... } exception_cancel(); å›åˆ°ç¨æ—©æåŠçš„ if (exception_setup(true)) æ•˜è¿°ä¸­ï¼Œè‹¥æ˜¯ç¬¬ä¸€æ¬¡å›å‚³ï¼Œé‚£éº¼æœƒé–‹å§‹æ¸¬è©¦å‡½å¼ã€‚è‹¥æ¸¬è©¦å‡½å¼çš„éç¨‹ä¸­ï¼Œç™¼ç”Ÿä»»ä½•éŒ¯èª¤ (äº¦å³è§¸ç™¼ SIGSEGV æˆ– SIGALRM ä¸€é¡çš„ signal)ï¼Œå°±æœƒç«‹åˆ»è·³å› signal handlerã€‚signal handler æœƒå°å‡ºéŒ¯èª¤è¨Šæ¯ï¼Œä¸¦é€²è¡Œ siglongjmpã€‚ç”± exception_setup çš„ç¨‹å¼å¯ä»¥çŸ¥é“åˆæ˜¯è·³åˆ° exception_setup(true) è£¡é¢ï¼Œä½†é€™æ™‚æœƒå›å‚³ falseï¼Œå› è€Œè·³éæ¸¬è©¦å‡½å¼ï¼Œç›´æ¥çµæŸæ¸¬è©¦ä¸¦å›å‚³ ok å…§å«å€¼ã€‚æ›è¨€ä¹‹ï¼Œexception_cancel() å¾Œå°±ç®—å†ç™¼ç”Ÿ SIGALRM æˆ– SIGSEGVï¼Œä¹Ÿä¸æœƒå†æœ‰æ©Ÿæœƒå›åˆ° exception_setup() è£¡é¢ã€‚ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:5:4","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"æ•´åˆç½‘é¡µæœåŠ¡å™¨ ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:6:0","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"æ•´åˆ tiny-web-server tiny-web-server å±é™© åŸæ–‡çš„ç¤ºä¾‹çš„ä»£ç ç‰‡æ®µä¸æœ€æ–°çš„ä»£ç æœ‰è®¸å¤šå·®åˆ« (ç‰¹åˆ«æ˜¯å‡½æ•°çš„åç§°)ï¼Œä¸€å®šè¦æ­é…é˜…è¯»æœ€æ–°çš„æºç ï¼Œå¦åˆ™ä¼šååˆ†è¿·ç³Šã€‚ ç¨‹åºç­‰å¾…è¾“å…¥çš„è°ƒç”¨é“¾ (linenoise.c): linenoise() -\u003e line_raw() -\u003e line_edit() ä½† line_edit ä¸­æ˜¯ä½¿ç”¨ read ç­‰å¾…ç”¨æˆ·è¾“å…¥ï¼Œæ‰€ä»¥å½“ read é˜»å¡æ—¶å°±æ— æ³•æ¥æ”¶æ¥è‡ª web ä¼ æ¥çš„ä¿¡æ¯ã€‚å°è¯•ä½¿ç”¨ select() æ¥åŒæ—¶å¤„ç†æ ‡å‡†è¾“å…¥ stdin å’Œç½‘ç»œ socketã€‚ select(2) On success, select() and pselect() return the number of file descriptors contained in the three returned descriptor sets (that is, the total number of bits that are set in readfds, writefds, exceptfds). The return value may be zero if the timeout expired before any file descriptors became ready. On error, -1 is returned, and errno is set to indicate the error; the file descriptor sets are unmodified, and timeout becomes undefined. select å’Œ poll éƒ½æ˜¯ä¸Šå›¾æ‰€ç¤ºçš„å¤šè·¯ I/O å¤ç”¨çš„æ¨¡å‹ï¼Œä¼˜åŠ¿åœ¨äºå¯ä»¥åŒæ—¶å¤„ç†å¤šä¸ª file descriptorï¼Œä½†ç¼ºç‚¹åœ¨äºéœ€è¦ä½¿ç”¨ 2 æ¬¡ syscallï¼Œç¬¬ä¸€æ¬¡æ˜¯ç­‰å¾… kernel å‘å‡ºé€šçŸ¥ï¼Œç¬¬äºŒæ¬¡æ˜¯ä» kernel æ‹·è´æ•°æ®ï¼Œæ¯æ¬¡ syscall éƒ½éœ€è¦è¿›è¡Œ context switchï¼Œå¯¼è‡´è¿™ä¸ªæ¨¡å‹æ¯”å…¶ä»–çš„ I/O æ¨¡å‹å¼€é”€å¤§ (context switch å¼€é”€æ˜¯å¾ˆå¤§çš„)ã€‚ ç›¸å…³æºä»£ç é˜…è¯» (linenoise.h, linenoise.c, console.c): ","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:6:1","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Linux Kernel Internals"],"content":"åœ¨ qtest æä¾›æ–°å‘½ä»¤ shuffle","date":"2024-02-19","objectID":"/posts/linux2023-lab0/:7:0","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: lab0-c","uri":"/posts/linux2023-lab0/"},{"categories":["Rust","Systems"],"content":" In this stream, we started implementing the ubiquitous TCP protocol that underlies much of the traffic on the internet! In particular, we followed RFC 793 â€” https://tools.ietf.org/html/rfc793 â€” which describes the original protocol, with the goal of being able to set up and tear down a connection with a â€œrealâ€ TCP stack at the other end (netcat in particular). Weâ€™re writing it using a user-space networking interface (see https://www.kernel.org/doc/Documentation/networking/tuntap.txt and the Rust bindings at https://docs.rs/tun-tap/). æ•´ç†è‡ª John Gjengset çš„å½±ç‰‡: Part 1 ","date":"2024-02-17","objectID":"/posts/rust-tcp/:0:0","tags":["Rust","TCP","Network"],"title":"Impl Rust: TCP/IP","uri":"/posts/rust-tcp/"},{"categories":["Rust","Systems"],"content":"å½±ç‰‡æ³¨è§£ Part 1 ","date":"2024-02-17","objectID":"/posts/rust-tcp/:1:0","tags":["Rust","TCP","Network"],"title":"Impl Rust: TCP/IP","uri":"/posts/rust-tcp/"},{"categories":["Rust","Systems"],"content":"Raw socket vs TUN/TAP device Raw sockets [Wikipedia] TUN/TAP [Wikipedia] Raw socket vs TUN device [Stack Overflow] Universal TUN/TAP device driver [Linux kernel documentation] Raw socket: Internet â€“\u003e NIC â€“\u003e kernel â€“\u003e user space Internet \u003câ€“ NIC \u003câ€“ kernel \u003câ€“ user space Host interact with other hosts in Internet. TUN/TAP device: kernel â€“\u003e | TUN/TAP | â€“\u003e user space kernel \u003câ€“ | TUN/TAP | \u003câ€“ user space Kernel interact with programs in user space in the same host. å’Œå…¶ä»–ç‰©ç†ç½‘å¡ä¸€æ ·ï¼Œç”¨æˆ·è¿›ç¨‹åˆ›å»ºçš„ TUN/TAP è®¾å¤‡ä»ç„¶æ˜¯è¢« kernel æ‰€æ‹¥æœ‰çš„ (kernel å¯ä»¥ä½¿ç”¨è®¾å¤‡è¿›è¡Œå‘é€/æ¥æ”¶)ï¼Œåªä¸è¿‡ç”¨æˆ·è¿›ç¨‹ä¹Ÿå¯ä»¥åƒæ“ä½œ ç®¡é“ (pipe) é‚£æ ·ï¼Œæ“ä½œæ‰€åˆ›å»ºçš„ TUN/TAP è®¾å¤‡ (å¯ä»¥ä½¿ç”¨è¯¥è®¾å¤‡è¿›è¡Œå‘é€/æ¥æ”¶)ï¼Œä»è€Œä¸ kernel çš„ç‰©ç†ç½‘å¡è¿›è¡Œé€šä¿¡ã€‚ Universal TUN/TAP device driver [Linux kernel documentation] 3.2 Frame format: If flag IFF_NO_PI is not set each frame format is: Flags [2 bytes] Proto [2 bytes] Raw protocol(IP, IPv6, etc) frame. é€šè¿‡ TUN/TAP è®¾å¤‡æ¥æ”¶çš„å°åŒ…ï¼Œä¼šæ‹¥æœ‰ Flags å’Œ Proto è¿™ä¸¤ä¸ªå­—æ®µ (å…± 4 ä¸ªå­—èŠ‚ï¼Œè¿™ä¹Ÿæ˜¯ iface çš„ without_packet_info å’Œ recv æ–¹æ³•æ‰€æè¿°çš„ prepended packet info)ï¼Œç„¶åæ‰æ˜¯åŸå§‹åè®®çš„ frameã€‚å…¶ä¸­çš„ Proto å­—æ®µæ˜¯ EtherType [Wikipedia]ï¼Œå¯ä»¥æ ¹æ®é‡Œé¢çš„ values æ¥åˆ¤æ–­æ¥å—å°åŒ…çš„åè®®ç±»å‹ (0x0800 è¡¨ç¤º IPv4ï¼Œ0x86DD è¡¨ç¤º IPv6)ã€‚ ","date":"2024-02-17","objectID":"/posts/rust-tcp/:1:1","tags":["Rust","TCP","Network"],"title":"Impl Rust: TCP/IP","uri":"/posts/rust-tcp/"},{"categories":["Rust","Systems"],"content":"setcap setcap [Linux manual page] cap_from_text [Linux manual page] å› ä¸º TUN/TAP æ˜¯ç”± kernel æä¾›çš„ï¼Œæ‰€ä»¥éœ€è¦èµ‹äºˆæˆ‘ä»¬é¡¹ç›®çš„å¯æ‰§è¡Œæ–‡ä»¶æƒé™ï¼Œä½¿å®ƒèƒ½è®¿é—®æˆ‘ä»¬åˆ›å»ºçš„ TUN/TAP è®¾å¤‡ (ä¸ºäº†ç®€å•èµ·è§ï¼Œä¸‹é¢åªåˆ—å‡º release ç‰ˆæœ¬çš„æ–¹æ³•ï¼Œdebug ç‰ˆæœ¬çš„æ–¹æ³•ç±»ä¼¼)ã€‚ # ç¼–è¯‘ $ cargo build --release # è®¾ç½®æ–‡ä»¶æƒé™ $ sudo setcap cap_net_admin=eip target/release/trust # è¿è¡Œ $ cargo run --release åœ¨å¦ä¸€ç»ˆç«¯è¾“å…¥å‘½ä»¤ ip addr å°±å¯ä»¥çœ‹åˆ°æ­¤æ—¶ä¼šå¤šå‡ºä¸€ä¸ªåä¸º tun0 çš„è®¾å¤‡ï¼Œè¿™æ­£æ˜¯æˆ‘ä»¬åˆ›å»ºçš„ TUN è®¾å¤‡ã€‚ ip-address [Linux manual page] ip-link [Linux manual page] åœ¨å¦ä¸€ä¸ªç»ˆç«¯ä¸­è¾“å…¥: # åˆ—å‡ºå½“å‰æ‰€æœ‰çš„ç½‘ç»œè®¾å¤‡ $ ip addr # é…ç½®è®¾å¤‡ tun0 çš„ IP åœ°å€ $ sudo ip addr add 192.168.0.1/24 dev tun0 # å¯åŠ¨è®¾å¤‡ tun0 $ sudo ip link set up dev tun0 æ¯æ¬¡ç¼–è¯‘åéƒ½éœ€è¦æ‰§è¡Œä¸€éè¿™ä¸ªæµç¨‹ (å› ä¸ºé‡æ–°ç¼–è¯‘ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶éœ€è¦é‡æ–°è®¾ç½®æƒé™)ï¼Œæˆ‘ä»¬å°†è¿™äº›æµç¨‹çš„é€»è¾‘å†™æˆä¸€ä¸ªè„šæœ¬ run.shã€‚è¿™ä¸ªè„šæœ¬ä¸ºäº†è¾“å‡ºçš„ç¾è§‚æ€§å¢åŠ äº†é¢å¤–é€»è¾‘ï¼Œä¾‹å¦‚å°† trust æ”¾åœ¨åå°æ‰§è¡Œï¼Œå°†è„šæœ¬è®¾ç½®ä¸ºç­‰å¾… trust æ‰§è¡Œå®Œæˆåæ‰ç»“æŸæ‰§è¡Œã€‚ ","date":"2024-02-17","objectID":"/posts/rust-tcp/:1:2","tags":["Rust","TCP","Network"],"title":"Impl Rust: TCP/IP","uri":"/posts/rust-tcp/"},{"categories":["Rust","Systems"],"content":"Endianness Endianness [Wikipedia] Why is network-byte-order defined to be big-endian? [Stack Overflow] Rust æä¾›äº† Trait std::simd::ToBytes ç”¨äºå¤§å°ç«¯å­—èŠ‚åºä¹‹é—´çš„ç›¸äº’è½¬æ¢ï¼Œæ–¹æ³• from_be_bytes æ˜¯å°†å¤§ç«¯å­—èŠ‚åºçš„ä¸€ç³»åˆ—å­—èŠ‚è½¬æ¢æˆå¯¹åº”è¡¨ç¤ºçš„æ•°å€¼ã€‚ ","date":"2024-02-17","objectID":"/posts/rust-tcp/:1:3","tags":["Rust","TCP","Network"],"title":"Impl Rust: TCP/IP","uri":"/posts/rust-tcp/"},{"categories":["Rust","Systems"],"content":"IP å› ä¸º TUN åªæ˜¯åœ¨ Network layer çš„è™šæ‹Ÿè®¾å¤‡ (TAP åˆ™æ˜¯ Data link layer å±‚)ï¼Œæ‰€ä»¥éœ€è¦æ‰‹åŠ¨è§£æ IP å°åŒ…ã€‚ RFC 791 3.1. Internet Header Format List of IP protocol numbers [Wikipedia] å¯ä»¥æŒ‰ç…§ä¸Šé¢çš„æ ¼å¼æ¥è§£æå°åŒ…å¤´ï¼Œä¹Ÿå¯ä»¥å¼•å…¥ Crate etherparse æ¥è§£æ IP å°åŒ…å¤´ã€‚ ping å‘½ä»¤ä½¿ç”¨çš„æ˜¯ Network layer ä¸Šçš„ ICMP åè®®ï¼Œå¯ä»¥ç”¨äºæµ‹è¯• TUN æ˜¯å¦æˆåŠŸé…ç½®å¹¶èƒ½æ¥æ”¶å°åŒ…ã€‚ $ ping -I tun0 192.168.0.2 ping (networking utility) [Wikipedia] ping [Linux man page] nc å‘½ä»¤ç”¨äºå‘é€ TCP å°åŒ… $ nc 192.168.0.2 80 nc [Linux man page] æ³¨æ„ ping, nc è¿™äº›å‘½ä»¤ä½¿ç”¨çš„éƒ½æ˜¯ kernel çš„åè®®æ ˆæ¥å®ç°ï¼Œæ‰€ä»¥åœ¨åˆ›å»ºè™šæ‹Ÿè®¾å¤‡ tun0 ä¹‹åï¼Œä½¿ç”¨ä»¥ä¸Š ping, nc å‘½ä»¤è¡¨ç¤º kernel å‘é€ç›¸åº”çš„ ICMP, TCP å°åŒ…ç»™åˆ›å»º tun0 çš„è¿›ç¨‹ (process)ã€‚ å¯ä»¥ä½¿ç”¨ tshark (Terminal Wireshark) å·¥å…·æ¥æŠ“åŒ…ï¼Œé…åˆ ping,nc å‘½ä»¤å¯ä»¥åˆ†æ tun0 çš„å°åŒ…ä¼ é€ã€‚ $ sudo apt install tshark $ sudo tshark -i tun0 Wireshark [Wikipedia] tshark [Manual Page] ","date":"2024-02-17","objectID":"/posts/rust-tcp/:1:4","tags":["Rust","TCP","Network"],"title":"Impl Rust: TCP/IP","uri":"/posts/rust-tcp/"},{"categories":["Rust","Systems"],"content":"TCP [RFC 793] 3.2 Terminology The state diagram in figure 6 illustrates only state changes, together with the causing events and resulting actions, but addresses neither error conditions nor actions which are not connected with state changes. è¿™é‡Œé¢æåˆ°çš„ Figure 6. TCP Connection State Diagram åœ¨å…¶ä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ° TCP çš„çŠ¶æ€è½¬æ¢ï¼Œéå¸¸æœ‰åˆ©äºç›´è§‚ç†è§£ TCP å»ºç«‹è¿æ¥æ—¶çš„ä¸‰æ¬¡æ¡æ‰‹è¿‡ç¨‹ã€‚ è­¦å‘Š NOTE BENE: this diagram is only a summary and must not be taken as the total specification. Time to live [Wikipedia] In the IPv4 header, TTL is the 9th octet of 20. In the IPv6 header, it is the 8th octet of 40. The maximum TTL value is 255, the maximum value of a single octet. A recommended initial value is 64. SND.WL1 and SND.WL2 Note that SND.WND is an offset from SND.UNA, that SND.WL1 records the sequence number of the last segment used to update SND.WND, and that SND.WL2 records the acknowledgment number of the last segment used to update SND.WND. The check here prevents using old segments to update the window. ","date":"2024-02-17","objectID":"/posts/rust-tcp/:1:5","tags":["Rust","TCP","Network"],"title":"Impl Rust: TCP/IP","uri":"/posts/rust-tcp/"},{"categories":["Rust","Systems"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-02-17","objectID":"/posts/rust-tcp/:2:0","tags":["Rust","TCP","Network"],"title":"Impl Rust: TCP/IP","uri":"/posts/rust-tcp/"},{"categories":["Rust","Systems"],"content":"Crate std Module std::io Type Alias std::io::Result Module std::collections::hash_map method std::collections::hash_map::HashMap::entry method std::collections::hash_map::Entry::or_default Trait std::default::Default Module std::net Macro std::eprintln method std::result::Result::expect method u16::from_be_bytes ","date":"2024-02-17","objectID":"/posts/rust-tcp/:2:1","tags":["Rust","TCP","Network"],"title":"Impl Rust: TCP/IP","uri":"/posts/rust-tcp/"},{"categories":["Rust","Systems"],"content":"Crate tun_tap Enum tun_tap::Mode ","date":"2024-02-17","objectID":"/posts/rust-tcp/:2:2","tags":["Rust","TCP","Network"],"title":"Impl Rust: TCP/IP","uri":"/posts/rust-tcp/"},{"categories":["Rust","Systems"],"content":"Crate etherparse Struct etherparse::Ipv4HeaderSlice Struct etherparse::Ipv4Header Struct etherparse::TcpHeaderSlice Struct etherparse::TcpHeader ","date":"2024-02-17","objectID":"/posts/rust-tcp/:2:3","tags":["Rust","TCP","Network"],"title":"Impl Rust: TCP/IP","uri":"/posts/rust-tcp/"},{"categories":["Rust","Systems"],"content":"References https://datatracker.ietf.org/doc/html/rfc793 https://datatracker.ietf.org/doc/html/rfc1122 https://datatracker.ietf.org/doc/html/rfc7414#section-2 https://datatracker.ietf.org/doc/html/rfc2398 https://datatracker.ietf.org/doc/html/rfc2525 https://datatracker.ietf.org/doc/html/rfc791 https://www.saminiir.com/lets-code-tcp-ip-stack-3-tcp-handshake/ https://www.saminiir.com/lets-code-tcp-ip-stack-4-tcp-data-flow-socket-api/ https://www.saminiir.com/lets-code-tcp-ip-stack-5-tcp-retransmission/ æ³¨æ„ RFC 793 æè¿°äº†åŸå§‹çš„ TCP åè®®çš„å†…å®¹ (é‡ç‚¹é˜…è¯» 3.FUNCTIONAL SPECIFICATION ) RFC 1122 åˆ™æ˜¯å¯¹åŸå§‹çš„ TCP åŠŸèƒ½çš„ä¸€äº›æ‰©å±•è¿›è¡Œè¯´æ˜ RFC 7414 çš„ Section 2 åˆ™å¯¹ TCP çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œäº†ç®€è¦æè¿° RFC 2398 æè¿°äº†å¯¹å®ç°çš„ TCP çš„ä¸€äº›æµ‹è¯•æ–¹æ³•å’Œå·¥å…· RFC 2525 è¯´æ˜äº†åœ¨å®ç° TCP è¿‡ç¨‹ä¸­å¯èƒ½ä¼šå‡ºç°çš„é”™è¯¯ï¼Œå¹¶æŒ‡å‡ºå¯èƒ½å¯¼è‡´é”™è¯¯çš„æ½œåœ¨é—®é¢˜ RFC 791 æè¿°äº† IP åè®® çš„å†…å®¹ æœ€å 3 ç¯‡åšå®¢ä»‹ç»äº† TCP åè®®ç›¸å…³æœ¯è¯­å’Œæ¦‚å¿µï¼Œå¯ä»¥æ­é… RFC 793 é˜…è¯» ","date":"2024-02-17","objectID":"/posts/rust-tcp/:3:0","tags":["Rust","TCP","Network"],"title":"Impl Rust: TCP/IP","uri":"/posts/rust-tcp/"},{"categories":["Linux Kernel Internals"],"content":"Source ","date":"2024-02-16","objectID":"/posts/linux-quiz1/:0:0","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: ç¬¬ 1 å‘¨æµ‹éªŒé¢˜ linked list","uri":"/posts/linux-quiz1/"},{"categories":["Linux Kernel Internals"],"content":"2018q1 ç¬¬ 4 é€±æ¸¬é©—é¡Œ ","date":"2024-02-16","objectID":"/posts/linux-quiz1/:1:0","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: ç¬¬ 1 å‘¨æµ‹éªŒé¢˜ linked list","uri":"/posts/linux-quiz1/"},{"categories":["Linux Kernel Internals"],"content":"æµ‹éªŒ 1 FuncA çš„ä½œç”¨æ˜¯ (e) å»ºç«‹æ–°ç¯€é»ï¼Œå…§å®¹æ˜¯ valueï¼Œä¸¦å®‰æ’åœ¨çµå°¾ FuncB çš„ä½œç”¨æ˜¯ (d) å»ºç«‹æ–°ç¯€é»ï¼Œå…§å®¹æ˜¯ valueï¼Œä¸¦å®‰æ’åœ¨é–‹é ­ FuncC çš„ä½œç”¨æ˜¯ (e) æ‰¾åˆ°ç¯€é»å…§å®¹ç‚º value2 çš„ç¯€é»ï¼Œä¸¦åœ¨ä¹‹å¾Œæ’å…¥æ–°ç¯€é»ï¼Œå…§å®¹ç‚º value1 åœ¨ main å‡½æ•°è°ƒç”¨ display å‡½æ•°ä¹‹å‰ï¼Œé“¾è¡¨åˆ†å¸ƒä¸º: 48 -\u003e 51 -\u003e 63 -\u003e 72 -\u003e 86 åœ¨ç¨‹å¼è¼¸å‡ºä¸­ï¼Œè¨Šæ¯ Traversal in forward direction å¾Œä¾åºå°å‡ºå“ªå¹¾å€‹æ•¸å­—å‘¢ï¼Ÿ (d) 48 (c) 51 (a) 63 (e) 72 (b) 86 åœ¨ç¨‹å¼è¼¸å‡ºä¸­ï¼Œè¨Šæ¯ Traversal in reverse direction å¾Œä¾åºå°å‡ºå“ªå¹¾å€‹æ•¸å­—å‘¢ï¼Ÿ (b) 86 (e) 72 (a) 63 (c) 51 (d) 48 æŠ€å·§ å»¶ä¼¸é¡Œç›®ï¼š åœ¨ä¸Šè¿° doubly-linked list å¯¦ä½œæ°£æ³¡æ’åºå’Œåˆä½µæ’åºï¼Œä¸¦æå‡ºéœ€è¦é¡å¤–å¯¦ä½œå“ªäº›å‡½ç¤ºæ‰è¶³ä»¥é”æˆç›®æ¨™ å¼•å…¥çµ±è¨ˆæ¨¡å‹ï¼Œéš¨æ©Ÿæ–°å¢å’Œåˆªé™¤ç¯€é»ï¼Œç„¶å¾Œè©•ä¼°ä¸Šè¿°åˆä½µæ’åºç¨‹å¼çš„æ™‚é–“è¤‡é›œåº¦å’Œæ•ˆèƒ½åˆ†ä½ˆ (éœ€è¦è£½åœ–å’Œæ•¸å­¸åˆ†æ) ","date":"2024-02-16","objectID":"/posts/linux-quiz1/:1:1","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: ç¬¬ 1 å‘¨æµ‹éªŒé¢˜ linked list","uri":"/posts/linux-quiz1/"},{"categories":["Linux Kernel Internals"],"content":"æµ‹éªŒ 2 FuncX çš„ä½œç”¨æ˜¯ (æ¶µè“‹ç¨‹å¼åŸ·è¡Œè¡Œç‚ºçš„æ­£ç¢ºæè¿°æœ€å¤šè€…) (f) åˆ¤æ–·æ˜¯å¦ç‚º circular linked listï¼Œè‹¥ç‚º circular å‰‡å›å‚³ 0ï¼Œå…¶ä»–éé›¶å€¼ï¼Œéç¨‹ä¸­è¨ˆç®—èµ°è¨ªçš„ç¯€é»ç¸½æ•¸ K1 Â» å¾Œé¢æ¥çš„è¼¸å‡ºç‚ºä½• (b) Yes K2 Â» å¾Œé¢æ¥çš„è¼¸å‡ºç‚ºä½• (a) No K3 Â» å¾Œé¢æ¥çš„è¼¸å‡ºç‚ºä½• (a) No K4 Â» å¾Œé¢æ¥çš„è¼¸å‡ºç‚ºä½• (a) No K5 Â» å¾Œé¢æ¥çš„è¼¸å‡ºç‚ºä½• (f) 0 count Â» å¾Œé¢æ¥çš„è¼¸å‡ºç‚ºä½• (f) 0 ","date":"2024-02-16","objectID":"/posts/linux-quiz1/:1:2","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: ç¬¬ 1 å‘¨æµ‹éªŒé¢˜ linked list","uri":"/posts/linux-quiz1/"},{"categories":["Linux Kernel Internals"],"content":"2020q1 ç¬¬ 1 é€±æ¸¬é©—é¡Œ ","date":"2024-02-16","objectID":"/posts/linux-quiz1/:2:0","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: ç¬¬ 1 å‘¨æµ‹éªŒé¢˜ linked list","uri":"/posts/linux-quiz1/"},{"categories":["Linux Kernel Internals"],"content":"æµ‹éªŒ 1 æœ¬é¢˜ä½¿ç”¨çš„æ˜¯å•å‘ linked list typedef struct __list { int data; struct __list *next; } list; ä¸€å¼€å§‹çš„ if è¯­å¥ç”¨äºåˆ¤æ–­ start æ˜¯å¦ä¸º NULL æˆ–æ˜¯å¦åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯åˆ™ç›´æ¥è¿”å›æ— éœ€æ’åº æ¥ä¸‹æ¥ä½¿ç”¨ mergesort æ¥å¯¹ linked list è¿›è¡Œä»å°åˆ°å¤§æ’åºï¼Œå¹¶ä¸”æ¯æ¬¡å·¦ä¾§é“¾è¡¨åªåˆ’åˆ†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå‰©ä½™èŠ‚ç‚¹å…¨éƒ¨åˆ’ä¸ºå³ä¾§é“¾è¡¨ list *left = start; list *right = left-\u003enext; left-\u003enext = NULL; // LL0; å†æ¥å°±æ˜¯å½’å¹¶æ“ä½œï¼Œå°† left å’Œ right è¿›è¡Œå½’å¹¶ï¼Œå¦‚æœ merge ä¸º NULLï¼Œåˆ™å°†å¯¹åº”çš„èŠ‚ç‚¹èµ‹å€¼ç»™å®ƒå’Œ startï¼Œå¦åˆ™éœ€è¦è¿­ä»£ left æˆ– right ä»¥åŠ merge ä»¥å®Œæˆå½’å¹¶æ“ä½œ for (list *merge = NULL; left || right; ) { if (!right || (left \u0026\u0026 left-\u003edata \u003c right-\u003edata)) { if (!merge) { start = merge = left; // LL1; } else { merge-\u003enext = left; // LL2; merge = merge-\u003enext; } left = left-\u003enext; // LL3; } else { if (!merge) { start = merge = right; // LL4; } else { merge-\u003enext = right; // LL5; merge = merge-\u003enext; } right = right-\u003enext; // LL6; } } æŠ€å·§ å»¶ä¼¸å•é¡Œ: è§£é‡‹ä¸Šè¿°ç¨‹å¼é‹ä½œåŸç†; æŒ‡å‡ºç¨‹å¼æ”¹é€²ç©ºé–“ï¼Œç‰¹åˆ¥æ˜¯è€ƒæ…®åˆ° Optimizing merge sort; å°‡ä¸Šè¿° singly-linked list æ“´å……ç‚º circular doubly-linked list ä¸¦é‡æ–°å¯¦ä½œå°æ‡‰çš„ sort; ä¾å¾ª Linux æ ¸å¿ƒ include/linux/list.h ç¨‹å¼ç¢¼çš„æ–¹å¼ï¼Œæ”¹å¯«ä¸Šè¿°æ’åºç¨‹å¼; å˜—è©¦å°‡åŸæœ¬éè¿´çš„ç¨‹å¼æ”¹å¯«ç‚º iterative ç‰ˆæœ¬; ","date":"2024-02-16","objectID":"/posts/linux-quiz1/:2:1","tags":["Sysprog","Linux","C"],"title":"Linux æ ¸å¿ƒè®¾è®¡: ç¬¬ 1 å‘¨æµ‹éªŒé¢˜ linked list","uri":"/posts/linux-quiz1/"},{"categories":["Linux","Linux Kernel Internals"],"content":" é¢å°åŸå§‹ç¨‹å¼ç¢¼è¶…è¶Š 3 åƒè¬è¡Œè¦æ¨¡çš„ Linux æ ¸å¿ƒ (2023 å¹´)ï¼Œæœ€ä»¤äººæ„Ÿåˆ°æŒ«æŠ˜çš„ï¼Œçµ•éç¼ºä¹ç¨‹å¼è¨»è§£ï¼Œè€Œæ˜¯å°±ç®—è¦‹åˆ°æ»¿æ»¿çš„è¨»è§£ï¼Œè‡ªå·±å»æœ‰å¦‚æ–‡ç›²ï¼Œå…¨ç„¶ç„¡å¾ç†è§£èµ·ã€‚ç‚ºä»€éº¼å‘¢ï¼Ÿå¾€å¾€æ˜¯å› ç‚ºå°ä½œæ¥­ç³»çµ±çš„èªçŸ¥å¤ªä¾·é™ã€‚ åŸæ–‡åœ°å€ ","date":"2024-02-15","objectID":"/posts/linux-concepts/:0:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ","uri":"/posts/linux-concepts/"},{"categories":["Linux","Linux Kernel Internals"],"content":"Linux æ ¸å¿ƒå‘å±• è™šæ‹ŸåŒ– (Virtualization) æŠ€æœ¯åˆ†ä¸º CPU å±‚çº§çš„è™šæ‹ŸåŒ–æŠ€æœ¯ï¼Œä¾‹å¦‚ KVM å’Œ RVMï¼Œä¹Ÿæœ‰æ“ä½œç³»ç»Ÿå±‚çº§çš„è™šæ‹ŸåŒ–æŠ€æœ¯ï¼Œä¾‹å¦‚ Dockerã€‚ Plan 9 from Bell Labs [Wikipedia] LXC [Wikipedia] ä¿¡æ¯ å¾ Revolution OS çœ‹ä½œæ¥­ç³»çµ±ç”Ÿæ…‹è®ŠåŒ– Linux æ ¸å¿ƒè¨­è¨ˆ: é€é eBPF è§€å¯Ÿä½œæ¥­ç³»çµ±è¡Œç‚º ","date":"2024-02-15","objectID":"/posts/linux-concepts/:1:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ","uri":"/posts/linux-concepts/"},{"categories":["Linux","Linux Kernel Internals"],"content":"çœ‹æ¼«ç”»å­¦ Linux åŸæ–‡åœ°å€ inside the linux kernel æ•´ç†ä¸Šå›¾ï¼Œå¯ä»¥å¾—åˆ° è‡ªåº•å‘ä¸Š çš„ Linux ç³»ç»Ÿç»“æ„: åœ°ä¸‹å±‚: æ–‡ä»¶ç³»ç»Ÿ (File System) ä¸­å¤®å¤§å…å±‚: è¿›ç¨‹è¡¨ (process table) å†…å­˜ç®¡ç† (memory management) ä¿¡æ¯å®‰å…¨ (security) çœ‹é—¨ç‹— (watchdog) httpd cron ç®¡é“ (pipe) FTP SSH Wine GNOME æœ€ä¸Šå±‚ tty / terminal wiki: Pipeline (Unix) [Wikipedia] Process identifier [Wikipedia] watchdog [Linux man page] init [Wikipedia] systemd [Wikipedia] fork [Linux man page] clone [Linux man page] Project Genie [Wikipedia] posix_spawn [Linux man page] Native POSIX Thread Library [Wikipedia] æå®¢æ¼«ç”»: ä¸è¦ä½¿ç”¨ SIGKILL çš„åŸå›  wait [Linux man page] signal [Linux man page] TUX web server [Wikipedia] -[x] cron æŠ€å·§ Multics é‡‡ç”¨äº†å½“æ—¶èƒŒæ™¯ä¸‹çš„å‡ ä¹æ‰€æœ‰çš„å…ˆè¿›æŠ€æœ¯ï¼Œå¯ä»¥å‚è€ƒè¯¥ç³»ç»Ÿè·å–ç³»ç»Ÿé¢†åŸŸçš„çµæ„Ÿã€‚ è™šæ‹Ÿå†…å­˜ç®¡ç†ä¸ç°ä»£é“¶è¡Œçš„è¿è¡Œé€»è¾‘ç±»ä¼¼ï¼Œé€šè¿‡ malloc åˆ†é…çš„æœ‰æ•ˆè™šæ‹Ÿåœ°å€å¹¶ä¸èƒ½ä¿è¯çœŸæ­£å¯ç”¨ï¼Œç±»ä¼¼äºæ”¯ç¥¨å¾—å»é“¶è¡Œå…‘ç°æ—¶æ‰çŸ¥é“é“¶è¡ŒçœŸæ­£çš„ç°é‡‘å‚¨å¤‡ã€‚ä½†æ˜¯æ ¹æ®ç»Ÿè®¡å­¦å…¬å¼ï¼Œè™šæ‹Ÿåœ°å€å’Œé“¶è¡Œç°é‡‘å¯ä»¥ä¿è¯åœ¨å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œéƒ½å¯ä»¥æ»¡è¶³éœ€æ±‚ï¼Œå½“ç„¶çªå‘çš„å¤§è§„æ¨¡è™šæ‹Ÿå†…å­˜ä½¿ç”¨ã€ç°é‡‘å…‘ç°æ—¶å°±æ— æ³•ä¿è¯äº†ã€‚è¿™éƒ¨åˆ†çš„åŸç†æ¨å¯¼éœ€è¦å­¦ä¹ æ¦‚ç‡è®ºã€ç»Ÿè®¡å­¦ç­‰æ•°ç†è¯¾ç¨‹ã€‚ ä¿¡æ¯ Linux æ ¸å¿ƒè®¾è®¡: Linux æ ¸å¿ƒè¨­è¨ˆ: æª”æ¡ˆç³»çµ±æ¦‚å¿µåŠå¯¦ä½œæ‰‹æ³• Linux æ ¸å¿ƒè¨­è¨ˆ: ä¸åƒ…æ˜¯å€‹åŸ·è¡Œå–®å…ƒçš„ Process Linux æ ¸å¿ƒè¨­è¨ˆ: ä¸åªæŒ‘é¸ä»»å‹™çš„æ’ç¨‹å™¨ UNIX ä½œæ¥­ç³»çµ± fork/exec ç³»çµ±å‘¼å«çš„å‰ä¸–ä»Šç”Ÿ Linux æ ¸å¿ƒè¨­è¨ˆ: è¨˜æ†¶é«”ç®¡ç† Linux æ ¸å¿ƒè¨­è¨ˆ: ç™¼å±•å‹•æ…‹å›é¡§ Linux æ ¸å¿ƒè¨­è¨ˆ: é‡å°äº‹ä»¶é©…å‹•çš„ I/O æ¨¡å‹æ¼”åŒ– Linux æ ¸å¿ƒè¨­è¨ˆ: Scalability è­°é¡Œ Effective System Call Aggregation (ESCA) ä½ æ‰€ä¸çŸ¥é“çš„ C èªè¨€: Stream I/O, EOF å’Œä¾‹å¤–è™•ç† Unix-like å·¥å…·ä½¿ç”¨æŠ€å·§: Mastering UNIX pipes, Part 1 Mastering UNIX pipes, Part 2 ","date":"2024-02-15","objectID":"/posts/linux-concepts/:2:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ","uri":"/posts/linux-concepts/"},{"categories":["Linux","Linux Kernel Internals"],"content":"é«˜é˜¶è§‚ç‚¹ æŠ•å½±ç‰‡: Linux Kernel: Introduction âœ… å¯¹æŠ•å½±ç‰‡çš„ é‡ç‚¹æè¿° ä¸€äº›æ¦‚å¿µç†è§£: 1963 Timesharing: A Solution to Computer Bottlenecks [YouTube] Supervisory program [Wikipedia] ","date":"2024-02-15","objectID":"/posts/linux-concepts/:3:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ","uri":"/posts/linux-concepts/"},{"categories":["Linux","Linux Kernel Internals"],"content":"Monolithic kernel vs Microkernel æ·ºè«‡ Microkernel è¨­è¨ˆå’ŒçœŸå¯¦ä¸–ç•Œä¸­çš„æ‡‰ç”¨ Hybrid kernel [wikipedia] â€œAs to the whole â€˜hybrid kernelâ€™ thing - itâ€™s just marketing. Itâ€™s â€˜oh, those microkernels had good PR, how can we try to get good PR for our working kernel? Oh, I know, letâ€™s use a cool name and try to imply that it has all the PR advantages that that other system hasâ€™.â€ â€”â€” Linus Torvalds ","date":"2024-02-15","objectID":"/posts/linux-concepts/:3:1","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ","uri":"/posts/linux-concepts/"},{"categories":["Linux","Linux Kernel Internals"],"content":"è™šæ‹ŸåŒ– MicroVM å’Œ Unikernel éƒ½æ˜¯ä½¿ç”¨ CPU å±‚çº§çš„è™šæ‹ŸåŒ–æŠ€æœ¯ï¼Œåœ¨ Host OS ä¸Šé¢æ„å»ºçš„ GuestOS: MicroVM ä¼šå‡å°‘ç¡¬ä»¶é©±åŠ¨æ–¹é¢çš„åˆå§‹åŒ–ï¼Œä»è€ŒåŠ å¿«å¯åŠ¨å’ŒæœåŠ¡é€Ÿåº¦ (åœ¨äº‘æœåŠ¡å™¨æ–¹é¢å¾ˆå¸¸è§ï¼ŒæœåŠ¡å™¨ç«¯å¹¶ä¸éœ€è¦è¿›è¡Œç¡¬ä»¶é©±åŠ¨)ã€‚ Unikernel åˆ™æ›´æ¿€è¿›ï¼Œå°† programs å’Œ kernel ä¸€èµ·è¿›è¡ŒåŠ¨æ€ç¼–è¯‘ï¼Œå¹¶ä¸”é™åˆ¶åªèƒ½è¿è¡Œä¸€ä¸ª process (ä¾‹å¦‚åªè¿è¡Œä¸€ä¸ªæ•°æ®åº“è¿›ç¨‹ï¼Œè¿™æ ·äº‘æœåŠ¡å™¨å¾ˆå¸¸è§)ï¼Œè¿™æ ·å°±å‡å°‘äº†ä¸€äº›ç³»ç»Ÿè°ƒç”¨çš„å‘¼å«ï¼Œä¾‹å¦‚ fork (å› ä¸ºåªèƒ½è¿è¡Œä¸€ä¸ª process)ï¼Œæå‡äº†å®‰å…¨æ€§ (å› ä¸º fork ç³»ç»Ÿè°ƒç”¨å¯èƒ½ä¼šé€ æˆä¸€äº›æ¼æ´)ã€‚Unikernel åˆå« Library OSï¼Œå¯ä»¥ç†è§£ä¸ºåˆ†æ—¶å¤šäººå¤šå·¥æ“ä½œç³»ç»Ÿçš„å¦ä¸€ä¸ªå¯¹ç«‹é¢ï¼Œæ‹¥æœ‰æé«˜çš„è¿è¡Œé€Ÿåº¦ (å› ä¸ºåªæœ‰ä¸€ä¸ª process)ã€‚ Container Sandbox ä½¿ç”¨çš„æ˜¯ OS å±‚çº§çš„è™šæ‹ŸåŒ–æŠ€æœ¯ï¼Œå³å®ƒæ˜¯å°†ä¸€ç»„è¿›ç¨‹éš”ç¦»èµ·æ¥æ„å»ºä¸ºå®¹å™¨ï¼Œè¿™æ ·å¯èƒ½ä¼šå¯¼è‡´è¿™ä¸€ç»„è¿›ç¨‹å°±è€—å°½äº†ç³»ç»Ÿçš„èµ„æºï¼Œå…¶ä»–è¿›ç¨‹æ— æ³•ä½¿ç”¨ç³»ç»Ÿçš„èµ„æºã€‚åŒæ—¶å› ä¸ºæ˜¯è¿›ç¨‹çº§çš„éš”ç¦»ï¼Œæ‰€ä»¥å®‰å…¨æ€§ä¸åŠ CPU å±‚çº§çš„ MicroVM å’Œ Unikernelã€‚ ä¿¡æ¯ ç›¸å…³æ¼”è®²ã€å½•å½±: YouTube: Inside the Mac OS X Kernel YouTube: What Are MicroVMs? And Why Should I Care? YouTube: From the Ground Up: How We Built the Nanos Unikernel ç›¸å…³è®ºæ–‡é˜…è¯»: ","date":"2024-02-15","objectID":"/posts/linux-concepts/:3:2","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ","uri":"/posts/linux-concepts/"},{"categories":["Linux","Linux Kernel Internals"],"content":"Scalability Wikipedia: scalability A system whose performance improves after adding hardware, proportionally to the capacity added, is said to be a scalable system. lock-free sequence lock RCU algorithm complexity ","date":"2024-02-15","objectID":"/posts/linux-concepts/:3:3","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ","uri":"/posts/linux-concepts/"},{"categories":["Linux","Linux Kernel Internals"],"content":"eBPF é€è¿‡ eBPF å¯å°† Monolithic kernel çš„ Linux å–å¾— microkernel çš„ç‰¹æ€§ The Beginners Guide to eBPF Programming, Liza RIce (live programming + source code) A thorough introduction to eBPF (four articles in lwn.net), Matt FLeming, December 2017 ","date":"2024-02-15","objectID":"/posts/linux-concepts/:3:4","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ","uri":"/posts/linux-concepts/"},{"categories":["Linux","Linux Kernel Internals"],"content":"ç»†èŠ‚åˆ‡å…¥ç‚¹ CPU å’Œ OS çš„åŸºæœ¬æ¦‚å¿µç§‘æ™®ç½‘ç«™: Putting the â€œYouâ€ in CPU ç›¸å½“äºç§‘æ™®ç‰ˆ CSAPP ä¿¡æ¯ UNSW COMP9242: Advanced Operating Systems (2023/T3) YouTube: 2022: UNSWâ€™s COMP9242 Advanced Operating Systems è¿™é—¨è¯¾å¯ä»¥ä½œä¸ºè¾…åŠ©ææ–™ï¼Œè®²å¾—æ·±å…¥æµ…å‡ºï¼Œå¯ä»¥ä½œä¸ºè¿›é˜¶ææ–™é˜…è¯»ã€‚ ","date":"2024-02-15","objectID":"/posts/linux-concepts/:4:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ","uri":"/posts/linux-concepts/"},{"categories":["Linux","Linux Kernel Internals"],"content":"ç³»ç»Ÿè½¯ä»¶å¼€å‘æ€ç»´ ","date":"2024-02-15","objectID":"/posts/linux-concepts/:5:0","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ","uri":"/posts/linux-concepts/"},{"categories":["Linux","Linux Kernel Internals"],"content":"Maslowâ€™s pyramid of code review Maslowâ€™s pyramid of code review ","date":"2024-02-15","objectID":"/posts/linux-concepts/:5:1","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ","uri":"/posts/linux-concepts/"},{"categories":["Linux","Linux Kernel Internals"],"content":"Benchmark / Profiling Benchmark / Profiling ","date":"2024-02-15","objectID":"/posts/linux-concepts/:5:2","tags":["Sysprog","Linux"],"title":"Linux æ ¸å¿ƒè®¾è®¡: æ“ä½œç³»ç»Ÿæœ¯è¯­åŠæ¦‚å¿µ","uri":"/posts/linux-concepts/"},{"categories":["Rust"],"content":" In this third Crust of Rust video, we cover iterators and trait bounds, by re-implementing the â€œflattenâ€ Iterator method from the standard library. As part of that, we cover some of the weirder trait bounds that are required, including whatâ€™s needed to extend the implementation to support backwards iteration. æ•´ç†è‡ª John Gjengset çš„å½±ç‰‡ ","date":"2024-02-05","objectID":"/posts/iterators/:0:0","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"å½±ç‰‡æ³¨è§£ ","date":"2024-02-05","objectID":"/posts/iterators/:1:0","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"Generic traits vs associated types trait Iterator { type Item; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e; } trait Iterator\u003cItem\u003e { fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e; } ä¸ºä»€ä¹ˆä½¿ç”¨ä¸Šé¢çš„ associated type è€Œä¸æ˜¯ä¸‹é¢çš„ generic æ¥å®ç° Iteratorï¼Ÿå› ä¸ºä½¿ç”¨ generic æ¥å®ç°çš„è¯ï¼Œå¯ä»¥å¯¹ä¸€ä¸ªç±»å‹å®ç°å¤šä¸ª Iterator trait ä¾‹å¦‚ Iterator\u003ci32\u003e, Iterator\u003cf64ï¼Œè€Œä»è¯­è¨€è¡¨è¾¾ä¸Šè®²ï¼Œæˆ‘ä»¬å¸Œæœ›ä¸€ä¸ªç±»å‹åªèƒ½å®ç°ä¸€ä¸ª Iterator traitï¼Œæ‰€ä»¥ä½¿ç”¨ associated type æ¥å®ç° Iterator traitï¼Œé˜²æ­¢äºŒä¹‰æ€§ã€‚ for v in vs.iter() { // borrow vs, \u0026 to v } for v in \u0026vs { // equivalent to vs.iter() } è¿™ä¸¤æ¡ for è¯­å¥è™½ç„¶æ•ˆæœä¸€æ ·ï¼Œä½†æ˜¯åè€…æ˜¯ä½¿ç”¨ \u003c\u0026vs\u003e into_iter è®² \u0026vs è½¬ä¸º iteratorï¼Œè€Œä¸æ˜¯è°ƒç”¨ iter() æ–¹æ³•ã€‚ ","date":"2024-02-05","objectID":"/posts/iterators/:1:1","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"Iterator::flatten method std::iter::Iterator::flatten Creates an iterator that flattens nested structure. This is useful when you have an iterator of iterators or an iterator of things that can be turned into iterators and you want to remove one level of indirection. flatten() çš„æœ¬è´¨æ˜¯å°†ä¸€ç§ Iterator ç±»å‹è½¬æ¢æˆå¦ä¸€ç§ Iterator ç±»å‹ï¼Œæ‰€ä»¥è°ƒç”¨è€…å’Œè¿”å›å€¼ Flatten éƒ½æ»¡è¶³ trait Iteratorï¼Œå› ä¸ºéƒ½æ˜¯è¿­ä»£å™¨ï¼Œåªæ˜¯å°†åŸå…ˆçš„ n-level å‹æ‰ä¸º 1-level çš„ Iterator äº†ã€‚å½•å½±è§†é¢‘é‡Œåªè€ƒè™‘ 2-level çš„æƒ…å†µã€‚ ","date":"2024-02-05","objectID":"/posts/iterators/:1:2","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"DoubleEndedIterator Trait std::iter::DoubleEndedIterator It is important to note that both back and forth work on the same range, and do not cross: iteration is over when they meet in the middle. ä¹Ÿå°±æ˜¯è¯´ï¼Œback å’Œ front çš„è¿­ä»£å™¨ç±»ä¼¼äºåŒæŒ‡é’ˆï¼Œä½†æ˜¯è¿™ä¸¤ä¸ªè¿­ä»£å™¨å¹¶ä¸ä¼šè¶Šè¿‡å¯¹æ–¹ã€‚ ","date":"2024-02-05","objectID":"/posts/iterators/:1:3","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"Homework ä¿¡æ¯ å®ä½œè¯´æ˜: å°è¯•å®ç° Iterator çš„ flat_map æ–¹æ³• (Github: My Implementation) å‚è€ƒèµ„æ–™: method std::iter::Iterator::flat_map struct std::iter::FlatMap ","date":"2024-02-05","objectID":"/posts/iterators/:2:0","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-02-05","objectID":"/posts/iterators/:3:0","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"Crate std å¯ä»¥ä½¿ç”¨è¿™é‡Œæä¾›çš„æœç´ æ è¿›è¡Œæœç´¢ (BTW ä¸è¦æµªè´¹æ—¶é—´åœ¨ Google æœå¯»ä¸Šï¼) Trait std::iter::Iterator method std::iter::Iterator::flatten method std::iter::Iterator::rev method std::iter::Iterator::flat_map Trait std::iter::IntoIterator Struct std::iter::Flatten function std::iter::empty Struct std::iter::Empty function std::iter::once Struct std::iter::Once Trait std::iter::DoubleEndedIterator Enum std::option::Option method std::option::Option::and_then method std::option::Option::as_mut Trait std::marker::Sized ","date":"2024-02-05","objectID":"/posts/iterators/:3:1","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["Rust"],"content":"References What is the difference between iter and into_iter? [Stack Overflow] How to run a specific unit test in Rust? [Stack Overflow] How do I implement a trait with a generic method? [Stack Overflow] å¯èƒ½ä¸æ˜¯ä½ çœ‹è¿‡æœ€æ— èŠçš„ Rust å…¥é—¨å–œå‰§ 102 (1) é—­åŒ…ä¸è¿­ä»£å™¨ [bilibili] ","date":"2024-02-05","objectID":"/posts/iterators/:4:0","tags":["Rust","Iterator"],"title":"Crust of Rust: Iterators","uri":"/posts/iterators/"},{"categories":["C","Linux Kernel Internals"],"content":" æ— è®ºæ˜¯æ“ä½œç³»ç»Ÿæ ¸å¿ƒã€C è¯­è¨€å‡½æ•°åº“å†…éƒ¨ã€ç¨‹åºå¼€å‘æ¡†æ¶ï¼Œåˆ°åº”ç”¨ç¨‹åºï¼Œéƒ½ä¸éš¾è§åˆ° linked list çš„èº«å½±ï¼ŒåŒ…å«å¤šç§é’ˆå¯¹æ€§èƒ½å’Œå®‰å…¨è®®é¢˜æ‰€åšçš„ linked list å˜å½¢ï¼Œåˆè¿˜è¦è€ƒè™‘åº”ç”¨ç¨‹åºçš„æ³›ç”¨æ€§ (generic programming)ï¼Œæ˜¯å¾ˆå¥½çš„è¿›é˜¶é¢˜æã€‚ åŸæ–‡åœ°å€ ","date":"2024-02-03","objectID":"/posts/c-linked-list/:0:0","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["C","Linux Kernel Internals"],"content":"Linux æ ¸å¿ƒçš„è‰ºæœ¯ YouTube: The mind behind Linux | Linus Torvalds | TED äº‹å®ä¸Š special case å’Œ indirect pointer è¿™ä¸¤ç§å†™æ³•åœ¨ clang çš„æœ€ä½³ä¼˜åŒ–ä¸‹æ•ˆèƒ½å¹¶æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ä½¿ç”¨ indirect pointer æ¥å†™ç¨‹åºï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦å­¦ä¹  indirect pointer è¿™ç§æ€ç»´æ–¹å¼ï¼Œå³ good tasteã€‚ æŠŠæ¡ç¨‹åºçš„æœ¬è´¨ï¼Œå³æœ¬è´¨ä¸Šæ˜¯ä¿®æ”¹æŒ‡é’ˆçš„å€¼ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨æŒ‡é’ˆçš„æŒ‡é’ˆæ¥å®ç°ï¼Œæ— éœ€è¿›è¡Œç‰¹åˆ¤ã€‚ åœ¨ Unix-like çš„æ“ä½œç³»ç»Ÿä¸­ï¼Œç±»å‹åå¸¦æœ‰åç¼€ _t è¡¨ç¤ºè¿™ä¸ªç±»å‹æ˜¯ç”± typedef å®šä¹‰çš„ï¼Œè€Œä¸æ˜¯è¯­è¨€åŸç”Ÿçš„ç±»å‹åï¼Œe.g. typedef struct list_entry { int value; struct list_entry *next; } list_entry_t; ","date":"2024-02-03","objectID":"/posts/c-linked-list/:1:0","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["C","Linux Kernel Internals"],"content":"linked list append \u0026 remove Source ä¿¡æ¯ The mind behind Linux Linus on Understanding Pointers ","date":"2024-02-03","objectID":"/posts/c-linked-list/:1:1","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["C","Linux Kernel Internals"],"content":"LeetCode Source LeetCode 21. Merge Two Sorted Lists LeetCode 23. Merge k Sorted Lists Leetcode 2095. Delete the Middle Node of a Linked List LeetCode 86. Partition List æ³¨æ„ åŸæ–‡å¯¹äº LeetCode 23. Merge k Sorted Lists ç»™å‡ºäº† 3 ç§è§£æ³•ï¼Œå…¶æ—¶é—´å¤æ‚åº¦åˆ†åˆ«ä¸ºï¼š $O(m \\cdot n)$ $O(m \\cdot n)$ $O(m \\cdot logn)$ $n$ ä¸º listsSizeï¼Œ$m$ ä¸º merge linked list è¿‡ç¨‹ä¸­äº§ç”Ÿçš„ linked list çš„æœ€å¤§é•¿åº¦ã€‚ å¦‚æœä½ å¯¹ç¬¬ 3 ç§è§£æ³•çš„æ—¶é—´å¤æ‚åº¦æ„Ÿåˆ°ç–‘æƒ‘ï¼Œè¯·å‚è€ƒ Josh Hug åœ¨ CS61B çš„ Merge Sort å¤æ‚åº¦è®²è§£ã€‚ ","date":"2024-02-03","objectID":"/posts/c-linked-list/:1:2","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["C","Linux Kernel Internals"],"content":"Circular linked list å•å‘ linked list ç›¸å¯¹äºåŒå‘ linked list çš„ä¼˜åŠ¿åœ¨äºï¼Œä¸€ä¸ª cache line å¯ä»¥å®¹çº³æ›´å¤šçš„ list nodeï¼Œè€Œä¸”å¾ˆå®¹æ˜“è¿›è¡Œåå‘æŸ¥è¯¢ï¼Œè¿™å¼¥è¡¥äº†åå‘æŸ¥è¯¢æ—¶çš„æ•ˆèƒ½å·®è·ã€‚ä¾‹å¦‚åœ¨ 64 ä½å¤„ç†å™¨ä¸Šï¼Œåœ°å€ä¸º 64 Bit å³ 8 Byteï¼Œå¦‚æœ list node çš„æ•°æ®åŸŸå­˜æ”¾ä¸€ä¸ª 2 Byte çš„æ•´æ•°ï¼Œé‚£ä¹ˆä¸€ä¸ªå•å‘çš„ list node å¤§å°ä¸º 10 Byteï¼ŒåŒå‘çš„åˆ™ä¸º 18 Byteï¼Œåˆå› ä¸ºä¸€èˆ¬çš„ cache line çš„å¤§å°ä¸º 64 Byteï¼Œåˆ™å¯¹äºå•å‘çš„ node æ¥è¯´ï¼Œcache line å¯ä»¥å­˜æ”¾ $64 / 10 = 6$ ä¸ª list nodeï¼Œä½†æ˜¯ä»…èƒ½å­˜æ”¾ $64 / 18 = 3$ ä¸ª list nodeï¼Œcache æ•ˆç‡æ˜æ˜¾é™ä½ã€‚ è¿™éƒ¨åˆ†å†…å®¹å¯ä»¥å‚è€ƒ jserv çš„è®²åº§ \u003cç¾ä»£è™•ç†å™¨è¨­è¨ˆ: Cache åŸç†å’Œå¯¦éš›å½±éŸ¿\u003e ","date":"2024-02-03","objectID":"/posts/c-linked-list/:2:0","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["C","Linux Kernel Internals"],"content":"Floydâ€™s Cycle detection è¿™ä¸ªâ€œé¾Ÿå…”èµ›è·‘â€ç®—æ³•ä¿è¯å…”å­åœ¨è·‘ä¸¤æ¬¡å¾ªç¯åœˆåï¼Œä¸€å®šä¼šå’Œåˆšå®Œæˆä¸€æ¬¡å¾ªç¯åœˆçš„ä¹Œé¾Ÿç›¸é‡ã€‚å› ä¸ºå·²çŸ¥ä¹Œé¾Ÿæ¯æ¬¡ç§»åŠ¨ä¸€æ­¥ï¼Œå…”å­æ¯æ¬¡ç§»åŠ¨ä¸¤æ­¥ï¼Œå¯ä»¥å‡è®¾åœ¨ç›¸é‡ç‚¹å¤„ä¹Œé¾Ÿç§»åŠ¨çš„ $X$ æ­¥ï¼Œåˆ™å…”å­ç§»åŠ¨äº† $2X$ æ­¥ï¼Œ$2X$ å¿…ä¸ºå¶æ•°ï¼Œæ‰€ä»¥å…”å­å¿…èƒ½åœ¨ç§»åŠ¨äº† $2X$ æ­¥åä¸ä¹Œé¾Ÿç›¸é‡ï¼Œä¸ä¼šå‡ºç°å…”å­å› ä¸ºæ¯æ¬¡ç§»åŠ¨ä¸¤æ­¥è€Œåˆšå¥½è¶Šè¿‡ä¹Œé¾Ÿä¸€æ­¥çš„æƒ…å†µã€‚ $\\lambda$ is the length of the loop to be found, $\\mu$ is the index of the first element of the cycle. Source LeetCode 141. Linked List Cycle LeetCode 142. Linked List Cycle II LeetCode 146. LRU Cache é‡‘åˆ€çš„ç®—æ³•å°å†Œå­ Linked List ä¸“é¢˜ LeetCode 206. Reverse Linked List ä¿¡æ¯ æ¢ç´¢ Floyd Cycle Detection Algorithm ","date":"2024-02-03","objectID":"/posts/c-linked-list/:2:1","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["C","Linux Kernel Internals"],"content":"Merge Sort å®ç°äº† recursion, non-recursion çš„ merge sort Source æŠ€å·§ Merge Sort ä¸å®ƒçš„å˜åŒ– ä¸è®ºæ˜¯è¿™é‡Œçš„ non-recursion ç‰ˆæœ¬çš„ merge sortï¼Œè¿˜æ˜¯åé¢çš„ non-recursion ç‰ˆæœ¬çš„ quick sortï¼Œæœ¬è´¨ä¸Šéƒ½æ˜¯é€šè¿‡æ¨¡æ‹Ÿæ ˆ (stack) æ“ä½œæ¥å®ç°çš„ï¼Œå…³äºè¿™ä¸ªæ¨¡æ‹Ÿ stack æ–¹æ³•ï¼Œå¯ä»¥å‚è€ƒè’‹ç‚å²©è€å¸ˆçš„å½•å½± åº”ç”¨è§†è§’çš„æ“ä½œç³»ç»Ÿ (ç¨‹åºçš„çŠ¶æ€æœºæ¨¡å‹ï¼›ç¼–è¯‘ä¼˜åŒ–)ã€‚ ","date":"2024-02-03","objectID":"/posts/c-linked-list/:3:0","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["C","Linux Kernel Internals"],"content":"Linux æ ¸å¿ƒçš„ linked list Linux æ ¸å¿ƒä½¿ç”¨çš„ linked list æ˜¯é€šè¿‡ Intrusive linked lists æ­é… contain_of å®ï¼Œæ¥å®ç°è‡ªå®šä¹‰çš„ linked list nodeã€‚ sysprog21/linux-list è¿™ä¸ªä»“åº“å°† Linux kernel ä¸­ linked list éƒ¨åˆ†æŠ½ç¦»å‡ºæ¥ï¼Œå¹¶æ”¹å†™ä¸º user mode çš„å®ä½œã€‚æœ¬äººå¯¹è¯¥ä»“åº“è¿›è¡Œäº†ä¸€äº›æ”¹å†™ï¼Œå¯¹ insert sort å’Œ quick sort å¢åŠ äº† makefile æ”¯æŒã€‚ ä¸Šé¢çš„ä»“åº“ä¸ Linux kernel çš„å®ä½œå·®å¼‚ä¸»è¦åœ¨äº WRITE_ONCE å®ã€‚WRITE_ONCE çš„åŸç†ç®€å•æ¥è¯´æ˜¯ï¼Œé€šè¿‡ union äº§ç”Ÿä¸¤ä¸ªå¼•ç”¨åŒä¸€åœ°å€çš„å¼•ç”¨ (å³ __val å’Œ __c)ï¼Œç„¶åå› ä¸ºå¯¹åŒä¸€åœ°å€æœ‰å¤šä¸ªå¼•ç”¨ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨è¿›è¡Œæœ€ä½³åŒ–æ—¶ä¸ä¼šè¿‡äºæ¿€è¿›çš„é‡æ’åºï¼Œä»è€Œè¾¾åˆ°é¡ºåºæ‰§è¡Œæ•ˆæœã€‚ Source ","date":"2024-02-03","objectID":"/posts/c-linked-list/:4:0","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["C","Linux Kernel Internals"],"content":"Intrusive linked lists Intrusive linked lists è¿™ç¯‡æ–‡ç« å¯¹äº Intrusive linked list è¯´æ˜çš„éå¸¸å¥½ï¼Œè§£é‡Šäº†å…¶åœ¨ memory allocations å’Œ cache thrashing çš„ä¼˜åŠ¿ï¼Œè¿˜æ­é… Linux kernel è®²è§£äº†åœºæ™¯åº”ç”¨ã€‚ ","date":"2024-02-03","objectID":"/posts/c-linked-list/:4:1","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["C","Linux Kernel Internals"],"content":"container_of æˆåŠŸ container_of å·¨é›†åœ¨ Linux æ ¸å¿ƒåŸå§‹ç¨‹å¼ç¢¼å‡ºç¾å°‡è¿‘ 7 åƒæ¬¡ (v5.13)ï¼Œä¸åƒ…åœ¨ linked list å’Œ hash table ä¸€é¡é€šç”¨è³‡æ–™çµæ§‹ä¸­å¯ç°¡åŒ–ç¨‹å¼è¨­è¨ˆï¼Œç”šè‡³æ˜¯ Linux æ ¸å¿ƒé”æˆç‰©ä»¶å°å‘ç¨‹å¼è¨­è¨ˆçš„é—œéµæ©Ÿåˆ¶ä¹‹ä¸€ã€‚ è‹¥è¦å¾æœ Linux æ ¸å¿ƒåŸå§‹ç¨‹å¼ç¢¼ï¼Œå° container_of å·¨é›†çš„æŒæ¡åº¦çµ•å°è¦å……åˆ†ã€‚ Linux æ ¸å¿ƒåŸå§‹ç¨‹å¼ç¢¼å·¨é›†: container_of è·Ÿä½ æƒ³è±¡ä¸åŒçš„ struct struct data { short a; char b; double c; }; å¯¹äºä¸Šé¢çš„ç»“æ„ä½“ï¼Œä¸‹é¢çš„å†…å­˜åˆ†å¸ƒå›¾ç¤ºæ˜¯é”™è¯¯çš„: åŸå› æ˜¯è¿™æ ·çš„å†…å­˜åˆ†å¸ƒå¿½ç•¥äº†ç¼–è¯‘å™¨ä¸ºäº†æ»¡è¶³ alignment éœ€æ±‚ï¼Œè¿›è¡Œçš„ structure padding 6.37.1 Common Type Attributes - packed This attribute, attached to a struct, union, or C++ class type definition, specifies that each of its members (other than zero-width bit-fields) is placed to minimize the memory required. This is equivalent to specifying the packed attribute on each of the members. åŠ ä¸Š packed å±æ€§åç»“æ„ä½“æˆå‘˜çš„å†…å­˜åˆ†å¸ƒå°±å’Œä¸€å¼€å§‹çš„ç›¸åŒï¼Œä½†è¿™æ˜¯ C è¯­è¨€çš„ä¸€ä¸ªé™·é˜±ï¼Œpacked çš„ç»“æ„ä½“å¯èƒ½ä¼šç‰ºç‰²èµ„æ–™å­˜å–çš„æ•ˆç‡ï¼Œå…·ä½“å¯ä»¥å‚è€ƒ ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: è®°å¿†ä½“ç®¡ç†ã€å¯¹é½åŠç¡¬ä½“ç‰¹æ€§ã€‚ C89/C99 æä¾› offset å®æ¥æå‡å¯ç§»æ¤æ€§ (portablity)ï¼Œå…¶åŠŸèƒ½ä¸ºæ¥æ”¶ç»“æ„ä½“çš„å‹æ€å’Œæˆå‘˜çš„åç§°ï¼Œè¿”å› æˆå‘˜çš„åœ°å€å‡å» struct çš„èµ·å§‹åœ°å€å¾—åˆ°çš„åç§»é‡: #include \u003cstddef.h\u003e size_t offsetof(type, member); The macro offsetof() returns the offset of the field member from the start of the structure type. typeof ä¹Ÿæ˜¯ GNU extensionï¼Œå®ƒå¯ä»¥åœ¨ç¼–è¯‘æ—¶æœŸå¾—åˆ° object çš„å‹æ€åç§°ï¼Œä¾‹å¦‚ x æ˜¯ struct dataï¼Œé‚£ä¹ˆé€šè¿‡ typeof(x) å³å¯å¾—åˆ° struct dataï¼Œè¿™æ ·å°±è”é€šäº† object å’Œå‹æ€çš„å…³ç³»ã€‚ Another way to refer to the type of an expression is with typeof. The syntax of using of this keyword looks like sizeof, but the construct acts semantically like a type name defined with typedef. container_of å®ä½œä¸ºèµ„æ–™å°è£…çš„åŸºç¡€ container_of å®åœ¨ offsetof çš„åŸºç¡€ä¸Šï¼Œæ‰©å……ä¸º ç»™å®šæˆå‘˜çš„åœ°å€ã€struct çš„å‹æ€ï¼Œä»¥åŠæˆå‘˜çš„åç§°ï¼Œä¼ å›æ­¤ struct ç‰©ä»¶çš„åœ°å€: è«‹ä¸è¦å°çœ‹é€™å·¨é›†ï¼Œç•¢ç«Ÿå¤§é‡åœ¨ Linux æ ¸å¿ƒåŸå§‹ç¨‹å¼ç¢¼æ¡ç”¨çš„å·¨é›†ï¼Œæ‡‰æœ‰å…¶ç¨åˆ°ä¹‹è™•ã€‚åœ¨ container_of å·¨é›†å‡ºç¾å‰ï¼Œç¨‹å¼è¨­è¨ˆçš„æ€ç¶­å¾€å¾€æ˜¯: çµ¦å®šçµæ§‹é«”èµ·å§‹åœ°å€ æ±‚å‡ºçµæ§‹é«”ç‰¹å®šæˆå“¡çš„è¨˜æ†¶é«”å…§å®¹ å‚³å›çµæ§‹é«”æˆå“¡çš„åœ°å€ï¼Œä½œæ—¥å¾Œå­˜å–ä½¿ç”¨ container_of å·¨é›†å‰‡é€†è½‰ä¸Šè¿°æµç¨‹ï¼Œç‰¹åˆ¥åœ¨ C èªè¨€ç¨‹å¼è¨­è¨ˆä¸­ï¼Œæˆ‘å€‘é€šå¸¸æœƒå®šç¾©ä¸€ç³»åˆ—å…¬é–‹ä»‹é¢ (interface)ï¼Œå¾è€Œå€éš”å„å¼å¯¦ä½œ (implementation)ã€‚ ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: ç‰©ä»¶å¯¼å‘ç¨‹åºè®¾è®¡ç¯‡ ä¾‹å¦‚å¯¹äºä¸‹é¢çš„ç¨‹å¼ç ï¼Œå¯ä»¥é€šè¿‡ container_of æ­é… base æˆå‘˜æ¥è·å¾—å…·ä½“çš„ç±»å‹ï¼Œå®ç°æŸç§æ„ä¹‰ä¸Šçš„ å°è£… (encapsulation)ï¼Œç»§æ‰¿ (inheritance) å’Œ å¤šæ€ (polymorphism) typedef struct { int ref; } Object; typedef struct { Object base; /* Vehicle-specific members */ } Vehicle; typedef struct { Vehicle base; /* Car-specific members */ } Car; void vehicleStart(Vehicle *obj) { if (obj) printf(\"%x derived from %x\\n\", obj, obj-\u003ebase); } int main(void) { Car c; vehicleStart((Vehicle *) \u0026c); } åœ¨ Linux æ ¸å¿ƒçš„è£…ç½®é©±åŠ¨ç¨‹å¼é‡Œä¹Ÿå¸¸ç”¨åˆ° container_of è¿›è¡Œç‰©ä»¶å¯¼å‘è®¾è®¡ï¼Œå¹¶é€šè¿‡æ­é…æŒ‡é’ˆæ“ä½œï¼Œç”¨äº æ¸…æ™°åœ°ç•Œå®šæ¥å£å’Œå®ä½œæœ¬ä½“ï¼Œè¿™æ˜¯ Linux æ ¸å¿ƒå¼€å‘è€…è¿½æ±‚çš„ä¼˜é›…ã€‚ drivers/media/i2c/imx214.c container_of å®ä½œæ‰‹æ³• å¯¹åº”çš„ç¨‹å¼ç : /* container_of() - Calculate address of object that contains address ptr * @ptr: pointer to member variable * @type: type of the structure containing ptr * @member: name of the member variable in struct @type * * Return: @type pointer of object containing ptr */ #define container_of(ptr, type, member) \\ __extension__({ \\ const __typeof__(((type *) 0)-\u003emember) *(__pmember) = (ptr); \\ (type *) ((char *) __pmember - offsetof(type, member)); \\ }) è¿™é‡Œé¢æ¶‰åŠåˆ°äº† __extension__ï¼Œå‚è€ƒ 6.51 Alternate Keywords: -pedantic and other options cause warnings for many GNU C extensions. You can suppress such warnings using the keyword __extension__. Writing __extension__ before an expression prevents warnings about extensions within that expression. å› ä¸ºç”¨åˆ°äº† typeof è¿™ä¸ª GNU extensionï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨ __extension__ æ¥è®¾ç½®ç¼–è¯‘æ—¶ä¸æŠ›å‡ºè­¦å‘Š å¼•ç”¨ ä¸Šè¿°ç¨‹å¼ç¢¼æ˜¯å¾ struct ä¸­çš„ member æ¨ç®—å‡ºåŸæœ¬ struct çš„ä½å€ã€‚è§£æ: å…ˆé€é __typeof__ å¾—åˆ° type ä¸­çš„æˆå“¡ member çš„å‹åˆ¥ï¼Œä¸¦å®£å‘Šä¸€å€‹æŒ‡å‘è©²å‹åˆ¥çš„æŒ‡æ¨™ __pmember å°‡ ptr æŒ‡æ´¾åˆ° __pmember __pmember ç›®å‰æŒ‡å‘çš„æ˜¯ member çš„ä½å€ offsetof(type, member) å¯å¾—çŸ¥ member åœ¨ type é€™å€‹çµæ§‹é«”ä½ç§»é‡ï¼Œå³ offset å°‡çµ•å°ä½å€ (char *) __pmember æ¸›å» offsetof(type, member)ï¼Œå¯å¾—åˆ°çµæ§‹é«”çš„èµ·å§‹ä½å€ã€‚è¨ˆç®— offset æ™‚è¦è½‰æˆ char *ï¼Œä»¥ç¢ºä¿ address çš„è¨ˆç®—ç¬¦åˆé æœŸ (å¯åƒè€ƒ The (char *) casting in container_of() macro in linux kernel çš„èªªæ˜) æœ€å¾Œ (type *) å†å°‡èµ·å§‹ä½ç½®è½‰å‹ç‚ºæŒ‡å‘ type çš„æŒ‡æ¨™ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç¨‹å¼ç çš„ç¬¬ä¸€è¡Œä¹ä¸€çœ‹æ„Ÿè§‰æ²¡ä»€ä¹ˆç”¨ï¼Œæ­¤æ—¶è¯·ä» robust çš„è§’åº¦çœ‹å¾…ï¼Œæ¯•ç«Ÿä¸€ä¸ªæœ‰å¼ºåº¦çš„ç³»ç»Ÿéƒ½æ˜¯ robust çš„ã€‚å®é™…ä¸Šç¬¬ä¸€è¡Œæ˜¯ç”¨äºç¼–è¯‘æ—¶æœŸç±»å‹æ£€æŸ¥çš„ï¼Œæ£€æŸ¥ä¼ å…¥çš„åœ°å€ ptr æ˜¯å¦å¯¹åº” member çš„ç±»å‹ï¼Œè¿™ä¸ªç±»å‹æ£€æŸ¥æ—¶é€šè¿‡ä¸åŒ object çš„ data alignment æ¥å®ç°çš„ (data alignment ä¼šåæ˜ åœ¨åœ°å€ä¸Šï¼Œè¿›è€Œåæ˜ åˆ°æŒ‡é’ˆçš„å€¼ä¸Šé¢)ã€‚ äº‹å®ä¸Šï¼ŒLinux æ ¸å¿ƒçš„ container_of å®åˆ™æ›´åŠ å¤æ‚: #define container_of(ptr, type, member) ({ \\ void *__mptr = (void *)(ptr); \\ BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)-\u003emember) \u0026\u0026 \\ !__same_type(*(ptr), void), \\ \"pointer type mismatch in container_of()\"); \\ ((type *)(__mptr - offsetof(type, member))); }) å¤æ‚å¢åŠ çš„åœ°æ–¹ä»ç„¶æ˜¯æˆ‘ä»¬æ‰€æçš„ robust ä¿è¯ï¼Œç”¨äºåœ¨ ç¼–è¯‘æ—¶æœŸ è¿›è¡Œæ›´åŠ ä¸¥æ ¼çš„ ç±»å‹","date":"2024-02-03","objectID":"/posts/c-linked-list/:4:2","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["C","Linux Kernel Internals"],"content":"Optimized QuickSort Optimized QuickSort: C Implementation (Non-Recursive) è¿™ç¯‡æ–‡ç« ä»‹ç»äº† non-recursion çš„ quick sort åœ¨ array ä¸Šçš„å®ä½œï¼Œå‚è€ƒè¯¥æ–‡ç« å®Œæˆ linked list ä¸Šçš„ non-recursion ç‰ˆæœ¬çš„ quick sort å®ä½œã€‚ éé€’å½’çš„å¿«é€Ÿæ’åºä¸­ if (L != R \u0026\u0026 \u0026begin[i]-\u003elist != head) { å…¶ä¸­çš„ \u0026begin[i]-\u003elist != head æ¡ä»¶åˆ¤æ–­ç”¨äºç©ºé“¾è¡¨æƒ…å†µï¼Œæ•°ç»„ç‰ˆæœ¬ä¸­ä½¿ç”¨çš„æ˜¯ä¸‹æ ‡æ¯”è¾ƒ L \u003c R æ¥åˆ¤æ–­ï¼Œä½†æ˜¯é“¾è¡¨ä¸­ä½¿ç”¨ L != R ä¸è¶³ä»¥å®Œå…¨è¡¨ç¤º L \u003c R è¿™ä¸ªæ¡ä»¶ï¼Œè¿˜éœ€è¦ \u0026begin[i]-\u003elist != head æ¥åˆ¤æ–­é“¾è¡¨æ˜¯å¦ä¸ºç©ºã€‚ ","date":"2024-02-03","objectID":"/posts/c-linked-list/:4:3","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["C","Linux Kernel Internals"],"content":"Linux æ ¸å¿ƒçš„ list_sort å®ä½œ linux/list_sort.c å…ˆå°†åŒå‘å¾ªç¯é“¾è¡¨è½¬æ¢æˆå•å‘é“¾è¡¨ï¼Œç„¶ååˆ©ç”¨é“¾è¡¨èŠ‚ç‚¹çš„ prev æ¥æŒ‚è½½ pending list (å› ä¸ºå•å‘é“¾è¡¨ä¸­ prev æ²¡æœ‰ä½œç”¨ï¼Œä½†æ˜¯é“¾è¡¨èŠ‚ç‚¹ä»ç„¶å­˜åœ¨ prev å­—æ®µï¼Œæ‰€ä»¥è¿›è¡Œå……åˆ†åˆ©ç”¨)ã€‚ å‡è®¾ count å¯¹åº”çš„ bits ç¬¬ k ä¸ª bit å€¼ä¸º 0 ä¸” $\u003e k$ çš„ bits éƒ½ä¸º 0ï¼Œ$\u003c k$ çš„ bits éƒ½ä¸º 1ï¼Œåˆ™ $\u003c k $ çš„è¿™äº› 1 å¯ä»¥è¡¨ç¤º pending list ä¸­åˆ†åˆ«æœ‰ $2^{k-1}, 2^{k-2}, â€¦, 2^0$ å¤§å°çš„ list å„ä¸€ä¸ªã€‚ å¦‚æœç¬¬ k ä¸ª bit å€¼ä¸º 0 ä¸” $\u003e k$ çš„ bits ä¸­å­˜åœ¨å€¼ä¸º 1 çš„ bitï¼Œ$\u003c k$ çš„ bits å‡ä¸º 1ï¼Œåˆ™åªæœ‰ $\u003c k$ çš„ bits å¯ä»¥è¡¨ç¤º pending list ä¸­åˆ†åˆ«æœ‰ $2^{k-1}, 2^{k-2}, â€¦, 2^0$ å¤§å°çš„ list å„ä¸€ä¸ªï¼Œ\u003e k çš„ 1 è¡¨ç¤ºéœ€è¦è¿›è¡Œ merge ä»¥è·å¾—å¯¹åº”å¤§å°çš„ listã€‚ è¿™æ ·ä¹Ÿåˆšå¥½èƒ½ä½¿å¾— merge æ—¶æ˜¯ $2: 1$ çš„é•¿åº¦æ¯”ä¾‹ï¼Œå› ä¸º 2 çš„æŒ‡æ•°ä¹‹é—´çš„æ¯”ä¾‹æ˜¯ $2: 1$ã€‚ æŠ€å·§ è¿™éƒ¨åˆ†å†…å®¹åœ¨ Lab0: Linux æ ¸å¿ƒçš„é“¾è¡¨æ’åº ä¸­æœ‰æ›´è¯¦ç»†çš„è§£é‡Šå’Œè®¨è®ºã€‚ ä¿¡æ¯ List, HList, and Hash Table hash table What is the strict aliasing rule? [Stack Overflow] Unions and type-punning [Stack Overflow] Nine ways to break your systems code using volatile [Stack Overflow] WRITE_ONCE in linux kernel lists [Stack Overflow] lib/list_sort: Optimize number of calls to comparison function ","date":"2024-02-03","objectID":"/posts/c-linked-list/:4:4","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["C","Linux Kernel Internals"],"content":"Fisherâ€“Yates shuffle Wikipedia Fisherâ€“Yates shuffle The Fisherâ€“Yates shuffle is an algorithm for shuffling a finite sequence. åŸæ–‡æ‰€è¯´çš„äº‹ä»¶å¤æ‚åº¦ï¼Œæ˜¯è€ƒè™‘å…³äºæ„é€ ç»“æœé“¾è¡¨æ—¶çš„å¤æ‚åº¦ï¼Œå¹¶ä¸è€ƒè™‘å¯»æ‰¾æŒ‡å®šèŠ‚ç‚¹çš„å¤æ‚åº¦ï¼Œæ‰€ä»¥å¯¹äºåŸå§‹æ–¹æ³•å¤æ‚åº¦ä¸º $1 + 2 + â€¦ + n = O(n^2)$ï¼Œå¯¹äº modern method å¤æ‚åº¦ä¸º $1 + 1 + â€¦ + 1 = O(n)$ åŸæ–‡å®ä½œè™½ç„¶ä½¿ç”¨äº† pointer to pointerï¼Œä½†æ˜¯ä½¿ç”¨ä¸Šå¹¶æ²¡æœ‰ä½“ç° linus æ‰€è¯´çš„ good tasteï¼Œé‡æ–°å®ä½œå¦‚ä¸‹: void shuffle(node_t **head) { srand(time(NULL)); // First, we have to know how long is the linked list int len = 0; node_t **indirect = head; while (*indirect) { len++; indirect = \u0026(*indirect)-\u003enext; } // Append shuffling result to another linked list node_t *new = NULL; node_t **new_tail = \u0026new; while (len) { int random = rand() % len; indirect = head; while (random--) indirect = \u0026(*indirect)-\u003enext; node_t *tmp = *indirect; *indirect = (*indirect)-\u003enext; tmp-\u003enext = NULL; *new_tail = tmp; new_tail = \u0026(*new_tail)-\u003enext; len--; } *head = new; } ä¸»è¦æ˜¯ä¿®æ”¹äº†æ–°é“¾è¡¨ new é‚£ä¸€éƒ¨åˆ†ï¼Œåªéœ€è¦ä¸€ä¸ª pointer to pinter new_tail å°±å¯ä»¥é¿å…æ¡ä»¶åˆ¤æ–­ã€‚ ","date":"2024-02-03","objectID":"/posts/c-linked-list/:5:0","tags":["Sysprog","C","Linked List"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: linked list å’Œéè¿ç»­è®°å¿†ä½“","uri":"/posts/c-linked-list/"},{"categories":["Rust"],"content":" In this second Crust of Rust video, we cover declarative macros, macro_rules!, by re-implementing the vec! macro from the standard library. As part of that, we cover not only how to write these, but some of the gotchas and tricks youâ€™ll run into, and some common use-cases. æ•´ç†è‡ª John Gjengset çš„å½±ç‰‡ ","date":"2024-01-31","objectID":"/posts/declarative-macros/:0:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"å½±ç‰‡æ³¨è§£ ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"regex macro å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ 3 ç§åˆ†éš”ç¬¦æ¥ä¼ å…¥å‚æ•° (æ³¨æ„èŠ±æ‹¬å· {} çš„éœ€è¦ä¸ macro åä¹‹é—´è¿›è¡Œç©ºæ ¼ï¼Œæœ«å°¾ä¸éœ€è¦åˆ†å·ï¼Œè¿™æ˜¯å› ä¸º {} ä¼šè¢«ç¼–è¯‘å™¨è§†ä¸ºä¸€ä¸ª statementï¼Œæ— éœ€ä½¿ç”¨ ; æ¥è¿›è¡Œåˆ†éš”): macro_rules! avec { () =\u003e {}; ... } avec!(); avec![]; avec! {} macro å®šä¹‰å†…çš„ () å’Œ {} ä¹Ÿéƒ½å¯ä»¥ä½¿ç”¨ (), [], {} ä¹‹é—´çš„ä»»æ„ä¸€ç§ï¼Œå¹¶ä¸å½±å“è°ƒç ” macro çš„åˆ†éš”ç¬¦çš„ä½¿ç”¨ï¼ˆéƒ½æ˜¯ 3 ä»»é€‰ 1 å³å¯ï¼‰ï¼Œä¸è¿‡æ¨èåœ¨ macro å®šä¹‰å†…ä½¿ç”¨ () å’Œ {} æ­é…ã€‚ å¦‚æœéœ€è¦åœ¨ macro ä¼ å…¥çš„ synatx ä¸­ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ (regex)ï¼Œåˆ™éœ€è¦åœ¨å¤–é¢ä½¿ç”¨ $() è¿›è¡ŒåŒ…è£…: ($($elem:expr),* $(,)?) =\u003e {{ let mut v = Vec::new(); $(v.push($elem);)* v }}; åŒæ ·çš„ï¼Œå¯ä»¥åœ¨ macro ä½“å†…ä½¿ç”¨ regex å¯¹å‚æ•°è¿›è¡Œè§£åŒ…è£…ï¼Œè¯­æ³•æ˜¯ç›¸åŒçš„ï¼š $(...)[delimiter](+|*|?) å…¶ä¸­åˆ†éš”ç¬¦ (delimiter) æ˜¯å¯é€‰çš„ã€‚å®ƒä¼šæ ¹æ®å†…éƒ¨æ‰€åŒ…å«çš„å‚æ•° $(...) (æœ¬ä¾‹ä¸­æ˜¯ $(elem)) æ¥è¿›è¡Œè‡ªåŠ¨è§£åŒ…è£…ï¼Œç”Ÿæˆå¯¹åº”æ¬¡æ•°çš„ statementï¼Œå¦‚æœæœ‰åˆ†éš”ç¬¦ (delimiter) ä¹Ÿä¼šç”Ÿæˆå¯¹åº”çš„ç¬¦å·ã€‚ ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:1","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"cargo expand cargo-expand å¯ä»¥å°†å®å±•å¼€ï¼Œå¯¹äºå®çš„é™¤é”™éå¸¸æ–¹ä¾¿ï¼Œå¯ä»¥ä»¥ä¸‹å‘½ä»¤æ¥å®‰è£…: $ cargo install cargo-expand ç„¶åå¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤å¯¹ macro è¿›è¡Œå±•å¼€: $ cargo expand ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å¯ä»¥å°† unit tests ä¸ cargo expand ç»“åˆèµ·æ¥ï¼Œå³å±•å¼€çš„æ˜¯ unit tests ä¹‹åçš„å®Œæ•´ä»£ç : $ cargo expand --lib tests ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:2","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"scope ç”±äº Rust ä¸­ macro å’Œ normal code çš„ä½œç”¨åŸŸä¸ä¸€è‡´ï¼Œæ‰€ä»¥åƒ C è¯­è¨€é‚£ç§åœ¨ macro ä¸­å®šä¹‰å˜é‡æˆ–åœ¨ macro ä¸­ç›´æ¥ä¿®æ”¹å·²æœ‰å˜é‡æ˜¯ä¸å¯è¡Œçš„ï¼Œæ“ä½œè¿™ç§ lvalue çš„æƒ…å†µéœ€è¦ä½¿ç”¨ macro å‚æ•°è¿›è¡Œä¼ å…¥ï¼Œå¦åˆ™æ— æ³•é€šè¿‡ç¼–è¯‘ã€‚ // cannot compile macro_rules! avec { () =\u003e { let x = 1; } } // cannot compile macro_rules! avec { () =\u003e { x = 42; } } // can compile macro_rules! avec { ($x: ident) =\u003e { $x += 1; } } ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:3","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"statements åœ¨ Rust macro ä¸­ï¼Œå¦‚æœéœ€è¦å°†ä¼ å…¥çš„ syntax è½¬æ¢æˆå¤šä¸ª statementsï¼Œéœ€è¦ä½¿ç”¨ {} è¿›è¡ŒåŒ…è£…: () =\u003e {{ ... }} å…¶ä¸­ç¬¬ä¸€å¯¹ {} æ˜¯ macro è¯­æ³•æ‰€è¦æ±‚çš„çš„ï¼Œç¬¬äºŒå¯¹ {} åˆ™æ˜¯ç”¨äºåŒ…è£… statements çš„ {}ï¼Œä½¿ç”¨ cargo expand è¿›è¡ŒæŸ¥çœ‹ä¼šæ›´ç›´è§‚ã€‚ ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:4","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"delimiter æ³¨æ„ macro ä¸­ä¼ å…¥çš„ syntaxï¼Œå…¶ä½¿ç”¨çš„ç±»ä¼¼äº =\u003e çš„åˆ†éš”ç¬¦æ˜¯æœ‰é™çš„ï¼Œä¾‹å¦‚ä¸èƒ½ä½¿ç”¨ -\u003e ä½œä¸ºåˆ†éš”ç¬¦ï¼Œå…·ä½“å¯ä»¥æŸ¥é˜…æ‰‹å†Œã€‚ ($arg1:ty =\u003e $arg2:ident) =\u003e { type $arg2 = $arg1; }; æŠ€å·§ å½“ declarative macros å˜å¾—å¤æ‚æ—¶ï¼Œå®ƒçš„å¯è¯»æ€§ä¼šå˜å¾—å¾ˆå·®ï¼Œè¿™æ—¶å€™éœ€è¦ä½¿ç”¨ procedural macrosã€‚ä½†æ˜¯ procedural macros éœ€è¦å¤šèŠ±è´¹ä¸€äº›ç¼–è¯‘å‘¨æœŸ (compilition cycle)ï¼Œå› ä¸ºéœ€è¦å…ˆå¯¹ procedural macros è¿›è¡Œç¼–è¯‘ï¼Œå†ç¼–è¯‘ lib/bin å¯¹åº”çš„æºæ–‡ä»¶ã€‚ ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:5","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"calculating ç¼–å†™ macro æ—¶ä¼ å…¥çš„å‚æ•°å¦‚æœæ˜¯ expressionï¼Œéœ€è¦å…ˆå¯¹å…¶è¿›è¡Œè®¡ç®—ï¼Œç„¶åä½¿ç”¨ clone æ–¹æ³•æ¥å¯¹è¯¥è®¡ç®—ç»“æœè¿›è¡Œæ‹·è´ï¼Œè¿™æ ·èƒ½æœ€å¤§é™åº¦çš„é¿å…æ‰“ç ´ Rust æ‰€æœ‰æƒåˆ¶åº¦çš„é™åˆ¶ã€‚ ($elem:expr; $count:expr) =\u003e {{ let mut v = Vec::new(); let x = $elem; for _ in 0..$count { v.push(x.clone()); } v }}; è¿™æ ·ä¼ å…¥ y.take().unwrap() ä½œä¸ºå®çš„ elem å‚æ•°å°±ä¸ä¼šäº§ç”Ÿ panicã€‚ æŠ€å·§ å¯¹äºä¼šå¯¼è‡´ compile fail çš„ unit testï¼Œæ— æ³•ä½¿ç”¨é€šå¸¸çš„ unit test æ¥æµ‹è¯•ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªæŠ€å·§ï¼šå¯ä»¥ä½¿ç”¨ Doc-tests çš„æ–¹å¼æ¥æ„å»ºï¼ˆéœ€è¦æ ‡è®° compile_failï¼Œå¦‚æœä¸æ ‡è®°åˆ™é»˜è®¤è¯¥æµ‹è¯•éœ€è¦ compile successï¼‰ /// ```compile_fail /// let v: Vec\u003cu32\u003e = vecmac::avec![42; \"foo\"]; /// ``` #[allow(dead_code)] struct CompileFailTest; ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:6","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"trait Rust ä¸­çš„ macro æ— æ³•é™åˆ¶ä¼ å…¥å‚æ•°çš„ Traitï¼Œä¾‹å¦‚ä¸èƒ½é™åˆ¶å‚æ•°å¿…é¡»å®ç° Clone è¿™ä¸ª Traitã€‚ ::std::iter å¸¦æœ‰å‰ç½®åŒå†’å· :: çš„è¯­æ³•ï¼Œæ˜¯åœ¨æ²¡æœ‰æ˜¾å¼å¼•å…¥ use std::iter æ¨¡å—çš„æƒ…å†µä¸‹è®¿é—®è¯¥æ¨¡å—çš„æ–¹å¼ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ::std::iter è¡¨ç¤ºå…¨å±€å‘½åç©ºé—´ (global namespace) ä¸­çš„ std::iter æ¨¡å—ï¼Œå³æ ‡å‡†åº“ä¸­çš„ iter æ¨¡å—ã€‚ç”±äº macro éœ€è¦è¿›è¡Œ export å»ºè®®ç¼–å†™ macro æ—¶å°½é‡ä½¿ç”¨ :: è¿™ç±»è¯­æ³•ã€‚ æŠ€å·§ è®¡ç®— vector çš„å…ƒç´ ä¸ªæ•°æ—¶ä½¿ç”¨ () å¼•ç”¨ [()] è¿›è¡Œè®¡æ•°æ˜¯ä¸€ä¸ªå¸¸è§æŠ€å·§ï¼Œå› ä¸º () æ˜¯ zero size çš„ï¼Œæ‰€ä»¥å¹¶ä¸ä¼šå ç”¨æ ˆç©ºé—´ã€‚å…¶ä»–çš„å…ƒç´ è®¡æ•°æ–¹æ³•å¯ä»¥å‚è€ƒ The Little Book of Rust Macros çš„ 2.5.2 Counting ä¸€èŠ‚ã€‚ ","date":"2024-01-31","objectID":"/posts/declarative-macros/:1:7","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"Homework ä¿¡æ¯ å®ä½œè¯´æ˜: å°è¯•ä½¿ç”¨ declarative macro æ¥å®ç° HashMap çš„åˆå§‹åŒ–è¯­æ³• (Github: My Implementation) å°è¯•é˜…è¯» vec macro åœ¨ std åº“çš„å®ç° Macro std::vec å‚è€ƒèµ„æ–™: Struct std::collections::HashMap ","date":"2024-01-31","objectID":"/posts/declarative-macros/:2:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-01-31","objectID":"/posts/declarative-macros/:3:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"Crate std å¯ä»¥ä½¿ç”¨è¿™é‡Œæä¾›çš„æœç´ æ è¿›è¡Œæœç´¢ (BTW ä¸è¦æµªè´¹æ—¶é—´åœ¨ Google æœå¯»ä¸Šï¼) Macro std::vec Struct std::vec::Vec Method std::vec::Vec::with_capacity method std::vec::Vec::extend method std::vec::Vec::resize Module std::iter Function std::iter::repeat method std::iter::Iterator::take method std::option::Option::take ","date":"2024-01-31","objectID":"/posts/declarative-macros/:3:1","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":"References åŸç‰ˆçš„ The Little Book of Rust Macros åœ¨ Rust æ›´æ–°æ–°ç‰ˆæœ¬åæ²¡æœ‰æŒç»­æ›´æ–°ï¼Œå¦ä¸€ä½å¤§ç‰›å¯¹è¿™æœ¬å°å†Œå­è¿›è¡Œäº†ç›¸åº”çš„æ›´æ–°: The Little Book of Rust Macros Rustè¯­è¨€ä¸­æ–‡ç¤¾åŒºä¹Ÿç¿»è¯‘äº†è¯¥å°å†Œå­: Rust å®å°å†Œ ","date":"2024-01-31","objectID":"/posts/declarative-macros/:4:0","tags":["Rust","Macro","Declarative Macros"],"title":"Crust of Rust: Declarative Macros","uri":"/posts/declarative-macros/"},{"categories":["Rust"],"content":" Weâ€™re going to investigate a case where you need multiple explicit lifetime annotations. We explore why they are needed, and why we need more than one in this particular case. We also talk about some of the differences between the string types and introduce generics over a self-defined trait in the process. æ•´ç†è‡ª John Gjengset çš„å½±ç‰‡ ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:0:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"C è¯­è¨€ä¸­çš„ lifetime Rust ä¸­çš„ lifetime ä¸€å‘æ˜¯ä¸€ä¸ªéš¾ç‚¹ï¼Œä¸ºäº†æ›´å¥½åœ°ç†è§£è¿™ä¸€éš¾ç‚¹çš„æœ¬è´¨ï¼Œå»ºè®®é˜…è¯» C è¯­è¨€è§„æ ¼ä¹¦å…³äº lifetime çš„éƒ¨åˆ†ï¼Œç›¸ä¿¡ä½ ä¼šå¯¹ Rust çš„ lifetime æœ‰ä¸åŒçš„çœ‹æ³•ã€‚ C11 [6.2.4] Storage durations of objects An object has a storage duration that determines its lifetime. There are four storage durations: static, thread, automatic, and allocated. ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:1:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"å½±ç‰‡æ³¨è§£ ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:2:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"cargo check cargo check å¯ä»¥ç»™å‡ºæ›´ç®€æ´çš„æç¤ºï¼Œä¾‹å¦‚ç›¸å¯¹äºç¼–è¯‘å™¨ç»™å‡ºçš„é”™è¯¯ä¿¡æ¯ï¼Œå®ƒä¼šæ•´åˆç›¸åŒçš„é”™è¯¯ä¿¡æ¯ï¼Œä»è€Œæä¾›ç®€æ´åˆ‡è¦çš„æç¤ºä¿¡æ¯ã€‚è€Œä¸”å®ƒæ˜¯ä¸€ä¸ªé™æ€åˆ†æå·¥å…·ï¼Œä¸éœ€è¦è¿›è¡Œç¼–è¯‘å³å¯ç»™å‡ºæç¤ºï¼Œæ‰€ä»¥é€Ÿåº¦ä¼šæ¯”ç¼–è¯‘å¿«å¾ˆå¤šï¼Œåœ¨å¤§å‹é¡¹ç›®ä¸Šå°¤ä¸ºæ˜æ˜¾ã€‚ ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:2:1","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"ref å½±ç‰‡å¤§æ¦‚ 49 åˆ†æ—¶æåˆ°äº† if let Some(ref mut remainder) = self.remainder {...} ref çš„ä½œç”¨é…åˆ if let è¯­å¥ä½“çš„é€»è¾‘å¯ä»¥ä½“ä¼šåˆ° pointer of pointer çš„ç¾å¦™ä¹‹å¤„ã€‚ å› ä¸ºåœ¨ pattern match ä¸­å½¢å¦‚ \u0026mut è¿™ç±»ä¹Ÿæ˜¯ç”¨äº pattern match çš„ï¼Œä¸èƒ½ç”¨äºè·å– referenceï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆéœ€è¦ä½¿ç”¨ ref mut è¿™ç±»è¯­æ³•æ¥è·å– reference çš„åŸå› ã€‚ ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:2:2","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"operator ? å½±ç‰‡å¤§æ¦‚ 56 åˆ†æ—¶æåˆ°äº† let remainder = self.remainder.as_mut()?; ä¸ºä»€ä¹ˆä½¿ç”¨ä¹‹å‰æ‰€æçš„ let remainder = \u0026mut self.remainder?; è¿™æ˜¯å› ä¸ºä½¿ç”¨ ? è¿ç®—ç¬¦è¿”å›çš„æ˜¯å†…éƒ¨å€¼çš„ copyï¼Œæ‰€ä»¥è¿™ç§æƒ…å†µ remainder é‡Œæ˜¯ self.remainder? è¿”å›çš„å€¼ (æ˜¯åŸæœ‰ self.remainder å†…éƒ¨å€¼çš„ copy) çš„ reference ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:2:3","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"\u0026str vs String å½±ç‰‡å¤§æ¦‚ 1:03 æ—¶æåˆ°äº† str ä¸ String çš„åŒºåˆ«ï¼Œä¸ªäººè§‰å¾—è®²çš„å¾ˆå¥½ï¼š str -\u003e [char] \u0026str -\u003e \u0026[char] // fat pointer (address and size) String -\u003e Vec\u003cchar\u003e String -\u003e \u0026str (cheap -- AsRef) \u0026str -\u003e String (expensive -- memcpy) å¯¹äº String ä½¿ç”¨ \u0026* å¯ä»¥ä¿è¯å°†å…¶è½¬æ¢æˆ \u0026strï¼Œå› ä¸º * ä¼šå…ˆå°† String è½¬æ¢æˆ strã€‚å½“ç„¶å¯¹äºå‡½æ•°å‚æ•°çš„ \u0026strï¼Œåªéœ€ä¼ å…¥ \u0026String å³å¯è‡ªåŠ¨è½¬æ¢ç±»å‹ã€‚ ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:2:4","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"lifetime å¯ä»¥å°†ç»“æ„ä½“çš„ lifetime çš„ç¬¬ä¸€ä¸ª (ä¸€èˆ¬ä¸º 'a) è§†ä¸ºå®ä¾‹çš„ lifetimeï¼Œå…¶å®ƒçš„å¯ä»¥è¡¨ç¤ºä¸å®ä¾‹ lifetime æ— å…³çš„ lifetimeã€‚ç”±äº compiler ä¸å¤Ÿæ™ºèƒ½ï¼Œæ‰€ä»¥å®ƒä¼šå°†å®ä¾‹åŒ–æ—¶ä¼ å…¥å‚æ•°çš„ lifetime ä¸­ç›¸å…³è”çš„æœ€å° lifetime è§†ä¸ºå®ä¾‹çš„ lifetime çº¦æŸ (å³å®ä¾‹çš„ lifetime åŒ…å«äºè¯¥ lifetime å†…)ã€‚ å½“åœ¨å®ç°ç»“æ„ä½“çš„æ–¹æ³•æˆ– Trait æ—¶ï¼Œå¦‚æœåœ¨å®ç°æ–¹æ³•æ—¶æ— éœ€ä½¿ç”¨ lifetime çš„åç§°ï¼Œåˆ™å¯ä»¥ä½¿ç”¨åŒ¿å lifetime '_ï¼Œæˆ–è€…åœ¨ç¼–è¯‘å™¨å¯ä»¥æ¨æ¨å¯¼å‡º lifetime æ—¶ä¹Ÿå¯ä»¥ä½¿ç”¨åŒ¿å lifetime '_ã€‚ only lifetime struct Apple\u003c'a\u003e { owner: \u0026'a Human, } impl Apple\u003c'_\u003e { ... } lifetime and generic struct Apple\u003c'a, T\u003e { owner: \u0026'a T, } impl\u003cT\u003e Apple\u003c'_, T\u003e { ... } compiler can know lifetime pun fn func(\u0026self) -\u003e Apple\u003c'_, T\u003e { ... } ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:2:5","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"Documentations è¿™é‡Œåˆ—ä¸¾è§†é¢‘ä¸­ä¸€äº›æ¦‚å¿µç›¸å…³çš„ documentation å­¦ä¹ çš„ä¸€æ‰‹èµ„æ–™æ˜¯å®˜æ–¹æ–‡æ¡£ï¼Œè¯·åŠ¡å¿…è‡ªä¸»å­¦ä¼šé˜…è¯»è§„æ ¼ä¹¦ä¹‹ç±»çš„èµ„æ–™ ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:3:0","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Rust"],"content":"Crate std å¯ä»¥ä½¿ç”¨è¿™é‡Œæä¾›çš„æœç´ æ è¿›è¡Œæœç´¢ (BTW ä¸è¦æµªè´¹æ—¶é—´åœ¨ Google æœå¯»ä¸Šï¼) Keywords Keyword SelfTy Keyword ref Trait std::iter::Iterator method std::iter::Iterator::eq method std::iter::Iterator::collect method std::iter::Iterator::position method std::iter::Iterator::find Enum std::option::Option method std::option::Option::take method std::option::Option::as_mut method std::option::Option::expect Primitive Type str method str::find method str::char_indices Trait std::ops::Try Macro std::try method char::len_utf8 ","date":"2024-01-25","objectID":"/posts/lifetime-annotations/:3:1","tags":["Rust","Lifetime"],"title":"Crust of Rust: Lifetime Annotations","uri":"/posts/lifetime-annotations/"},{"categories":["Toolkit"],"content":"è®°å½•ä¸€ä¸‹æŠ˜è…¾ Deepin 20.9 çš„ç‰©ç†æœºçš„è¿‡ç¨‹ä¸ç›¸å…³çš„é…ç½®ã€‚ ","date":"2024-01-24","objectID":"/posts/deepin20.9/:0:0","tags":["Linux","Deepin"],"title":"æ·±åº¦æ“ä½œç³»ç»Ÿ Deepin 20.9 å®‰è£…é…ç½®","uri":"/posts/deepin20.9/"},{"categories":["Toolkit"],"content":"å®‰è£…ä¸é…ç½® æ–°æ‰‹æ•™å­¦å½±ç‰‡ï¼š æ·±åº¦æ“ä½œç³»ç»Ÿdeepinä¸‹è½½å®‰è£… (é™„åŒç³»ç»Ÿå®‰è£…åŠåˆ†åŒºæŒ‡å¼•) [bilibili] å®‰è£…å®Œdeepinä¹‹åè¯¥åšçš„äº‹æƒ… [bilibili] ","date":"2024-01-24","objectID":"/posts/deepin20.9/:1:0","tags":["Linux","Deepin"],"title":"æ·±åº¦æ“ä½œç³»ç»Ÿ Deepin 20.9 å®‰è£…é…ç½®","uri":"/posts/deepin20.9/"},{"categories":["Toolkit"],"content":"ç½‘ç»œä»£ç† æ–°æ‰‹æ•™å­¦æ–‡æ¡£: Ubuntu 22.04LTS ç›¸å…³é…ç½® åœ¨å¢ƒå†…å¯ä»¥ä½¿ç”¨ gitclone é•œåƒç«™æ¥åŠ å¿« clone çš„é€Ÿåº¦ã€‚ ","date":"2024-01-24","objectID":"/posts/deepin20.9/:2:0","tags":["Linux","Deepin"],"title":"æ·±åº¦æ“ä½œç³»ç»Ÿ Deepin 20.9 å®‰è£…é…ç½®","uri":"/posts/deepin20.9/"},{"categories":["Toolkit"],"content":"ç¼–è¾‘å™¨: VS Code æ–°æ‰‹æ•™å­¦æ–‡æ¡£: ç¼–è¾‘å™¨: Visual Studio Code [HackMD] æœ¬äººçš„ä¸€äº›æ³¨è§£: GNU/Linux å¼€å‘å·¥å…· è¿™é‡Œåˆ—ä¸¾ä¸€ä¸‹æœ¬äººé…ç½®çš„æ’ä»¶ï¼š Even Better TOML CodeLLDB ç”¨äºè°ƒè¯• Rust Git History Native Debug ç”¨äºè°ƒè¯• C/C++ rust-analyzer Tokyo Night æŒºå¥½çœ‹çš„ä¸€ä¸ªä¸»é¢˜ Vim VSCode Great Icons æ–‡ä»¶å›¾æ ‡ä¸»é¢˜ é—®é¢˜ rust5-analyzer æ’ä»¶å¯èƒ½ä¼šå› ä¸ºæ–°ç‰ˆæœ¬è¦æ±‚ glibc 2.29 è€Œå¯¼è‡´å¯åŠ¨å¤±è´¥ï¼Œè¯·å‚è€ƒè¿™ä¸ª issue æ¥è§£å†³ã€‚ ","date":"2024-01-24","objectID":"/posts/deepin20.9/:3:0","tags":["Linux","Deepin"],"title":"æ·±åº¦æ“ä½œç³»ç»Ÿ Deepin 20.9 å®‰è£…é…ç½®","uri":"/posts/deepin20.9/"},{"categories":["Toolkit"],"content":"ç»ˆç«¯å’Œ Vim æ–°æ‰‹æ•™å­¦æ–‡æ¡£: çµ‚ç«¯æ©Ÿå’Œ Vim è¨­å®š [HackMD] æœ¬äººçš„ä¸€äº›æ³¨è§£: GNU/Linux å¼€å‘å·¥å…· æœ¬äººçš„ç»ˆç«¯æç¤ºç¬¦é…ç½®: \\u@\\h\\W æœ¬äººä½¿ç”¨ Minimalist Vim Plugin Manager æ¥ç®¡ç† Vim æ’ä»¶ï¼Œé…ç½®å¦‚ä¸‹: \" Specify a directory for plugins (for Neovim: ~/.local/share/nvim/plugged) call plug#begin('~/.vim/plugged') Plug 'Shougo/neocomplcache' Plug 'scrooloose/nerdtree' map \u003cF5\u003e :NERDTreeToggle\u003cCR\u003e call plug#end() let g:neocomplcache_enable_at_startup = 1 let g:neocomplcache_enable_smart_case = 1 inoremap \u003cexpr\u003e\u003cTAB\u003e pumvisible()?\"\\\u003cC-n\u003e\" : \"\\\u003cTAB\u003e\" syntax on set number set cursorline colorscheme default set bg=dark set tabstop=4 set expandtab set shiftwidth=4 set ai set hlsearch set smartindent map \u003cF4\u003e : set nu!\u003cBAR\u003eset nonu?\u003cCR\u003e \" autocomplete dropdown list colorscheme hi Pmenu ctermfg=0 ctermbg=7 hi PmenuSel ctermfg=7 ctermbg=4 ","date":"2024-01-24","objectID":"/posts/deepin20.9/:4:0","tags":["Linux","Deepin"],"title":"æ·±åº¦æ“ä½œç³»ç»Ÿ Deepin 20.9 å®‰è£…é…ç½®","uri":"/posts/deepin20.9/"},{"categories":["Toolkit"],"content":"ç³»ç»Ÿè¯­è¨€: Rust å®‰è£…æ•™ç¨‹: Installation [The book] å®‰è£… Rust [Rust course] Channels [The rustup book] # install rust $ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh # install nightly toolchain $ rustup toolchain install nightly # change to nightly toolchain $ rustup default nightly # list installed toolchain $ rustup toolchain list # update installed toolchain $ rustup update ä¸ªäººåå‘äºä½¿ç”¨ nightly toolchain ","date":"2024-01-24","objectID":"/posts/deepin20.9/:5:0","tags":["Linux","Deepin"],"title":"æ·±åº¦æ“ä½œç³»ç»Ÿ Deepin 20.9 å®‰è£…é…ç½®","uri":"/posts/deepin20.9/"},{"categories":["Toolkit"],"content":"tldr The tldr-pages project is a collection of community-maintained help pages for command-line tools, that aims to be a simpler, more approachable complement to traditional man pages. å®‰è£… tldr: $ sudo apt install tldr ","date":"2024-01-24","objectID":"/posts/deepin20.9/:6:0","tags":["Linux","Deepin"],"title":"æ·±åº¦æ“ä½œç³»ç»Ÿ Deepin 20.9 å®‰è£…é…ç½®","uri":"/posts/deepin20.9/"},{"categories":["Toolkit"],"content":"æ•ˆæœå±•ç¤º Deepin Terminial Vim Deepin DDE Desktop ","date":"2024-01-24","objectID":"/posts/deepin20.9/:7:0","tags":["Linux","Deepin"],"title":"æ·±åº¦æ“ä½œç³»ç»Ÿ Deepin 20.9 å®‰è£…é…ç½®","uri":"/posts/deepin20.9/"},{"categories":["Toolkit"],"content":"FAQ é—®é¢˜ é‡å¯åå¯èƒ½ä¼šå‡ºç°ï¼Œè¾“å…¥å¯†ç æ— æ³•è¿›å…¥å›¾å½¢ç•Œé¢é‡æ–°è¿”å›ç™»å½•ç•Œé¢ï¼Œè¿™ä¸€å¾ªç¯çŠ¶å†µã€‚è¿™ä¸ªæ˜¯ deepin çš„é»˜è®¤ shell æ˜¯ dash é€ æˆçš„ï¼Œåªéœ€å°†é»˜è®¤çš„ shell æ”¹ä¸º bash å³å¯è§£å†³é—®é¢˜ï¼š $ ls -l /bin/sh lrwxrwxrwx 1 root root 9 xxæœˆ xx xx:xx /bin/sh -\u003e /bin/dash $ sudo rm /bin/sh $ sudo ln -s /bin/bash /bin/sh å¦‚æœä½ å·²ç»å¤„äºæ— é™ç™»å½•ç•Œé¢å¾ªç¯è¿™ä¸€çŠ¶å†µï¼Œå¯ä»¥é€šè¿‡ Ctrl + Alt + \u003cF2\u003e è¿›å…¥ tty2 ç•Œé¢è¿›è¡Œä¿®æ”¹ï¼š # å…ˆæŸ¥çœ‹é—®é¢˜æ—¥å¿—ï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯ shell å¯¼è‡´çš„é—®é¢˜ $ cat .xsession-errors # å¦‚æœæ˜¯ï¼Œåˆ™é‡å¤ä¸Šé¢çš„æ“ä½œå³å¯ ","date":"2024-01-24","objectID":"/posts/deepin20.9/:8:0","tags":["Linux","Deepin"],"title":"æ·±åº¦æ“ä½œç³»ç»Ÿ Deepin 20.9 å®‰è£…é…ç½®","uri":"/posts/deepin20.9/"},{"categories":["Toolkit"],"content":"åœ¨ deepin 20.9 ä¸Šæ ¹æ® DragonOS æ„å»ºæ–‡æ¡£ çš„ bootstrap.sh çš„æ–¹å¼æ¥æ„å»º DragonOS æ—¶ï¼Œå¦‚æœæ²¡æœ‰äº‹å…ˆå®‰è£… Qemu ä¼šå‡ºç° KVM ç›¸å…³çš„ä¾èµ–é—®é¢˜ã€‚æœ¬æ–‡è®°å½•è§£å†³è¿™ä¸€é—®é¢˜çš„è¿‡ç¨‹ã€‚ å¦‚æœäº‹å…ˆæ²¡æœ‰å®‰è£… Qemuï¼Œåœ¨ä½¿ç”¨ bootstrap.sh æ—¶ä¼šå‡ºç°å¦‚ä¸‹æŠ¥é”™ï¼š $ bash bootstrap.sh ... ä¸‹åˆ—è½¯ä»¶åŒ…æœ‰æœªæ»¡è¶³çš„ä¾èµ–å…³ç³»ï¼š qemu-kvm : ä¾èµ–: qemu-system-x86 E: æ— æ³•ä¿®æ­£é”™è¯¯ï¼Œå› ä¸ºæ‚¨è¦æ±‚æŸäº›è½¯ä»¶åŒ…ä¿æŒç°çŠ¶ï¼Œå°±æ˜¯å®ƒä»¬ç ´åäº†è½¯ä»¶åŒ…é—´çš„ä¾èµ–å…³ç³»ã€‚ æŸ¥è¯¢ deepin è®ºå›ä¸Šçš„ç›¸å…³å†…å®¹ï¼šqemu-kvmæ— æ³•å®‰è£…ï¼Œå¯ä»¥å¾—çŸ¥æ˜¯å› ä¸º qemu-kvm åœ¨ debian å‘è¡Œç‰ˆä¸Šåªæ˜¯ä¸€ä¸ªè™šåŒ…ï¼Œæ‰€ä»¥å¯¹äº x86 æ¶æ„çš„æœºå™¨å¯ä»¥ç›´æ¥å®‰è£… qemu-systerm-x86 Debian qemu-kvm https://packages.debian.org/search?keywords=qemu-kvm å®‰è£… qemu-systerm-x86: $ sudo apt install qemu-systerm-x86 $ $ qemu-system-x86_64 --version QEMU emulator version 5.2.0 (Debian 1:5.2+dfsg-11+deb11u1) Copyright (c) 2003-2020 Fabrice Bellard and the QEMU Project developers å®‰è£…çš„ qemu ç‰ˆæœ¬çœ‹èµ·æ¥æœ‰ç‚¹ä½ï¼Œä½†æ˜¯å…ˆä½¿ç”¨ bootstrap.sh å¿«é€Ÿå®‰è£…å…¶å®ƒä¾èµ–é¡¹ï¼Œç„¶åå°è¯•ç¼–è¯‘è¿è¡Œä¸€ä¸‹ DragonOS: $ bash bootstrap.sh ... |-----------Congratulations!---------------| | | | ä½ æˆåŠŸå®‰è£…äº†DragonOSæ‰€éœ€çš„ä¾èµ–é¡¹! | | | | è¯·å…³é—­å½“å‰ç»ˆç«¯, å¹¶é‡æ–°æ‰“å¼€ä¸€ä¸ªç»ˆç«¯ | | ç„¶åé€šè¿‡ä»¥ä¸‹å‘½ä»¤è¿è¡Œ: | | | | make run | | | |------------------------------------------| æ–°å¼€ä¸€ä¸ªç»ˆç«¯æˆ–åˆ·æ–°ä¸€ä¸‹ ~/.bashrc: $ cd DragonOS $ make run è¿è¡Œ DragonOS Ok å¯ä»¥æˆåŠŸè¿è¡Œ æ³¨æ„ å¦‚æœéœ€è¦ä½¿ç”¨ RISC-V çš„ Qemu æ¨¡æ‹Ÿå™¨ï¼Œå®‰è£… qemu-system-misc å³å¯ï¼š $ sudo apt install qemu-system-misc ","date":"2024-01-22","objectID":"/posts/deepin-dragonos/:0:0","tags":["Deepin","Linux","DragonOS"],"title":"Deepin 20.9 æ„å»º DragonOS","uri":"/posts/deepin-dragonos/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"å¤§å‹å¼€æºé¡¹ç›®çš„è§„æ¨¡ååˆ†åºå¤§ï¼Œä¾‹å¦‚ä½¿ç”¨ Rust ç¼–å†™çš„ Servo æµè§ˆå™¨ï¼Œè¿™ä¸ªé¡¹ç›®æœ‰è¿‘åä¸‡è¡Œä»£ç ã€‚åœ¨å¼€å‘è§„æ¨¡å¦‚æ­¤åºå¤§çš„é¡¹ç›®æ—¶ï¼Œäº†è§£å¦‚ä½•é€šè¿‡æ­£ç¡®çš„æ–¹å¼è¿›è¡Œè°ƒè¯•éå¸¸é‡è¦ï¼Œå› ä¸ºè¿™æ ·å¯ä»¥å¸®åŠ©å¼€å‘è€…å¿«é€Ÿåœ°æ‰¾åˆ°ç“¶é¢ˆã€‚ åŸæ–‡åœ°å€ | æ•™å­¦å½•å½± ","date":"2024-01-16","objectID":"/posts/debug-gdb/:0:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"GDB è°ƒè¯• è§‚çœ‹æ•™å­¦è§†é¢‘ æ‹¯æ•‘è³‡å·¥ç³»å­¸ç”Ÿçš„åŸºæœ¬ç´ é¤Šâ€”ä½¿ç”¨ GDB é™¤éŒ¯åŸºæœ¬æ•™å­¸ å’Œæ­é…åšæ–‡ ==[How to debug Rust/C/C++ via GDB][debug-gdb]==ï¼Œå­¦ä¹  GDB çš„åŸºæœ¬æ“ä½œå’Œç†Ÿæ‚‰ä½¿ç”¨ GDB è°ƒè¯• Rust/C/C++ ç¨‹åºã€‚ æŒæ¡ run/r, break/b, print/p, continue/c, step/s info/i, delete/d, backtrace/bt, frame/f, up/down, exit/q ç­‰å‘½ä»¤çš„ç”¨æ³•ã€‚ä»¥åŠ GBD çš„ä¸€äº›ç‰¹æ€§ï¼Œä¾‹å¦‚ GDB ä¼šå°†ç©ºç™½è¡Œçš„æ–­ç‚¹è‡ªåŠ¨ä¸‹ç§»åˆ°ä¸‹ä¸€ä»£ç è¡Œï¼›ä½¿ç”¨ break å‘½ä»¤æ—¶å¯ä»¥è¾“å…¥æºæ–‡ä»¶è·¯å¾„ï¼Œä¹Ÿå¯ä»¥åªè¾“å…¥æºæ–‡ä»¶åç§°ã€‚ ç›¸å…³çš„æµ‹è¯•æ–‡ä»¶ï¼š test.c hello_cargo/ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:1:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"GDB åŸºæœ¬ä»‹ç» å¼•ç”¨ â€œGDB, the GNU Project debugger, allows you to see what is going on â€˜insideâ€™ another program while it executes â€” or what another program was doing at the moment it crashed.â€ â€” from gnu.org å®‰è£… GDB: $ sudo apt install gdb å¯åŠ¨ GDB æ—¶å¯ä»¥åŠ å…¥ -q å‚æ•° (quite)ï¼Œè¡¨ç¤ºå‡å°‘æˆ–ä¸è¾“å‡ºä¸€äº›æç¤ºæˆ–ä¿¡æ¯ã€‚ LLDB ä¸ GDB çš„å‘½ä»¤ç±»ä¼¼ï¼Œæœ¬æ–‡ä¹Ÿå¯ç”¨äº LLDB çš„å…¥é—¨å­¦ä¹ ã€‚ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:2:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"GDB è°ƒè¯• C/C++ è¦ä½¿ç”¨ GDB æ¥è°ƒè¯• C/C++ï¼Œéœ€è¦åœ¨ç¼–è¯‘æ—¶åŠ ä¸Š -g å‚æ•°ï¼ˆå¿…éœ€ï¼‰ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ -Og å‚æ•°æ¥å¯¹ debug è¿›è¡Œä¼˜åŒ–ï¼ˆä½†ä½¿ç”¨ -Og å compiler å¯èƒ½ä¼šæŠŠä¸€äº›ä¸œè¥¿ç§»é™¤æ‰ï¼Œæ‰€ä»¥ debug æ—¶å¯èƒ½ä¸ä¼šç¬¦åˆé¢„æœŸï¼‰ï¼Œä¾‹å¦‚ï¼š $ gcc test.c -Og -g -o test $ gdb -q ./test Source ","date":"2024-01-16","objectID":"/posts/debug-gdb/:3:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"GDB è°ƒè¯• Rust åœ¨ä½¿ç”¨ build å‘½ä»¤æ„å»º debug ç›®æ ‡æ–‡ä»¶ï¼ˆå³ä½äº target/debug ç›®å½•ä¸‹çš„ç›®æ ‡æ–‡ä»¶ï¼Œä¸ package åŒåï¼‰åï¼Œå°±å¯ä»¥é€šè¿‡ gdb æ¥è¿›è¡Œè°ƒè¯•ï¼š $ cargo build $ gdb -q ./target/debug/\u003cpackage name\u003e ä½†æ˜¯å¦‚æœæ˜¯ä½¿ç”¨ cargo build --release æ„å»ºçš„ release ç›®æ ‡æ–‡ä»¶ï¼ˆå³ä½äº target/release ç›®å½•ä¸‹çš„ç›®æ ‡æ–‡ä»¶ï¼‰ï¼Œåˆ™æ— æ³•ä½¿ç”¨ GDB è¿›è¡Œè°ƒè¯•ï¼Œå› ä¸º release ç›®æ ‡æœªåŒ…å«ä»»ä½•è°ƒè¯•ä¿¡æ¯ï¼Œç±»ä¼¼äºæœªä½¿ç”¨ -g å‚æ•°ç¼–è¯‘ C/C++ æºä»£ç ã€‚ Source ","date":"2024-01-16","objectID":"/posts/debug-gdb/:4:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"GDB åŸºæœ¬å‘½ä»¤ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"run run (r) å‘½ä»¤ç”¨äºä»ç¨‹åºçš„æ‰§è¡Œèµ·å§‹ç‚¹å¼€å§‹æ‰§è¡Œï¼Œç›´åˆ°é‡åˆ°ä¸‹ä¸€ä¸ªæ–­ç‚¹æˆ–è€…ç¨‹åºç»“æŸã€‚ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:1","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"continue continue (c) å‘½ä»¤ç”¨äºä»å½“å‰åœæ­¢çš„æ–­ç‚¹ä½ç½®å¤„ç»§ç»­æ‰§è¡Œç¨‹åºï¼Œç›´åˆ°é‡åˆ°ä¸‹ä¸€ä¸ªæ–­ç‚¹æˆ–è€…ç¨‹åºç»“æŸã€‚ æ³¨æ„ run å’Œ continue çš„åŒºåˆ«åœ¨äº run æ˜¯å°†ç¨‹åºä»å¤´å¼€å§‹æ‰§è¡Œã€‚ä¾‹å¦‚å¦‚æœæœªè®¾ç½®ä»»ä½•æ–­ç‚¹ï¼Œä½¿ç”¨ run å¯ä»¥åå¤æ‰§è¡Œç¨‹åºï¼Œè€Œå¦‚æœä½¿ç”¨ continue åˆ™ä¼šæç¤º The program is not being runã€‚ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:2","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"step step (s) å‘½ä»¤ç”¨äº é€è¡Œ æ‰§è¡Œç¨‹åºï¼Œåœ¨é‡åˆ°å‡½æ•°è°ƒç”¨æ—¶è¿›å…¥å¯¹åº”å‡½æ•°ï¼Œå¹¶åœ¨å‡½æ•°å†…éƒ¨çš„ç¬¬ä¸€è¡Œæš‚åœã€‚step å‘½ä»¤ä»¥ å•æ­¥æ–¹å¼ æ‰§è¡Œç¨‹åºçš„æ¯ä¸€è¡Œä»£ç ï¼Œå¹¶è·Ÿè¸ªå‡½æ•°è°ƒç”¨çš„è¿›å…¥å’Œé€€å‡ºã€‚ (gdb) step 6 bar += 3; (gdb) step 7 printf(\"bar = %d\\n\", bar); æ³¨æ„ step å‘½ä»¤ä¸ continue å‘½ä»¤ç›¸åŒï¼Œåªèƒ½åœ¨ç¨‹åºå¤„äºè¿è¡Œæ€ï¼ˆå³åœç•™åœ¨æ–­ç‚¹å¤„ï¼‰æ—¶æ‰èƒ½ä½¿ç”¨ã€‚ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:3","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"next next (n) å‘½ä»¤ç”¨äºæ‰§è¡Œå½“å‰è¡Œå¹¶ç§»åŠ¨åˆ° ä¸‹ä¸€è¡Œï¼Œå®ƒç”¨äºé€è¡Œæ‰§è¡Œç¨‹åºï¼Œä½†ä¸ä¼šè¿›å…¥å‡½æ•°è°ƒç”¨ã€‚ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:4","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"break break (b) å‘½ä»¤ç”¨äºåœ¨å¯æ‰§è¡Œé—®å·å¯¹åº”çš„æºç¨‹åºä¸­åŠ å…¥æ–­ç‚¹ï¼Œå¯ä»¥åœ¨ç¨‹åºå¤„äº æœªè¿è¡Œæ€/è¿è¡Œæ€ æ—¶åŠ å…¥æ–­ç‚¹ï¼ˆè¿è¡Œæ€æ˜¯æŒ‡ç¨‹åºåœç•™åœ¨æ–­ç‚¹å¤„ä½†æœªæ‰§è¡Œå®Œæ¯•çš„å§¿æ€ï¼‰ã€‚ å¯ä»¥é€šè¿‡æŒ‡å®š æºæ–‡ä»¶å¯¹åº”çš„ è¡Œæ•°/å‡½æ•°å æ¥åŠ å…¥æ–­ç‚¹ï¼ˆæºæ–‡ä»¶åå¯ä»¥çœç•¥ï¼‰ï¼š (gdb) break test.c:7 (gdb) break test.c:foo å¦‚æœå¯æ‰§è¡Œæ–‡ä»¶ç”±å¤šä¸ªæºæ–‡ä»¶ç¼–è¯‘é“¾æ¥å¾—åˆ°ï¼Œå¯ä»¥é€šè¿‡æŒ‡å®š æºæ–‡ä»¶åå­— çš„æ–¹å¼æ¥åŠ å…¥æ–­ç‚¹ï¼Œæ— éœ€æºæ–‡ä»¶è·¯å¾„ï¼Œä½†å¦‚æœä¸åŒè·¯å¾„æœ‰é‡åæºæ–‡ä»¶ï¼Œåˆ™éœ€è¦æŒ‡å®šè·¯å¾„æ¥åŒºåˆ†ï¼š (gdb) break test1.c:7 (gdb) break test2.c:main ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:5","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"print print (p) å‘½ä»¤ç”¨äºåœ¨è°ƒè¯•è¿‡ç¨‹ä¸­æ‰“å° å˜é‡çš„å€¼æˆ– è¡¨è¾¾å¼ çš„ç»“æœï¼Œå¸®åŠ©å¼€å‘è€…æ£€æŸ¥ç¨‹åºçŠ¶æ€å¹¶æŸ¥çœ‹ç‰¹å®šå˜é‡çš„å½“å‰å€¼ã€‚ # Assume x: 3, y: 4 (gdb) print x $1 = 3 (gdb) print x + y $2 = 7 ä½¿ç”¨ p å‘½ä»¤æ‰“å°å˜é‡å€¼æ—¶ï¼Œä¼šåœ¨å·¦ä¾§æ˜¾ç¤ºä¸€ä¸ª $\u003cnumber\u003eï¼Œè¿™ä¸ªå¯ä»¥ç†è§£æˆä¸´æ—¶å˜é‡ï¼Œåç»­ä¹Ÿå¯ä»¥é€šè¿‡è¿™ä¸ªæ ‡å¿—æ¥å¤ç”¨è¿™äº›å€¼ã€‚ä¾‹å¦‚åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼š (gdb) print $1 $3 = 3 (gdb) print $1 + $3 $4 = 4 Use p/format to instead select other formats such as x for hex, t for binary, and c for char. ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:6","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"backtrace backtrace (bt) å‘½ä»¤ç”¨äºæ‰“å°å½“å‰è°ƒç”¨æ ˆçš„ä¿¡æ¯ï¼Œä¹Ÿç§°ä¸ºå †æ ˆå›æº¯ (backtrace)ã€‚å®ƒæ˜¾ç¤ºäº†ç¨‹åºåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ç»è¿‡çš„å‡½æ•°è°ƒç”¨åºåˆ—ï¼Œä»¥åŠæ¯ä¸ªå‡½æ•°è°ƒç”¨çš„ä½ç½®å’Œå‚æ•°ï¼Œå³å¯ä»¥è·å–ä»¥ä¸‹ä¿¡æ¯ï¼š å‡½æ•°è°ƒç”¨åºåˆ—ï¼šæ˜¾ç¤ºç¨‹åºå½“å‰çš„å‡½æ•°è°ƒç”¨åºåˆ—ï¼Œä»¥åŠæ¯ä¸ªå‡½æ•°çš„åç§°å’Œæ‰€åœ¨çš„æºä»£ç æ–‡ä»¶ã€‚ æ ˆå¸§ä¿¡æ¯ï¼šå¯¹äºæ¯ä¸ªå‡½æ•°è°ƒç”¨ï¼Œæ˜¾ç¤ºè¯¥å‡½æ•°çš„æ ˆå¸§ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ ˆå¸§çš„åœ°å€å’Œæ ˆå¸§çš„å¤§å°ã€‚ (gdb) backtrace (gdb) backtrace #0 foo () at test.c:7 #1 0x00005555555551d2 in main () at test.c:14 æŠ€å·§ backtrace å‘½ä»¤å¯¹äºè·Ÿè¸ªç¨‹åºçš„æ‰§è¡Œè·¯å¾„ã€æ£€æŸ¥å‡½æ•°è°ƒç”¨çš„é¡ºåºä»¥åŠå®šä½é”™è¯¯éå¸¸æœ‰ç”¨ã€‚åœ¨å®é™…ä¸­ï¼Œä¸€èˆ¬ä¼šæ­é…å…¶ä»–GDBå‘½ä»¤ï¼ˆå¦‚ upã€down å’Œ frameï¼‰ç»“åˆä½¿ç”¨ï¼Œä»¥æŸ¥çœ‹ç‰¹å®šæ ˆå¸§çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯æˆ–åˆ‡æ¢åˆ°ä¸åŒçš„æ ˆå¸§ã€‚åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ#0 å’Œ #1 è¡¨ç¤ºæ ˆå¸§çš„ç¼–å·ï¼Œå¯ä»¥é€šè¿‡ frame é…åˆè¿™äº›ç¼–å·æ¥åˆ‡æ¢æ ˆå¸§ã€‚ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:7","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"where where å’Œ backtrace å‘½ä»¤éƒ½ç”¨äºæ˜¾ç¤ºç¨‹åºçš„è°ƒç”¨æ ˆä¿¡æ¯ã€‚backtrace æä¾›æ›´è¯¦ç»†çš„è°ƒç”¨æ ˆä¿¡æ¯ï¼ŒåŒ…æ‹¬å‡½æ•°åç§°ã€æ–‡ä»¶åã€è¡Œå·ã€å‚æ•°å’Œå±€éƒ¨å˜é‡çš„å€¼ã€‚è€Œ where å‘½ä»¤å¯ä»¥ç†è§£ä¸º backtrace çš„ä¸€ä¸ªç®€åŒ–ç‰ˆæœ¬ï¼Œå®ƒæä¾›çš„æ˜¯è¾ƒä¸ºç´§å‡‘çš„è°ƒç”¨æ ˆä¿¡æ¯ï¼Œé€šå¸¸åªåŒ…å«å‡½æ•°åç§°ã€æ–‡ä»¶åå’Œè¡Œå·ã€‚ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:8","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"frame frame (f) å‘½ä»¤ç”¨äºé€‰æ‹©ç‰¹å®šçš„æ ˆå¸§ (stack frame)ï¼Œä»è€Œåˆ‡æ¢åˆ°ä¸åŒçš„å‡½æ•°è°ƒç”¨ä¸Šä¸‹æ–‡ï¼Œæ¯ä¸ªæ ˆå¸§å¯¹åº”äºç¨‹åºä¸­çš„ä¸€ä¸ªå‡½æ•°è°ƒç”¨ã€‚ æ¥ç€ä¸Šä¸€ä¸ªä¾‹å­ï¼Œåˆ‡æ¢åˆ° main å‡½æ•°æ‰€åœ¨çš„æ ˆå¸§ï¼š (gdb) frame 1 #1 0x00005555555551d2 in main () at test.c:14 14 int result = foo(); ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:9","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"up/down up å’Œ down å‘½ä»¤ç”¨äºåœ¨è°ƒè¯•è¿‡ç¨‹ä¸­åœ¨ä¸åŒçš„æ ˆå¸§ä¹‹é—´è¿›è¡Œåˆ‡æ¢ï¼š up ç”¨äºåœ¨è°ƒç”¨æ ˆä¸­å‘ä¸Šç§»åŠ¨åˆ°è¾ƒé«˜çš„æ ˆå¸§ï¼Œå³è¿›å…¥è°ƒç”¨å½“å‰å‡½æ•°çš„å‡½æ•°ã€‚æ¯æ¬¡æ‰§è¡Œ up å‘½ä»¤ï¼ŒGDB å°†åˆ‡æ¢åˆ°ä¸Šä¸€ä¸ªï¼ˆæ›´é«˜å±‚æ¬¡ï¼‰çš„æ ˆå¸§ã€‚è¿™å¯ä»¥ç”¨äºæŸ¥çœ‹è°ƒç”¨å½“å‰å‡½æ•°çš„ä¸Šå±‚å‡½æ•°çš„æ‰§è¡Œä¸Šä¸‹æ–‡ã€‚ down ç”¨äºåœ¨è°ƒç”¨æ ˆä¸­å‘ä¸‹ç§»åŠ¨åˆ°è¾ƒä½çš„æ ˆå¸§ï¼Œå³è¿”å›åˆ°å½“å‰å‡½æ•°è°ƒç”¨çš„å‡½æ•°ã€‚æ¯æ¬¡æ‰§è¡Œ down å‘½ä»¤ï¼ŒGDB å°†åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªï¼ˆè¾ƒä½å±‚æ¬¡ï¼‰çš„æ ˆå¸§ã€‚è¿™å¯ä»¥ç”¨äºè¿”å›åˆ°è°ƒç”¨å½“å‰å‡½æ•°çš„å‡½æ•°çš„æ‰§è¡Œä¸Šä¸‹æ–‡ã€‚ è¿™ä¸¤ä¸ªå‘½ä»¤éœ€è¦å¼€å‘è€…å¯¹åº”å‡½æ•°è°ƒç”¨å †æ ˆçš„å¸ƒå±€æœ‰ä¸€å®šç¨‹åº¦çš„äº†è§£ã€‚ æ¥ç€ä¸Šä¸€ä¸ªä¾‹å­ï¼š (gdb) up #1 0x00005555555551d2 in main () at test.c:14 14 int result = foo(); (gdb) down #0 foo () at test.c:7 7 printf(\"bar = %d\\n\", bar); ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:10","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"info info (i) å‘½ä»¤ç”¨äºè·å–ç¨‹åºçŠ¶æ€å’Œè°ƒè¯•ç¯å¢ƒçš„ç›¸å…³ä¿¡æ¯ï¼Œè¯¥å‘½ä»¤åé¢å¯ä»¥è·Ÿéšä¸åŒçš„å­å‘½ä»¤ï¼Œç”¨äºè·å–ç‰¹å®šç±»å‹çš„ä¿¡æ¯ã€‚ ä¸€äº›å¸¸ç”¨çš„ info å­å‘½ä»¤ï¼š info breakpoints æ˜¾ç¤ºå·²è®¾ç½®çš„æ‰€æœ‰æ–­ç‚¹ (breakpoint) ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ–­ç‚¹ç¼–å·ã€æ–­ç‚¹ç±»å‹ã€æ–­ç‚¹ä½ç½®ç­‰ã€‚ info watchpoints æ˜¾ç¤ºå·²è®¾ç½®çš„æ‰€æœ‰ç›‘è§†ç‚¹ (watchpoint) ä¿¡æ¯ï¼ŒåŒ…æ‹¬ç›‘è§†ç‚¹ç¼–å·ã€ç›‘è§†ç‚¹ç±»å‹ã€ç›‘è§†çš„è¡¨è¾¾å¼ç­‰ã€‚ info locals æ˜¾ç¤ºå½“å‰å‡½æ•°çš„å±€éƒ¨å˜é‡çš„å€¼å’Œåç§°ã€‚ info args æ˜¾ç¤ºå½“å‰å‡½æ•°çš„å‚æ•°çš„å€¼å’Œåç§°ã€‚ info registers æ˜¾ç¤ºå½“å‰ CPU å¯„å­˜å™¨çš„å€¼ã€‚ info threads æ˜¾ç¤ºå½“å‰æ­£åœ¨è°ƒè¯•çš„æ‰€æœ‰çº¿ç¨‹ (thread) ä¿¡æ¯ï¼ŒåŒ…æ‹¬çº¿ç¨‹ç¼–å·ã€çº¿ç¨‹çŠ¶æ€ç­‰ã€‚ info frame æ˜¾ç¤ºå½“å‰æ ˆå¸§ (stack frame) çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬å‡½æ•°åç§°ã€å‚æ•°ã€å±€éƒ¨å˜é‡ç­‰ã€‚ info program æ˜¾ç¤ºè¢«è°ƒè¯•ç¨‹åºçš„ç›¸å…³ä¿¡æ¯ï¼Œä¾‹å¦‚ç¨‹åºå…¥å£åœ°å€ã€ç¨‹åºçš„åŠ è½½åœ°å€ç­‰ã€‚ (gdb) info breakpoints # or simply: i b Num Type Disp Enb Address What 1 breakpoint keep y 0x000055555555518f in foo at test.c:7 2 breakpoint keep y 0x0000555555555175 in foo at test.c:4 ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:11","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"delete delete (d) å‘½ä»¤ç”¨äºåˆ é™¤æ–­ç‚¹ (breakpoint) æˆ–è§‚å¯Ÿç‚¹ (watchpoint)ã€‚æ–­ç‚¹æ˜¯åœ¨ç¨‹åºæ‰§è¡ŒæœŸé—´æš‚åœæ‰§è¡Œçš„ç‰¹å®šä½ç½®ï¼Œè€Œè§‚å¯Ÿç‚¹æ˜¯åœ¨ç‰¹å®šæ¡ä»¶æ»¡è¶³æ—¶æš‚åœæ‰§è¡Œçš„ä½ç½®ã€‚ å¯ä»¥é€šè¿‡æŒ‡å®š æ–­ç‚¹ / è§‚å¯Ÿç‚¹ çš„ç¼–å·æˆ–ä½¿ç”¨ delete å‘½ä»¤ç›¸å…³çš„å‚æ•°ï¼Œæ¥åˆ é™¤å·²è®¾ç½®çš„æ–­ç‚¹ / è§‚å¯Ÿç‚¹ã€‚æ–­ç‚¹ / è§‚å¯Ÿç‚¹ç¼–å·å¯ä»¥åœ¨ä½¿ç”¨ info breakpoints / info watchpoints å‘½ä»¤æ—¶è·å¾—ã€‚ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:12","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"quit quit (q) å‘½ä»¤ç”¨äºé€€å‡º GDBï¼Œè¿”å›ç»ˆç«¯é¡µé¢ã€‚ (gdb) quit $ # Now, in the terminial ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:13","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"list list å‘½ä»¤ç”¨äºæ˜¾ç¤ºå½“å‰ä½ç½®çš„ä»£ç ç‰‡æ®µï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒä¼šæ˜¾ç¤ºå½“å‰ä½ç½®çš„å‰å10è¡Œä»£ç ã€‚ list å‘½ä»¤ä¹Ÿå¯ä»¥æ˜¾ç¤ºæŒ‡å®šèŒƒå›´çš„ä»£ç ï¼Œä½¿ç”¨ list \u003cstart\u003e,\u003cend\u003e å‘½ä»¤å°†æ˜¾ç¤ºä» start è¡Œåˆ° end è¡Œçš„æºä»£ç ã€‚ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:14","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"whatis whatis å‘½ä»¤ç”¨äºè·å–ç»™å®šæ ‡è¯†ç¬¦ï¼ˆå¦‚å˜é‡ã€å‡½æ•°æˆ–ç±»å‹ï¼‰çš„ç±»å‹ä¿¡æ¯ã€‚ // in source code int calendar[12][31]; // in gdb (gdb) whatis calendar type = int [12][31] ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:15","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"x x å‘½ä»¤ç”¨äºæŸ¥çœ‹å†…å­˜ä¸­çš„æ•°æ®ï¼Œä½¿ç”¨ x å‘½ä»¤æ­é…ä¸åŒçš„æ ¼å¼æ¥æ˜¾ç¤ºå†…å­˜ä¸­çš„æ•°æ®ï¼Œä¹Ÿå¯ä»¥æ­é… / åè·Ÿæ•°å­—æ¥æŒ‡å®šè¦æ˜¾ç¤ºçš„å†…å­˜å•å…ƒæ•°é‡ã€‚ä¾‹å¦‚ï¼Œx/4 \u003caddress\u003e è¡¨ç¤ºæ˜¾ç¤ºåœ°å€ address å¼€å§‹çš„è¿ç»­ 4 ä¸ªå†…å­˜å•å…ƒçš„å†…å®¹ã€‚ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:16","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"å…¶ä»– å¦‚æœè¢«è°ƒè¯•ç¨‹åºæ­£å¤„äºè¿è¡Œæ€ï¼ˆå³å·²ç»é€šè¿‡ run å‘½ä»¤æ¥è¿è¡Œç¨‹åºï¼‰ï¼Œæ­¤æ—¶å¯ä»¥é€šè¿‡ Ctrl+C æ¥ä¸­æ–­ GDBï¼Œç¨‹åºå°†è¢«ç«‹å³ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æ—¶æ‰€è¿è¡Œåˆ°çš„åœ°æ–¹æš‚åœã€‚è¿™ç§æ–¹å¼è¢«ç§°ä¸º æ‰‹åŠ¨æ–­ç‚¹ï¼Œæ‰‹åŠ¨æ–­ç‚¹å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªä¸´æ—¶æ–­ç‚¹ï¼Œåªä¼šåœ¨è¯¥å¤„æš‚åœä¸€æ¬¡ã€‚ GDB ä¼šå°†ç©ºç™½è¡Œçš„æ–­ç‚¹è‡ªåŠ¨ä¸‹ç§»åˆ°ä¸‹ä¸€éç©ºçš„ä»£ç è¡Œã€‚ set print pretty å‘½ä»¤å¯ä»¥ä»¥æ›´æ˜“è¯»å’Œæ ¼å¼åŒ–çš„æ–¹å¼æ˜¾ç¤ºç»“æ„åŒ–æ•°æ®ï¼Œä»¥æ›´å‹å¥½çš„æ–¹å¼è¾“å‡ºç»“æ„ä½“ã€ç±»ã€æ•°ç»„ç­‰å¤æ‚ç±»å‹çš„æ•°æ®ï¼Œæ›´æ˜“äºé˜…è¯»å’Œç†è§£ã€‚ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:5:17","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"References video: Linux basic anti-debug video: C Programming, Disassembly, Debugging, Linux, GDB rr (Record and Replay Framework) video: Quick demo video: Record and replay debugging with â€œrrâ€ ","date":"2024-01-16","objectID":"/posts/debug-gdb/:6:0","tags":["Debug","GDB","Rust","C/C++","Sysprog"],"title":"ç¨‹åºè°ƒè¯•å·¥å…· GDB","uri":"/posts/debug-gdb/"},{"categories":["C","Linux Kernel Internals"],"content":" ã€ŒæŒ‡é’ˆã€ æ‰®æ¼” ã€Œè®°å¿†ä½“ã€ å’Œ ã€Œç‰©ä»¶ã€ ä¹‹é—´çš„æ¡¥æ¢ åŸæ–‡åœ°å€ ","date":"2024-01-14","objectID":"/posts/c-pointer/:0:0","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"å‰è¨€æ‚è°ˆ Letâ€™s learn programming by inventing it [CppCon 2018] âœ… åœ¨ K\u0026R ä¸€ä¹¦ä¸­ï¼Œç›´åˆ° 93 é¡µæ‰å¼€å§‹è°ˆè®º pointerï¼Œè€Œå…¨ä¹¦æ€»è®¡ 185 é¡µï¼Œæ‰€ä»¥å¤§æ¦‚æ˜¯åœ¨å…¨ä¹¦ $50.27\\%$ çš„ä½ç½®æ‰å¼€å§‹è®² pointerã€‚æ‰€ä»¥å³ä½¿ä¸å­¦ pointerï¼Œä½ è¿˜æ˜¯èƒ½å¤ŸæŒæ¡ $~50\\%$ çš„ C è¯­è¨€çš„å†…å®¹ï¼Œä½†æ˜¯ C è¯­è¨€çš„æ ¸å¿ƒæ­£æ˜¯ pointerï¼Œæ‰€ä»¥ Good Luck ğŸ¤£ godbolt å¯ä»¥ç›´æ¥åœ¨ç½‘é¡µä¸Šçœ‹åˆ°ï¼Œæºä»£ç ç”±å„ç±» compiler ç”Ÿæˆçš„ Assembly Code How to read this prototype? [Stack Overflow] âœ… Note è¿™ä¸ªé—®é¢˜æ˜¯å…³äº signal ç³»ç»Ÿè°ƒç”¨çš„å‡½æ•°åŸå‹è§£è¯»ï¼Œé‡Œé¢çš„å›ç­”é¡µç»™å‡ºäº†å¾ˆå¤šå¯¹äºæŒ‡é’ˆï¼Œç‰¹åˆ«æ˜¯ å‡½æ•°æŒ‡é’ˆ çš„è¯´æ˜ï¼Œä¸‹é¢èŠ‚é€‰ä¸€äº›ç‰¹åˆ«æœ‰æ„æ€çš„å›ç­”ï¼š å¼•ç”¨ The whole thing declares a function called signal: signal takes an int and a function pointer this function pointer takes an int and returns void signal returns a function pointer this function pointer takes an intand returns avoid` Thatâ€™s where the last int comes in. You can use the spiral rule to make sense of such declarations, or the program cdecl(1). The whole thing declares a function called signal: è¿™é‡Œé¢æåˆ°äº† the spiral rule è¿™æ˜¯ä¸€ä¸ªç”¨äºè§£æ C è¯­è¨€ä¸­å£°æ˜ (declaration) çš„æ–¹æ³•ï¼›å¦å¤–è¿˜æåˆ°äº† cdecl è¿™ä¸€ç¨‹åºï¼Œå®ƒä¹Ÿæœ‰ç±»ä¼¼çš„ä½œç”¨ï¼Œå¯ä»¥ä½¿ç”¨è‹±æ–‡è¿›è¡Œå£°æ˜æˆ–è€…è§£é‡Šã€‚ å¼•ç”¨ Find the leftmost identifier and work your way out, remembering that [] and () bind before *; IOW, *a[] is an array of pointers, (*a)[] is a pointer to an array, *f() is a function returning a pointer, and (*f)() is a pointer to a function. Thus, void ( *signal(int sig, void (*handler)(int)) ) (int); breaks down as signal -- signal signal( ) -- is a function signal( sig ) -- with a parameter named sig signal(int sig, ) -- of type int signal(int sig, handler ) -- and a parameter named handler signal(int sig, *handler ) -- which is a pointer signal(int sig, (*handler)( )) ) -- to a function signal(int sig, (*handler)(int)) ) -- taking an int parameter signal(int sig, void (*handler)(int)) ) -- and returning void *signal(int sig, void (*handler)(int)) ) -- returning a pointer ( *signal(int sig, void (*handler)(int)) )( ) -- to a function ( *signal(int sig, void (*handler)(int)) )(int) -- taking an int parameter void ( *signal(int sig, void (*handler)(int)) )(int); -- and returning void è¿™ä¸€å›ç­”å¼ºè°ƒäº† * å’Œ []ã€() ä¼˜å…ˆçº§çš„å…³ç³»ï¼Œè¿™åœ¨åˆ¤æ–­æ•°ç»„æŒ‡é’ˆã€å‡½æ•°æŒ‡é’ˆæ—¶æ˜¯ä¸ªéå¸¸å¥½ç”¨çš„æŠ€å·§ã€‚ Rob Pike äº 2009/10/30 çš„ Golang Talk [PDF] David Brailsford æ•™æˆè§£è¯´å½±ç‰‡ Essentials: Pointer Power! - Computerphile [YouTube] ","date":"2024-01-14","objectID":"/posts/c-pointer/:1:0","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"é˜…è¯» C è¯­è¨€è§„æ ¼ä¹¦ ä¸€æ‰‹èµ„æ–™çš„é‡è¦æ€§æ¯‹åº¸ç½®ç–‘ï¼Œå¯¹äº C è¯­è¨€ä¸­çš„æ ¸å¿ƒæ¦‚å¿µ æŒ‡é’ˆï¼Œå€ŸåŠ©å®˜æ–¹è§„æ ¼ä¹¦æ¸…æ™°æ¦‚å¿µæ˜¯éå¸¸é‡è¦çš„ã€‚ C99 [6.2.5] Types An array type of unknown size is an incomplete type. It is completed, for an identifier of that type, by specifying the size in a later declaration (with internal or external linkage). A structure or union type of unknown content is an incomplete type. It is completed, for all declarations of that type, by declaring the same structure or union tag with its defining content later in the same scope. incomplete type å’Œ linkage é…åˆå¯ä»¥è¿›è¡Œ forward declarationï¼Œå¦‚æœæ­é… pointer åˆ™å¯ä»¥è¿›ä¸€æ­¥ï¼Œåœ¨æ— éœ€çŸ¥é“ object å†…éƒ¨ç»†èŠ‚å³å¯è¿›è¡Œç¨‹åºå¼€å‘ã€‚ Array, function, and pointer types are collectively called derived declarator types. A declarator type derivation from a type T is the construction of a derived declarator type from T by the application of an array-type, a function-type, or a pointer-type derivation to T. æ³¨æ„ derived declarator types è¡¨ç¤ºè¡ç”Ÿçš„å£°æ˜ç±»å‹ï¼Œå› ä¸º array, function, pointer æœ¬è´¨éƒ½æ˜¯åœ°å€ï¼Œè€Œå®ƒä»¬çš„ç±»å‹éƒ½æ˜¯ç”±å…¶å®ƒç±»å‹è¡ç”Ÿè€Œæ¥çš„ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨è¿™äº›æ‰€è°“çš„ derived declarator types æ¥æå‰å£°æ˜ objectï¼Œè¡¨ç¤ºåœ¨æŸä¸ªåœ°å€ä¼šå­˜å‚¨ä¸€ä¸ª objectï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¿™äº›ç±»å‹è¢«è§„æ ¼ä¹¦å®šä¹‰ä¸º derived declarator typesã€‚ lvalue: Locator value å±é™© C è¯­è¨€é‡Œåªæœ‰ call by value ","date":"2024-01-14","objectID":"/posts/c-pointer/:2:0","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"void \u0026 void * C89 ä¹‹å‰ï¼Œå‡½æ•°å¦‚æœæ²¡æœ‰æ ‡æ³¨è¿”å›ç±»å‹ï¼Œåˆ™é»˜è®¤è¿”å›ç±»å‹ intï¼Œè¿”å›å€¼ 0ã€‚ä½†ç”±äºè¿™æ ·æ—¢å¯ä»¥è¡¨ç¤ºè¿”å›å€¼ä¸é‡è¦ï¼Œä¹Ÿå¯ä»¥è¡¨ç¤ºè¿”å›å€¼ä¸º 0ï¼Œè¿™ä¼šé€ æˆæ­§ä¹‰ï¼Œæ‰€ä»¥å¼•è¿›äº† voidã€‚ void * åªèƒ½è¡¨ç¤ºåœ°å€ï¼Œè€Œä¸èƒ½å¯¹æ‰€æŒ‡å‘çš„åœ°å€åŒºåŸŸçš„å†…å®¹è¿›è¡Œæ“ä½œã€‚å› ä¸ºé€šè¿‡ void * æ— æ³•çŸ¥é“æ‰€æŒ‡å‘åŒºåŸŸçš„ sizeï¼Œæ‰€ä»¥æ— æ³•å¯¹åŒºåŸŸçš„å†…å®¹è¿›è¡Œæ“ä½œï¼Œå¿…é¡»å¯¹ void * è¿›è¡Œ æ˜¾ç¤ºè½¬æ¢ æ‰èƒ½æ“ä½œæŒ‡å‘çš„å†…å®¹ã€‚ï¼ˆé™¤æ­¤ä¹‹å¤–ï¼Œé’ˆå¯¹äº gccï¼Œå¯¹äºæŒ‡é’ˆæœ¬èº«çš„æ“ä½œï¼Œvoid * ä¸ char * æ˜¯ç­‰ä»·çš„ï¼Œå³å¯¹äº +/- 1 è¿™ç±»çš„æ“ä½œï¼ŒäºŒè€…çš„åç§»é‡æ˜¯ä¸€è‡´çš„ (è¿™æ˜¯ GNU extensions å¹¶ä¸æ˜¯ C è¯­è¨€æ ‡å‡†)ï¼›å¯¹äºå…¶å®ƒçš„ç¼–è¯‘å™¨ï¼Œå»ºè®®å°† void * è½¬æ¢æˆ char * å†è¿›è¡ŒæŒ‡é’ˆçš„åŠ å‡è¿ç®—ï¼‰ ","date":"2024-01-14","objectID":"/posts/c-pointer/:3:0","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"Alignment è¿™éƒ¨åˆ†åŸæ–‡æè¿°ä¸æ˜¯å¾ˆæ¸…æ™°ï¼Œ2-byte aligned å›¾ç¤ºå¦‚ä¸‹ï¼š Alignment å¦‚æœæ˜¯ 2-byte aligned ä¸”æ˜¯ little-endian çš„å¤„ç†å™¨ï¼Œå¯¹äºå·¦è¾¹ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ *(uint16_t *) ptrï¼Œä½†å¯¹äºå³è¾¹å°±æ— æ³•è¿™æ ·ï¼ˆä¸ç¬¦åˆ alignmentï¼‰ï¼š /* may receive wrong value if ptr is not 2-byte aligned */ uint16_t value = *(uint16_t *) ptr; /* portable way of reading a little-endian value */ uint16_t value = *(uint8_t *) ptr | ((*(uint8_t *) (ptr + 1)) \u003c\u003c 8); å› ä¸ºå†…å­˜å¯»å€çš„æœ€å°ç²’åº¦æ˜¯ Byteï¼Œæ‰€ä»¥ä½¿ç”¨ (uint_8 *) ä¸éœ€è¦æ‹…å¿ƒ alignment çš„é—®é¢˜ã€‚åŸæ–‡å¹¶æ²¡æœ‰ç»™å‡º 32-bit aligned çš„ portable wayï¼Œæˆ‘ä»¬æ¥å†™ä¸€ä¸‹ï¼š /* may receive wrong value if ptr is not 2-byte aligned */ uint32_t value = *(uint32_t *) ptr; /* portable way of reading a little-endian value */ uint32_t value = *(uint8_t *) ptr | ((*(uint8_t *) (ptr + 1)) \u003c\u003c 8) | ((*(uint8_t *) (ptr + 2)) \u003c\u003c 16) | ((*(uint8_t *) (ptr + 3)) \u003c\u003c 24); ä¿¡æ¯ The Lost Art of Structure Packing ","date":"2024-01-14","objectID":"/posts/c-pointer/:3:1","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"è§„æ ¼ä¹¦ä¸­çš„ Pointer C99 [6.3.2.3] Pointers A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. Ifaconverted pointer is used to call a function whose type is not compatible with the pointed-to type, the behavior is undefined. C11 [6.3.2.3] Pointers A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. If a converted pointer is used to call a function whose type is not compatible with the referenced type, the behavior is undefined. C99 å’Œ C11 éƒ½ä¸ä¿è¯ pointers (whose type is not compatible with the pointed-to / referenced type) ä¹‹é—´çš„è½¬æ¢æ˜¯æ­£ç¡®çš„ã€‚ å¯¼è‡´è¿™ä¸ªçš„åŸå› æ­£æ˜¯ä¹‹å‰æ‰€æçš„ Alignmentï¼Œè½¬æ¢åçš„æŒ‡é’ˆç±»å‹ä¸ä¸€å®šæ»¡è¶³åŸæœ‰ç±»å‹çš„ Alignment è¦æ±‚ï¼Œè¿™ç§æƒ…å†µä¸‹è¿›è¡Œ dereference ä¼šå¯¼è‡´å¼‚å¸¸ã€‚ä¾‹å¦‚å°†ä¸€ä¸ª char * æŒ‡é’ˆè½¬æ¢æˆ int * æŒ‡é’ˆï¼Œç„¶åè¿›è¡Œ deference æœ‰å¯èƒ½ä¼šäº§ç”Ÿå¼‚å¸¸ã€‚ ","date":"2024-01-14","objectID":"/posts/c-pointer/:3:2","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"Pointers vs. Arrays C99 6.3.2.1 Except when it is the operand of the sizeof operator or the unary \u0026 operator, or is a string literal used to initialize an array, an expression that has type â€˜â€˜array of typeâ€™â€™ is converted to an expression with type â€˜â€˜pointer to typeâ€™â€™ that points to the initial element of the array object and is not an lvalue. Array åªæœ‰åœ¨è¡¨ç¤ºå…¶è‡ªèº«ä¸ºæ•°ç»„æ—¶æ‰ä¸ä¼šè¢« converted to Pointerï¼Œä¾‹å¦‚ // case 1: extern declaration of array extern char a[]; // case 2: defintion of array char a[10]; // case 3: size of array sizeof(a); // case 4: address of array \u0026a åœ¨å…¶ä»–æƒ…å†µåˆ™ä¼šå€ converted to Pointerï¼Œè¿™æ—¶ Array å¯ä»¥å’Œ Pointer äº’æ¢è¿›è¡Œè¡¨ç¤ºæˆ–æ“ä½œï¼Œä¾‹å¦‚ // case 1: function parameter void func(char a[]); void func(char *a); // case 2: operation in expression char c = a[2]; char c = *(a + 2); è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆå¯¹äºä¸€ä¸ª Array aï¼Œ\u0026a å’Œ \u0026a[0] å€¼è™½ç„¶ç›¸åŒï¼Œä½† \u0026a + 1 å’Œ \u0026a[0] + 1 çš„ç»“æœå¤§éƒ¨åˆ†æ—¶å€™æ˜¯å¤§ä¸ç›¸åŒçš„ï¼Œè¿™ä»¶äº‹ä¹ä¸€çœ‹æ˜¯éå¸¸æƒŠäººçš„ï¼Œä½†å…¶å®ä¸ç„¶ï¼Œåœ¨äº†è§£ Array å’Œ Pointer ä¹‹åï¼Œä¹Ÿå°±é‚£ä¹ˆä¸€å›äº‹ ğŸ¤£ Source ","date":"2024-01-14","objectID":"/posts/c-pointer/:4:0","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"GDB å®ä½œ char a[10]; int main() { return 0; }; æˆ‘ä»¬ä»¥ä¸Šé¢è¿™ä¸ªä¾‹å­ï¼Œé€šè¿‡ GDB æ¥å¯¹ Array å’Œ Pointer è¿›è¡Œæ·±å…¥ç ”ç©¶ï¼š (gdb) print \u0026a $1 = (char (*)[10]) 0x555555558018 \u003ca\u003e (gdb) print \u0026a[0] $2 = 0x555555558018 \u003ca\u003e \"\" ç¬¦åˆé¢„æœŸï¼Œ\u0026a å’Œ \u0026a[0] å¾—åˆ°çš„å€¼æ˜¯ç›¸åŒçš„ï¼Œè™½ç„¶ç±»å‹çœ‹èµ·æ¥ä¸åŒï¼Œä½†æ˜¯ç°åœ¨å…ˆæ”¾åˆ°ä¸€è¾¹ã€‚ (gdb) print \u0026a + 1 $3 = (char (*)[10]) 0x555555558022 (gdb) print \u0026a[0] + 1 $4 = 0x555555558019 \u003ca+1\u003e \"\" (gdb) print a + 1 $5 = 0x555555558019 \u003ca+1\u003e \"\" Oh! æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€è¯´çš„ \u0026a + 1 ä¸ \u0026a[0] + 1 ç»“æœå¹¶ä¸ç›¸åŒï¼ˆè€Œ \u0026a[0] + 1 å’Œ a + 1 ç»“æœç›¸åŒæ­£æ˜¯æˆ‘ä»¬æ‰€æåˆ°çš„ Array é€€åŒ–ä¸º Pointerï¼‰ï¼Œè™½ç„¶å¦‚æ­¤ï¼ŒGDB æ‰€ç»™çš„ä¿¡æ¯æç¤ºæˆ‘ä»¬å¯èƒ½æ˜¯äºŒè€… Pointer ç±»å‹ä¸ç›¸åŒå¯¼è‡´çš„ã€‚ (gdb) whatis \u0026a type = char (*)[10] (gdb) whatis \u0026a[0] type = char * Great! æœç„¶æ˜¯ Pointer ç±»å‹ä¸åŒå¯¼è‡´çš„ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° \u0026a çš„ç±»å‹æ˜¯ char (*)[10] ä¸€ä¸ªæŒ‡å‘ Array çš„æŒ‡é’ˆï¼Œ\u0026a[0] åˆ™æ˜¯ char *ã€‚æ‰€ä»¥è¿™ä¸¤ä¸ª Pointer åœ¨è¿›è¡Œ +/- è¿ç®—æ—¶çš„åç§»é‡æ˜¯ä¸åŒçš„ï¼Œ\u0026a[0] çš„åç§»é‡ä¸º sizeof(a[0]) å³ä¸€ä¸ª char çš„å®½åº¦ ($0x18 + 1 = 0x19$)ï¼Œè€Œ \u0026a çš„åç§»é‡ä¸º sizeof(a) å³ 10 ä¸ª char çš„å®½åº¦ ($0x18 + 10 = 0x22$)ã€‚ è­¦å‘Š åœ¨ GDB ä¸­ä½¿ç”¨ memcpy åç›´æ¥æ‰“å°å¯èƒ½ä¼šå‡ºç°ä»¥ä¸‹é”™è¯¯ï¼š (gdb) p memcpy(calendar, b, sizeof(b[0])) 'memcpy' has unknown return type; cast the call to its declared return type åªéœ€åŠ å…¥ void * è¿›è¡Œç±»å‹è½¬æ¢å³å¯è§£å†³è¯¥é—®é¢˜ï¼š (gdb) p (void *) memcpy(calendar, b, sizeof(b[0])) ... æŠ€å·§ é‡åˆ°é™Œç”Ÿçš„å‡½æ•°ï¼Œå¯ä»¥ä½¿ç”¨ man æ¥å¿«é€ŸæŸ¥é˜…æ‰‹å†Œï¼Œä¾‹å¦‚ man strcpy, man strcatï¼Œæ‰‹å†Œå¯ä»¥è®©æˆ‘ä»¬å¿«é€ŸæŸ¥è¯¢å‡½æ•°çš„ä¸€äº›ä¿¡æ¯ï¼Œä»è€Œè¿›å…¥å®ä½œã€‚ ","date":"2024-01-14","objectID":"/posts/c-pointer/:4:1","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"Runtime Environment æ ¹æ® Zero size arrays in C ï¼ŒåŸæ–‡ä¸­çš„ char (*argv)[0] åœ¨å‡½æ•°å‚æ•°ä¼ é€’æ—¶ä¼šè¢«è½¬æ¢æˆ char **argvã€‚è€Œä¸ºä»€ä¹ˆåœ¨æŸ¥çœ‹åœ°å€ ((char **) argv)[0] å¼€å§‹çš„è¿ç»­ 4 ä¸ª char * å†…å®¹æ—¶ï¼Œä¼šæ‰“å°å‡º envp ä¸­çš„å†…å®¹ï¼Œå¯ä»¥å‚è€ƒä»¥ä¸‹çš„è¿›å…¥ main å‡½æ•°æ—¶çš„æ ˆå¸ƒå±€ï¼š argv å’Œ envp æ‰€æŒ‡çš„å­—ç¬¦ä¸²åŒºåŸŸæ˜¯ç›¸è¿çš„ï¼Œæ‰€ä»¥åœ¨è¶Šè¿‡ argv å­—ç¬¦ä¸²åŒºåŸŸçš„è¾¹ç•Œåï¼Œä¼šç»§ç»­æ‰“å° envp åŒºåŸŸçš„å­—ç¬¦ä¸²ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæ‰“å°å‡ºçš„å­—ç¬¦ä¸²ä¹‹é—´åœ°å€å¢é•¿äºå…¶é•¿åº¦ç›¸åŒ¹é…ã€‚æ‰€ä»¥ä»åœ°å€ (char **) argv å¼€å§‹çš„åŒºåŸŸåªæ˜¯ä¸€ä¸ª char * æ•°ç»„ï¼Œä½¿ç”¨ x/4s å¯¹è¿™éƒ¨åˆ†è¿›è¡Œå­—ç¬¦ä¸²æ ¼å¼æ‰“å°æ˜¾ç„¶æ˜¯çœ‹ä¸æ‡‚çš„ã€‚ æ³¨æ„ argv å’Œ envp éƒ½æ˜¯åœ¨ shell è¿›è¡Œ exec ç³»ç»Ÿè°ƒç”¨ä¹‹å‰è¿›è¡Œä¼ é€’ï¼ˆäº‹å®ä¸Šæ˜¯ä»¥ arguments çš„å½¢å¼ä¼ é€’ç»™ execï¼‰ man 2 execve int execve(const char *pathname, char *const argv[], char *const envp[]); execve å®é™…ä¸Šåœ¨å†…éƒ¨è°ƒç”¨äº† forkï¼Œæ‰€ä»¥ argv å’Œ envp çš„ä¼ é€’æ˜¯åœ¨ fork ä¹‹å‰ã€‚ï¼ˆè®¾æƒ³å¦‚æœæ˜¯åœ¨ fork ä¹‹åä¼ é€’ï¼Œå¯èƒ½ä¼šå‡ºç° fork å child process å…ˆæ‰§è¡Œï¼Œè¿™ç§æƒ…å†µ child process æ˜¾ç„¶æ— æ³•è·å¾—è¿™äº›è¢«ä¼ é€’çš„ä¿¡æ¯ï¼‰ æ³¨æ„åˆ° execve åªä¼ é€’äº† argv è€Œæ²¡æœ‰ä¼ é€’ argcï¼Œè¿™ä¹Ÿå¾ˆå®¹æ˜“ç†è§£ï¼Œargc æ˜¯ argv çš„è®¡æ•°ï¼Œåªéœ€ argv å³å¯æ¨å¯¼å‡º argcã€‚ ","date":"2024-01-14","objectID":"/posts/c-pointer/:4:2","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"Function Pointer å±é™© ä¸ Array ç±»ä¼¼ï¼ŒFunction åªæœ‰åœ¨è¡¨ç¤ºè‡ªèº«æ—¶ä¸ä¼šè¢« converted to Function Pointer (å³é™¤ sizeof å’Œ \u0026 è¿ç®—ä¹‹å¤–)ï¼Œå…¶å®ƒæƒ…å†µã€è¿ç®—æ—¶éƒ½ä¼šè¢« convert to Function Pointer ç†è§£ C è¯­è¨€ä¸­çš„ Function ä»¥åŠ Function Pointer çš„æ ¸å¿ƒåœ¨äºç†è§£ Function Designator è¿™ä¸ªæ¦‚å¿µï¼Œå‡½æ•°åå­—å¿…ç„¶æ˜¯ Function Designatorï¼Œå…¶å®ƒçš„ designator åˆ™æ˜¯æ ¹æ®ä»¥ä¸‹ä¸¤æ¡è§„åˆ™è¿›è¡Œæ¨å¯¼å¾—æ¥ã€‚ C99 [ 6.3.2.1 ] A function designator is an expression that has function type. Except when it is the operand of the sizeof operator or the unary \u0026 operator, a function designator with type â€˜â€˜function returning typeâ€™â€™ is converted to an expression that has type â€˜â€˜pointer to function returning typeâ€™â€™. C99 [6.5.3.2-4] The unary * operator denotes indirection. If the operand points to a function, the result is a function designator. ","date":"2024-01-14","objectID":"/posts/c-pointer/:5:0","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"æŒ‡é’ˆçš„ä¿®é¥°ç¬¦ æŒ‡é’ˆ p è‡ªèº«ä¸èƒ½å˜æ›´ï¼Œæ—¢ä¸èƒ½æ”¹å˜ p è‡ªèº«æ‰€å­˜å‚¨çš„åœ°å€ã€‚const åœ¨ * ä¹‹åï¼š char * const p; æŒ‡é’ˆ p æ‰€æŒ‡å‘çš„å†…å®¹ä¸èƒ½å˜æ›´ï¼Œå³ä¸èƒ½é€šè¿‡ p æ¥æ›´æ”¹æ‰€æŒ‡å‘çš„å†…å®¹ã€‚const åœ¨ * ä¹‹å‰ï¼š const char * p; char const * p; æŒ‡é’ˆ p è‡ªèº«äºæ‰€æŒ‡å‘çš„å†…å®¹éƒ½ä¸èƒ½å˜æ›´ï¼š const char * const p; char const * const p; ","date":"2024-01-14","objectID":"/posts/c-pointer/:6:0","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"å­—ç¬¦ä¸² å¯¹äºå‡½æ•°å†…éƒ¨çš„ char *p = \"hello\"; char p[] = \"hello\"; è¿™ä¸¤ä¸ªæ˜¯ä¸ä¸€æ ·çš„ï¼Œå› ä¸º string literals æ˜¯å¿…é¡»æ”¾åœ¨ â€œstatic storageâ€ ä¸­ï¼Œè€Œ char p[] åˆ™è¡¨ç¤ºå°†èµ„æ–™åˆ†é…åœ¨ stack å…§ï¼Œæ‰€ä»¥è¿™ä¼šé€ æˆç¼–è¯‘å™¨éšå¼åœ°ç”Ÿæˆé¢å¤–ä»£ç ï¼Œåœ¨æ‰§è¡Œæ—¶ (runtime) å°† string literals ä» static storage æ‹·è´åˆ° stack ä¸­ï¼Œæ‰€ä»¥æ­¤æ—¶ return p ä¼šé€ æˆ UBã€‚è€Œ char *p çš„æƒ…å½¢ä¸åŒï¼Œæ­¤æ—¶ p åªæ˜¯ä¸€ä¸ªæŒ‡å‘ static storage çš„æŒ‡é’ˆï¼Œè¿›è¡Œ return p æ˜¯åˆæ³•çš„ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œæ— æ³•å¯¹ç¬¬ä¸€ç§æ–¹æ³•çš„å­—ç¬¦ä¸²è¿›è¡Œä¿®æ”¹æ“ä½œï¼Œå› ä¸ºå®ƒæŒ‡å‘çš„å­—ç¬¦ä¸²å­˜æ”¾çš„åŒºåŸŸçš„èµ„æ–™æ˜¯æ— æ³•ä¿®æ”¹çš„ï¼Œå¦åˆ™ä¼šé€ æˆ segmentationfalut ğŸ¤£ åœ¨å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œnull pointer å¹¶ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥åœ¨ glibc ä¸­å­—ç¬¦ç›¸å…³çš„å¤§éƒ¨åˆ†å‡½æ•°ä¹Ÿä¸ä¼šå¯¹ null pointer è¿›è¡Œç‰¹åˆ¤ (ç‰¹åˆ¤ä¼šå¢åŠ åˆ†æ”¯ï¼Œä»è€Œå½±å“ç¨‹åºæ•ˆèƒ½)ï¼Œæ‰€ä»¥åœ¨è°ƒç”¨è¿™äº›å‡½æ•°æ—¶éœ€è¦ç”¨æˆ·è‡ªå·±åˆ¤æ–­æ˜¯å¦ä¸º null pointerï¼Œå¦åˆ™ä¼šé€ æˆ UBã€‚ ","date":"2024-01-14","objectID":"/posts/c-pointer/:7:0","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"Linus çš„â€œæ•™å¯¼â€ Linus è¦ªè‡ªæ•™ä½  C èªè¨€ array argument çš„ä½¿ç”¨ because array arguments in C donâ€™t actually exist. Sadly, compilers accept it for various bad historical reasons, and silently turn it into just a pointer argument. There are arguments for them, but they are from weak minds. The â€œarray as function argumentâ€ syntax is occasionally useful (particularly for the multi-dimensional array case), so I very much understand why it exists, I just think that in the kernel weâ€™d be better off with the rule that itâ€™s against our coding practices. array argument åº”è¯¥åªç”¨äºå¤šç»´æ•°ç»„ (multi-dimensional arrays) çš„æƒ…å½¢ï¼Œè¿™æ ·å¯ä»¥ä¿è¯ä½¿ç”¨ä¸‹æ ‡è¡¨ç¤ºæ—¶ offset æ˜¯æ­£ç¡®çš„ï¼Œä½†å¯¹äºä¸€ç»´æ•°ç»„åˆ™ä¸åº”è¯¥ä½¿ç”¨æ•°ç»„è¡¨ç¤ºä½œä¸ºå‡½æ•°å‚æ•°ï¼Œå› ä¸ºè¿™ä¼šå¯¹å‡½æ•°ä½“å†…çš„ sizeof ç”¨æ³•è¯¯è§£ (ä»¥ä¸ºä¼šè·å¾—æ•°ç»„çš„ sizeï¼Œå®é™…ä¸Šè·å¾—çš„åªæ˜¯æŒ‡é’ˆçš„ size)ã€‚ æŠ€å·§ ä¸€ä¸ªå¸¸ç”¨äºè®¡ç®—æ•°ç»„ä¸­å…ƒç´ ä¸ªæ•°çš„å®ï¼š #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0])) è¿™ä¸ªå®éå¸¸æœ‰ç”¨ï¼Œxv6 ä¸­ä½¿ç”¨åˆ°äº†è¿™ä¸ªå®ã€‚ ä½†æ˜¯éœ€è¦æ³¨æ„ï¼Œä½¿ç”¨æ—¶å¿…é¡»ä¿è¯ x æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œè€Œä¸æ˜¯å‡½æ•°å‚æ•°ä¸­ç”±æ•°ç»„é€€åŒ–è€Œæ¥çš„æŒ‡é’ˆï¼Œä»¥åŠä¿è¯æ•°ç»„å¿…é¡»è‡³å°‘æ‹¥æœ‰ä¸€ä¸ªå…ƒç´ çš„é•¿åº¦ (è¿™ä¸ªå¾ˆå®¹æ˜“æ»¡è¶³ï¼Œæ¯•ç«Ÿ x[0] ç¼–è¯‘å™¨ä¼šæŠ›å‡ºè­¦å‘Š)ã€‚ ","date":"2024-01-14","objectID":"/posts/c-pointer/:8:0","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["C","Linux Kernel Internals"],"content":"Lvalue \u0026 Rvalue Lvalue: locator value Rvalue: Read-only value C99 6.3.2.1 footnote The name â€œlvalueâ€ comes originally from the assignment expression E1 = E2, in which the left operand E1 is required to be a (modifiable) lvalue. It is perhaps better considered as representing an object â€œlocator valueâ€. What is sometimes called â€œrvalueâ€ is in this International Standard described as the â€œvalue of an expressionâ€. An obvious example of an lvalue is an identifier of an object. As a further example, if E is a unary expression that is a pointer to an object, *E is an lvalue that designates the object to which E points. å³åœ¨ C è¯­è¨€ä¸­ lvalue æ˜¯å¿…é¡»èƒ½åœ¨å†…å­˜ (memory) ä¸­å¯ä»¥å®šä½ (locator) çš„ä¸œè¥¿ï¼Œå› ä¸ºå¯ä»¥å®šä½ (locator) æ‰€ä»¥æ‰å¯ä»¥åœ¨è¡¨è¾¾å¼å·¦è¾¹ä»è€Œä¿®æ”¹å€¼ã€‚æƒ³åƒä¸€ä¸‹ï¼Œåœ¨ C è¯­è¨€ä¸­ä¿®æ”¹ä¸€ä¸ªå¸¸æ•°çš„å€¼æ˜¾ç„¶æ˜¯ä¸å¯èƒ½çš„ï¼Œå› ä¸ºå¸¸æ•°æ— æ³•åœ¨å†…å­˜ (memory) å®šä½ (locator) æ‰€ä»¥å¸¸æ•°åœ¨ C è¯­è¨€ä¸­ä¸æ˜¯ lvalueã€‚C è¯­è¨€ä¸­é™¤äº† lvalue ä¹‹å¤–çš„ value éƒ½æ˜¯ rvalue (è¿™ä¸ C++ æœ‰äº›ä¸åŒï¼ŒC++ çš„ lvalue å’Œ rvalue çš„å®šä¹‰è¯·å‚è€ƒ C++ çš„è§„æ ¼ä¹¦)ã€‚ ","date":"2024-01-14","objectID":"/posts/c-pointer/:9:0","tags":["Sysprog","C","Pointer"],"title":"ä½ æ‰€ä¸çŸ¥é“çš„ C è¯­è¨€: æŒ‡é’ˆç¯‡","uri":"/posts/c-pointer/"},{"categories":["Systems"],"content":"ä¹‹å‰å­¦æ ¡çš„è®¡ç½‘ç†è®ºè¯¾å­¦å¾—äº‘é‡Œé›¾é‡Œï¼Œå¯¹äºç‰©ç†å±‚å’Œæ•°æ®é“¾è·¯å±‚å¹¶æ²¡æœ‰æ¸…æ™°çš„é€»è¾‘æ¡†æ¶ï¼Œè€Œè¿™å­¦æœŸçš„è®¡ç½‘è¯¾è®¾å†…å®¹ä¸ºæ•°æ®é“¾è·¯å±‚å’Œç½‘ç»œå±‚çš„ç›¸å…³å†…å®¹ï¼Œå†™èµ·æ¥è¿˜æ˜¯äº‘é‡Œé›¾é‡Œã€‚è™½ç„¶æœ€ç»ˆè‰°éš¾åœ°æŠŠè¯¾è®¾æ°´è¿‡å»äº†ï¼Œä½†æ˜¯ä¸ªäººè®¤ä¸ºç½‘ç»œå¯¹äº CSer éå¸¸é‡è¦ï¼Œç‰¹åˆ«æ˜¯åœ¨äº’è”ç½‘è¡Œä¸šï¼Œç½‘ç»œçŸ¥è¯†æ˜¯å¿…ä¸å¯å°‘çš„ã€‚ æ‰€ä»¥å†³å®šå¯’å‡é‡å­¦è®¡ç½‘ï¼Œäºæ˜¯åœ¨ HackMD ä¸Šå†²æµªå¯»æ‰¾ç›¸å…³èµ„æ–™ã€‚ç„¶åå‘ç°äº†è¿™ç¯‡ç¬”è®° 110-1 è¨ˆç®—æ©Ÿç¶²è·¯ (æ¸…å¤§é–‹æ”¾å¼èª²ç¨‹)ï¼Œé‡Œé¢æåˆ°æ¸…å¤§è®¡ç½‘ä¸»è¦ä»‹ç» L2 ~ L4 ä¸€äº›è‘—åçš„åè®®å’Œç®—æ³•ï¼Œè¿™å®Œç¾ç¬¦åˆä¸ªäººçš„éœ€æ±‚ï¼Œè€Œä¸”è¯¥ç¬”è®°è¿˜è¡¥å……äº†ä¸€äº›é¢å¤–çš„å†…å®¹ï¼Œä¾‹å¦‚ IPv6ï¼Œæ‰€ä»¥å½“å³å†³å®šæ­é…è¿™ç¯‡ç¬”è®°æ¥å­¦ä¹ æ¸…å¤§çš„è®¡ç®—æœºç½‘ç»œæ¦‚è®ºã€‚ ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:0:0","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"æ¸…å¤§è®¡ç®—æœºç½‘ç»œæ¦‚è®º æœ¬èª²ç¨‹å°‡ä»‹ç´¹è¨ˆç®—æ©Ÿç¶²è·¯çš„åŸºæœ¬é‹ä½œåŸç†èˆ‡æ¨™æº–çš„ç¶²è·¯ä¸ƒå±¤çµæ§‹,ç”±æ·ºå…¥æ·±,å¯ä»¥è®“æˆ‘å€‘å°æ–¼è¨ˆç®—æ©Ÿç¶²è·¯çš„é‹ä½œæœ‰æœ€åŸºæœ¬çš„èªè­˜,æœ¬èª²ç¨‹é‚„æœƒä»‹ç´¹å…¨çƒå»ºç½®æœ€å¤šçš„æœ‰ç·šç¶²è·¯â”€â”€IEEE 802.3 Ethernet çš„åŸºæœ¬é‹ä½œåŸç†, é‚„æœ‰å…¨çƒå»ºç½®æœ€å¤šçš„ç„¡ç·šå€åŸŸç¶²è·¯â”€â”€IEEE 802.11 Wireless LAN çš„åŸºæœ¬é‹ä½œåŸç†, æƒ³çŸ¥é“ç¶²è·¯äº¤æ›æ©Ÿ(switches) æ˜¯å¦‚ä½•é‹ä½œçš„å— ? æƒ³çŸ¥é“ç¶²éš›ç¶²è·¯æœ€é‡è¦ä¹Ÿæœ€é—œéµçš„é€šè¨Šå”è­° â”€â”€ TCP/IP æ˜¯å¦‚ä½•é‹ä½œçš„å— ? æƒ³çŸ¥é“ç¶²éš›ç¶²è·¯æœ€é‡è¦çš„è·¯ç”±å™¨ (Routers) æ˜¯å¦‚ä½•é‹ä½œçš„å— ? åœ¨æœ¬èª²ç¨‹è£¡æ‚¨éƒ½å¯ä»¥å­¸åˆ°é€™äº›é‡è¦çš„åŸºæœ¬çŸ¥è­˜ã€‚ å¼€è¯¾å­¦æ ¡ è¯¾ç¨‹ä¸»é¡µ è¯¾ç¨‹èµ„æ–™ è¯¾ç¨‹å½±ç‰‡ åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯æ¦‚è«– èª²ç¨‹è¬›ç¾©èˆ‡ç·´ç¿’é¡Œ Youtube ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:1:0","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"Foundation Outline: Applications Network Connectivity Network Architecture Network Performance ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:0","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"Applications Foundation - 5 è¿›è¡Œ 1 æ¬¡ URL request éœ€è¦è¿›è¡Œ 17 æ¬¡çš„è®¯æ¯äº¤æ¢ï¼š 6 æ¬¡è®¯æ¯äº¤æ¢ç”¨äºæŸ¥è¯¢ URL å¯¹åº”çš„ IP Address 3 æ¬¡è®¯æ¯äº¤æ¢ç”¨äºå»ºç«‹ TCP è¿æ¥ï¼ˆTCP çš„ 3 æ¬¡æ¡æ‰‹ï¼‰ 4 æ¬¡è®¯æ¯äº¤æ¢ç”¨äº HTTP åè®®çš„è¯·æ±‚å’Œå›å¤ 4 æ¬¡è®¯æ¯äº¤æ¢ç”¨äºå…³é—­ TCP è¿æ¥ï¼ˆTCP çš„ 4 æ¬¡æ¡æ‰‹ï¼‰ ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:1","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"Network Connectivity Foundation - 8 äº¤æ¢æœº (Switches) å¯ä»¥åˆ†ä¸ºå¾ˆå¤šå±‚çº§ï¼Œå³å¯ä»¥æœ‰ä¸åŒå±‚çº§çš„äº¤æ¢æœºï¼Œä¾‹å¦‚ L2 å±‚çš„äº¤æ¢æœºï¼ŒL3 å±‚çš„äº¤æ¢æœºä»¥åŠ L4 å±‚çš„äº¤æ¢æœºã€‚å¦‚ä½•åˆ¤æ–­äº¤æ¢æœºæ˜¯å“ªä¸ªå±‚çº§ï¼Ÿå¾ˆç®€å•ï¼Œåªéœ€è¦æ ¹æ®äº¤æ¢æœºæ‰€å¤„ç†çš„è®¯æ¯ï¼ŒL2 å±‚äº¤æ¢æœºå¤„ç†çš„æ˜¯ MAC Addressï¼ŒL3 å±‚äº¤æ¢æœºå¤„ç†çš„æ˜¯ IP Addressï¼Œè€Œ L4 å±‚äº¤æ¢æœºå¤„ç†çš„æ˜¯ TCP æˆ–è€… UDP ç›¸å…³çš„è®¯æ¯ã€‚ äº¤æ¢æœº (Switches) ç”¨äºç½‘ç»œ (Network) å†…éƒ¨çš„è¿æ¥ï¼Œè·¯ç”± (Router) ç”¨äºè¿æ¥ä¸åŒçš„ç½‘ç»œ (Network)ï¼Œä»è€Œå½¢æˆ Internetworkã€‚ åœ°å€ (Address)ï¼Œå¯¹äºç½‘å¡æ¥è¯´æ˜¯æŒ‡ MAC Addressï¼Œå¯¹äºä¸»æœºæ¥è¯´æ˜¯æŒ‡ IP Addressã€‚Host-to-Host connectivity æ˜¯æŒ‡ä¸åŒç½‘ç»œ (Network) çš„ä¸»æœºï¼Œå³ä½äº Internetwork çš„ä¸åŒä¸»æœºä¹‹é—´ï¼Œè¿›è¡Œè¿æ¥ã€‚ ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:2","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"Network Architecture Foundation - 22 Physical Layer: å¦‚ä½•å°†åŸå§‹èµ„æ–™åœ¨ link ä¸Šä¼ è¾“ï¼Œä¾‹å¦‚ä¸åŒä»‹è´¨ã€ä¿¡æ¯ç¼–ç ã€‚(P25) Data Link Layer: åœ¨ Physical Layer åŸºç¡€ä¸Šï¼Œå¦‚ä½•å°† frame ä¼ ç»™ç›´æ¥ç›¸è¿çš„ä¸»æœºæˆ–è®¾å¤‡ï¼Œæ ¸å¿ƒæ˜¯é€šè¿‡ Media Access Control Protocol è§£å†³ Multiple access äº§ç”Ÿçš„ç¢°æ’é—®é¢˜ã€‚è¿™ä¸€å±‚äº¤æ¢çš„æ•°æ®è¢«ç§°ä¸º frameã€‚(P26) Network Layer: åœ¨ Data Link Layer åŸºç¡€ä¸Šï¼Œå¦‚ä½•å°† packet é€šè¿‡ Internet é€ç»™ç›®çš„åœ°ä¸»æœºã€‚æ ¸å¿ƒæ˜¯é€šè¿‡ Routing Protocols åŠ¨æ€è½¬å‘ packetã€‚è¿™ä¸€å±‚äº¤æ¢çš„æ•°æ®è¢«ç§°ä¸º packetã€‚(P27) Transport Layer: åœ¨ Network Layer åŸºç¡€ä¸Šï¼Œæä¾›ä¸åŒä¸»æœº processes ä¹‹é—´çš„èµ„æ–™ä¼ é€ã€‚ç”±äº Networkd Layer æ˜¯ä¸»æœºé—´è¿›è¡Œèµ„æ–™ä¼ é€ï¼Œæ‰€ä»¥åœ¨ Transport Layer ä¸è®ºæ˜¯å¯é è¿˜æ˜¯ä¸å¯é çš„ä¼ è¾“åè®®ï¼Œéƒ½å¿…é¡»è¦å®ç°æœ€åŸºæœ¬çš„æœºåˆ¶ï¼šä¸»æœºä¸ process ä¹‹é—´æ•°æ®çš„å¤ç”¨å’Œåˆ†è§£ã€‚è¿™ä¸€å±‚äº¤æ¢çš„æ•°æ®è¢«ç§°ä¸º messageã€‚(P28) æ³¨æ„ Switch ä¸€èˆ¬å¤„äº L2 Layerï¼ŒRouter ä¸€èˆ¬å¤„äº L3 Layerã€‚L4 Layer åŠä»¥ä¸Šçš„ layers é€šå¸¸åªå­˜åœ¨äº hostsï¼Œswitches å’Œ routers å†…éƒ¨ä¸€èˆ¬ä¸å…·æœ‰è¿™äº› layersã€‚(P29) Internet Architecture çš„å±‚çº§å¹¶ä¸æ˜¯ä¸¥æ ¼çš„ï¼ŒHost å¯ä»¥ç•¥è¿‡ Application Layer è€Œç›´æ¥ä½¿ç”¨ Transport Layerã€Network Layer ä¸­çš„åè®®ã€‚(P30) Internet Architecture çš„æ ¸å¿ƒæ˜¯ IP åè®®ï¼Œå®ƒä½œä¸ºæ²™æ¼å½¢çŠ¶çš„ä¸­å¿ƒä½ç½®ï¼Œä¸ºå¤„äºå…¶ä¸Šå±‚çš„åè®®ä¸å¤„äºå…¶ä¸‹å±‚åè®®ä¹‹é—´æä¾›äº†ä¸€ä¸ªæ˜ å°„å…³ç³»ã€‚(P31) ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:3","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"Network Performance Foundation - 36 Foundation - 37 Bandwidth: Number of bits per second (P34) Delay å¯ä»¥è¿‘ä¼¼ç†è§£ä¸º Propagation timeã€‚æœ‰æ•ˆåˆ©ç”¨ network çš„æ ‡å¿—æ˜¯åœ¨æ¥æ”¶å¯¹æ–¹çš„å›åº”ä¹‹å‰ï¼Œå‘é€æ–¹ä¼ é€çš„èµ„æ–™å……æ»¡äº† pipeï¼Œå³å‘é€äº† Delay $\\times$ Bandwitdh bits çš„èµ„æ–™é‡ã€‚(P39) Foundation - 40 RTT å¯ä»¥è¿‘ä¼¼ç†è§£ä¸º 2 $\\times$ Propagation timeï¼Œå› ä¸ºä¸€ä¸ªæ¥å›éœ€è¦ä» sender åˆ° recieverï¼Œå†ä» reciever åˆ° senderã€‚ ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:4","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"Homework Redis ä½œè€… Salvatore Sanfilippo çš„èŠå¤©å®¤é¡¹ç›®: smallchatï¼Œé€šè¿‡è¯¥é¡¹ç›®å¯ä»¥å…¥é—¨å­¦ä¹ ç½‘ç»œç¼–ç¨‹ (Network Programming)ï¼Œè¯·å¤ç°è¯¥é¡¹ç›®ã€‚ Salvatore Sanfilippo åœ¨ YouTube ä¸Šå¯¹ smallchat çš„è®²è§£ï¼š Smallchat intro smallchat client \u0026 raw line input GitHub ä¸Šä¹Ÿæœ‰ä½¿ç”¨ Go å’Œ Rust å®ç°è¯¥é¡¹ç›®çš„ä»“åº“ï¼Œå¦‚æœä½ å¯¹ Go æˆ– Rust çš„ç½‘ç»œç¼–ç¨‹ (Network Programming) æ„Ÿå…´è¶£ï¼Œå¯ä»¥å‚è€ƒè¿™ä¸ªä»“åº“ã€‚ ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:2:5","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"IEEE 802.3 Ethernet Outline: Introduction Ethernet Topologies Ethernet Frame Format Ethernet MAC Protocol â€“ CSMA/CD 802.3 Ethernet Standards Summary: MAC Protocol â€“ CSMA/CD Connection less, unreliable transmission Topology from Bus to Star (switches) Half-duplex transmission in Bus topology Work best under lightly loaded conditions Too much collision under heavy load Full-duplex transmission in Switch topology (point-to-point) No more collisions !! Excellent performance (wired speed) ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:3:0","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"Introduction Ethernet - 03 Ethernet å‘å±•è¿‡ç¨‹: ä¼ è¾“é€Ÿåº¦ä» 10Mb å‘å±•åˆ° 100Gb (P4) Ethernet çš„ç‰¹ç‚¹: Unreliable, Connectionless, CSMA/CD (P5) ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:3:1","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"Ethernet Topologies Ethernet - 07 Ethernet - 18 10Base5: 10Mbps, segment up to 500m (P8) 10Base2: 10Mbps, segment up to 200m (P8) 10BaseT: 10Mbps, Twisted pair, segment up to 100m (P16) Repeater, Hub éƒ½æ˜¯ physical layer çš„è®¾å¤‡ï¼Œåªè´Ÿè´£ è½¬å‘ä¿¡å·ï¼Œæ— æ³•é˜²æ­¢ collision (P12, P16) Switch åˆ™æ˜¯ data-link layer çš„è®¾å¤‡ï¼Œå†…ç½®èŠ¯ç‰‡è¿›è¡Œ æ•°æ®è½¬å‘ï¼Œå¯ä»¥é˜²æ­¢ collision (P19) Manchester Encoding (P11): Ethernet ä¸‹å±‚çš„ physical layer ä½¿ç”¨çš„ç¼–ç æ–¹å¼æ˜¯ Manchester Encoding: åœ¨ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸå†…ï¼Œä¿¡å·ä»ä½åˆ°é«˜è¡¨ç¤º 1ï¼Œä»é«˜åˆ°ä½è¡¨ç¤º 0 æ³¨æ„ Manchester Encoding å‘é€æ–¹åœ¨è¿›è¡Œæ•°æ®ä¼ è¾“ä¹‹å‰éœ€è¦å‘é€ä¸€äº› bits æ¥è¿›è¡Œæ—¶é’ŸåŒæ­¥ (ä¾‹å¦‚ P22 çš„ Preamble éƒ¨åˆ†)ï¼Œæ¥æ”¶æ–¹å®Œæˆæ—¶é’ŸåŒæ­¥åï¼Œå¯ä»¥å¯¹ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸè¿›è¡Œä¸¤æ¬¡é‡‡æ ·ï¼šä¸€æ¬¡å‰åŠæ®µï¼Œä¸€æ¬¡ååŠæ®µï¼Œç„¶åå¯ä»¥é€šè¿‡ä¸¤æ¬¡å–æ ·ç”µä½ä¿¡å·çš„å˜åŒ–æ¥è·å–å¯¹åº”çš„ bit (ä½åˆ°é«˜è¡¨ç¤º 1ï¼Œé«˜åˆ°ä½è¡¨ç¤º 0)ã€‚ æœ‰äº›è¯»è€…å¯èƒ½ä¼šç–‘æƒ‘ï¼Œæ—¢ç„¶éƒ½è¿›è¡Œæ—¶é’ŸåŒæ­¥äº†ï¼Œä¸ºä»€ä¹ˆä¸ç›´æ¥ä½¿ç”¨é«˜ç”µä½ä¿¡å·è¡¨ç¤º 1ï¼Œä½ç”µä½ä¿¡å·è¡¨ç¤º 0 è¿™æ ·ç›´è§‚çš„ç¼–ç æ–¹å¼ï¼Ÿè¿™æ˜¯å› ä¸ºå¦‚æœé‡‡å–è¿™ç§ç¼–ç æ–¹å¼ï¼Œé‚£ä¹ˆåœ¨ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸå†…ä¿¡å·ä¸ä¼šæœ‰å˜åŒ–ï¼Œå¦‚æœæ¥æ”¶çš„æ˜¯ä¸€ç³»åˆ—çš„ 1 æˆ– 0ï¼Œä¿¡å·ä¹Ÿä¸ä¼šå˜åŒ–ã€‚è¿™æ ·å¯èƒ½ä¼šå¯¼è‡´æ¼é‡‡æ ·ï¼Œæˆ–è€…ç¼–ç å‡ºé”™å´æ— æ³•åŠæ—¶ä¾¦æµ‹ã€‚è€Œé‡‡ç”¨ Manchester Encoding æ¥æ”¶æ–¹æ¯ä¸ªæ—¶é’Ÿå‘¨æœŸå†…ä¿¡å·éƒ½ä¼šå˜åŒ–ï¼Œå¦‚æœæ¥æ”¶æ–¹åœ¨ä¸€æ¬¡æ—¶é’Ÿå‘¨æœŸå†…çš„ä¸¤æ¬¡é‡‡æ ·ï¼Œä¿¡å·æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œé‚£ä¹ˆå¯ä»¥ç«‹å³ä¾¦æµ‹åˆ°å‡ºé”™äº† (è¦ä¹ˆæ˜¯æ¼é‡‡æ ·äº†ï¼Œè¦ä¹ˆæ˜¯ç¼–ç å‡ºé”™äº†)ã€‚ ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:3:2","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"Ethernet Frame Format Ethernet - 23 é™¤å¼€ Preamble, SFD ä¹‹å¤–ï¼Œä¸€ä¸ª Frame çš„å¤§å°ä¸º $64 \\sim 1518$ bytesã€‚å› ä¸º DA, SA, TYPE, FCS å æ®äº† $6 + 6 + 2 + 4 = 18$ bytesï¼Œæ‰€ä»¥ Data éƒ¨åˆ†çš„å¤§å°ä¸º $48 ~\\sim 1500$ bytes (P43) MAC Address æ˜¯ unique å¹¶ä¸”æ˜¯ä¸ Adaptor ç›¸å…³çš„ï¼Œæ‰€ä»¥ä¸€ä¸ªä¸»æœºå¯èƒ½æ²¡æœ‰ MAC Address (æ²¡æœ‰ Adaptor)ï¼Œå¯èƒ½æœ‰ä¸¤ä¸ª MAC Address (æœ‰ä¸¤ä¸ª Adaptor)ã€‚MAC Address æ˜¯ç”± Adaptor çš„ç”Ÿäº§å•†æ¥å†³å®šçš„ã€‚(P24) unicast address, broadcast address, multicast address (P26) ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:3:3","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"CSMA/CD Ethernet - 46 Ethernet - 41 Ethernet - 45 Ethernet - 49 å…³äº CSMA/CD çš„è¯¦ç»†ä»‹ç»å¯ä»¥æŸ¥çœ‹ P34 ~ P38 å…³äº Ethernet Frame çš„å¤§å°é™åˆ¶è®¾è®¡å¯ä»¥æŸ¥çœ‹ P39 ~ P43 å…³äº CSMA/CD Collision Handling çš„ç­–ç•¥æœºåˆ¶å¯ä»¥æŸ¥çœ‹ P44 ~ P45, P47 ~ P48 æ³¨æ„ Host åœ¨ detect collision ä¹‹åè¿›è¡Œ backoff random delayï¼Œdelay ç»“æŸåæŒ‰ç…§ 1-persistent protocol (P35) ç»§ç»­ç­‰å¾…åˆ° busy channel goes idle åç«‹åˆ»è¿›è¡Œä¼ è¾“ã€‚ ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:3:4","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"IEEE 802.11 Wireless LAN æ— çº¿ç½‘ç»œè¿™ç« å¤ªéš¾äº†ï¼Œæˆ˜æœ¯æ€§æ”¾å¼ƒ ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:4:0","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"IEEE 802.1D Spanning Tree Algorithm ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:5:0","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["Systems"],"content":"Referenecs 110-1 è¨ˆç®—æ©Ÿç¶²è·¯ (æ¸…å¤§é–‹æ”¾å¼èª²ç¨‹) å°èœå­¦ç½‘ç»œ NUDT é«˜çº§è®¡ç®—æœºç½‘ç»œå®éªŒ: åŸºäºUDPçš„å¯é ä¼ è¾“ å¯é  UDP çš„å®ç° (KCP over UDP) åŸºäº UDP çš„å¯é ä¼ è¾“ [bilibili] å®ç°åŸºäº UDP çš„ç½‘ç»œæ–‡ä»¶ä¼ è¾“å™¨ï¼Œç¨‹åºå‘˜çš„ç»éªŒå¤§ç¤¼åŒ…é¡¹ç›® [bilibili] ping å‘½ä»¤ä½†æ˜¯ç”¨æ¥é€šä¿¡ï¼Œå­¦ä¹ è®¡ç®—æœºç½‘ç»œå¥½é¡¹ç›®ï¼Œä¹Ÿå¯èƒ½æ˜¯æ ¡å›­ç½‘ç¦åˆ© [bilibili] Implementing TCP in Rust [YouTube] Let's code a TCP/IP stack ","date":"2024-01-14","objectID":"/posts/nthu-computer-network/:6:0","tags":["Network"],"title":"åœ‹ç«‹æ¸…è¯å¤§å­¸ è¨ˆç®—æ©Ÿç¶²è·¯ é‡é»æç¤º","uri":"/posts/nthu-computer-network/"},{"categories":["C","Linux Kernel Internals"],"content":"C è¯­è¨€è§„æ ¼ä¹¦é˜…è¯»å­¦ä¹ è®°å½•ã€‚ è§„æ ¼ä¹¦è‰æ¡ˆç‰ˆæœ¬ä¸º n1256ï¼Œå¯¹åº” C99 æ ‡å‡†ï¼Œå¯¹åº”çš„ PDF ä¸‹è½½åœ°å€ã€‚ ä¹Ÿé…åˆ C11 æ ‡å‡†æ¥é˜…è¯»ï¼Œè‰æ¡ˆç‰ˆæœ¬ n1570ï¼Œå¯¹åº”çš„ PDF ä¸‹è½½åœ°å€ã€‚ é˜…è¯»è§„æ ¼ä¹¦éœ€è¦ä¸€å®šçš„ä½“ç³»ç»“æ„ã€ç¼–è¯‘åŸç†çš„ç›¸å…³çŸ¥è¯†ï¼Œä½†ä¸éœ€è¦å¾ˆé«˜çš„ç¨‹åº¦ã€‚è¯·å–„ç”¨æ£€ç´¢å·¥å…·ï¼Œåœ¨é˜…è¯»è§„æ ¼ä¹¦æ—¶é‡åˆ°æœ¯è¯­æ—¶ï¼Œè¯·å…ˆåœ¨è§„æ ¼ä¹¦ä¸­è¿›è¡Œæ£€ç´¢ï¼Œå› ä¸ºæå¤§å¯èƒ½æ˜¯è§„æ ¼ä¹¦è‡ªå·±å®šä¹‰çš„æœ¯è¯­ã€‚ ","date":"2024-01-06","objectID":"/posts/c-specification/:0:0","tags":["C","Sysprog"],"title":"C è¯­è¨€è§„æ ¼ä¹¦ é‡ç‚¹æç¤º","uri":"/posts/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"6. Language ","date":"2024-01-06","objectID":"/posts/c-specification/:1:0","tags":["C","Sysprog"],"title":"C è¯­è¨€è§„æ ¼ä¹¦ é‡ç‚¹æç¤º","uri":"/posts/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"6.2 Concepts ","date":"2024-01-06","objectID":"/posts/c-specification/:2:0","tags":["C","Sysprog"],"title":"C è¯­è¨€è§„æ ¼ä¹¦ é‡ç‚¹æç¤º","uri":"/posts/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"6.2.2 Linkages of identifiers linkage: external internal none ä¸€ä¸ªæ‹¥æœ‰ file scope å¹¶ä¸”å…³äº object æˆ– function çš„ identifier å£°æ˜ï¼Œå¦‚æœä½¿ç”¨ static ä¿®é¥°ï¼Œåˆ™è¯¥ identifer æœ‰ internal linkageï¼Œe.g. // file scope static int a; static void f(); int main() {} ä¸€ä¸ª scope å†…ä½¿ç”¨ static ä¿®é¥°çš„ identifier å£°æ˜ï¼Œå¦‚æœåœ¨åŒä¸€ scope å†…å·²å­˜åœ¨è¯¥ identifier å£°æ˜ï¼Œåˆ™è¯¥ identifier çš„ linkage å–å†³äºå…ˆå‰çš„ identifier å£°æ˜ã€‚å¦‚æœè¯¥ identifier ä¸å­˜åœ¨å…ˆå‰å£°æ˜æˆ–è€…å…ˆå‰å£°æ˜ no linkageï¼Œåˆ™è¯¥ identifier æ˜¯ external linkageï¼Œe.g. // Example 1 static int a; // a is internal linkage extern int a; // linkage is the same as prior // Example 2 extern int b; // no prior, a is external linkage extern int b; // linkage is the same as prior å¦‚æœä¸€ä¸ª function identifier å£°æ˜æ²¡æœ‰ storage-class ä¿®é¥°ç¬¦ï¼Œåˆ™å…¶ linkage ç­‰ä»·äºåŠ ä¸Š extern ä¿®é¥°çš„å£°æ˜çš„ linkageï¼Œe.g. int func(int a, int b); // equal to `extern int func(int a. int b);` // and then no prior, it is external linkage å¦‚æœä¸€ä¸ª object identifier å£°æ˜æ²¡æœ‰ storage-class ä¿®é¥°ç¬¦ï¼Œä¸”æ‹¥æœ‰ file scopeï¼Œåˆ™å…¶æ‹¥æœ‰ external linkageï¼Œe.g. // file scope int a; // external linkage int main() {} ","date":"2024-01-06","objectID":"/posts/c-specification/:2:1","tags":["C","Sysprog"],"title":"C è¯­è¨€è§„æ ¼ä¹¦ é‡ç‚¹æç¤º","uri":"/posts/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"6.5 Expressions ","date":"2024-01-06","objectID":"/posts/c-specification/:3:0","tags":["C","Sysprog"],"title":"C è¯­è¨€è§„æ ¼ä¹¦ é‡ç‚¹æç¤º","uri":"/posts/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"6.5.3 Unary operators æ³¨æ„ C99 [6.2.5] Types There are three real floating types, designated as float, double, and long double. The real floating and complex types are collectively called the floating types. The integer and real floating types are collectively called real types. Integer and floating types are collectively called arithmetic types. A function type describes a function with specified return type. A function type is characterized by its return type and the number and types of its parameters. A function type is said to be derived from its return type, and if its return type is T, the function type is sometimes called â€˜â€˜function returning Tâ€™â€™. The construction of a function type from a return type is called â€˜â€˜function type derivationâ€™â€™. Arithmetic types and pointer types are collectively called scalar types. C99 [6.3.2.1] Lvalues, arrays, and function designators A function designator is an expression that has function type. Except when it is the operand of the sizeof operator or the unary \u0026 operator, a function designator with type â€˜â€˜function returning typeâ€™â€™ is converted to an expression that has type â€˜â€˜pointer to function returning typeâ€™â€™. 6.5.3.1 Prefix increment and decrement operators Constraints å‰ç¼€è‡ªå¢æˆ–è‡ªå‡è¿ç®—ç¬¦çš„æ“ä½œæ•°ï¼Œå¿…é¡»ä¸ºå®æ•° (real types) ç±»å‹ï¼ˆå³ä¸èƒ½æ˜¯å¤æ•°ï¼‰æˆ–è€…æ˜¯æŒ‡é’ˆç±»å‹ï¼Œå¹¶ä¸”å…¶å€¼æ˜¯å¯å˜çš„ã€‚ Semantics ++E ç­‰ä»·äº (E+=1) --E ç­‰ä»·äº (E-=1) 6.5.3.2 Address and indirection operators Constraints \u0026 è¿ç®—ç¬¦çš„æ“ä½œæ•°å¿…é¡»ä¸º function designatorï¼Œ[] æˆ– * çš„è¿ç®—ç»“æœï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªä¸æ˜¯ bit-field å’Œ register ä¿®é¥°çš„å·¦å€¼ã€‚ * è¿ç®—ç¬¦çš„æ“ä½œæ•°å¿…é¡»ä¸ºæŒ‡é’ˆç±»å‹ã€‚ Semantics \u0026*E ç­‰ä»·äº Eï¼Œå³ \u0026 å’Œ * è¢«ç›´æ¥å¿½ç•¥ï¼Œä½†æ˜¯å®ƒä»¬çš„ constraints ä»ç„¶èµ·ä½œç”¨ã€‚æ‰€ä»¥ (\u0026*(void *)0) å¹¶ä¸ä¼šæŠ¥é”™ã€‚ \u0026a[i] ç­‰ä»·äº a + iï¼Œå³å¿½ç•¥äº† \u0026 ä»¥åŠ * (ç”± [] éšå¼æŒ‡ä»£)ã€‚ å…¶å®ƒæƒ…å†µ \u0026 è¿ç®—çš„ç»“æœä¸ºä¸€ä¸ªæŒ‡å‘ object æˆ– function çš„æŒ‡é’ˆã€‚ å¦‚æœ * è¿ç®—ç¬¦çš„æ“ä½œæ•°æ˜¯ä¸€ä¸ªæŒ‡å‘ function çš„æŒ‡é’ˆï¼Œåˆ™ç»“æœä¸ºå¯¹åº”çš„ function designatorã€‚ å¦‚æœ * è¿ç®—ç¬¦çš„æ“ä½œæ•°æ˜¯ä¸€ä¸ªæŒ‡å‘ object çš„æŒ‡é’ˆï¼Œåˆ™ç»“æœä¸ºæŒ‡ç¤ºè¯¥ obejct çš„å·¦å€¼ã€‚ å¦‚æœ * è¿ç®—ç¬¦çš„æ“ä½œæ•°ä¸ºéæ³•å€¼çš„æŒ‡é’ˆï¼Œåˆ™å¯¹è¯¥æŒ‡é’ˆè¿›è¡Œ * è¿ç®—çš„è¡Œä¸ºä¸‰æœªå®šä¹‰çš„ã€‚ 6.5.3.3 Unary arithmetic operators Constraints å•ç›® + æˆ– - è¿ç®—ç¬¦çš„æ“ä½œæ•°å¿…é¡»ä¸ºç®—æ•°ç±»å‹ (arithmetic type)ï¼Œ~ è¿ç®—ç¬¦çš„æ“ä½œæ•°å¿…é¡»ä¸ºæ•´æ•°ç±»å‹ (integer type)ï¼Œ! è¿ç®—ç¬¦çš„æ“ä½œæ•°å¿…é¡»ä¸ºå¸¸æ•°ç±»å‹ (scalar type)ã€‚ Semantics åœ¨è¿›è¡Œå•ç›® +ã€-ã€~ è¿ç®—ä¹‹å‰ï¼Œä¼šå¯¹æ“ä½œæ•°è¿›è¡Œæ•´æ•°æå‡ (integer promotions)ï¼Œç»“æœçš„ç±»å‹ä¸æ“ä½œæ•°è¿›è¡Œæ•´æ•°æå‡åçš„ç±»å‹ä¸€è‡´ã€‚ !E ç­‰ä»·äº (E==0)ï¼Œç»“æœä¸º int ç±»å‹ã€‚ ","date":"2024-01-06","objectID":"/posts/c-specification/:3:1","tags":["C","Sysprog"],"title":"C è¯­è¨€è§„æ ¼ä¹¦ é‡ç‚¹æç¤º","uri":"/posts/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"6.5.6 Additive operators ä»‹ç»åŠ å‡æ³•è¿ç®—ï¼Œå…¶ä¸­åŒ…æ‹¬äº†æŒ‡é’ˆçš„è¿ç®—ï¼ŒåŠ¡å¿…é˜…è¯»è¿™éƒ¨åˆ†å…³äºæŒ‡é’ˆè¿ç®—çš„æ ‡å‡†è¯´æ˜ã€‚ ","date":"2024-01-06","objectID":"/posts/c-specification/:3:2","tags":["C","Sysprog"],"title":"C è¯­è¨€è§„æ ¼ä¹¦ é‡ç‚¹æç¤º","uri":"/posts/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"6.5.7 Bitwise shift operators Constraints ä½è¿ç®—çš„æ“ä½œæ•°éƒ½å¿…é¡»ä¸ºæ•´æ•°ç±»å‹ã€‚ Semantics åœ¨è¿›è¡Œä½è¿ç®—ä¹‹å‰ä¼šå…ˆå¯¹æ“ä½œæ•°è¿›è¡Œæ•´æ•°æå‡ (integer promotion)ï¼Œä½è¿ç®—ç»“æœç±»å‹ä¸æ•´æ•°æå‡åçš„å·¦æ“ä½œæ•°ä¸€è‡´ã€‚å¦‚æœå³è¿ç®—æ•°æ˜¯è´Ÿæ•°ï¼Œæˆ–è€…å¤§äºç­‰äºæ•´æ•°æå‡åçš„å·¦è¿ç®—æ•°çš„ç±»å‹çš„å®½åº¦ï¼Œé‚£ä¹ˆè¿™ä¸ªä½è¿ç®—è¡Œä¸ºæ˜¯æœªå®šä¹‰çš„ã€‚ å‡è®¾è¿ç®—ç»“æœçš„ç±»å‹ä¸º T $E1 \u003c\u003c E2$ å¦‚æœ E1 æ˜¯æ— ç¬¦å·ï¼Œåˆ™ç»“æœä¸º $E1 \\times 2^{E2} \\bmod (\\max[T] + 1)$ã€‚ å¦‚æœ E1 æ˜¯æœ‰ç¬¦å·ï¼ŒE1 ä¸æ˜¯è´Ÿæ•°ï¼Œå¹¶ä¸” T å¯ä»¥è¡¨ç¤º $E1 \\times 2^{E2}$ï¼Œåˆ™ç»“æœä¸º $E1 \\times 2^{E2}$ã€‚ é™¤äº†ä»¥ä¸Šä¸¤ç§è¡Œä¸ºå¤–ï¼Œå…¶ä»–å‡æ˜¯æœªå®šä¹‰è¡Œä¸ºã€‚ $E1 \u003e\u003e E2$ å¦‚æœ E1 æ˜¯æ— ç¬¦å·ï¼Œæˆ–è€… E1 æ˜¯æœ‰ç¬¦å·å¹¶ä¸”æ˜¯éè´Ÿæ•°ï¼Œåˆ™ç»“æœä¸º $E1 / 2^{E2}$ã€‚ å¦‚æœ E1 æ˜¯æœ‰ç¬¦å·å¹¶ä¸”æ˜¯è´Ÿæ•°ï¼Œåˆ™ç»“æœç”±å…·ä½“å®ç°å†³å®š (implementation-defined)ã€‚ ","date":"2024-01-06","objectID":"/posts/c-specification/:3:3","tags":["C","Sysprog"],"title":"C è¯­è¨€è§„æ ¼ä¹¦ é‡ç‚¹æç¤º","uri":"/posts/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"7. Library ","date":"2024-01-06","objectID":"/posts/c-specification/:4:0","tags":["C","Sysprog"],"title":"C è¯­è¨€è§„æ ¼ä¹¦ é‡ç‚¹æç¤º","uri":"/posts/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"7.18 Integer types \u003cstdint.h\u003e æè¿°äº†å¤´æ–‡ä»¶ stdint.h å¿…é¡»å®šä¹‰å’Œå®ç°çš„æ•´æ•°ç±»å‹ï¼Œä»¥åŠç›¸åº”çš„å®ã€‚ ","date":"2024-01-06","objectID":"/posts/c-specification/:5:0","tags":["C","Sysprog"],"title":"C è¯­è¨€è§„æ ¼ä¹¦ é‡ç‚¹æç¤º","uri":"/posts/c-specification/"},{"categories":["C","Linux Kernel Internals"],"content":"7.18.1 Integer types 7.18.1.1 Exact-width integer types äºŒè¡¥æ•°ç¼–ç ï¼Œå›ºå®šé•¿åº¦ N çš„æ•´æ•°ç±»å‹ï¼š æœ‰ç¬¦å·æ•°ï¼šintN_t æ— ç¬¦å·æ•°ï¼šuintN_t 7.18.1.2 Minimum-width integer types è‡³å°‘æ‹¥æœ‰é•¿åº¦ N çš„æ•´æ•°ç±»å‹ï¼š æœ‰ç¬¦å·æ•°ï¼šint_leastN_t æ— ç¬¦å·æ•°ï¼šuint_leastN_t 7.18.1.3 Fastest minimum-width integer types è‡³å°‘æ‹¥æœ‰é•¿åº¦ Nï¼Œä¸”æ“ä½œé€Ÿåº¦æœ€å¿«çš„æ•´æ•°ç±»å‹ï¼š æœ‰ç¬¦å·æ•°ï¼šint_fastN_t æ— ç¬¦å·æ•°ï¼šuint_fastN_t 7.18.1.4 Integer types capable of holding object pointers å¯ä»¥å°†æŒ‡å‘ void çš„æœ‰æ•ˆæŒ‡é’ˆè½¬æ¢æˆè¯¥æ•´æ•°ç±»å‹ï¼Œä¹Ÿå¯ä»¥å°†è¯¥æ•´æ•°ç±»å‹è½¬æ¢å›æŒ‡å‘ void çš„æŒ‡é’ˆç±»å‹ï¼Œå¹¶ä¸”è½¬æ¢ç»“æœä¸ä¹‹å‰çš„æŒ‡é’ˆå€¼ä¿æŒä¸€è‡´ï¼š æœ‰ç¬¦å·æ•°ï¼šintptr_t æ— ç¬¦å·æ•°ï¼šuintptr_t 7.18.1.5 Greatest-width integer types å¯ä»¥è¡¨ç¤ºä»»æ„æ•´æ•°ç±»å‹æ‰€è¡¨ç¤ºçš„å€¼çš„æ•´æ•°ç±»å‹ï¼Œå³å…·æœ‰æœ€å¤§é•¿åº¦çš„æ•´æ•°ç±»å‹ï¼š æœ‰ç¬¦å·æ•°ï¼šintmax_t æ— ç¬¦å·æ•°ï¼šuintmax_t ","date":"2024-01-06","objectID":"/posts/c-specification/:5:1","tags":["C","Sysprog"],"title":"C è¯­è¨€è§„æ ¼ä¹¦ é‡ç‚¹æç¤º","uri":"/posts/c-specification/"},{"categories":["Toolkit"],"content":"Git ä¸­æ–‡æ•™å­¦ æ–°æ‰‹å…¥é—¨æ¨èï¼Œå¯¹äº Git çš„å…¥é—¨æ“ä½œè®²è§£ååˆ†å‹å¥½ã€‚ è§†é¢‘åœ°å€ å­¦ä¹ è®°å½• ","date":"2024-01-04","objectID":"/posts/git/:1:0","tags":["Git","GitHub"],"title":"Git/GitHub èµ„æºä¸é—®é¢˜æ±‡æ€»","uri":"/posts/git/"},{"categories":["Toolkit"],"content":"Git å¸¸è§é—®é¢˜åŠè§£å†³ ","date":"2024-01-04","objectID":"/posts/git/:2:0","tags":["Git","GitHub"],"title":"Git/GitHub èµ„æºä¸é—®é¢˜æ±‡æ€»","uri":"/posts/git/"},{"categories":["Toolkit"],"content":"git pull/push é‡åˆ° Port 22 connect timeout ç½‘ç»œé—®é¢˜å¯¼è‡´ 22 ç«¯å£è¢«ç¦æ­¢ï¼Œæ— æ³•æ­£å¸¸ä½¿ç”¨ sshã€‚åˆ‡æ¢æˆ 443 ç«¯å£å¹¶ä¸”ç¼–å†™é…ç½®æ–‡ä»¶å³å¯ï¼š $ vim ~/.ssh/config # In ~/.ssh/config Host github.com HostName ssh.github.com Port 443 ","date":"2024-01-04","objectID":"/posts/git/:2:1","tags":["Git","GitHub"],"title":"Git/GitHub èµ„æºä¸é—®é¢˜æ±‡æ€»","uri":"/posts/git/"},{"categories":["Toolkit"],"content":"GitHub æ”¯æŒå¤šä¸ªè´¦æˆ·é€šè¿‡ ssh è¿æ¥ Using multiple github accounts with ssh keys ","date":"2024-01-04","objectID":"/posts/git/:2:2","tags":["Git","GitHub"],"title":"Git/GitHub èµ„æºä¸é—®é¢˜æ±‡æ€»","uri":"/posts/git/"},{"categories":["Toolkit"],"content":"References Git åŸºæœ¬åŸç† Learn Git Branching DIY a Git ugit åŠ¨æ‰‹å­¦ä¹ GIT - æœ€å¥½å­¦ä¹ GITçš„æ–¹å¼æ˜¯ä»é›¶å¼€å§‹åšä¸€ä¸ª ","date":"2024-01-04","objectID":"/posts/git/:3:0","tags":["Git","GitHub"],"title":"Git/GitHub èµ„æºä¸é—®é¢˜æ±‡æ€»","uri":"/posts/git/"},{"categories":["Linux Kernel Internals"],"content":" äººä»¬å¯¹æ•°å­¦çš„åŠ å‡è¿ç®—å¯è½»æ˜“åœ¨è„‘ä¸­è¾¨è¯†ç¬¦å·å¹¶ç†è§£å…¶ç»“æœï¼Œä½†ç”µè„‘åšä»»ä½•äº‹éƒ½å—é™äºå®ä½“èµ„æ–™å‚¨å­˜åŠæ“ä½œæ–¹å¼ï¼Œæ¢è¨€ä¹‹ï¼Œç”µè„‘ç¡¬ä½“å®é™…åªè®¤å¾— 0 å’Œ 1ï¼Œå´ä¸çŸ¥é“ç¬¦å· + å’Œ - åœ¨æ•°å­¦åŠåº”ç”¨åœºåŸŸçš„æ„ä¹‰ï¼Œæ–¼æ˜¯å·¥ç¨‹äººå‘˜å¼•å…¥ã€Œè¡¥æ•°ã€ä»¥ä¾¿åœ¨äºŒè¿›ä½ç³»ç»Ÿä¸­ï¼Œè¡¨è¾¾äººä»¬è®¤çŸ¥ä¸Šçš„æ­£è´Ÿæ•°ã€‚ä½†æ‚¨æœ‰æ²¡æœ‰æƒ³è¿‡ï¼Œä¸ºä½•ã€ŒäºŒè¡¥æ•°ã€(2â€™s complement) è¢«ç”µè„‘å¹¿æ³›é‡‡ç”¨å‘¢ï¼ŸèƒŒå¾Œçš„è®¾è®¡è€ƒé‡åˆæ˜¯ä»€éº½ï¼Ÿæœ¬æ–‡å°è¯•ä»æ•°å­¦è§‚ç‚¹å»è§£è¯»ç¼–ç èƒŒå¾Œçš„åŸç†ï¼Œå¹¶ä½ä»¥èµ„è®¯å®‰å…¨åŠç¨‹å¼ç æœ€ä½³åŒ–çš„è€ƒé‡ï¼Œæ¢è®¨äºŒè¡¥æ•°è¿™æ ·çš„ç¼–ç å¯¹äºç¨‹å¼è®¾è®¡æœ‰ä½•å…³é”®å½±å“ã€‚ åŸæ–‡åœ°å€ï¼šè§£è®€è¨ˆç®—æ©Ÿç·¨ç¢¼ æŠ€å·§ ä¸ºäº†æ›´å¥½çš„ç†è§£æœ¬æ–‡çš„ä¸€äº›æ•°å­¦æ¦‚å¿µï¼Œä¾‹å¦‚ç¾¤ï¼Œä»¥åŠåç»­å…¶ä»–å…³äºæ•°å€¼ç³»ç»Ÿã€æµ®ç‚¹æ•°çš„è®²åº§ï¼ŒJserv å¼ºçƒˆå»ºè®®æˆ‘ä»¬å»ä¿®è¯»æ•°å­¦ç³»çš„ æ•°å­¦å¯¼è®ºã€‚ç¬”è€…åœ¨è¿™é‡Œåˆ†äº«ä¸€ä¸‹å°å¤§é½éœ‡å®‡è€å¸ˆçš„ 2015 å¹´çš„æ–°ç”Ÿè¥è®²åº§ï¼Œè¿™ä¸ªè®²åº§è¦†ç›–äº†æ•°å­¦å¯¼è®ºçš„å†…å®¹ã€‚ YouTube: è‡ºå¤§ 2015 æ•¸å­¸ç³»æ–°ç”Ÿç‡Ÿ ","date":"2023-12-31","objectID":"/posts/binary-representation/:0:0","tags":["Sysprog","Numerics","Bitwise"],"title":"è§£è¯»è®¡ç®—æœºç¼–ç ","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"ä¸€è¡¥æ•° (Onesâ€™ complement) ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:0","tags":["Sysprog","Numerics","Bitwise"],"title":"è§£è¯»è®¡ç®—æœºç¼–ç ","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"9 çš„è¡¥æ•° ç§‘æ™®çŸ­ç‰‡: Not just counting, but saving lives: Curta ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:1","tags":["Sysprog","Numerics","Bitwise"],"title":"è§£è¯»è®¡ç®—æœºç¼–ç ","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"è¿ç®—åŸç† æ³¨æ„ ä»¥ä¸€è¡¥æ•°ç¼–ç å½¢å¼è¡¨ç¤ºçš„è¿ç®—å­ï¼Œåœ¨å‚ä¸è¿ç®—åï¼Œè¿ç®—ç»“æœç¬¦åˆä¸€è¡¥æ•°çš„ç¼–ç ï¼š $$ [X]_{ä¸€è¡¥æ•°} + [Y]_{ä¸€è¡¥æ•°} = [X+Y]_{ä¸€è¡¥æ•°} $$ æ¥ä¸‹æ¥è¿›è¡Œåˆ†ç±»è®¨è®ºï¼Œä»¥ 32-bit æ­£æ•° $X$, $Y$ ä¸ºä¾‹ï¼š $X + Y = X + Y$ æ˜¾ç„¶è¿ç®—å­å’Œè¿ç®—ç»“æœéƒ½æ»¡è¶³ä¸€è¡¥æ•°ç¼–ç ã€‚ $X - Y = X + (2^{32} - 1 - Y)$ å¦‚æœ $X \u003e Y$ï¼Œåˆ™è¿ç®—ç»“æœåº”ä¸º $X - Y$ ä¸”ä¸ºæ­£æ•°ï¼Œå…¶ä¸€è¡¥æ•°ç¼–ç ä¸º $X - Y$ã€‚è€Œæ­¤æ—¶ $$ 2^{32} - 1 + X - Y $$ æ˜¾ç„¶ä¼šæº¢å‡ºï¼Œä¸ºäº†ä½¿è¿ç®—ç»“æœå¯¹åº”ä¸€è¡¥æ•°ç¼–ç ï¼Œæ‰€ä»¥æ­¤æ—¶å¾ªç¯è¿›ä½å¯¹åº” $+\\ (1 - 2_{32})$ã€‚ å¦‚æœ $X \u003c Y$ï¼Œåˆ™è¿ç®—ç»“æœåº”ä¸º $X - Y$ ä¸”ä¸ºè´Ÿæ•°ï¼Œå…¶ä¸€è¡¥æ•°ç¼–ç ä¸º $$ 2^{32} - 1 - ï¼ˆY - Xï¼‰ = 2_{32} - 1 - X - Y $$ è€Œæ­¤æ—¶ $2^{32} - 1 + X - Y$ å¹¶ä¸ä¼šæº¢å‡ºï¼Œå¹¶ä¸”æ»¡è¶³è¿ç®—ç»“æœçš„ä¸€è¡¥æ•°ç¼–ç ï¼Œæ‰€ä»¥æ— éœ€è¿›è¡Œå¾ªç¯è¿›ä½ã€‚ å¦‚æœ $X = Y$ï¼Œæ˜¾ç„¶ $$ X - Y = X + 2^{32} - 1 - Y = 2^{32} - 1 $$ ä¸º 0 æˆç«‹ã€‚ $-X - Y = (2^{32} - 1 - X) + (2^{32} - 1 - Y)$ï¼Œæ˜¾ç„¶ä¼šå¯¼è‡´æº¢å‡ºã€‚è€Œ $-X - Y$ çš„ä¸€è¡¥æ•°ç¼–ç ä¸º $$ 2^{32} - 1 - (X + Y) = 2^{32} - 1 - X - Y $$ æ‰€ä»¥éœ€è¦åœ¨æº¢å‡ºæ—¶å¾ªç¯è¿›ä½ $+\\ (1 - 2^{32})$ æ¥æ¶ˆé™¤è¿ç®—ç»“æœä¸­çš„ä¸€ä¸ª $2^{32} - 1$ã€‚ ","date":"2023-12-31","objectID":"/posts/binary-representation/:1:2","tags":["Sysprog","Numerics","Bitwise"],"title":"è§£è¯»è®¡ç®—æœºç¼–ç ","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"äºŒè¡¥æ•° (Twoâ€™s complement) ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:0","tags":["Sysprog","Numerics","Bitwise"],"title":"è§£è¯»è®¡ç®—æœºç¼–ç ","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"æ­£è´Ÿæ•°ç¼–ç è¡¨ç¤º å‡è®¾æœ‰ n-bit çš„äºŒè¡¥æ•°ç¼–ç  $A$ï¼Œ$-A$ çš„æ¨å¯¼å¦‚ä¸‹ï¼š æ ¼å¼ä¸€ï¼š $$ \\begin{align*} A + \\neg A \u0026= 2^n - 1 \\\\ A + \\neg A + 1 \u0026\\equiv 0 \\equiv 2^n \\ (\\bmod 2^n) \\\\ -A \u0026= \\neg A + 1 \\\\ \\end{align*} $$ æ ¼å¼äºŒï¼š $$ \\begin{align*} A + \\neg A \u0026= 2^n - 1 \\\\ A + \\neg A - 1 \u0026= 2^n - 2 \\\\ A - 1 \u0026= 2^n - 1 - (\\neg A + 1) \\\\ \\neg (A - 1) \u0026= \\neg A + 1 \\\\ \\neg (A - 1) \u0026= -A \\\\ \\end{align*} $$ ä¹Ÿå¯ä»¥é€šè¿‡ä¸€è¡¥æ•°å’ŒäºŒè¡¥æ•°ï¼Œåœ¨æ—¶é’Ÿè¡¨ä¸Šçš„å¯¹ç§°è½´åå·®ï¼Œæ¥ç†è§£ä¸Šè¿°ä¸¤ç§æ–¹å¼æ˜¯ç­‰ä»·çš„ã€‚ CS:APP 2.2.3 Twoâ€™s-Complement Encodings Note the different position of apostrophes: twoâ€™s complement versus onesâ€™ complement. The term â€œtwoâ€™s complementâ€ arises from the fact that for nonnegative x we compute a w-bit representation of âˆ’x as 2w âˆ’ x (a single two.) The term â€œonesâ€™ complementâ€ comes from the property that we can compute âˆ’x in this notation as [111 . . . 1] âˆ’ x (multiple ones). Twosâ€™ complement æ³¨æ„ åœ¨äºŒè¡¥æ•°ç¼–ç ä¸­ï¼Œå°†ä¸€ä¸ªæ•´æ•°è½¬æ¢æˆå…¶é€†å…ƒï¼Œä¹Ÿå¯ä»¥ä¾æ®ä»¥ä¸‹çš„æ–¹æ³•ï¼š ä»¥ LSB åˆ° MSB çš„é¡ºåºï¼Œå¯»æ‰¾ç¬¬ä¸€ä¸ªå€¼ä¸º 1 çš„ bitï¼Œå°†è¿™ä¸ª bit ä»¥åŠæ¯”å…¶æ›´ä½çš„ bits (åŒ…å«è¯¥ bit) éƒ½ä¿æŒä¸å˜ï¼Œå°†æ¯”è¯¥ bit æ›´é«˜çš„ bits (ä¸åŒ…æ‹¬è¯¥ bit) è¿›è¡Œå–åæ“ä½œã€‚ä¸‹é¢æ˜¯ä¸€äº›ä¾‹å­ (ä»¥ 32-bit ä¸ºä¾‹)ï¼š 0x0080 \u003c-\u003e 0xff80 0x0001 \u003c-\u003e 0xffff 0x0002 \u003c-\u003e 0xfffe ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:1","tags":["Sysprog","Numerics","Bitwise"],"title":"è§£è¯»è®¡ç®—æœºç¼–ç ","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"åŠ  / å‡æ³•å™¨è®¾è®¡ ç§‘æ™®çŸ­ç‰‡: See How Computers Add Numbers In One Lesson âœ… äº†è§£æ™¶ä½“ç®¡çš„åŸç† äº†è§£åŸºæœ¬é€»è¾‘é—¨å…ƒä»¶ï¼Œä¾‹å¦‚ OR, AND é€»è¾‘é—¨çš„è®¾è®¡ äº†è§£åŠ æ³•å™¨çš„åŸç†å’Œå·¥ä½œæµç¨‹ã€‚ ","date":"2023-12-31","objectID":"/posts/binary-representation/:2:2","tags":["Sysprog","Numerics","Bitwise"],"title":"è§£è¯»è®¡ç®—æœºç¼–ç ","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"é˜¿è´å°”ç¾¤åŠå¯¹ç§°æ€§ æŠ€å·§ ç¾¤è®ºçš„æœ€å¤§ç”¨é€”æ˜¯å…³äºã€Œå¯¹ç§°æ€§ã€çš„ç ”ç©¶ï¼›æ‰€æœ‰å…·æœ‰å¯¹ç§°æ€§è´¨ï¼Œç¾¤è®ºéƒ½å¯æ´¾ä¸Šç”¨åœºã€‚åªè¦å‘ç”Ÿå˜æ¢åä»æœ‰ä»€ä¹ˆä¸œè¥¿è¿˜ç»´æŒä¸å˜ï¼Œé‚£ç¬¦åˆå¯¹ç§°çš„æ€§è´¨ã€‚ ä¸€ä¸ªåœ†å·¦å³ç¿»è½¬åè¿˜æ˜¯åœ†ï¼Œå®ƒåœ¨è¿™ç§å˜æ¢ä¸‹æ˜¯å¯¹ç§°çš„ï¼Œè€Œè¿™åˆšå¥½ä¸ç¾¤çš„ å°é—­æ€§ (Closure) å¯¹åº”ã€‚ ä¸€ä¸ªæ—¶é’Ÿçš„æ—¶åˆ»ï¼Œä» 0 æ—¶åˆ»å¼€å§‹ï¼Œä¸¤è¾¹çš„æ—¶åˆ»ç›¸åŠ æ¨¡ 12 çš„ç»“æœå‡ä¸º 0ï¼Œè¿™ä¸ç¾¤çš„ å•ä½å…ƒ (Identity element) å’Œ é€†å…ƒ (Inverse element) å¯¹åº”ã€‚ ä¸Šè¿°ä¸¤ä¸ªä¾‹å­åæ˜ äº†ç¾¤è®ºçš„æ€§è´¨ï¼Œå¯¹äºå¯¹ç§°æ€§ç ”ç©¶çš„é‡è¦æ€§å’ŒåŸç†ä¾æ®ã€‚ ç§‘æ™®å½±ç‰‡: ä»äº”æ¬¡æ–¹ç¨‹åˆ°ä¼½ç½—ç“¦ç†è®º ","date":"2023-12-31","objectID":"/posts/binary-representation/:3:0","tags":["Sysprog","Numerics","Bitwise"],"title":"è§£è¯»è®¡ç®—æœºç¼–ç ","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"æ—è·¯æ”»å‡» è§‚çœ‹ç§‘æ™®è§†é¢‘: æˆ‘å¬å¾—åˆ°ä½ æ‰“äº†ä»€ä¹ˆå­— âœ… é˜…è¯»ç›¸å…³è®ºæ–‡ Keyboard Acoustic Emanations ä½“éªŒä½¿ç”¨ç›¸å…³å·¥å…· kbd-audio å€Ÿç”± Wikipedia äº†è§£æ—è·¯æ”»å‡» (Side-channel attack) å’Œæ—¶åºæ”»å‡» (Timing attack) çš„åŸºæœ¬æ¦‚å¿µ âœ… Black-box testing Row hammer Cold boot attack Rubber-hose cryptanalysis å»¶ä¼¸é˜…è¯» The password guessing bug in Tenex Side Channel Attack By Using Hidden Markov Model One\u0026Done: A Single-Decryption EM-Based Attack on OpenSSLâ€™s Constant-Time Blinded RSA ","date":"2023-12-31","objectID":"/posts/binary-representation/:4:0","tags":["Sysprog","Numerics","Bitwise"],"title":"è§£è¯»è®¡ç®—æœºç¼–ç ","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals"],"content":"Constant-Time Functions æ¯”è¾ƒå¸¸è§çš„å¸¸æ•°æ—¶é—´å®ä½œæ–¹æ³•æ˜¯ï¼Œæ¶ˆé™¤åˆ†æ”¯ã€‚å› ä¸ºä¸åŒåˆ†æ”¯çš„æ‰§è¡Œæ—¶é—´å¯èƒ½ä¼šä¸åŒï¼Œè¿™ä¼šè¢«åˆ©ç”¨è¿›è¡Œæ—¶åºæ”»å‡»ã€‚è¿™ä¸ªæ–¹æ³•éœ€è¦å¯¹ C è¯­è¨€ä¸­çš„ç¼–ç å’Œä½è¿ç®—æœ‰ä¸€å®šçš„äº†è§£ã€‚ C99 7.18.1.1 Exact-width integer types C99 6.5.7.5 Bitwise shift operators Source Branchless abs å¦‚æœ n æ˜¯ signed 32-bitï¼Œåˆ™ n \u003e\u003e 31 ç­‰ä»·äº n == 0 ? 0 : -1 æ–¹æ³•ä¸€ï¼ŒåŸç†ä¸º $-A = \\neg (A - 1)$: #include \u003cstdint.h\u003e int32_t abs(int32_t x) { int32_t mask = (x \u003e\u003e 31); return (x + mask) ^ mask; } æ–¹æ³•äºŒï¼ŒåŸç†ä¸º $-A = \\neg A + 1$: #include \u003cstdint.h\u003e int32_t abs(int32_t x) { int32_t mask = (x \u003e\u003e 31); return (x ^ mask) - mask; } Branchless min/max Min: #include \u003cstdint.h\u003e int32_t min(int32_t a, int32_t b) { int32_t diff = (a - b); return b + (diff \u0026 (diff \u003e\u003e 31)); } å¦‚æœ diff \u003e 0 å³ b å°ï¼Œé‚£ä¹ˆ (diff \u003e\u003e 31) == 0ï¼Œåˆ™ b + (diff \u0026 (diff \u003e\u003e 31)) == b å¦‚æœ diff \u003c 0 å³ a å°ï¼Œé‚£ä¹ˆ (diff \u003e\u003e 31) == -1ï¼Œåˆ™ b + (diff \u0026 (diff \u003e\u003e 31)) == b + (a - b) == a Max: #include \u003cstdint.h\u003e int32_t max(int32_t a, int32_t b) { int32_t diff = (b - a); return b - (diff \u0026 (diff \u003e\u003e 31)); } å¦‚æœ diff \u003e 0 å³ b å¤§, é‚£ä¹ˆ (diff \u003e\u003e 31) == 0ï¼Œåˆ™ b - (diff \u0026 (diff \u003e\u003e 31)) == b å¦‚æœ diff \u003c 0 å³ a å¤§ï¼Œé‚£ä¹ˆ (diff \u003e\u003e 31) == -1ï¼Œåˆ™ b - (diff \u0026 (diff \u003e\u003e 31)) == b - (b - a) == a ä¿¡æ¯ åŸºäº C è¯­è¨€æ ‡å‡†ç ”ç©¶ä¸ç³»ç»Ÿç¨‹åºå®‰å…¨è®®é¢˜ ","date":"2023-12-31","objectID":"/posts/binary-representation/:4:1","tags":["Sysprog","Numerics","Bitwise"],"title":"è§£è¯»è®¡ç®—æœºç¼–ç ","uri":"/posts/binary-representation/"},{"categories":["Linux Kernel Internals","Rust"],"content":" The year 2022 marks seven years since the stable version of the Rust language was officially released. Since its release, Rust has been popular among developers. In a Stack Overflow poll of over 73,000 developers from 180 countries, Rust was voted the most popular programming language for the seventh consecutive year, with 87% of developers expressing a desire to use it. ","date":"2023-12-28","objectID":"/posts/why-rust/:0:0","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Rust in 100 Seconds è§‚çœ‹çŸ­ç‰‡: Rust in 100 Seconds âœ… äº†è§£ Rustï¼Œåˆæ­¥äº†è§£å…¶å®‰å…¨æ€§åŸç† æ‰€æœ‰æƒ (ownership) å€Ÿç”¨ (borrow) è­¦å‘Š 0:55 This is wrong, value mutability doesnâ€™t have anything to do with the value being stored on the stack or the heap (and the example let mut hello = \"hi mom\" will be stored on the stack since itâ€™s type is \u0026'static str), it depends on the type of the value (if itâ€™s Sized or not). ","date":"2023-12-28","objectID":"/posts/why-rust/:1:0","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"The adoption of Rust in Business (2022) é˜…è¯»æŠ¥å‘Š: The adoption of Rust in Business (2022) âœ… Rust ç›®å‰è“¬å‹ƒå‘å±•ï¼Œé¢„æµ‹æœªæ¥æ˜¯å¾ˆéš¾çš„ï¼Œä½†æ˜¯ Rust å·²ç»æ˜¯è¿›è¡Œæ—¶çš„æœªæ¥äº† ğŸ¤£ ","date":"2023-12-28","objectID":"/posts/why-rust/:2:0","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"The Rust Programming Language Book Video Documentation Examples The Book æ•™å­¦å½•å½± The Standard Library Rust by Example ","date":"2023-12-28","objectID":"/posts/why-rust/:3:0","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Getting Started $ cargo new \u003cpackage\u003e # åˆ›å»ºé¡¹ç›® $ cargo build # ç¼–è¯‘ã€æ„å»ºã€è°ƒè¯•ç‰ˆæœ¬ $ cargo build --release # ç¼–è¯‘ä¼˜åŒ–ã€å‘å¸ƒç‰ˆæœ¬ $ cargo run # ç¼–è¯‘ã€è¿è¡Œ $ cargo check # é™æ€åˆ†ææ£€æŸ¥ $ cargo clean # æ¸…é™¤æ„å»ºå‡ºæ¥çš„ç›®æ ‡æ–‡ä»¶ $ cargo test # è¿è¡Œæµ‹è¯• ","date":"2023-12-28","objectID":"/posts/why-rust/:3:1","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Programming a Game Module std::io Module std::cmp Crate rand ","date":"2023-12-28","objectID":"/posts/why-rust/:3:2","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Common Concepts å˜é‡æ˜ç¡®åŒºåˆ†å¯å˜å’Œä¸å¯å˜ï¼Œå¥½å¤„åœ¨äºå¯¹äºæ˜ç¡®ä¸å¯å˜çš„å˜é‡ï¼Œä½¿ç”¨å¼•ç”¨æ—¶ç¼–è¯‘å™¨å¯ä»¥è¿›è¡Œæ›´ä¸ºæ¿€è¿›çš„æœ€ä½³åŒ–ã€‚å¸¸é‡å¿…é¡»æ»¡è¶³å¯ä»¥åœ¨ç¼–è¯‘æœŸè®¡ç®—å‡ºç»“æœã€‚ shadow å¯ç†è§£ä¸ºå˜é‡åå¯ä»¥å’Œå‚¨å­˜æ•°æ®çš„åœ°å€ç»‘å®šã€è§£ç»‘ï¼Œæ‰€ä»¥å¯ä»¥è¿›è¡Œå˜é‡é®è”½ã€‚è€Œ C è¯­è¨€ä¸­çš„å˜é‡åä¸€æ—¦ä½¿ç”¨å°±å’Œå‚¨å­˜æ•°æ®çš„åœ°å€ç»‘æ­»äº†ï¼Œè‡ªç„¶æ— æ³•è¿›è¡Œé®è”½ã€‚ 3.2. Data Types When youâ€™re compiling in release mode with the --release flag, Rust does not include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs twoâ€™s complement wrapping. In short, values greater than the maximum value the type can hold â€œwrap aroundâ€ to the minimum of the values the type can hold. In the case of a u8, the value 256 becomes 0, the value 257 becomes 1, and so on. The program wonâ€™t panic, but the variable will have a value that probably isnâ€™t what you were expecting it to have. Relying on integer overflowâ€™s wrapping behavior is considered an error. å³å½“ä½¿ç”¨ --release ç¼–è¯‘å‚æ•°æ—¶ï¼Œç¼–è¯‘å™¨ä¸ä¼šå°† integer overflow è§†ä¸º UB æ¨¡å¼åŒ¹é…çš„è¯­æ³•ä¸»è¦æ˜¯ä¸ºäº†æ–¹ä¾¿ç¼–è¾‘å™¨çš„å®ç°ï¼Œå› ä¸º (x, y, z) = tup è¿™æ ·çš„è¯æ³•ã€è¯­æ³•åˆ†ææ˜¾ç„¶æ¯” Python é£æ ¼çš„ x, y, z = tup åˆ†æéš¾åº¦ä½ã€‚ 3.2. Data Types Letâ€™s see what happens if you try to access an element of an array that is past the end of the array. This code compiles successfully. The program resulted in a runtime error at the point of using an invalid value in the indexing operation. æ•°ç»„å…ƒç´ çš„éæ³•è®¿é—®å¹¶ä¸ä¼šå¯¼è‡´ç¼–è¯‘å¤±è´¥ï¼Œè€Œæ˜¯ç¼–è¯‘æ—¶æœŸä¼šåœ¨è®¿é—®å…ƒç´ çš„é™„è¿‘åŠ ä¸Šæ£€æŸ¥æœ‰æ•ˆçš„è¯­å¥ï¼Œå¦‚æœè¿è¡Œæ—¶è®¿é—®äº†éæ³•çš„å…ƒç´ èŒƒå›´ï¼Œä¼šè§¦å‘è¿™ä¸ªæ£€æµ‹ä»è€Œå¯¼è‡´ panicã€‚ 3.3. Functions Rust code uses snake case as the conventional style for function and variable names, in which all letters are lowercase and underscores separate words. å‡½æ•°çš„å‚æ•°ç±»å‹å¿…é¡»æŒ‡æ˜ï¼Œè¿™å¯ä»¥æ–¹ä¾¿ç¼–è¯‘å™¨å¯¹æ ¹æ®å‡½æ•°å®šä¹‰å¯¹å‡½æ•°è°ƒç”¨è¿›è¡Œæ£€æŸ¥ï¼Œæ˜¯å¦ç¬¦åˆè¦æ±‚ï¼Œå¦ä¸€æ–¹é¢è¿˜å¯ä»¥è®©ç¼–è¯‘å™¨ç”Ÿæˆæ°å½“çš„æŒ‡ä»¤ç”¨äºè·³è½¬è¿›å‡½æ•°æ‰§è¡Œ (ç¼–è¯‘å™¨å¯èƒ½éœ€è¦åœ¨æ ˆä¸Šç»™å‡½æ•°ä¼ å…¥çš„å‚æ•°åˆ†é…ç©ºé—´ï¼Œä¾‹å¦‚ x86 æ¶æ„çš„æœºå™¨çš„ ABI å°±æ˜¯è¿™ä¹ˆè§„å®šçš„)ã€‚ 3.3. Functions Statements are instructions that perform some action and do not return a value. Expressions evaluate to a resultant value. Letâ€™s look at some examples. A new scope block created with curly brackets is an expression ä»è¿™ä¸ªè§’åº¦çœ‹ï¼ŒRust ä¸­çš„å‡½æ•°ä½“ä¹Ÿæ˜¯è¡¨è¾¾å¼ (å› ä¸ºç”¨ {} åŒ…è£¹èµ·æ¥)ï¼Œç„¶åå°†å‡½æ•°çš„è¿”å›å€¼è§†ä¸ºè¡¨è¾¾å¼çš„ç»“æœå€¼ã€‚å¥½åƒä¹Ÿæ²¡æ¯›ç—…ï¼Œæ¯•ç«Ÿ Rust ä¸­æ‰€æœ‰å‡½æ•°éƒ½æœ‰è¿”å›å€¼ï¼Œæ²¡å†™è¿”å›å€¼çš„é»˜è®¤ä¸ºè¿”å› ()ï¼Œè¡¨è¾¾å¼ä¹Ÿç±»ä¼¼ï¼Œæœ€åä¸€æ¡ä¸æ˜¯è¡¨è¾¾å¼çš„ä¼šè¡¥å……ä¸€ä¸ª () ä½œä¸ºè¯¥è¡¨è¾¾å¼çš„ç»“æœã€‚Rust ä¸­å¾ˆå¤šè¯­æ³•éƒ½æ˜¯è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ if, match ä»¥åŠ {} éƒ½æ˜¯è¡¨è¾¾å¼ï¼Œè€Œåœ¨å…¶ä»–è¯­è¨€ä¸­ä¸€èˆ¬æ˜¯è¯­å¥ (statement)ï¼Œéš¾æ€ªæœ‰: Rust is an expression-based language 3.3. Functions You can return early from a function by using the return keyword and specifying a value, but most functions return the last expression implicitly. å‡½æ•°ä½“çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼è§†ä¸ºè¿”å›å€¼ï¼Œè¿™åœ¨ç¼–è¯‘å™¨å®ä½œè§’åº¦å¹¶ä¸éš¾ï¼Œåªéœ€è¦åœ¨è¯­æ³•åˆ†ææ—¶åŠ å…¥è¿™ä¸ªé€»è¾‘å³å¯ï¼Œé™¤æ­¤ä¹‹å¤–çš„è¿”å›è¯­æ³•ï¼Œéœ€è¦ä½¿ç”¨å…³é”®å­— return ä»ç¼–è¯‘å™¨è¯­æ³•åˆ†æè§’åº¦çœ‹æ¥ä¹Ÿå¾ˆå½“ç„¶ (å› ä¸ºè¿”å›æ“ä½œéœ€è¦ç”Ÿæˆç›¸å¯¹åº”çš„æŒ‡ä»¤ï¼Œæ‰€ä»¥éœ€è¦æŒ‡ç¤ºå½“å‰æ˜¯è¿”å›æ“ä½œï¼Œé€šè¿‡æœ€åä¸€æ¡è¡¨è¾¾å¼æš—ç¤ºæˆ– return å…³é”®å­—æŒ‡ç¤º)ã€‚ 3.5. Control Flow You might also need to pass the result of that operation out of the loop to the rest of your code. To do this, you can add the value you want returned after the break expression you use to stop the loop; that value will be returned out of the loop so you can use it Range, provided by the standard library, which generates all numbers in sequence starting from one number and ending before another number. rev, to reverse the range. ","date":"2023-12-28","objectID":"/posts/why-rust/:3:3","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Ownership What is Ownership? Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks. If any of the rules are violated, the program won't compile. None of the features of ownership will slow down your program while it's running. By the same token, a processor can do its job better if it works on data thatâ€™s close to other data (as it is on the stack) rather than farther away (as it can be on the heap). è¿™ä¸»è¦æ˜¯å› ä¸º cache æœºåˆ¶å¸¦æ¥çš„æ•ˆèƒ½æå‡ Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you donâ€™t run out of space are all problems that ownership addresses. ä»ä¸Šé¢çš„æè¿°å¯ä»¥çœ‹å‡ºï¼Œæ‰€æœ‰æƒ (ownership) æœºåˆ¶ä¸»è¦é’ˆå¯¹çš„æ˜¯ heap ç©ºé—´çš„ç®¡ç†ï¼Œæ‰€ä»¥ä¸‹é¢çš„ 3 æ¡è§„åˆ™ä¹Ÿæ˜¯é’ˆå¯¹ heap ç©ºé—´ä¸Šçš„æ•°æ®: Each value in Rust has an owner. There can only be one owner at a time. When the owner goes out of scope, the value will be dropped. Rust takes a different path: the memory is automatically returned once the variable that owns it goes out of scope. ä¹Ÿå°±æ˜¯è¯´ï¼ŒRust ä½¿ç”¨ç±»ä¼¼ä¸ stack çš„æ–¹å¼æ¥ç®¡ç† heap ç©ºé—´ï¼Œå› ä¸º stack ä¸Šçš„æ•°åœ¨è¶…è¿‡ä½œç”¨äºå°±ä¼šè‡ªåŠ¨æ¶ˆäº¡ (é€šè¿‡ sp å¯„å­˜å™¨è¿›è¡Œå‡ºæ ˆæ“ä½œ)ã€‚Rust å¯¹äº heap çš„ç®¡ç†ä¹Ÿç±»ä¼¼ï¼Œåœ¨å‡ºæ ˆåŒæ—¶è¿˜å›æ”¶ heap å¯¹åº”çš„ç©ºé—´ï¼Œè¿™æ˜¯åˆç†çš„ï¼Œå› ä¸º heap ä¸Šçš„æ•°æ®éƒ½ä¼šç›´æ¥/ç®€æ¥åœ°è¢« stack ä¸Šçš„æ•°æ®æ‰€å¼•ç”¨ï¼Œä¾‹å¦‚æŒ‡é’ˆã€‚ å‡½æ•°å‚æ•°ä¹Ÿç±»ä¼¼ï¼Œå› ä¸ºä»å‡½æ•°è°ƒç”¨ ABI è§’åº¦æ¥çœ‹ï¼Œèµ‹å€¼å’Œå‡½æ•°è°ƒç”¨æ—¶å‚æ•°ã€è¿”å›çš„å¤„ç†éƒ½æ˜¯ç›¸åŒçš„ï¼Œå³åœ¨ stack ç©ºé—´è¿›è¡Œå…¥æ ˆæ“ä½œã€‚ We do not copy the data on the heap that the pointer refers to. ä¹Ÿå°±æ˜¯è¯´é€šå¸¸æƒ…å†µä¸‹ ç§»åŠ¨ (Move) åªå¯¹ heap ä¸Šçš„æ•°æ®èµ·ä½œç”¨ï¼Œå¯¹äº stack ä¸Šçš„æ•°æ®ï¼Œä½“ç°çš„æ˜¯ æ‹·è´ (Copy) æ“ä½œï¼Œå½“ç„¶è¿™ä¹Ÿä¸ç»å¯¹ï¼Œå¯ä»¥é€šè¿‡å®ç° Copy è¿™ä¸ª trait æ¥å¯¹ heap çš„æ•°æ®ä¹Ÿè¿›è¡Œæ‹·è´æ“ä½œã€‚Rust å¯¹äº stack å’Œ heap ä¸Šéƒ½æœ‰æ•°æ®çš„ object (ä¾‹å¦‚ String) çš„èµ‹å€¼å¤„ç†é»˜è®¤æ˜¯: æ‹·è´ stack ä¸Šçš„æ•°æ®ï¼Œæ–°çš„ stack æ•°æ®ä»ç„¶æŒ‡å‘åŒä¸€ä¸ª heap çš„æ•°æ®ï¼ŒåŒæ—¶å°†åŸå…ˆ stack æ•°æ®æ‰€åœ¨çš„å†…å­˜æ— æ•ˆåŒ–ã€‚ This is known as a double free error and is one of the memory safety bugs we mentioned previously. Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities. To ensure memory safety, after the line let s2 = s1;, Rust considers s1 as no longer valid. Therefore, Rust doesnâ€™t need to free anything when s1 goes out of scope. In addition, thereâ€™s a design choice thatâ€™s implied by this: Rust will never automatically create â€œdeepâ€ copies of your data. Therefore, any automatic copying can be assumed to be inexpensive in terms of runtime performance. ç§»åŠ¨ (Move) æ“ä½œè§£å†³äº† double free è¿™ä¸ªå®‰å…¨éšæ‚£ï¼Œè®© Rust åœ¨å†…å­˜å®‰å…¨çš„é¢†åŸŸå æ®äº†ä¸€å¸­ä¹‹åœ°ã€‚é™¤æ­¤ä¹‹å¤–ï¼ŒMove æ“ä½œä½¿å¾—è‡ªåŠ¨èµ‹å€¼çš„å¼€é”€å˜å¾—ä½å»‰ï¼Œå› ä¸ºä½¿ç”¨çš„æ˜¯ Move ç§»åŠ¨æ“ä½œï¼Œè€Œä¸æ˜¯ Copy æ‹·è´æ“ä½œã€‚ Rust wonâ€™t let us annotate a type with Copy if the type, or any of its parts, has implemented the Drop trait. If the type needs something special to happen when the value goes out of scope and we add the Copy annotation to that type, weâ€™ll get a compile-time error. References and Borrowing ä»å†…å­˜è§’åº¦æ¥çœ‹ï¼Œreference å¸¸ç”¨çš„åœºæ™¯ä¸º: Reference Owner +-------+ +----------------+ | stack | --\u003e | stack --\u003e Heap | +-------+ +----------------+ Mutable references have one big restriction: if you have a mutable reference to a value, you can have no other references to that value. The benefit of having this restriction is that Rust can prevent data races at compile time. A data race is similar to a race condition and happens when these three behaviors occur: Two or more pointers access the same data at the same time. At least one of the pointers is being used to write to the data. Thereâ€™s no mechanism being used to synchronize access to the data. We also cannot have a mutable reference while we have an immutable one to the same value. ç¼–è¯‘æ—¶æœŸå³å¯é˜²æ­¢æ•°æ®ç«äº‰ï¼ŒåŒæ—¶å…è®¸äº†ç¼–è¯‘å™¨è¿›è¡Œæ¿€è¿›çš„æœ€ä½³åŒ–ç­–ç•¥ (å› ä¸ºä¿è¯æ²¡æœ‰éé¢„æœŸçš„æ•°æ®ç«äº‰å‘ç”Ÿ)ã€‚ In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does. ç¼–è¯‘å™¨ä¿è¯äº†æˆ‘ä»¬ä½¿ç”¨å¼•ç”¨æ—¶çš„æ­£ç¡®æ€§ï¼ŒåŒæ—¶è¿™ä¹Ÿæ˜¯åé¢æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ (lifetime) çš„æœºåˆ¶åŸºç¡€ã€‚ At any given time, you can have either one mutable reference or any number of immutable references. References must always be valid. The Slice Type Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection. A slice is a kind of reference, so it does not have ownership. åˆ‡ç‰‡ (slice) ä¹Ÿ","date":"2023-12-28","objectID":"/posts/why-rust/:3:4","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Structs Rust ä¸å…è®¸ç»“æ„ä½“åˆå§‹åŒ–æ—¶åªæŒ‡å®šä¸€éƒ¨åˆ†å­—æ®µçš„å€¼ï¼Œè¿™é˜²æ­¢äº† UB ç›¸å…³é—®é¢˜çš„è§¦å‘ã€‚ 5.1. Defining and Instantiating Structs Note that the entire instance must be mutable; Rust doesnâ€™t allow us to mark only certain fields as mutable. Tuple structs are useful when you want to give the whole tuple a name and make the tuple a different type from other tuples, and when naming each field as in a regular struct would be verbose or redundant. Unit-like structs can be useful when you need to implement a trait on some type but donâ€™t have any data that you want to store in the type itself. æ³¨æ„ Rust ä¸­ struct é»˜è®¤æ˜¯è¿›è¡Œç§»åŠ¨ (Move) æ“ä½œï¼Œè€Œ tuple é»˜è®¤æ˜¯è¿›è¡Œæ‹·è´ (Copy) æ“ä½œã€‚è¿™æ˜¯å› ä¸º struct ä¸€èˆ¬ä½¿ç”¨æ—¶éƒ½ä¼šå¼•ç”¨ heap ä¸­çš„æ•°æ® (ä¾‹å¦‚ String)ï¼Œè€Œä¾æ®ç§»åŠ¨ (Move) æ“ä½œçš„è¯­ä¹‰ï¼Œè¿›è¡Œè‡ªåŠ¨èµ‹å€¼æ—¶ä¼šæ‹·è´ stack ä¸Šçš„æ•°æ®å¹¶ä¸”æ‰§è¡ŒåŒä¸€ heap çš„æ•°æ®ï¼Œä½†æ˜¯åŸå…ˆ stack çš„æ•°æ®ä¼šæ— æ•ˆåŒ–é˜²æ­¢å‘ç”Ÿ double freeã€‚ä¾æ®è¿™ä¸ªè¯­ä¹‰ï¼Œå°±ä¸éš¾ç†è§£ä¸ºä½• Rust ä¸­çš„ç»“æ„ä½“ä½äº stack æ—¶ä¹Ÿä¸ä¼šè¿›è¡Œæ‹·è´ (Copy) æ“ä½œè€Œæ˜¯è¿›è¡Œç§»åŠ¨ (Move) æ“ä½œäº†ï¼Œå› ä¸ºéœ€è¦æ ¹æ®å¸¸ç”¨åœºæ™¯å¯¹è¯­ä¹‰è¿›è¡Œ trade-offï¼Œå³ä½¿ struct æ²¡æœ‰å¼•ç”¨ heap çš„æ•°æ®ï¼Œä¸ºäº†ä¿éšœå¸¸ç”¨åœºæ™¯çš„æ•ˆèƒ½ï¼Œè¿˜æ˜¯å°†è¿™ç±»ç»“æ„ä½“è®¾è®¡æˆ Move æ“ä½œï¼Œå³ä¼šå¯¼è‡´åŸå…ˆçš„ç»“æ„ä½“æ— æ•ˆåŒ–ã€‚tuple ä¹ŸåŒç†ï¼Œå…¶å¸¸ç”¨åœºæ™¯ä¸º stack ä¸Šçš„å¤åˆæ•°æ®ï¼Œæ‰€ä»¥é»˜è®¤ä¸º Copy æ“ä½œã€‚ 5.2. An Example Program Using Structs Itâ€™s not the prettiest output, but it shows the values of all the fields for this instance, which would definitely help during debugging. When we have larger structs, itâ€™s useful to have output thatâ€™s a bit easier to read; in those cases, we can use {:#?} instead of {:?} in the println! string. è°ƒè¯•æ—¶å¸¸ä½¿ç”¨ #[derive(Debug)] æ­é… {:?} æˆ– {:#ï¼Ÿ} æ‰“å°ç›¸å…³çš„æ•°æ®ä¿¡æ¯è¿›è¡Œé™¤é”™ã€‚ 5.3. Method Syntax Rust doesnâ€™t have an equivalent to the -\u003e operator; instead, Rust has a feature called automatic referencing and dereferencing. Calling methods is one of the few places in Rust that has this behavior. è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæ–¹æ³• (Method) çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ self å¹¶ä¸”æ ¹æ®ä½¿ç”¨çš„å¼•ç”¨ç±»å‹å’Œæ‰€æœ‰æƒæœ‰ä¸åŒçš„ç­¾åï¼Œè¿™æ­£æ˜¯ä¸ºäº†æ–¹ä¾¿ç¼–è¯‘å™¨è¿›è¡Œè‡ªåŠ¨æ¨æ–­ (ä¸ªäººä¼°è®¡æ˜¯è¯­æ³•åˆ†ææ—¶è¿›è¡Œçš„)ã€‚ 5.3. Method Syntax The Self keywords in the return type and in the body of the function are aliases for the type that appears after the impl keyword è¿™ä¸ª Self å…³é”®å­—è¯­æ³•åœ¨åé¢â€œé™„é­”â€ä¸Šæ³›å‹å’Œç”Ÿå‘½å‘¨æœŸæ—¶å°±ååˆ†æœ‰ç”¨äº† ğŸ¤£ ","date":"2023-12-28","objectID":"/posts/why-rust/:3:5","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Enums and Pattern Matching è¿™éƒ¨åˆ†å†…å®¹å› ä¸ºæ˜¯ä»å‡½æ•°å¼ç¼–ç¨‹æ¼”åŒ–è€Œæ¥çš„ï¼Œå¯èƒ½ä¼šæ¯”è¾ƒéš¾ç†è§£ã€‚ æ³¨æ„ Rust ä¸­çš„æšä¸¾ (Enum) å®ç°äº†æŸç§æ„ä¹‰ä¸Šçš„ã€Œå¤§å°ç±»å‹ã€ï¼Œå³ä¸€ä¸ªå¤§ç±»å‹æ¶µç›–æœ‰å¾ˆå¤šå°ç±»å‹ï¼Œç„¶åä¸åŒçš„å°ç±»å‹å¯ä»¥æœ‰ä¸åŒçš„æ•°æ®æ„æˆï¼Œç„¶åæœ€å…·è¡¨è¾¾åŠ›çš„ä¸€ç‚¹æ˜¯ï¼šè¿™ä¸ªå¤§å°ç±»å‹å…³ç³»å¯ä»¥ä¸æ–­é€’å½’ä¸‹å»ã€‚æšä¸¾é™„å¸¦çš„æ•°æ®ç±»å‹æ”¯æŒï¼šç»“æ„ä½“ã€åŒ¿åç»“æ„ä½“ã€å…ƒç»„ï¼Œè¿™äº›é€šè¿‡ç¼–è¯‘å™¨çš„è¯­æ³•åˆ†æéƒ½ä¸éš¾å®ç°ã€‚ 6.1. Defining an Enum However, representing the same concept using just an enum is more concise: rather than an enum inside a struct, we can put data directly into each enum variant. å› ä¸ºæšä¸¾é™„å¸¦çš„æ•°æ®åœ¨å¤§éƒ¨åˆ†åœºæ™¯éƒ½æ˜¯å¼•ç”¨ heap æ•°æ®çš„ objectï¼Œæ‰€ä»¥å¯¹æšä¸¾çš„è‡ªåŠ¨èµ‹å€¼æ“ä½œå’Œç»“æ„ä½“ä¸€æ ·ï¼Œé»˜è®¤éƒ½æ˜¯ç§»åŠ¨ (Move) æ“ä½œï¼Œå³è‡ªåŠ¨èµ‹å€¼ååŸå…ˆæ•°æ®ä½äº stack çš„é‚£éƒ¨åˆ†å†…å­˜ä¼šå¤±æ•ˆã€‚ æ³¨æ„ Rust çš„ Option\u003cT\u003e çš„è®¾è®¡é¿å…äº†å…¶å®ƒè¯­è¨€ä¸­å¯èƒ½ä¼šå‡ºç°çš„ UBï¼Œä¾‹å¦‚å‡è®¾ä¸€ä¸ªå€¼å­˜åœ¨ï¼Œä½†å®é™…ä¸Šè¿™ä¸ªå€¼å¹¶ä¸å­˜åœ¨ï¼Œè¿™å…è®¸ç¼–è¯‘å™¨è¿›è¡Œæ›´æ¿€è¿›çš„æœ€ä½³åŒ–ã€‚åœ¨ Rust ä¸­åªè¦ä¸€ä¸ªå€¼ä¸æ˜¯ Option\u003cT\u003eï¼Œé‚£å®ƒå¿…ç„¶å­˜åœ¨ï¼Œå¹¶ä¸”åœ¨ Rust ä¸­ä¸èƒ½å¯¹ Option\u003cT\u003e è¿›è¡Œ T çš„æ“ä½œï¼Œè€Œæ˜¯éœ€è¦å…ˆè·å–é‡Œé¢ T çš„å€¼æ‰èƒ½è¿›è¡Œæ“ä½œï¼Œå³ Option\u003cT\u003e å¹¶æ²¡æœ‰ç»§æ‰¿ T çš„è¡Œä¸ºã€‚ 6.1. Defining an Enum Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. the compiler canâ€™t infer the type that the corresponding Some variant will hold by looking only at a None value. None ä¸æ˜¯ä¸€ç§ç±»å‹ï¼Œè€Œæ˜¯ä¸€ä¸ªå¤§ç±»å‹ Option\u003cT\u003e ä¸‹çš„ä¸€ä¸ªå°ç±»å‹ï¼Œæ‰€ä»¥ä¼šæœ‰å„ç§å„æ ·çš„ None ç±»å‹ï¼Œè€Œä¸å­˜åœ¨ä¸€ä¸ªç‹¬ä¸€æ— äºŒçš„ None ç±»å‹ã€‚ 6.2. The match Control Flow Construct Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants. æ¨¡å¼åŒ¹é…çš„æœºåˆ¶æ˜¯å¯¹ æšä¸¾çš„ç±»å‹ (åŒ…æ‹¬å¤§å°ç±»å‹) è¿›è¡ŒåŒ¹é…ï¼Œåƒå‰¥æ´‹è‘±ä¸€æ ·ï¼Œæœ€åå°†æšä¸¾ç±»å‹é™„å¸¦çš„ æ•°æ® ç»‘å®šåˆ°æˆ‘ä»¬æƒ³è¦çš„å˜é‡ä¸Šã€‚åªéœ€è¦ç†è§£ä¸€ç‚¹: åªèƒ½å¯¹å€¼è¿›è¡Œç»‘å®šï¼Œç±»å‹æ˜¯ç”¨æ¥åŒ¹é…çš„ã€‚å½“ç„¶æ¨¡å¼åŒ¹é…ä¹Ÿå¯ä»¥ç²¾ç¡®åŒ¹é…åˆ°å€¼ï¼Œä½†è¿™æ ·æ²¡å•¥æ„ä¹‰ï¼Œå› ä¸ºä½ éƒ½çŸ¥é“å€¼äº†ï¼Œè¿˜è¿›è¡Œæ¨¡å¼åŒ¹é…ç©·ä¸¾å¹²å•¥ï¼ŸğŸ¤£ è¿™ç§ç²¾ç¡®åˆ°å€¼çš„æ¨¡å¼åŒ¹é…ä¸€èˆ¬å‡ºç°åœ¨ä¸‹é¢çš„ if let è¡¨è¾¾å¼ä¸­ï¼Œmatch è¡¨è¾¾å¼ä¸€èˆ¬ä¸ä¼šè¿™æ ·ç”¨ã€‚ 6.2. The match Control Flow Construct Rust also has a pattern we can use when we want a catch-all but donâ€™t want to use the value in the catch-all pattern: _ is a special pattern that matches any value and does not bind to that value. 6.3. Concise Control Flow with if let The if let syntax lets you combine if and let into a less verbose way to handle values that match one pattern while ignoring the rest. if let è¡¨è¾¾å¼æœ¬è´¨ä¸Šæ˜¯æ‰§è¡Œæ¨¡å¼åŒ¹é…çš„ if è¡¨è¾¾å¼ In other words, you can think of if let as syntax sugar for a match that runs code when the value matches one pattern and then ignores all other values. We can include an else with an if let. The block of code that goes with the else is the same as the block of code that would go with the _ case in the match expression that is equivalent to the if let and else. å»¶ä¼¸é˜…è¯» Keyword ref ","date":"2023-12-28","objectID":"/posts/why-rust/:3:6","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Packages, Crates, and Modules Packages: A Cargo feature that lets you build, test, and share crates Crates: A tree of modules that produces a library or executable Modules and use: Let you control the organization, scope, and privacy of paths Paths: A way of naming an item, such as a struct, function, or module Package |__ Crate (Root Module) |__ Module ... |__ Module |__ Crate (Root Module) |__ Module ... |__ Module ... |__ Crate (Root Module) |__ Module ... |__ Module ä¸Šé¢å°±æ˜¯ä¸‰è€…çš„å…³ç³»å›¾ï¼Œæ³¨æ„ Package å’Œ crate æ˜¯ä»å·¥ç¨‹ç®¡ç†è§’åº¦è€Œè¡ç”Ÿæ¥çš„æ¦‚å¿µï¼Œè€Œ Module åˆ™æ˜¯ä»ä»£ç ç®¡ç†è§’åº¦çš„æ¦‚å¿µ (æ–‡ä»¶ç³»ç»Ÿæ ‘)ï¼Œå°†è¿™ä¸¤ç§è§†è§’ç»“åˆåœ¨ä¸€èµ·çš„ä¸­é—´å±‚åˆ™æ˜¯: crate çš„åå­—è¢«è§†ä¸ºè¯¥ crate çš„ root moduleã€‚ æ³¨æ„ æ¯ä¸ª module åŒ…æ‹¬ä¸ crate åŒåçš„ root moduleï¼Œè¯¥ module èŒƒå›´ä¸‹çš„ã€Œä¸€ç­‰å…¬æ°‘ã€(æ— è®ºæ˜¯æ˜¯ä¸æ˜¯å…¬å¼€çš„ï¼Œå› ä¸ºå…¬å¼€æƒé™åªé’ˆå¯¹å¤–éƒ¨) ä¹‹é—´å¯ä»¥äº’ç›¸è®¿é—®ï¼Œä½†æ— æ³•è®¿é—®è¿™äº›ä¸€ç­‰å…¬æ°‘çš„ç§æœ‰ä¸‹å±ï¼Œä¾‹å¦‚ä¸€ç­‰å…¬æ°‘æ˜¯ moduleï¼Œé‚£ä¹ˆå°±æ— æ³•è®¿é—®è¿™ä¸ª module å†…éƒ¨çš„ç§æœ‰ä¸‹å±ã€‚ æˆ‘åŒçº§çš„ä¸‹çº§ä¸æ˜¯æˆ‘çš„ä¸‹çº§ åœ¨ Rust æ¨¡å—ç®¡ç†ä¸­ï¼Œä¸Šçº§æ˜¯å¤–éƒ¨ï¼Œæ‰€ä»¥ä¸Šçº§æ— æ³•è®¿é—®ä¸‹çº§çš„ç§æœ‰æˆå‘˜ï¼Œä½†æ˜¯ä¸‹çº§çš„ä»»æ„æˆå‘˜éƒ½å¯ä»¥è®¿é—®ä¸Šçº§çš„ä»»æ„æˆå‘˜ã€‚ä»æ ‘çš„è§’åº¦æ¯”è¾ƒå¥½ç†è§£ï¼Œå› ä¸ºä»æå¶èŠ‚ç‚¹å¯ä»¥å‘ä¸Šæº¯æºåˆ°ç¥–å…ˆèŠ‚ç‚¹ï¼Œè€Œåœ¨ Rust æ¨¡å—ç®¡ç†çš„å‡†åˆ™æ˜¯: å¯ä»¥è¢«æœå¯»åˆ° (å³å­˜åœ¨ä¸€æ¡è·¯å¾„) çš„èŠ‚ç‚¹éƒ½å¯ä»¥è¢«è®¿é—®ã€‚å‘ä¸‹æœå¯»éœ€è¦è€ƒè™‘å…¬å¼€æƒé™ï¼Œå‘ä¸Šæœå¯»åˆ™ä¸éœ€è¦(è¿™é‡Œçš„å‘ä¸Šå‘ä¸‹æ˜¯æŒ‡ç»å¯¹çš„å‘å‘ï¼Œå› ä¸ºå¯èƒ½ä¼šå‡ºç°å…ˆå‘ä¸Šå†å‘ä¸‹çš„åœºæ™¯ï¼Œè¿™æ—¶éœ€è¦åœ°è¿™ä¸¤é˜¶æ®µåˆ†å¼€è€ƒè™‘)ï¼Œè€Œä¸Šé¢çš„è§„åˆ™ä¹Ÿå¯ä»¥å½’çº³ä¸º: è®¿é—®å…„å¼ŸèŠ‚ç‚¹æ— éœ€è€ƒè™‘æƒé™ã€‚ 7.1. Packages and Crates If a package contains src/main.rs and src/lib.rs, it has two crates: a binary and a library, both with the same name as the package. A package can have multiple binary crates by placing files in the src/bin directory: each file will be a separate binary crate. 7.3. Paths for Referring to an Item in the Module Tree We can construct relative paths that begin in the parent module, rather than the current module or the crate root, by using super at the start of the path. This is like starting a filesystem path with the .. syntax. Rust By Example 10.2. Struct visibility Structs have an extra level of visibility with their fields. The visibility defaults to private, and can be overridden with the pub modifier. This visibility only matters when a struct is accessed from outside the module where it is defined, and has the goal of hiding information (encapsulation). æ³¨æ„è¿™å¥è¯ This visibility only matters when a struct is accessed from outside the module where it is defined è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒä»»æ„æ··æ·†çš„ç‚¹ï¼Œè¿™å¥è¯è¯´æ˜åªæœ‰ä» å¤–éƒ¨è®¿é—® æ—¶è¿™ä¸ªè§„åˆ™æ‰ç”Ÿæ•ˆï¼ŒåŒçº§è®¿é—® æ—¶ struct çš„æƒé™å°±ç±»ä¼¼ä¸ C è¯­è¨€ï¼Œæˆå‘˜æ˜¯å…¬å¼€çš„ã€‚è¿™å¾ˆåˆç†ï¼Œè¦ä¸ç„¶ç»“æ„ä½“å¯¹åº” impl éƒ¨åˆ†ä¹Ÿæ— æ³•è®¿é—®ç§æœ‰å­—æ®µå—ï¼Ÿé‚£è¿™æ ·æ€ä¹ˆè¿›è¡Œåˆå§‹åŒ–æ„é€ ï¼Ÿæ˜¯ä¸æ˜¯å°±è±ç„¶å¼€æœ—äº†ã€‚ 7.3. Paths for Referring to an Item in the Module Tree In contrast, if we make an enum public, all of its variants are then public. We only need the pub before the enum keyword 7.4. Bringing Paths Into Scope with the use Keyword Adding use and a path in a scope is similar to creating a symbolic link in the filesystem. ä½¿ç”¨ use å°±ç±»ä¼¼ä¸ Linux æ–‡ä»¶ç³»ç»Ÿä¸­çš„ã€Œç¬¦å·é“¾æ¥ã€ï¼Œå½“ç„¶ä½¿ç”¨è¿™ç§è¯­æ³•éœ€è¦éµå®ˆä¸€å®šçš„é£æ ¼ï¼Œæ–¹ä¾¿å¤šå·¥åˆä½œ: Specifying the parent module when calling the function makes it clear that the function isn't locally defined while still minimizing repetition of the full path. On the other hand, when bringing in structs, enums, and other items with use, it's idiomatic to specify the full path. The exception to this idiom is if we're bringing two items with the same name into scope with use statements, because Rust doesnâ€™t allow that. As you can see, using the parent modules distinguishes the two Result types. Rust ä¸­ä¹Ÿæœ‰ç±»ä¼¼äº Linux ç³»ç»Ÿçš„åˆ«åæŠ€å·§ï¼Œé‚£å°±æ˜¯ä½¿ç”¨ as å…³é”®å­—æ¥æ­é… use è¯­æ³•: There's another solution to the problem of bringing two types of the same name into the same scope with use: after the path, we can specify as and a new local name, or alias, for the type. When we bring a name into scope with the use keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code's scope, we can combine pub and use. This technique is called re-exporting because we're bringing an item into scope but also making that item available for others to bring into their scope. ä½¿ç”¨ use è¯­æ³•å¼•å…¥çš„åˆ«ååœ¨å½“å‰ä½œç”¨åŸŸå (scope) æ˜¯ç§æœ‰çš„ (private)ï¼Œå¦‚æœæƒ³è®©è¿™ä¸ªåˆ«ååœ¨å½“å‰ä½œç”¨åŸŸé‡æ–°å¯¼å‡ºä¸ºå…¬å¼€æƒé™ï¼Œå¯ä»¥ä½¿ç”¨ pub use è¯­æ³•ã€‚ The common part of these two paths is std::io, and that's the complete first path. To merge these two paths into one use statement, we can use self in the nested path, self å…³é”®å­—é™¤äº†åœ¨å¯¹è±¡çš„ impl éƒ¨åˆ†è¡¨ç¤ºå®ä¾‹è‡ªèº«ä¹‹å¤–ï¼Œåœ¨æ¨¡å— (Module) ç®¡ç†ä¸Šä¹Ÿå¯ä»¥ç”¨äºè¡¨ç¤ºæ¨¡å—è‡ªèº« (è¿™ä¸ªè¯­æ³•ä¸å¸¸ç”¨ï¼Œå› ä¸ºä¸€èˆ¬æƒ…å†µä¸‹ LSP ä¼šå¸®ç¨‹åºå‘˜è‡ªåŠ¨å¤„ç†å¥½)ã€‚ æ³¨æ„ Rust å¯¹äºæ¨¡å—çš„åˆ†ç¦»è¯­æ³•çš„æ–‡ä»¶ç®¡","date":"2023-12-28","objectID":"/posts/why-rust/:3:7","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Common Collections Documentation Struct std::vec::Vec Struct std::string::String Struct std::collections::HashMap Vector Like any other struct, a vector is freed when it goes out of scope When the vector gets dropped, all of its contents are also dropped, meaning the integers it holds will be cleaned up. The borrow checker ensures that any references to contents of a vector are only used while the vector itself is valid. å¼•ç”¨æ­é… vector åœ¨ drop åœºæ™¯æ¯”è¾ƒå¤æ‚ï¼Œæ¶‰åŠåˆ°ç”Ÿå‘½å‘¨æœŸä»¥åŠå€Ÿç”¨æ£€æŸ¥æœºåˆ¶ã€‚ Using \u0026 and [] gives us a reference to the element at the index value. When we use the get method with the index passed as an argument, we get an Option\u003c\u0026T\u003e that we can use with match. ä½¿ç”¨ [] è¿ç®—ç¬¦è·å¾—çš„æ˜¯å…ƒç´ æœ¬èº«ï¼Œæ— è®ºå®¹å™¨æ˜¯å¼•ç”¨çš„è¿˜æ˜¯æ‹¥æœ‰æ‰€æœ‰æƒçš„ã€‚ä½†è¯»å– vector çš„å…ƒç´ è·å¾—çš„åº”è¯¥æ˜¯è¯¥å…ƒç´ çš„å¼•ç”¨ï¼Œå› ä¸ºè¯»å–ä¸€ä¸ªå…ƒç´ å¤§éƒ¨åˆ†æƒ…å†µä¸‹ä¸éœ€è¦è¯¥å…ƒç´ çš„æ‰€æœ‰æƒï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œå¦‚æœè·å–äº†å…ƒç´ çš„æ‰€æœ‰æƒï¼Œé‚£ä¹ˆå¯¹äº vector çš„ä½¿ç”¨ä¼šæœ‰ä¸€äº›å®‰å…¨é™åˆ¶ã€‚ let mut v = vec![1, 2, 3, 4, 5]; let first = \u0026v[0]; v.push(6); println!(\"The first element is: {first}\"); why should a reference to the first element care about changes at the end of the vector? This error is due to the way vectors work: because vectors put the values next to each other in memory, adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isnâ€™t enough room to put all the elements next to each other where the vector is currently stored. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation. å€Ÿç”¨è§„åˆ™åœ¨ vector ä»ç„¶æˆç«‹ï¼Œå¹¶ä¸”å¯¹ vector ä¸€äº›çœ‹ä¼¼ä¸ç›¸å…³å®åˆ™ç›¸å…³çš„äº‹ä¾‹çš„åŸç†è¿›è¡Œäº†è§£é‡Šã€‚ let mut v = vec![100, 32, 57]; for i in \u0026mut v { *i += 50; } To change the value that the mutable reference refers to, we have to use the * dereference operator to get to the value in i before we can use the += operator. ä¸€èˆ¬æ¥è¯´ï¼Œåªæœ‰å¯å˜å¼•ç”¨ \u0026mut æ‰éœ€è¦å…³å¿ƒè§£å¼•ç”¨ * è¿ç®—ç¬¦ï¼Œå› ä¸ºä¸å¯å˜å¼•ç”¨åªèƒ½è¡¨è¾¾æ‰€å¼•ç”¨çš„æ•°æ®æœ¬èº«ï¼Œå¹¶ä¸èƒ½ä¿®æ”¹ï¼Œè€Œå¯å˜å¼•ç”¨æ—¢èƒ½è¡¨è¾¾æ‰€å¼•ç”¨çš„æ•°æ®æœ¬èº«ï¼Œè¿˜èƒ½å¯¹è¿™ä¸ªæ•°æ®è¿›è¡Œä¿®æ”¹ï¼Œéœ€è¦ä¸€ä¸ªæœºåˆ¶å°†è¿™ä¸¤ä¸ªè¡¨è¾¾èƒ½åŠ›åŒºåˆ†å¼€ (æ–¹ä¾¿ç¼–è¯‘å™¨åœ¨è¯­æ³•åˆ†æä¸Šçš„å®ä½œ)ï¼ŒRust é‡‡ç”¨çš„ç­–ç•¥æ˜¯é’ˆå¯¹ä¿®æ”¹æ•°æ®è¿™ä¸ªèƒ½åŠ›éœ€è¦ä½¿ç”¨ * è¿ç®—ç¬¦ã€‚ é™¤äº†åŒºåˆ†è¡¨è¾¾è¡Œä¸ºä¹‹å¤–ï¼Œè¿™ä¸ªè§‚ç‚¹ä¹Ÿå¯ä»¥å¸®åŠ©æˆ‘ä»¬ç†è§£ä¸€äº› Rust å“²å­¦ï¼Œä¾‹å¦‚æŸ¥è¯¢æ•°æ®çš„å‡½æ•° / æ–¹æ³•ä¸€èˆ¬åªéœ€è¦ä¸å¯å˜å¼•ç”¨ \u0026 ä½œä¸ºå‚æ•°ï¼ŒæŒ‰ç…§ä¸Šé¢çš„è§£é‡Šï¼Œä¸å¯å˜å¼•ç”¨ \u0026 åªèƒ½è¡¨ç¤ºæ‰€å¼•ç”¨çš„æ•°æ®æœ¬èº«ï¼Œæ‰€ä»¥ä½œä¸ºå‚æ•°å¯¹äºå‡½æ•°å†…éƒ¨å®ä½œå¹¶æ— å½±å“ (å› ä¸ºåªéœ€è¦æŸ¥çœ‹æ•°æ®æœ¬èº«è€Œä¸éœ€è¦å¯¹å…¶ä¿®æ”¹)ï¼ŒåŒæ—¶é¿å…äº†æ‰€æœ‰æƒå¸¦æ¥çš„é«˜æ˜‚æˆæœ¬ã€‚ Vectors can only store values that are the same type. Fortunately, the variants of an enum are defined under the same enum type, so when we need one type to represent elements of different types, we can define and use an enum! è¿ç”¨æšä¸¾ (enum) æ­é… vector å¯ä»¥å®ä½œå‡ºæ¯”æ³›å‹æ›´å…·è¡¨è¾¾åŠ›çš„ vectorï¼Œå³ vector ä¸­çš„æ¯ä¸ªå…ƒç´ çš„ç±»å‹å¯ä»¥ä¸ç›¸åŒ (é€šè¿‡ enum çš„å¤§å°ç±»å‹æœºåˆ¶å³å¯å®ä½œ)ã€‚ String Rust has only one string type in the core language, which is the string slice str that is usually seen in its borrowed form \u0026str. The String type, which is provided by Rustâ€™s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. Although this section is largely about String, both types are used heavily in Rustâ€™s standard library, and both String and string slices are UTF-8 encoded. Rust ä¸­çš„å­—ç¬¦ä¸²æ˜¯ UTF-8 ç¼–ç ï¼Œæ³¨æ„ä¸ä¹‹å‰æ‰€æçš„ char ç±»å‹ä½¿ç”¨çš„ Unicode ç¼–ç ä¸åŒã€‚è¿™ä¸€ç‚¹å¾ˆé‡è¦ï¼Œå› ä¸º String çš„ len() æ–¹æ³•æ˜¯è®¡ç®— byte çš„æ•°é‡ (UTF-8 ç¼–ç åªå æ®ä¸€ä¸ª byte)ã€‚ The push_str method takes a string slice because we donâ€™t necessarily want to take ownership of the parameter. å‚æ•°æ˜¯å­—ç¬¦ä¸²çš„å¼•ç”¨è€Œä¸æ˜¯ String çš„åŸå› æ˜¯ï¼Œå¦‚æœä¼ å…¥çš„æ˜¯ String ä¼šè½¬ç§»æ‰€æœ‰æƒï¼Œè¿›è€Œå¯¼è‡´åŸå…ˆçš„ String æ‰€åœ¨çš„ stack å†…å­˜å¤±æ•ˆï¼Œåˆå› ä¸ºå­—ç¬¦ä¸²çš„å­—ç¬¦æ‹·è´æ“ä½œæ˜¯æ¯”è¾ƒå®¹æ˜“å®ç°çš„ï¼Œæ‰€ä»¥é€šè¿‡å­—ç¬¦ä¸²å¼•ç”¨ä¹Ÿå¯ä»¥å¯¹å­—ç¬¦ä¸²å†…å®¹çš„å­—ç¬¦è¿›è¡Œæ‹·è´ï¼Œè€Œä¸ä¼šå¯¹ String çš„æ‰€æœ‰æƒé€ æˆå½±å“ã€‚å¼•ç”¨æœªå¿…ä¸å¯æ‹·è´ï¼Œæ‹·è´ä¸æ˜¯æ‰€æœ‰æƒçš„ä¸“å± (åªè¦å¼•ç”¨çš„å¯¹è±¡çš„å…ƒç´ å®ç°äº† Copyï¼Œé‚£å°±å¯ä»¥é€šè¿‡å¼•ç”¨æ¥è¿›è¡Œæ‹·è´ï¼Œä¾‹å¦‚ \u0026str åŠå…¶å…ƒç´ â€”â€”å­—ç¬¦)ã€‚ The version of the code using format! is much easier to read, and the code generated by the format! macro uses references so that this call doesnâ€™t take ownership of any of its parameters. format! å’Œ print! å®çš„å…³ç³»å°±å’Œ C è¯­è¨€ä¸­çš„ sprintf å’Œ printf çš„å…³ç³»ç±»ä¼¼ã€‚ Rust strings donâ€™t support indexing. A String is a wrapper over a Vec\u003cu8\u003e. A final reason Rust doesnâ€™t allow us to index into a String to get a character is that indexing operations are expected to always take constant time $O(1)$. But it isnâ€™t possible to guarantee that performance with a String, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were. å­—ç¬¦ä¸²åº•å±‚å®ä½œæ˜¯ä½¿ç”¨ UTF-8 ç¼–ç çš„ï¼Œä½†æ˜¯ä¸ºäº†å…¼å®¹ï¼Œå­—ç¬¦ä¸²ä¹Ÿå¯ä»¥è¡¨ç¤ºå…¶ä»–","date":"2023-12-28","objectID":"/posts/why-rust/:3:8","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Error Handling Rust groups errors into two major categories: recoverable and unrecoverable errors. For a recoverable error, such as a file not found error, we most likely just want to report the problem to the user and retry the operation. Unrecoverable errors are always symptoms of bugs, like trying to access a location beyond the end of an array, and so we want to immediately stop the program. Rust doesnâ€™t have exceptions. Instead, it has the type Result\u003cT, E\u003e for recoverable errors and the panic! macro that stops execution when the program encounters an unrecoverable error. Rust å¹¶æ²¡æœ‰å¼‚å¸¸æœºåˆ¶ï¼Œè€Œæ˜¯ä½¿ç”¨ Result\u003cT, E\u003e å’Œ panic! åˆ†åˆ«æ¥å¤„ç†å¯æ¢å¤ (recoverable) å’Œä¸å¯æ¢å¤ (unrecoverable) çš„é”™è¯¯ã€‚å¯æ¢å¤é”™è¯¯çš„å¤„ç†ç­–ç•¥æ¯”è¾ƒç‰¹åˆ«ï¼Œå› ä¸ºå®ƒä½¿ç”¨äº† Rust ç‹¬æœ‰çš„æšä¸¾ç±»å‹ï¼Œè€Œå¯¹äºä¸å¯æ¢å¤é”™è¯¯çš„å¤„ç†å°±æ¯”è¾ƒå¸¸è§„äº†ï¼Œæœ¬è´¨ä¸Šå’Œ C è¯­è¨€çš„ exit å¤„ç†ç›¸åŒã€‚ 9.1. Unrecoverable Errors with panic! By default, when a panic occurs, the program starts unwinding, which means Rust walks back up the stack and cleans up the data from each function it encounters. However, this walking back and cleanup is a lot of work. Rust, therefore, allows you to choose the alternative of immediately aborting, which ends the program without cleaning up. # abort on panic in release mode [profile.release] panic = 'abort' A backtrace is a list of all the functions that have been called to get to this point. Backtraces in Rust work as they do in other languages: the key to reading the backtrace is to start from the top and read until you see files you wrote. Thatâ€™s the spot where the problem originated. $ RUST_BACKTRACE=1 cargo run $ RUST_BACKTRACE=full cargo run 9.2. Recoverable Errors with Result If the Result value is the Ok variant, unwrap will return the value inside the Ok. If the Result is the Err variant, unwrap will call the panic! macro for us. Similarly, the expect method lets us also choose the panic! error message. Using expect instead of unwrap and providing good error messages can convey your intent and make tracking down the source of a panic easier. å¯¹äº Result\u003cT, E\u003e ä¸€èˆ¬æ˜¯é€šè¿‡ match æ¨¡å¼åŒ¹é…è¿›è¡Œå¤„ç†ï¼Œè€Œ unwrap å’Œ expect æœ¬è´¨éƒ½æ˜¯å¯¹ Result\u003cT, E\u003e çš„å¸¸è§çš„ match å¤„ç†æ¨¡å¼çš„ç¼©å†™ï¼Œå€¼å¾—ä¸€æçš„æ˜¯ï¼Œå®ƒä»¬å¯¹äº Option\u003cT\u003e ä¹Ÿæœ‰ç±»ä¼¼çš„æ•ˆæœã€‚ The ? placed after a Result value is defined to work in almost the same way as the match expressions we defined to handle the Result values in Listing 9-6. If the value of the Result is an Ok, the value inside the Ok will get returned from this expression, and the program will continue. If the value is an Err, the Err will be returned from the whole function as if we had used the return keyword so the error value gets propagated to the calling code. When the ? operator calls the from function, the error type received is converted into the error type defined in the return type of the current function. ? è¿ç®—ç¬¦æ˜¯å¸¸ç”¨çš„ä¼ æ’­é”™è¯¯çš„ match æ¨¡å¼åŒ¹é…çš„ç¼©å†™ï¼Œå¦å¤–ç›¸å¯¹äºç›´æ¥ä½¿ç”¨ match æ¨¡å¼åŒ¹é…ï¼Œ? è¿ç®—ç¬¦ä¼šå°†æ¥æ”¶çš„é”™è¯¯ç±»å‹è½¬æ¢æˆè¿”å›ç±»å‹çš„é”™è¯¯ç±»å‹ï¼Œä»¥åŒ¹é…å‡½æ•°ç­¾åã€‚ç±»ä¼¼çš„ï¼Œ? å¯¹äº Option\u003cT\u003e ä¹Ÿæœ‰ç±»ä¼¼çš„æ•ˆæœã€‚ 9.3. To panic! or Not to panic! Therefore, returning Result is a good default choice when youâ€™re defining a function that might fail. å®šä¹‰ä¸€ä¸ªå¯èƒ½ä¼šå¤±è´¥çš„å‡½æ•°æ—¶ (å³é¢„æœŸè®¡åˆ’å¤„ç†é”™è¯¯)ï¼Œåº”è¯¥ä½¿ç”¨ Result è¿›è¡Œé”™è¯¯å¤„ç†ï¼Œå…¶å®ƒæ—¶å€™ä¸€èˆ¬ä½¿ç”¨ panic! å¤„ç†å³å¯ (å› ä¸ºé¢„æœŸå°±æ²¡æ‰“ç®—å¤„ç†é”™è¯¯)ã€‚ ","date":"2023-12-28","objectID":"/posts/why-rust/:3:9","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Generic, Traits, and Lifetimes å¼•ç”¨ Removing Duplication by Extracting a Function: Identify duplicate code. Extract the duplicate code into the body of the function and specify the inputs and return values of that code in the function signature. Update the two instances of duplicated code to call the function instead. Generic Data Types æ³¨æ„ æ³›å‹ (generic) å’Œå‡½æ•°æ¶ˆé™¤é‡å¤ä»£ç çš„é€»è¾‘ç±»ä¼¼ï¼ŒåŒºåˆ«åœ¨äºå‡½æ•°æ˜¯åœ¨ è¿è¡Œæ—¶æœŸ è°ƒç”¨æ—¶æ‰é’ˆå¯¹ä¼ å…¥å‚æ•°çš„ æ•°å€¼ è¿›è¡Œå®ä¾‹åŒ–ï¼Œè€Œæ³›å‹æ˜¯åœ¨ ç¼–è¯‘æ—¶æœŸ é’ˆå¯¹æ¶‰åŠçš„è°ƒç”¨çš„ ç±»å‹ (è°ƒç”¨æ—¶æ¶‰åŠçš„ç±»å‹æ˜¯å‚æ•°çš„ç±»å‹ï¼Œè¿”å›ç±»å‹æš‚æ—¶æ— æ³•ä½¿ç”¨æ³›å‹) è¿›è¡Œå®ä¾‹åŒ–ã€‚ Note that we have to declare T just after impl so we can use T to specify that weâ€™re implementing methods on the type Point\u003cT\u003e. By declaring T as a generic type after impl, Rust can identify that the type in the angle brackets in Point is a generic type rather than a concrete type. ä»ç¼–è¯‘å™¨è¯æ³•åˆ†æå’Œè¯­æ³•åˆ†æè§’åº¦æ¥ç†è§£è¯¥è¯­æ³• The good news is that using generic types wonâ€™t make your program run any slower than it would with concrete types. Rust accomplishes this by performing monomorphization of the code using generics at compile time. Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled. æ³›å‹åœ¨ç¼–è¯‘æ—¶æœŸè€Œä¸æ˜¯è¿è¡Œæ—¶æœŸè¿›è¡Œå•ä¾‹åŒ–ï¼Œå¹¶ä¸å½±å“æ•ˆèƒ½ Traits: Defining Shared Behavior A typeâ€™s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose. Trait å®ç°çš„æ˜¯ è¡Œä¸º çš„å…±äº«ï¼Œè€Œæ²¡æœ‰å®ç°æ•°æ®çš„å…±äº«ï¼Œå³å®ƒåªå®ç°äº†è¡Œä¸ºæ¥å£çš„å…±äº«ã€‚ Note that it isnâ€™t possible to call the default implementation from an overriding implementation of that same method. pub fn notify\u003cT: Summary\u003e(item: \u0026T) { println!(\"Breaking news! {}\", item.summarize()); } pub fn notify\u003cT: Summary + Display\u003e(item: \u0026T) {} The impl Trait syntax is convenient and makes for more concise code in simple cases, while the fuller trait bound syntax can express more complexity in other cases. Trait Bound æœ¬è´¨ä¹Ÿæ˜¯æ³›å‹ï¼Œåªä¸è¿‡å®ƒé™åˆ¶äº†æ³›å‹åœ¨ç¼–è¯‘æ—¶æœŸå¯ä»¥è¿›è¡Œå®ä¾‹åŒ–çš„å…·ä½“ç±»å‹ï¼Œä¾‹å¦‚è¯¥å…·ä½“ç±»å‹å¿…é¡»å®ç°æŸä¸ªæˆ–æŸäº› Traitã€‚è€Œ impl Trait æ˜¯å®ƒçš„è¯­æ³•ç³–ï¼Œæˆ‘ä¸ªäººå€¾å‘äºä½¿ç”¨ Trait Boundï¼Œå› ä¸ºå¯è¯»æ€§æ›´å¥½ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œimpl Trait åº”ç”¨åœ¨è¿”å›ç±»å‹æ—¶æœ‰ä¸€äº›é™åˆ¶ (Trait Bound ä¹Ÿæš‚æ—¶æ— æ³•è§£å†³è¯¥é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬æš‚æ—¶åªèƒ½å°† Trait Bound åº”ç”¨äºå‡½æ•°å‚æ•°): However, you can only use impl Trait if youâ€™re returning a single type. pub fn notify(item: \u0026(impl Summary + Display)) {...} // equal pub fn notify\u003cT: Summary + Display\u003e(item: \u0026T) {...} æ³¨æ„ Rust æ˜¯ä¸€é—¨æ³¨é‡ ç¼–è¯‘æ—¶æœŸ çš„è¯­è¨€ï¼Œæ‰€ä»¥å®ƒä½¿ç”¨ Trait ä¸å¯èƒ½åƒ Java ä½¿ç”¨ Inteface é‚£ä¹ˆçµæ´»ã€‚å› ä¸º Rust å¤„ç† Trait ä¹Ÿæ˜¯åœ¨ç¼–è¯‘æ—¶æœŸè¿›è¡Œå¤„ç†çš„ï¼Œéœ€è¦åœ¨ç¼–è¯‘æ—¶æœŸå°† Trait è½¬æ¢æˆå…·ä½“ç±»å‹ï¼Œæ‰€ä»¥å…¶åº•å±‚æœ¬è´¨å’Œæ³›å‹ç›¸åŒï¼Œéƒ½æ˜¯ç¼–è¯‘æ—¶æœŸå®ä¾‹åŒ–ï¼Œåªä¸è¿‡åŠ ä¸Šäº†å®ä¾‹åŒ–çš„å…·ä½“ç±»å‹çš„é™åˆ¶ (å¦‚æœæ²¡æ»¡è¶³é™åˆ¶å°±ä¼šç¼–è¯‘é”™è¯¯)ã€‚ fn some_function\u003cT: Display + Clone, U: Clone + Debug\u003e(t: \u0026T, u: \u0026U) -\u003e i32 {} fn some_function\u003cT, U\u003e(t: \u0026T, u: \u0026U) -\u003e i32 where T: Display + Clone, U: Clone + Debug, {} Rust has alternate syntax for specifying trait bounds inside a where clause after the function signature. where è¯­æ³•ä½¿å¾—ä½¿ç”¨ Trait Bound è¯­æ³•çš„å‡½æ•°ç­¾åå˜å¾—ç®€æ´ï¼Œå¢å¼ºäº†å¯è¯»æ€§ï¼Œç‰¹åˆ«æ˜¯åœ¨ Trait Bound æ¯”è¾ƒå¤æ‚çš„æƒ…å†µä¸‹ã€‚ By using a trait bound with an impl block that uses generic type parameters, we can implement methods conditionally for types that implement the specified traits. impl\u003cT: Display + PartialOrd\u003e Pair\u003cT\u003e {} We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called blanket implementations and are extensively used in the Rust standard library. impl\u003cT: Display\u003e ToString for T {} ä¸€æ ·çš„è¿˜æ˜¯ Trait Bound çš„ æ³›å‹æ­é…å…·ä½“ç±»å‹é™åˆ¶ çš„æ€æƒ³ Validating References with Lifetimes The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data itâ€™s intended to reference. ä¸»è¦ç›®çš„å°±æ˜¯é˜²æ­¢ dangling reference è¿™ä¸ª UB Lifetime annotations donâ€™t change how long any of the references live. Rather, they describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes. è¿›è¡Œæ ‡æ³¨å¹¶ä¸ä¼šå½±å“å¯¹è±¡æœ¬èº«çœŸæ­£çš„ç”Ÿå‘½å‘¨æœŸï¼Œåªæ˜¯ å¸®åŠ©ç¼–è¯‘å™¨è¿›è¡Œæ¨å¯¼ï¼ŒåŒæ—¶è¿™ä¸ªæ ‡æ³¨ä¸å‡½æ•°å†…éƒ¨é€»è¾‘ä¹Ÿæ— å…³ï¼Œä¸»è¦ä½œç”¨æ˜¯å¸®åŠ©ç¼–è¯‘å™¨é€šè¿‡ å‡½æ•°ç­¾å å’Œ å‡½æ•°è°ƒç”¨ å¯¹æ¶‰åŠçš„ç”Ÿå‘½å‘¨æœŸè¿›è¡Œæ£€æŸ¥ (æœ‰äº›æƒ…å†µéœ€è¦å¯¹å‡½æ•°ä½“å†…çš„è¿”å›é€»è¾‘è¿›è¡Œæ£€æŸ¥)ï¼Œé˜²æ­¢å‡ºç° dangling reference è¿™ä¸ª UBã€‚ Just as functions can accept any type when the signature specifies a","date":"2023-12-28","objectID":"/posts/why-rust/:3:10","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Automated Tests 11.1. How to Write Tests Tests are Rust functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions: Set up any needed data or state. Run the code you want to test. Assert the results are what you expect. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed. è‡ªåŠ¨æµ‹è¯•æ¨¡æ¿: #[cfg(test)] mod tests { use super::*; #[test] fn larger_can_hold_smaller() {} } è‡ªåŠ¨æµ‹è¯•å¸¸ç”¨å®: Macro std::assert Macro std::assert_eq Macro std::assert_ne You can also add a custom message to be printed with the failure message as optional arguments to the assert!, assert_eq!, and assert_ne! macros. Any arguments specified after the required arguments are passed along to the format! macro ä¸Šé¢æ¶‰åŠçš„å®éƒ½æ˜¯ç”¨æ¥å¯¹è¿”å›å€¼è¿›è¡Œæµ‹è¯•çš„ (ä¹Ÿå¯ä»¥é™„åŠ é”™è¯¯ä¿¡æ¯)ï¼Œæœ‰æ—¶æˆ‘ä»¬éœ€è¦æµ‹è¯•ä»£ç åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ˜¯å¦æŒ‰ç…§é¢„æœŸå‘ç”Ÿææ…Œï¼Œè¿™æ—¶æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ should_panic å±æ€§: In addition to checking return values, itâ€™s important to check that our code handles error conditions as we expect. We do this by adding the attribute should_panic to our test function. The test passes if the code inside the function panics; the test fails if the code inside the function doesnâ€™t panic. #[test] #[should_panic] fn greater_than_100() { ... } Tests that use should_panic can be imprecise. A should_panic test would pass even if the test panics for a different reason from the one we were expecting. To make should_panic tests more precise, we can add an optional expected parameter to the should_panic attribute. The test harness will make sure that the failure message contains the provided text. #[test] #[should_panic(expected = \"less than or equal to 100\")] fn greater_than_100() { ... } should_panic å±æ€§å¯é™„å¸¦ expected æ–‡æœ¬ï¼Œè¿™æ ·è‡ªåŠ¨æµ‹è¯•æ—¶ï¼Œä¸ä»…ä¼šæ£€æµ‹æ˜¯å¦å‘ç”Ÿ panic è¿˜ä¼šæ£€æµ‹ panic ä¿¡æ¯æ˜¯å¦åŒ…å« expect æ–‡æœ¬ï¼Œè¿™æ ·ä½¿å¾— should_panic å¯¹äºå‘ç”Ÿ panic çš„åŸå› æŒæ¡çš„æ›´åŠ ç²¾å‡† (å› ä¸ºä¸åŒåŸå› å¯¼è‡´çš„ panic çš„ä¿¡æ¯ä¸€èˆ¬ä¸ç›¸åŒ)ã€‚ é™¤äº†ä½¿ç”¨ panic æ–¹æ³•æ¥ç¼–å†™è‡ªåŠ¨æµ‹è¯• (ä¸Šé¢æ‰€æçš„æ–¹æ³•æœ¬è´¨éƒ½æ˜¯æµ‹è¯•å¤±è´¥æ—¶è§¦å‘ panic)ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡ Result\u003cT, E\u003e æ¥ç¼–å†™æµ‹è¯•ï¼Œè¿”å› Ok è¡¨ç¤ºæµ‹è¯•æˆåŠŸï¼Œè¿”å› Err åˆ™è¡¨ç¤ºæµ‹è¯•å¤±è´¥ã€‚ rather than calling the assert_eq! macro, we return Ok(()) when the test passes and an Err with a String inside when the test fails. #[test] fn it_works() -\u003e Result\u003c(), String\u003e { if 2 + 2 == 4 { Ok(()) } else { Err(String::from(\"two plus two does not equal four\")) } } You canâ€™t use the #[should_panic] annotation on tests that use Result\u003cT, E\u003e. 11.2. Controlling How Tests Are Run The default behavior of the binary produced by cargo test is to run all the tests in parallel and capture output generated during test runs, preventing the output from being displayed and making it easier to read the output related to the test results. You can, however, specify command line options to change this default behavior. separate these two types of arguments, you list the arguments that go to cargo test followed by the separator -- and then the ones that go to the test binary. $ cargo test \u003cargs1\u003e -- \u003cargs2\u003e # args1: cargo test çš„å‚æ•° # args2: cargo test ç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶çš„å‚æ•° When you run multiple tests, by default they run in parallel using threads, meaning they finish running faster and you get feedback quicker. Because the tests are running at the same time, you must make sure your tests donâ€™t depend on each other or on any shared state, including a shared environment, such as the current working directory or environment variables. è‡ªåŠ¨æµ‹è¯•é»˜è®¤è¡Œä¸ºæ˜¯å¹¶è¡Œçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨ç¼–å†™æµ‹è¯•ä»£ç æ—¶ï¼Œéœ€è¦å®‰è£…å¹¶è¡Œè®¾è®¡çš„æ€ç»´è¿›è¡Œç¼–å†™ï¼Œä¿è¯ä¸ä¼šå‡ºç°å› ä¸ºå¹¶è¡Œè€Œå¯¼è‡´çš„ UBã€‚å½“ç„¶ä½ ä¹Ÿå¯ä»¥æŒ‡å®šè‡ªåŠ¨æµ‹è¯•æ—¶ä½¿ç”¨çš„çº¿ç¨‹æ•°é‡ï¼Œç”šè‡³å¯ä»¥å°†çº¿ç¨‹æ•°è®¾ç½®ä¸º 1 è¿™æ ·å°±ä¸éœ€è¦ä»¥å¹¶è¡Œè®¾è®¡æµ‹è¯•ä»£ç äº†ã€‚ If you donâ€™t want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the â€“test-threads flag and the number of threads you want to use to the test binary. $ cargo test -- --test-threads=1 By default, if a test passes, Rustâ€™s test library captures anything printed to standard output. For example, if we call println! in a test and the test passes, we wonâ€™t see the println! output in the terminal; weâ€™ll see only the line that indicates the test passed. If a test fails, weâ€™ll see whatever was printed to standard ou","date":"2023-12-28","objectID":"/posts/why-rust/:3:11","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"An I/O Project: minigrep 12.3. Refactoring to Improve Modularity and Error Handling As a result, the Rust community has developed guidelines for splitting the separate concerns of a binary program when main starts getting large. This process has the following steps: Split your program into a main.rs and a lib.rs and move your programâ€™s logic to lib.rs. As long as your command line parsing logic is small, it can remain in main.rs. When the command line parsing logic starts getting complicated, extract it from main.rs and move it to lib.rs. The responsibilities that remain in the main function after this process should be limited to the following: Calling the command line parsing logic with the argument values Setting up any other configuration Calling a run function in lib.rs Handling the error if run returns an error è¿™æ ·å¤„ç†ä½¿å¾—æˆ‘ä»¬å¯ä»¥æµ‹è¯•è¯¥ç¨‹åºçš„å‡ ä¹å…¨éƒ¨å†…å®¹ï¼Œå› ä¸ºæˆ‘ä»¬å°†å¤§éƒ¨åˆ†é€»è¾‘éƒ½ç§»åŠ¨åˆ°äº† lib.rs æ–‡ä»¶é‡Œé¢ï¼Œè€Œ lib.rs æ–‡ä»¶çš„å†…å®¹æ˜¯å¯ä»¥è¢«æµ‹è¯•çš„ã€‚ Documentation: method std::iter::Iterator::collect method std::result::Result::unwrap_or_else Function std::process::exit method str::lines method str::contains method str::to_lowercase method std::result::Result::is_err ","date":"2023-12-28","objectID":"/posts/why-rust/:3:12","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Iterators and Closures Rustâ€™s design has taken inspiration from many existing languages and techniques, and one significant influence is functional programming. æˆåŠŸ è¿™ä¸€ç« æ˜¯å…³äºå‡½æ•°å¼ç¼–ç¨‹çš„ï¼ŒRust å¸æ”¶äº†å¾ˆå¤šç¼–ç¨‹èŒƒå¼çš„ç²¾åï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥ä½¿ç”¨å‡½æ•°å¼ç¼–ç¨‹é£æ ¼ã€‚å…³äºå‡½æ•°å¼ç¼–ç¨‹çš„èµ„æ–™ï¼Œå¯ä»¥å‚è€ƒåº·å¥ˆå°”å¤§å­¦çš„ OCaml Programming: Correct + Efficient + Beautiful å’Œæ–¯å¦ç¦å¤§å­¦çš„ç¼–ç¨‹èŒƒå¼ CS107ï¼Œä»¥åŠæœ€å‡ºåçš„éº»çœç†å·¥å­¦é™¢çš„ SICP (è¿™ä¸ªç‰ˆæœ¬æ˜¯ç»™ IBM å·¥ç¨‹å¸ˆåŸ¹è®­çš„ï¼ŒMIT è¿˜æœ‰ä¸€ä¸ª 2004 å¹´çš„ç‰ˆæœ¬ æ˜¯ç»™å­¦ç”Ÿä¸Šè¯¾çš„)ã€‚ Closures: Anonymous Functions that Capture Their Environment Rustâ€™s closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure elsewhere to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which theyâ€™re defined. ä¸¥æ ¼ä¸Šæ¥è®²ï¼Œå‡½æ•°ä¹Ÿå¯ä»¥æ•è·å…¶å®šä¹‰çš„ä½œç”¨åŸŸçš„å˜é‡ï¼Œä¾‹å¦‚ C è¯­è¨€çš„å‡½æ•°å°±å¯ä»¥è®¿é—®å…¨å±€å˜é‡ï¼Œå› ä¸ºå…¨å±€å˜é‡å’Œå‡½æ•°éƒ½æ˜¯å®šä¹‰æœ€é¡¶å±‚ï¼Œä½œä¸º first-classã€‚æ‹…ä»»é—­åŒ…çš„çµæ´»æ€§æ›´å¼ºï¼Œä¾‹å¦‚å¯ä»¥å°†é—­åŒ…å®šä¹‰åœ¨ç»“æ„ä½“é‡Œé¢ï¼Œä½œä¸ºç»“æ„ä½“çš„æˆå‘˜ï¼Œä»è€Œå¯ä»¥å®ç°æ‡’è®¡ç®—çš„åŠŸèƒ½ã€‚ Closures donâ€™t usually require you to annotate the types of the parameters or the return value like fn functions do. Type annotations are required on functions because the types are part of an explicit interface exposed to your users. Closures, on the other hand, arenâ€™t used in an exposed interface like this: theyâ€™re stored in variables and used without naming them and exposing them to users of our library. Closures are typically short and relevant only within a narrow context rather than in any arbitrary scenario. Within these limited contexts, the compiler can infer the types of the parameters and the return type As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. å› ä¸ºé—­åŒ…ä¸æš´éœ²ç»™å¤–éƒ¨ä½¿ç”¨è€…ï¼Œå¹¶ä¸”é—­åŒ…é€»è¾‘ä¸€èˆ¬æ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥é—­åŒ…çš„å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹ç”±ç¨‹åºå‘˜è‡ªå·±ä¿è¯å³å¯ï¼Œç¼–è¯‘å™¨ä¸€èˆ¬å¯ä»¥æ¨æ–­å‡ºæ¥ (ç±»ä¼¼äºç¼–è¯‘å™¨å¯ä»¥æ¨æ–­å‡ºå˜é‡çš„ç±»å‹)ã€‚å½“ç„¶ä¹Ÿå¯ä»¥ç»™é—­åŒ…çš„å‚æ•°å’Œè¿”å›å€¼åŠ ä¸Šç±»å‹æ ‡æ³¨ (ç±»ä¼¼äºå¯ä»¥ç»™å˜é‡åŠ ä¸Šç±»å‹æ ‡æ³¨)ï¼Œè¿™ä¹Ÿæ˜¯åˆæ³•çš„ã€‚ fn add_one_v1 (x: u32) -\u003e u32 { x + 1 } let add_one_v2 = |x: u32| -\u003e u32 { x + 1 }; let add_one_v3 = |x| { x + 1 }; let add_one_v4 = |x| x + 1 ; é—­åŒ…çš„å†…éƒ¨é€»è¾‘å¿…é¡»æ˜¯ä¸€ä¸ª è¡¨è¾¾å¼ï¼Œä½¿å¾—é—­åŒ…æ‹¥æœ‰è¿”å›å€¼ï¼Œä¾‹å¦‚ä¸Šé¢çš„ä¸­é—´ä¸¤è¡Œçš„é—­åŒ…é€»è¾‘éƒ½æ˜¯ {} è¡¨è¾¾å¼ï¼Œæœ€åä¸€è¡Œçš„æ˜¯ x + 1 è¿™ä¸ªåŠ æ³•è¡¨è¾¾å¼ (å‡½æ•°å’Œæˆ‘ä»¬ä¹‹å‰æåˆ°çš„ä¸€æ ·ï¼Œå‡½æ•°ä½“å¿…é¡»æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œé€šå¸¸æ˜¯ {} è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ç¬¬ä¸€è¡Œ)ã€‚ For closure definitions, the compiler will infer one concrete type for each of their parameters and for their return value. å¦‚æœä¾èµ–ç¼–è¯‘å™¨æ¨æ–­é—­åŒ…çš„ç›¸å…³ç±»å‹ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨åªä¼šæ¨æ–­å‡ºä¸€ä¸ªå…·ä½“çš„ç±»å‹ï¼Œç±»ä¼¼äºç¼–è¯‘å™¨å¯¹äºå˜é‡çš„ç±»å‹ä¹Ÿåªèƒ½æ¨æ–­å‡ºä¸€ä¸ªï¼Œæ‰€ä»¥ä¸‹é¢çš„ä¾‹å­ä¼šæŠ¥é”™: let example_closure = |x| x; let s = example_closure(String::from(\"hello\")); // |x: String| let n = example_closure(5); // |x: i32| å¼•ç”¨ FnOnce applies to closures that can be called once. All closures implement at least this trait, because all closures can be called. A closure that moves captured values out of its body will only implement FnOnce and none of the other Fn traits, because it can only be called once. FnMut applies to closures that donâ€™t move captured values out of their body, but that might mutate the captured values. These closures can be called more than once. Fn applies to closures that donâ€™t move captured values out of their body and that donâ€™t mutate captured values, as well as closures that capture nothing from their environment. These closures can be called more than once without mutating their environment, which is important in cases such as calling a closure multiple times concurrently. impl\u003cT\u003e Option\u003cT\u003e { pub fn unwrap_or_else\u003cF\u003e(self, f: F) -\u003e T where F: FnOnce() -\u003e T { match self { Some(x) =\u003e x, None =\u003e f(), } } } å› ä¸ºé—­åŒ…æ˜¯ Traitï¼Œæ‰€ä»¥é—­åŒ…ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’æ—¶ï¼Œéœ€è¦ä½¿ç”¨ æ³›å‹çº¦æŸ æ¥æŒ‡å®šå¯¹åº”çš„ Trait If you want to force the closure to take ownership of the values it uses in the environment even though the body of the closure doesnâ€™t strictly need ownership, you can use the move keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so that itâ€™s owned by the new thread. å¤šçº¿ç¨‹ç¼–ç¨‹æ—¶ä½¿ç”¨ move å…³é”®å­—å¯ä»¥å¼ºåˆ¶å°†ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒäº¤ç»™å¦ä¸€ä¸ªçº¿ç¨‹ã€‚ Processing a Series of Items with Iterators æ³¨æ„ è¿™ä¸€èŠ‚ç®€å•ä»‹ç»äº†ä¸‹è¿­ä»£å™¨æ˜¯ä»€ä¹ˆä»¥åŠè¿­ä»£å™¨çš„åŠŸèƒ½ï¼Œå¦‚æœæƒ³æ›´è¿›ä¸€æ­¥åœ°äº†è§£è¿­ä»£å™¨çš„å®ä½œï¼Œå»ºè®®è§‚çœ‹ John Gjengset çš„å½±ç‰‡ Crust of Rust: Iteratorsï¼Œæœ¬äººä¹Ÿæœ‰å†™ç›¸å…³çš„ ç¬”è®° æ¥å¯¹å½±ç‰‡å†…å®¹è¿›è¡Œè§£é‡Šå’Œæ‰©å±•ã€‚ The Iterator Trait and the next Method An iterator is responsible for the logic of iterating over each item and determinin","date":"2023-12-28","objectID":"/posts/why-rust/:3:13","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Cargo and Crates.io 14.1. Customizing Builds with Release Profiles Cargo has two main profiles: the dev profile Cargo uses when you run cargo build and the release profile Cargo uses when you run cargo build --release. Cargo has default settings for each of the profiles that apply when you havenâ€™t explicitly added any [profile.*] sections in the projectâ€™s Cargo.toml file. By adding [profile.*] sections for any profile you want to customize, you override any subset of the default settings. [profile.dev] opt-level = 0 [profile.release] opt-level = 3 14.2. Publishing a Crate to Crates.io Rust also has a particular kind of comment for documentation, known conveniently as a documentation comment, that will generate HTML documentation. Documentation comments use three slashes, ///, instead of two and support Markdown notation for formatting the text. Place documentation comments just before the item theyâ€™re documenting. We can generate the HTML documentation from this documentation comment by running cargo doc. For convenience, running cargo doc --open will build the HTML for your current crateâ€™s documentation (as well as the documentation for all of your crateâ€™s dependencies) and open the result in a web browser. Documentation Comments as Tests running cargo test will run the code examples in your documentation as tests! Commenting Contained Items The style of doc comment //! adds documentation to the item that contains the comments rather than to the items following the comments. Exporting a Convenient Public API with pub use The good news is that if the structure isnâ€™t convenient for others to use from another library, you donâ€™t have to rearrange your internal organization: instead, you can re-export items to make a public structure thatâ€™s different from your private structure by using pub use. 14.3. Cargo Workspaces [workspace] members = [ \"adder\", ] $ cargo new adder Created binary (application) `adder` package â”œâ”€â”€ Cargo.lock â”œâ”€â”€ Cargo.toml â”œâ”€â”€ adder â”‚ â”œâ”€â”€ Cargo.toml â”‚ â””â”€â”€ src â”‚ â””â”€â”€ main.rs â””â”€â”€ target [dependencies] add_one = { path = \"../add_one\" } ","date":"2023-12-28","objectID":"/posts/why-rust/:3:14","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Smart Pointers Rust, with its concept of ownership and borrowing, has an additional difference between references and smart pointers: while references only borrow data, in many cases, smart pointers own the data they point to. ä¸å¼•ç”¨ä¸åŒï¼Œæ™ºèƒ½æŒ‡é’ˆæ˜¯å¯ä»¥æ‹¥æœ‰æ•°æ®çš„æ‰€æœ‰æƒçš„ Trait std::ops::Deref Trait std::ops::DerefMut The Deref trait allows an instance of the smart pointer struct to behave like a reference so you can write your code to work with either references or smart pointers. Trait std::ops::Drop The Drop trait allows you to customize the code thatâ€™s run when an instance of the smart pointer goes out of scope. Box\u003cT\u003e Boxes allow you to store data on the heap rather than the stack. Box\u003cT\u003e ä¼šå°†æ‰€æŒ‡å‘çš„æ•°æ®å­˜å‚¨åœ¨ heap ä¸Šè€Œä¸æ˜¯åœ¨ stack ä¸Š The Box\u003cT\u003e type is a smart pointer because it implements the Deref trait, which allows Box\u003cT\u003e values to be treated like references. When a Box\u003cT\u003e value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the Drop trait implementation. Box\u003cT\u003e è¿™ç§åŠŸèƒ½ç®€å•çš„æŒ‡é’ˆä¹Ÿæ˜¯æ™ºèƒ½æŒ‡é’ˆçš„åŸå› åœ¨äºï¼Œå®ƒå®ç°äº†å¿…è¦çš„ä¸¤ä¸ª Trait: Deref å’Œ Dropï¼Œä½¿å¾—å…¶æ ¸å¿ƒè¡Œä¸ºå’Œå…¶ä»–æ™ºèƒ½æŒ‡é’ˆä¸€è‡´ Deref Trait Implementing the Deref trait allows you to customize the behavior of the dereference operator * (not to be confused with the multiplication or glob operator). By implementing Deref in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too. è§£å¼•ç”¨è¿ç®—ç¬¦ * æ˜¯å’Œå¼•ç”¨è¿ç®—ç¬¦ \u0026 æ­é…ä½¿ç”¨çš„ï¼Œä¾‹å¦‚: let x: i32 = 5; let y: \u0026i32 = \u0026x; assert_eq!(5, *y); æ™ºèƒ½æŒ‡é’ˆå®ç° Deref çš„æ„ä¹‰åœ¨äºï¼ŒDeref çš„å¿…è¦æ–¹æ³• deref ä¼šå°†è¯¥æ™ºèƒ½æŒ‡é’ˆè½¬æ¢æˆå¯¹åº”çš„å¼•ç”¨å½¢å¼ \u0026ï¼Œè¿™æ—¶å€™è§£å¼•ç”¨è¿ç®—ç¬¦ * å°±å¯ä»¥å¯¹åº”ä¸Š \u0026 äº†ã€‚è¿™ä½¿å¾—ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆå°±å’Œä½¿ç”¨å¼•ç”¨ä¸€æ ·ï¼Œå®é™…ä¸Šæ˜¯ç¼–è¯‘å™¨å¯¹æˆ‘ä»¬éšè—äº†ä¸­é—´ä½¿ç”¨çš„ deref è½¬æ¢ã€‚ let x: i32 = 5; let y: Box\u003ci32\u003e = Box::new(x); assert_eq!(5, *y); // equal assert_eq!(5, *y.deref()); // y.deref() -\u003e \u0026i32 è¿ç»­å¤šæ¬¡éšå¼ deref è½¬æ¢: fn main() { let m = MyBox::new(String::from(\"Rust\")); // \u0026m -\u003e \u0026MyBox // (\u0026m).deref() -\u003e \u0026String | by impl Deref for MyBox // ((\u0026m).deref()).deref() -\u003e \u0026str | by impl Deref for String hello(\u0026m); } fn hello(name: \u0026str) { println!(\"Hello, {name}!\"); } Rust does deref coercion when it finds types and trait implementations in three cases: From \u0026T to \u0026U when T: Deref\u003cTarget=U\u003e From \u0026mut T to \u0026mut U when T: DerefMut\u003cTarget=U\u003e From \u0026mut T to \u0026U when T: Deref\u003cTarget=U\u003e Drop Trait Rust automatically called drop for us when our instances went out of scope, calling the code we specified. call the std::mem::drop function provided by the standard library if you want to force a value to be dropped before the end of its scope. Rc\u003cT\u003e The Rc\u003cT\u003e type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid. RefCell\u003cT\u003e But we can use the methods on RefCell\u003cT\u003e that provide access to its interior mutability so we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and itâ€™s sometimes worth trading a bit of speed for this flexibility in our data structures. æ³¨æ„ å»¶ä¼¸é˜…è¯»: Crust of Rust: Smart Pointers and Interior Mutability Rust æ™ºèƒ½æŒ‡é’ˆæ•™ç¨‹ ","date":"2023-12-28","objectID":"/posts/why-rust/:3:15","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Fearless Concurrency ","date":"2023-12-28","objectID":"/posts/why-rust/:3:16","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Object-Oriented Programming 17.1. Characteristics of Object-Oriented Languages Object-oriented programs are made up of objects. An object packages both data and the procedures that operate on that data. The procedures are typically called methods or operations. Using this definition, Rust is object-oriented: structs and enums have data, and impl blocks provide methods on structs and enums. Rust ä¸­ä½¿ç”¨ç»“æ„ä½“ã€æšä¸¾å’Œ impl å—æ¥å®ç°äº† OOP èŒƒå¼çš„å¯¹è±¡ã€æ•°æ®å’Œè¡Œä¸ºä¸‰å¤§è¦ç´ ã€‚ Another aspect commonly associated with OOP is the idea of encapsulation, which means that the implementation details of an object arenâ€™t accessible to code using that object. we can use the pub keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. Rust ä½¿ç”¨ pub å…³é”®å­—æ¥æ§åˆ¶å¯è§æ€§ï¼Œå®ç°äº† OOP èŒƒå¼çš„å°è£…è¦æ±‚ã€‚ Inheritance is a mechanism whereby an object can inherit elements from another objectâ€™s definition, thus gaining the parent objectâ€™s data and behavior without you having to define them again. You can do this in a limited way in Rust code using default trait method implementations We can also override the default implementation Rust é€šè¿‡ä½¿ç”¨ Trait å¯ä»¥â€œç»§æ‰¿â€æŸäº›å…±æœ‰çš„è¡Œä¸ºï¼Œä¹Ÿå¯ä»¥è¦†ç›–å®ç°è¿™äº›é»˜è®¤è¡Œä¸ºã€‚ This is also called polymorphism, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics. Rust instead uses generics to abstract over different possible types and trait bounds to impose constraints on what those types must provide. This is sometimes called bounded parametric polymorphism. Rust é€šè¿‡æ³›å‹å’Œ Trait æ¥å®ç°å¤šæ€ 17.2. Using Trait Objects That Allow for Values of Different Types However, trait objects are more like objects in other languages in the sense that they combine data and behavior. But trait objects differ from traditional objects in that we canâ€™t add data to a trait object. Trait objects arenâ€™t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior. Trait åªæ˜¯å¯¹è¡Œä¸ºçš„æŠ½è±¡ï¼Œå®ƒå¹¶æ²¡æœ‰æŒæœ‰æ•°æ®ã€‚è¿™é‡Œéœ€è¦æ³¨æ„ Trait å¯¹è±¡å’Œä¹‹å‰æ‰€æçš„ Trait çº¦æŸæ˜¯ä¸åŒçš„ï¼ŒTrait å¯¹è±¡ç±»ä¼¼äº Box\u003cdyn Trait\u003eã€‚ Vec\u003cBox\u003cdyn Trait\u003e\u003e Vec\u003cT\u003e where T: Trait ä½¿ç”¨ Trait å¯¹è±¡å¯ä»¥å®ç°æŸç§æ„ä¹‰ä¸Šçš„å¤šæ€ï¼Œè€Œä½¿ç”¨æ³›å‹ (ä»¥åŠ Trait çº¦æŸ) åˆ™æ— æ³•åšåˆ°ï¼Œå› ä¸ºæ³›å‹ (ä»¥åŠ Trait çº¦æŸ) åœ¨ç¼–è¯‘å™¨å°±ä¼šè¢«ç¼–è¯‘æˆå…·ä½“ç±»å‹ï¼Œæ˜¾ç„¶æ— æ³•å¤šæ€ã€‚å¯ä»¥ç»“åˆä¸Šé¢çš„ä¾‹å­è¿›è¡Œæ€è€ƒã€‚ when we use trait bounds on generics: the compiler generates nongeneric implementations of functions and methods for each concrete type that we use in place of a generic type parameter. The code that results from monomorphization is doing static dispatch, which is when the compiler knows what method youâ€™re calling at compile time. This is opposed to dynamic dispatch, which is when the compiler canâ€™t tell at compile time which method youâ€™re calling. In dynamic dispatch cases, the compiler emits code that at runtime will figure out which method to call. When we use trait objects, Rust must use dynamic dispatch. The compiler doesnâ€™t know all the types that might be used with the code thatâ€™s using trait objects, so it doesnâ€™t know which method implemented on which type to call. ","date":"2023-12-28","objectID":"/posts/why-rust/:3:17","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Patterns and Matching æ³¨æ„ è¿™ä¸€ç« å»ºè®®æ­é…ä¹‹å‰çš„ 6. Enums and Pattern Matching æ¥é˜…è¯»ï¼Œæœ¬ç« æ˜¯å¯¹å…¶çš„æ‰©å±•ã€‚ 18.1. All the Places Patterns Can Be Used match Arms match VALUE { PATTERN =\u003e EXPRESSION, PATTERN =\u003e EXPRESSION, PATTERN =\u003e EXPRESSION, } The particular pattern _ will match anything, but it never binds to a variable, so itâ€™s often used in the last match arm. _ åœ¨æ¨¡å¼åŒ¹é…ä¸­ç›¸å½“äºä¸€ä¸ªå ä½ç¬¦ï¼Œå¸¸ç”¨äº match åŒ¹é…çš„æœ€åä¸€ä¸ªï¼Œä½œä¸ºç±»ä¼¼äº C/C++ swicth-case çš„ default åˆ†æ”¯ã€‚ if let can have a corresponding else containing code to run if the pattern in the if let doesnâ€™t match. Also, Rust doesnâ€™t require that the conditions in a series of if let, else if, else if let arms relate to each other. Rust è¿˜å¯ä»¥æ··ç”¨ if let å’Œ if-else è¯­å¥ï¼Œå³å¯ä»¥å°†æ¨¡å¼åŒ¹é…å’Œæ¡ä»¶åˆ¤æ–­ç»“åˆèµ·æ¥ï¼Œååˆ†çµæ´» if let Some(color) = favorite_color { println!(\"Using your favorite color, {color}, as the background\"); } else if is_tuesday { println!(\"Tuesday is green day!\"); } else if let Ok(age) = age { if age \u003e 30 { println!(\"Using purple as the background color\"); } else { println!(\"Using orange as the background color\"); } } else { println!(\"Using blue as the background color\"); } The downside of using if let expressions is that the compiler doesnâ€™t check for exhaustiveness, whereas with match expressions it does. ä½†æ˜¯ if-let è¡¨è¾¾å¼å¹¶ä¸ä¼šæ£€æŸ¥æ¨¡å¼åŒ¹é…çš„å…¨éƒ¨æƒ…å†µï¼Œè€Œ match ä¼šå¼ºåˆ¶è¦æ±‚æ£€æŸ¥æ¨¡å¼åŒ¹é…çš„æ‰€æœ‰æƒ…å†µ Similar in construction to if let, the while let conditional loop allows a while loop to run for as long as a pattern continues to match. I while let Some(top) = stack.pop() { println!(\"{}\", top); } In a for loop, the value that directly follows the keyword for is a pattern. For example, in for x in y the x is the pattern. let v = vec!['a', 'b', 'c']; for (index, value) in v.iter().enumerate() { println!(\"{} is at index {}\", value, index); } æ¨¡å¼åŒ¹é…æ— å¤„ä¸åœ¨ï¼Œfor å¾ªç¯ä¸­ for å…³é”®å­—åé¢çš„ token åœ¨è¯­æ³•åˆ†ææ—¶æ˜¯æŒ‰æ¨¡å¼åŒ¹é…è¿›è¡Œåˆ†æçš„ Every time youâ€™ve used a let statement like this youâ€™ve been using patterns, although you might not have realized it! let PATTERN = EXPRESSION; let è¯­å¥ä¹Ÿæ˜¯æ¨¡å¼åŒ¹é…ï¼Œä½†æ˜¯å®ƒçš„ä½¿ç”¨å’Œå…ˆå‰çš„é‚£äº›æ¨¡å¼åŒ¹é…ç›¸æ¯”èµ·æ¥ä¸æ˜¯ç‰¹åˆ«çµæ´»ï¼Œè¿™ä¸€éƒ¨åˆ†åœ¨åé¢ä¼šè¿›è¡Œè§£é‡Š Function parameters can also be patterns. fn foo(x: i32) {...} å‡½æ•°å‚æ•°ä¹Ÿæ˜¯æ¨¡å¼åŒ¹é…ï¼Œæ¯•ç«Ÿå®ƒæœ¬è´¨ä¹Ÿæ˜¯ä¸€ç§ let è¯­å¥ï¼Œç›¸åº”çš„ï¼Œå®ƒçš„çµæ´»æ€§ä¹Ÿä¸æ˜¯ç‰¹åˆ«å¥½ 18.2. Refutability: Whether a Pattern Might Fail to Match å¼•å…¥ä¸¤ä¸ªæ¦‚å¿µç”¨äºè§£é‡Šä¹‹å‰æ‰€æçš„ï¼Œä¸åŒæ¨¡å¼åŒ¹é…è¯­å¥çš„çµæ´»æ€§ä¸åŒçš„é—®é¢˜ Patterns come in two forms: refutable and irrefutable. Patterns that will match for any possible value passed are irrefutable. An example would be x in the statement let x = 5; because x matches anything and therefore cannot fail to match. Patterns that can fail to match for some possible value are refutable. An example would be Some(x) in the expression if let Some(x) = a_value because if the value in the a_value variable is None rather than Some, the Some(x) pattern will not match. ç®€å•æ¥è¯´ï¼Œå°±ä¸€ç§æ¨¡å¼å¯ä»¥å¯¹ä»»ä½•å€¼æ— æ¡ä»¶æ¥å—ï¼Œè€Œå¦ä¸€ç§æ¨¡å¼å¯¹ä¸€äº›å¯èƒ½çš„å€¼å¹¶ä¸æ¥å—ï¼Œè¿™ä¸¤ç§æ¨¡å¼çš„å·®å¼‚å¯¼è‡´äº†ä¸åŒæ¨¡å¼åŒ¹é…è¯­å¥çš„çµæ´»æ€§ä¸åŒ (å› ä¸ºå¯¹äºä»»ä½•å€¼éƒ½å¯ä»¥æ— æ¡ä»¶æ¥å—çš„è¯ï¼Œéœ€è¦å¯¹ä¼ å…¥çš„å€¼è¿›è¡Œä¸€å®šçš„é™åˆ¶ï¼Œè¿›è€Œå¯¼è‡´æ¥æ”¶å€¼çš„çµæ´»æ€§ä¸åŒ)ã€‚ Function parameters, let statements, and for loops can only accept irrefutable patterns, because the program cannot do anything meaningful when values donâ€™t match. The if let and while let expressions accept refutable and irrefutable patterns 18.3. Pattern Syntax Named variables are irrefutable patterns that match any value, and weâ€™ve used them many times in the book. åœ¨æ¨¡å¼åŒ¹é…ä¸­ä½¿ç”¨å‘½åå˜é‡ä¼šåŒ¹é…ä»»æ„å€¼ï¼Œä½†è¿™ä¹Ÿä¼šå¯¼è‡´åœ¨æ¨¡å¼åŒ¹é…çš„ Block å¯¹è¯¥å˜é‡åç§°è¿›è¡Œå˜é‡é®è”½ Because match starts a new scope, variables declared as part of a pattern inside the match expression will shadow those with the same name outside the match construct, as is the case with all variables. let x = Some(5); let y = 10; match x { Some(50) =\u003e println!(\"Got 50\"), Some(y) =\u003e println!(\"Matched, y = {y}\"), _ =\u003e println!(\"Default case, x = {:?}\", x), } println!(\"at the end: x = {:?}, y = {y}\", x); In match expressions, you can match multiple patterns using the | syntax, which is the pattern or operator. match x { 1 | 2 =\u003e println!(\"one or two\"), 3 =\u003e println!(\"three\"), _ =\u003e println!(\"anything\"), } The ..= syntax allows us to match to an inclusive range of values. match x { 'a'..='j' =\u003e println!(\"early ASCII letter\"), 'k'..='z' =\u003e println!(\"late ASCII letter\"), _ =\u003e println!(\"something else\"), } a..=b è¡¨ç¤ºé—­åŒºé—´ ","date":"2023-12-28","objectID":"/posts/why-rust/:3:18","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Advanced Features Unsafe Rust Unsafe Rust exists because, by nature, static analysis is conservative. When the compiler tries to determine whether or not code upholds the guarantees, itâ€™s better for it to reject some valid programs than to accept some invalid programs. if you use unsafe code incorrectly, problems can occur due to memory unsafety, such as null pointer dereferencing. Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. é™æ€åˆ†æçš„ä¿å®ˆä»¥åŠç³»ç»Ÿç¼–ç¨‹çš„éœ€æ±‚ä½¿å¾— Unsafe Rust çš„å‡ºç°å˜å¾—åˆç† unsafe superpowers: Dereference a raw pointer Call an unsafe function or method Access or modify a mutable static variable Implement an unsafe trait Access fields of unions Itâ€™s important to understand that unsafe doesnâ€™t turn off the borrow checker or disable any other of Rustâ€™s safety checks: if you use a reference in unsafe code, it will still be checked. unsafe æœ‰ä¸€å®šçš„ç‰¹æƒï¼Œä½†æ˜¯å³ä½¿ä½¿ç”¨ unsafeï¼ŒRust çš„å€Ÿç”¨æ£€æŸ¥æœºåˆ¶ä»ç„¶å­˜åœ¨ï¼Œå¹¶ä¸”èµ·ä½œç”¨ è§£å¼•ç”¨ è£¸æŒ‡é’ˆ æ“ä½œåªèƒ½åœ¨ unsafe ä¸­ä½¿ç”¨ï¼Œæ³¨æ„è¿™é‡Œè¯´çš„æ˜¯ è§£å¼•ç”¨ï¼Œå¦‚æœä¸æ¶‰åŠå¯¹è£¸æŒ‡é’ˆçš„è§£å¼•ç”¨æ“ä½œï¼Œè£¸æŒ‡é’ˆè¿˜æ˜¯å¯ä»¥åœ¨ safe å†…ä½¿ç”¨çš„ï¼Œä¾‹å¦‚: let mut num = 5; let r1 = \u0026num as *const i32; let r2 = \u0026mut num as *mut i32; unsafe { println!(\"r1: {}\", *r1); println!(\"r2: {}\", *r2); } let address = 0x012345usize; let r = address as *const i32; Unsafe Rust has two new types called raw pointers that are similar to references. As with references, raw pointers can be immutable or mutable and are written as *const T and *mut T, respectively. In the context of raw pointers, immutable means that the pointer canâ€™t be directly assigned to after being dereferenced. Different from references and smart pointers, raw pointers: Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location Arenâ€™t guaranteed to point to valid memory Are allowed to be null Donâ€™t implement any automatic cleanup Rust ä¸­çš„è£¸æŒ‡é’ˆå’Œ C/C++ ä¸­çš„åŸå§‹æŒ‡é’ˆç±»å‹æ¯”è¾ƒç›¸ä¼¼ã€‚è€Œ Rust çš„è£¸æŒ‡é’ˆå’Œå¼•ç”¨ã€æ™ºèƒ½æŒ‡é’ˆæœ€å¤§çš„åŒºåˆ«åœ¨äº: è£¸æŒ‡é’ˆä¸éœ€è¦éµå¾ªå€Ÿç”¨è§„åˆ™ï¼Œä»¥åŠå¼•ç”¨ã€æ™ºèƒ½æŒ‡é’ˆå¿…å®šä¸ä¸ºç©ºå¹¶ä¸”å¼•ç”¨çš„æ˜¯æœ‰æ•ˆçš„ç‰©ä»¶ (å› ä¸ºæ˜¯å¯¹ç‰©ä»¶çš„å¼•ç”¨ï¼Œæ‰€ä»¥ç‰©ä»¶å¿…é¡»å…ˆäºå¼•ç”¨è€Œå­˜åœ¨ï¼Œæ•…å¼•ç”¨çš„åœ°å€ä¹Ÿæ˜¯æœ‰æ•ˆçš„)ï¼Œè€Œè£¸æŒ‡é’ˆå¯ä»¥ä¸ºç©º (ç±»ä¼¼äº C/C++ çš„ NULL)ï¼Œä¹Ÿå¯ä»¥æŒ‡å‘æ— æ•ˆçš„åœ°å€ã€‚å› ä¸ºå¯ä»¥ä¸ºç©ºæˆ–æŒ‡å‘æ— æ•ˆåŒºåŸŸï¼Œæ‰€ä»¥è£¸æŒ‡é’ˆä¸èƒ½åƒæ™ºèƒ½æŒ‡é’ˆé‚£æ ·ï¼Œè¶…å‡ºä½œç”¨åŸŸå°±è‡ªåŠ¨æ¸…ç†æŒ‡å‘çš„å†…å®¹ã€‚ With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code Another case is when building up safe abstractions that the borrow checker doesnâ€™t understand. ä¸åº•å±‚ C ä»£ç è¿›è¡Œäº¤äº’ï¼Œä»¥åŠå€Ÿç”¨æ£€æŸ¥æœºåˆ¶æ— æ³•æ¶µç›–ç°å®ä¸–ç•Œçš„æ‰€æœ‰å…³ç³»ï¼Œæ˜¯ Unsafe Rust ä½¿ç”¨çš„ç†ç”± Just because a function contains unsafe code doesnâ€™t mean we need to mark the entire function as unsafe. In fact, wrapping unsafe code in a safe function is a common abstraction å°†ä¸å®‰å…¨çš„ä»£ç å—å°è£…ä¸ºå®‰å…¨çš„å‡½æ•°ï¼Œè¿™æ ·è°ƒç”¨è¯¥å‡½æ•°æ—¶å°±ä¸éœ€è¦ç‰¹åˆ«è€ƒè™‘ unsafe éƒ¨åˆ†äº† (unsafe éƒ¨åˆ†ç”±å‡½æ•°å®ç°æ–¹è¿›è¡Œè€ƒè™‘ã€å°è£…) Sometimes, your Rust code might need to interact with code written in another language. For this, Rust has the keyword extern that facilitates the creation and use of a Foreign Function Interface (FFI). An FFI is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions. The \"C\" ABI is the most common and follows the C programming languageâ€™s ABI. é€šè¿‡ extern å…³é”®å­—æŒ‡å®šæ±‡ç¼–å±‚é¢ä½¿ç”¨çš„ ABIï¼Œå¯ä»¥ä½¿ Rust ç¨‹åºå’Œå…¶ä»–è¯­è¨€ç¼–å†™çš„ç¨‹åºè¿›è¡Œé€šè®¯ï¼Œè¿™éƒ¨åˆ†åœ¨ Rust ä¸­å« FFI Advanced Traits Associated types connect a type placeholder with a trait such that the trait method definitions can use these placeholder types in their signatures. å…³è”ç±»å‹ç›¸å½“äºç±»å‹çš„å ä½ç¬¦ï¼Œå¸¸ç”¨äºè¿­ä»£å™¨ç›¸å…³çš„ Trait çš„å®šä¹‰ä¸­: pub trait Iterator { type Item; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e; } ç»“åˆä¸‹é¢çš„ä¾‹å­ï¼Œå¹¶ä¸ä¸Šé¢çš„ä¾‹å­è¿›è¡Œå¯¹æ¯”ï¼Œæ€è€ƒæ³›å‹å‚æ•°çš„ Trait å’Œå…³è”ç±»å‹çš„ Trait çš„åŒºåˆ«: pub trait Iterator\u003cT\u003e { fn next(\u0026mut self) -\u003e Option\u003cT\u003e; } In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. With associated types, we donâ€™t need to annotate types because we canâ€™t implement a trait on a type multiple times. é»˜è®¤æ³›å‹å‚æ•°å¯ä»¥åœ¨æœªæ ‡æ³¨å…·ä½“ç±»å‹æ—¶ï¼Œä½¿ç”¨é»˜è®¤çš„å…·ä½“ç±»å‹ When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. You specify a default typ","date":"2023-12-28","objectID":"/posts/why-rust/:3:19","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Final Project: Web Server è¿™éƒ¨åˆ†å†…å®¹æ¨èè§‚çœ‹è¯¥å½•å½± Rust ç¼–ç¨‹å°é¡¹ç›®ï¼šWeb Server Documentation: ","date":"2023-12-28","objectID":"/posts/why-rust/:3:20","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"Homework ä½œä¸š å®Œæˆ rustlings çš„å…¨éƒ¨ç»ƒä¹ é¢˜ / å‚è€ƒé¢˜è§£ / æˆ‘çš„é¢˜è§£ é˜…è¯»å¹¶å®Œæˆ LifetimeKata çš„æ‰€æœ‰ç« èŠ‚ã€ç»ƒä¹ é¢˜ é˜…è¯»å¹¶å®Œæˆ MacroKata çš„æ‰€æœ‰ç« èŠ‚ã€ç»ƒä¹ é¢˜ ","date":"2023-12-28","objectID":"/posts/why-rust/:4:0","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Linux Kernel Internals","Rust"],"content":"References The Rust Programming Language - Brown University Rust è¯­è¨€åœ£ç» (Rust Course) Rust ç¼–ç¨‹è§†é¢‘æ•™ç¨‹: åŸºç¡€ã€è¿›é˜¶ Visualizing memory layout of Rust's data types: å½•å½± / ä¸­æ–‡ç¿»è¯‘ pretzelhammer's Rust blog Learn Rust the Dangerous Way ","date":"2023-12-28","objectID":"/posts/why-rust/:5:0","tags":["Rust","Sysprog"],"title":"Rust è¯­è¨€ç¨‹åºè®¾è®¡","uri":"/posts/why-rust/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"æ•™å­¦å½±ç‰‡ï¼šGit ä¸­æ–‡æ•™å­¦ ","date":"2023-12-27","objectID":"/posts/git-learn/:0:0","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"å®‰è£…ä¸è®¾å®š æ³¨æ„ âœ… è§‚çœ‹å½±ç‰‡ Git æ•™å­¦ç³»åˆ— - å®‰è£…ä¸é…ç½®ï¼Œå®Œæˆå¸¸ç”¨çš„ Git è®¾ç½®ã€‚ è®¾ç½® Git çš„ç¼–è¾‘å™¨ä¸º vimï¼Œä¸»è¦ç”¨äº commit æ—¶çš„ç¼–è¾‘ï¼š $ git config --global core.editor vim è®¾ç½® Git çš„åˆå¹¶è§£å†³å†²çªå·¥å…·ä¸º vimdiffï¼š $ git config --global merge.tool vimdiff å¯ç”¨ Git å‘½ä»¤è¡Œç•Œé¢çš„é¢œè‰²æ˜¾ç¤ºï¼š $ git config --global color.ui true è®¾ç½®å¸¸ç”¨å‘½ä»¤çš„åˆ«åï¼š $ git config --global alias.st status $ git config --global alias.ch checkout $ git config --global alias.rst reset HEAD æ•ˆæœä¸ºï¼šå‘½ä»¤ git st ç­‰ä»·äº git statusï¼Œå…¶ä½™çš„ç±»ä¼¼ã€‚ è®¾ç½® Windows å’Œ Mac/Linux çš„æ¢è¡Œç¬¦åŒæ­¥ï¼š # In Windows $ git config --global core.autocrlf true # In Mac/Linux $ git config --global core.autocrlf input æ•ˆæœä¸ºï¼šåœ¨ Windows æäº¤æ—¶è‡ªåŠ¨å°† CRLF è½¬ä¸º LFï¼Œæ£€å‡ºä»£ç æ—¶å°† LF è½¬æ¢æˆ CRLFã€‚åœ¨ Mac/Linux æäº¤æ—¶å°† CRLFè½¬ä¸º LFï¼Œæ£€å‡ºä»£ç æ—¶ä¸è½¬æ¢ã€‚è¿™æ˜¯å› ä¸º Windows çš„æ¢è¡Œç¬¦ä¸º \\r\\nï¼Œè€Œ Mac/Linux çš„æ¢è¡Œç¬¦ä»…ä¸º \\nã€‚ ","date":"2023-12-27","objectID":"/posts/git-learn/:1:0","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Add å’Œ Commit ","date":"2023-12-27","objectID":"/posts/git-learn/:2:0","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"æŒ‡å®š Commit æ³¨æ„ âœ… è§‚çœ‹å½±ç‰‡ Git æ•™å­¦ç³»åˆ— - æŒ‡å®š Commitï¼ŒæŒæ¡ git logã€git showã€git diff çš„å¸¸ç”¨æ–¹æ³•ã€‚ç†è§£ Hash Value å’Œ commit å¯¹äº Git ç‰ˆæœ¬æ§åˆ¶çš„æ ¸å¿ƒä½œç”¨ã€‚ åªè¦ commit äº†ï¼Œèµ„æ–™åŸºæœ¬ä¸å¯èƒ½ä¸¢å¤±ï¼Œå³ä½¿è¯¯æ“ä½œäº†ä¹Ÿæ˜¯å¯ä»¥è¡¥æ•‘å›æ¥çš„ï¼ˆé™¤éæŠŠ .git/ æ–‡ä»¶å¤¹ä¹Ÿåˆ é™¤äº†ï¼‰ã€‚ ","date":"2023-12-27","objectID":"/posts/git-learn/:3:0","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Hash Value Every commit has a unique hash value. Calculate by SHA1 Hash value can indicate a commit absolutely. ","date":"2023-12-27","objectID":"/posts/git-learn/:3:1","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Indicate Commit git manage references to commit HEAD Branch Tag Remote Also, We can indicate commit by ^, ~ é€šä¿—åœ°å°†ï¼Œä¸è®ºæ˜¯ HEADã€Branchã€Tagã€Remoteï¼Œå…¶æœ¬è´¨éƒ½æ˜¯ä½¿ç”¨ Hash Value è¿›è¡Œç´¢å¼•çš„ commitï¼Œæ‰€ä»¥ ~ å’Œ ^ ä¹Ÿå¯ä»¥ä½œç”¨äºå®ƒä»¬ã€‚ å¯ä»¥é€šè¿‡ git log æ¥æŸ¥çœ‹ commit ä»¥åŠå¯¹åº”çš„ Hash å€¼ã€‚äº‹å®ä¸Šï¼Œè¿™ä¸ªå‘½ä»¤ååˆ†çµæ´»ï¼Œä¸¾ä¸ªä¾‹å­ï¼š git log 4a6ebc -n1 è¿™ä¸ªå‘½ä»¤çš„æ•ˆæœæ˜¯ä» Hash å€¼ä¸º 4a6bc çš„ commit å¼€å§‹æ‰“å° 1 æ¡ commit è®°å½•ï¼ˆæ²¡é”™ï¼Œå¯¹åº”çš„æ˜¯ -n1ï¼‰ï¼Œå› ä¸º Git ååˆ†èªæ˜ï¼Œæ‰€ä»¥ commit å¯¹åº”çš„ Hash å€¼åªéœ€å‰ 6 ä½å³å¯ï¼ˆå› ä¸ºè¿™æ ·å·²ç»å‡ ä¹ä¸ä¼šå‘ç”Ÿ Hash å†²çªï¼‰ã€‚ Examples æ‰“å° master åˆ†æ”¯çš„æœ€æ–°ä¸€ä¸ª commitï¼š git log master -n1 æ‰“å° master åˆ†æ”¯çš„æœ€æ–°ä¸€ä¸ª commitï¼ˆä»…ä½¿ç”¨ä¸€è¡Œæ‰“å° commit ä¿¡æ¯ï¼‰ï¼š git log master -n1 --oneline æ‰“å° HEAD æ‰€æŒ‡å‘çš„ commitï¼š git log HEAD -n1 --oneline æ‰“å° HEAD æ‰€æŒ‡å‘çš„ commit çš„å‰ä¸€ä¸ª commitï¼š git log HEAD^ -n1 --oneline ^ å¯ä»¥æŒç»­ä½¿ç”¨ï¼Œæ¯”å¦‚ HEAD^^ è¡¨ç¤º HEAD æ‰€æŒ‡å‘çš„ commit çš„å‰ä¸¤ä¸ª commitã€‚å½“ ^ æ•°é‡è¿‡å¤šæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ ~ æ­é…æ•°å­—æ¥è¾¾åˆ°ç›¸åŒæ•ˆæœã€‚ä¾‹å¦‚ï¼š git log HEAD^^^^^ -n1 --oneline git log HEAD~5 -n1 --oneline ä¸€èˆ¬æ¥è¯´ï¼Œä½¿ç”¨ ^ å°±å·²ç»è¶³å¤Ÿäº†ï¼Œå‡ ä¹ä¸ä¼šé‡åˆ°ä½¿ç”¨ ~ çš„åœºæ™¯ï¼Œå› ä¸ºè¿™ç§åœºæ™¯ä¸€èˆ¬ä¼šå»æ‰¾å›¾å½¢åŒ–ç•Œé¢å§ã€‚ğŸ¤£ æ‰“å°ä¸æ–‡ä»¶ README.md ç›¸å…³çš„ commitsï¼ˆä»…ä½¿ç”¨ä¸€è¡Œæ˜¾ç¤ºï¼‰ï¼š git log --oneline README.md æ‰“å°ä¸æ–‡ä»¶ README.md ç›¸å…³çš„ commitsï¼ˆæ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ–‡ä»¶å†…å®¹çš„å¢å‡ç»Ÿè®¡ï¼‰ï¼š git log --stat README.md æ‰“å°ä¸æ–‡ä»¶ README.md ç›¸å…³çš„ commitsï¼ˆæ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ–‡ä»¶å†…å®¹çš„å¢å‡ç»†èŠ‚ï¼‰ï¼š git log --patch README.md åœ¨æ‰“å°çš„ commit ä¿¡æ¯ä¸­æŠ“å–ä¸ README ç¬¦åˆçš„ä¿¡æ¯ï¼ˆå¯ä»¥ä¸ --stat æˆ– --patch é…åˆä½¿ç”¨ï¼‰ï¼š git log -S README ","date":"2023-12-27","objectID":"/posts/git-learn/:3:2","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"View History git log \u003cpath\u003e|\u003ccommit\u003e -n: limit number --oneline: view hash and commit summary --stat: view files change --patch: view lines change -S or --grep: find modification ","date":"2023-12-27","objectID":"/posts/git-learn/:3:3","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"View Commit git show \u003ccommit\u003e Equal to log -n1 ","date":"2023-12-27","objectID":"/posts/git-learn/:3:4","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"See Difference æŸ¥çœ‹å½“å‰çš„ä¿®æ”¹ï¼Œå¯ä»¥æŸ¥çœ‹å·²ç»ä¿®æ”¹ä½†æ²¡æœ‰ staged æ–‡ä»¶çš„å˜åŒ–ï¼š git diff æŸ¥çœ‹å½“å‰çš„ä¿®æ”¹ï¼Œå¯ä»¥æŸ¥çœ‹å·²ç»ä¿®æ”¹ä¸” staged æ–‡ä»¶çš„å˜åŒ–ï¼š git diff --staged æŸ¥çœ‹å½“å‰ä¸æŒ‡å®šçš„ commit çš„å·®å¼‚ï¼š git diff \u003ccommit\u003e # e.g. git diff master^ æŸ¥ä¸¤ä¸ªæŒ‡å®šçš„ commit ä¹‹é—´çš„å·®å¼‚ï¼š git diff \u003ccommit\u003e \u003ccommit\u003e # e.g. git diff master^ master^^ ","date":"2023-12-27","objectID":"/posts/git-learn/:3:5","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Path Add and Amend æ³¨æ„ âœ… è§‚çœ‹å½±ç‰‡ Git æ•™å­¦ç³»åˆ— - Patch Add and Amendï¼ŒæŒæ¡ git add -pã€git checkout -pã€git add ---amend çš„ç”¨æ³•ï¼Œä½¿ç”¨ add å’Œ checkout æ—¶å¼ºçƒˆå»ºè®®ä½¿ç”¨ -pï¼ŒæŒæ¡ä¿®æ”¹ commit çš„ä¸¤ç§æ–¹æ³•ã€‚ ","date":"2023-12-27","objectID":"/posts/git-learn/:4:0","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Only Add Related git add -p æ¨èå°½é‡ä½¿ç”¨è¿™ä¸ª git add -p è€Œä¸æ˜¯å•çº¯çš„ git addã€‚ ä½¿ç”¨ git add -p åï¼ŒGit ä¼šå¸®æˆ‘ä»¬æŠŠæ¶‰åŠçš„ä¿®æ”¹åˆ†æˆ sectionï¼Œç„¶åæˆ‘ä»¬å°±å¯ä»¥å¯¹æ¯ä¸€ä¸ª section æ¶‰åŠçš„ä¿®æ”¹è¿›è¡Œ reviewï¼Œé€‰æ‹© y(yes) è¡¨ç¤ºé‡‡çº³è¯¥ sction å¯¹åº”çš„ä¿®æ”¹ï¼Œé€‰æ‹© n(no) è¡¨ç¤ºä¸é‡‡çº³ã€‚ å¦‚æœè§‰å¾— section åˆ‡å‰²çš„ç²’åº¦å¤ªå¤§äº†ï¼Œå¯ä»¥é€‰æ‹© s(split) æ¥è¿›è¡Œæ›´ç»†ç²’åº¦çš„åˆ’åˆ†ã€‚å¦‚æœè¿™æ ·ä»ç„¶è§‰å¾—ç²’åº¦ä¸å¤Ÿï¼Œå¯ä»¥é€‰æ‹© e(edit) å¯¹ section æ¶‰åŠçš„ä¿®æ”¹ï¼Œè¿›è¡Œä»¥è¡Œä¸ºç²’åº¦çš„ reviewï¼Œå…·ä½“æ“ä½œå¯ä»¥æŸ¥é˜…æ­¤æ—¶ç»™å‡ºçš„æç¤ºã€‚ è¿˜æœ‰ä¸€äº›å…¶å®ƒçš„é€‰é¡¹ï¼Œæ¯”å¦‚ jã€Jã€kã€Kï¼Œè¿™äº›æ˜¯ç±»ä¼¼ vimï¼Œç”¨äºåˆ‡æ¢è¿›è¡Œ review çš„ sectionï¼Œä¸å¤ªå¸¸ç”¨ã€‚q(quit) è¡¨ç¤ºé€€å‡ºã€‚ ç”±äºå¯ä»¥é’ˆå¯¹ä¸€ä¸ªæ–‡ä»¶çš„ä¸åŒ section è¿›è¡Œ reviewï¼Œæ‰€ä»¥åœ¨è¿›è¡Œ git add -p ä¹‹åï¼Œä½¿ç”¨ git status å¯ä»¥å‘ç°åŒä¸€ä¸ªæ–‡ä»¶ä¼šåŒæ—¶å¤„äºä¸¤ç§çŠ¶æ€ã€‚ ","date":"2023-12-27","objectID":"/posts/git-learn/:4:1","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Checkout Also git checkout -p è¿™ä¸ªæ“ä½œæ¯”è¾ƒå±é™©ï¼Œå› ä¸ºè¿™ä¸ªæ“ä½œçš„æ•ˆæœä¸ git add -p ç›¸åï¼Œå¦‚æœé€‰æ‹© y çš„è¯ï¼Œæ–‡ä»¶æ¶‰åŠçš„ä¿®æ”¹å°±ä¼šæ¶ˆå¤±ï¼Œå¦‚æœæ¶‰åŠçš„ä¿®æ”¹æ²¡æœ‰ commit çš„è¯ï¼Œé‚£ä¹ˆæ¶‰åŠçš„ä¿®æ”¹æ˜¯æ— æ³•æ•‘å›çš„ã€‚ä½†æ˜¯æ€ä¹ˆè¯´ï¼Œè¿™ä¸ªæ“ä½œè¿˜æ˜¯æ¯”ç›´æ¥ä½¿ç”¨ git checkout ç¨å¾®ä¿é™©ä¸€ç‚¹ï¼Œå› ä¸ºä¼šå…ˆè¿›å…¥ review ç•Œé¢ï¼Œè€Œä¸æ˜¯ç›´æ¥æ’¤é”€ä¿®æ”¹ã€‚æ‰€ä»¥ï¼Œè¯·ä¸€å®šè¦ä½¿ç”¨ git checkout -pï¼ ","date":"2023-12-27","objectID":"/posts/git-learn/:4:2","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Modify Commit æœ‰ä¸¤ç§æ–¹å¼æ¥ä¿®æ”¹æœ€æ–°çš„ commitï¼š # 1. Use git commit --amend git commit --amend # 2. Use reset HEAD^ then re-commit git reset HEAD^ git add -p git commit git commit --amend å¹¶ä¸æ˜¯ç›´æ¥æ›¿æ¢åŸæœ‰çš„ commitï¼Œè€Œæ˜¯åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ commit å¹¶é‡æ–°è®¾ç½®äº† HEAD çš„æŒ‡å‘ã€‚æ‰€ä»¥ï¼Œæ–°æ—§ä¸¤ä¸ª commit çš„ Hash Value å¹¶ä¸ç›¸åŒï¼Œäº‹å®ä¸Šï¼Œå¦‚æœä½ æ‹¥æœ‰æ—§ commit çš„ Hash Valueï¼Œæ˜¯å¯ä»¥é€šè¿‡ git checkout \u003ccommit\u003e åˆ‡æ¢åˆ°é‚£ä¸ª commit çš„ã€‚å…¶åŸç†å¦‚ä¸‹å›¾ï¼š ä½†æ˜¯æ³¨æ„ï¼Œgit reset HEAD^ æ˜¯ä¼šæ’¤é”€åŸå…ˆçš„ commitï¼ˆä»…é™äºæœ¬åœ° Git å­˜å‚¨åº“ï¼‰ã€‚ ","date":"2023-12-27","objectID":"/posts/git-learn/:4:3","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Branch and Merge æ³¨æ„ âœ… è§‚çœ‹å½±ç‰‡ Git æ•™å­¦ç³»åˆ— - Branch and Mergeï¼ŒæŒæ¡åˆ›å»ºã€åˆ é™¤ã€åˆ‡æ¢åˆ†æ”¯çš„ç”¨æ³•ï¼ŒæŒæ¡åˆå¹¶åˆ†æ”¯ã€è§£å†³å†²çªçš„æ–¹æ³•ã€‚ git checkout \u003ccommit\u003e git branch \u003cname\u003e git branch \u003cname\u003e \u003ccommit\u003e git branch [-d|-D] \u003cname\u003e git merge \u003cname\u003e --no-ff ","date":"2023-12-27","objectID":"/posts/git-learn/:5:0","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Move and Create Branch Checkout: move HEAD git checkout \u003ccommit\u003e: Move HEAD to commit git checkout \u003cpath\u003e: WARNING: discard change å¯ä»¥å°†è·¯å¾„ä¸Šçš„æ–‡ä»¶å¤åŸåˆ°ä¹‹å‰ commit çš„çŠ¶æ€ã€‚ Branch: git branch: List branch git branch \u003cname\u003e: Create branch Or just: git checkout -b Examples ä¿®æ”¹ä¸€ä¸ªæ–‡ä»¶å¹¶æ¢å¤ï¼š # modify file load.cpp git status git checkout load.cpp git status åˆ é™¤ä¸€ä¸ªæ–‡ä»¶å¹¶æ¢å¤ï¼š rm load.cpp git status git checkout load.cpp git status æ­£å¦‚ä¸Šä¸€èŠ‚æ‰€è¯´çš„ï¼Œgit checkout å°½é‡å¸¦ä¸Š -p å‚æ•°ï¼Œå› ä¸ºå¦‚æœä¸€ä¸å°å¿ƒè¾“å…¥äº† git checkout .ï¼Œé‚£å°±å‰åŠŸå°½å¼ƒäº†ã€‚ æ˜¾ç¤ºåˆ†æ”¯ï¼š # only show name git branch # show more infomation git branch -v åˆ‡æ¢åˆ†æ”¯ï¼š # switch to branch 'main' git checkout main åˆ›å»ºåˆ†æ”¯ï¼š # 1. using `git branch` git branch cload # 2. using `git checkout -b` git checkout -b asmload # 3. create a new branch in \u003ccommit\u003e git branch cload \u003ccommit\u003e åˆ‡æ¢åˆ°ä»»ä¸€ commitï¼š git checkout \u003ccommit\u003e ç›´æ¥ checkout åˆ°ä»»ä¸€ commit ä¼šæœ‰è­¦å‘Šï¼Œè¿™æ˜¯å› ä¸ºï¼Œå½“ä½ ä»¥è¯¥ commit ä¸ºåŸºç‚¹è¿›è¡Œä¸€ç³»åˆ—çš„ commitï¼Œè¿™äº›æ–°çš„ commit ä¼šåœ¨ä½ åˆ‡æ¢åˆ†æ”¯åæ¶ˆå¤±ï¼Œå› ä¸ºæ²¡æœ‰ branch æ¥å¼•ç”¨å®ƒä»¬ã€‚ä¹‹å‰å¯ä»¥è¢«å¼•ç”¨æ˜¯å› ä¸º HEAD å¼•ç”¨ï¼Œåˆ‡æ¢åˆ†æ”¯å HEAD ä¸å†å¼•ç”¨è¿™äº› commitï¼Œæ‰€ä»¥å°±ä¼šæ¶ˆå¤±ã€‚åœ¨è¿™ç§æƒ…å†µï¼ŒGit ä¼šåœ¨å‘å‡ºè­¦å‘Šçš„åŒæ—¶å»ºè®®æˆ‘ä»¬ä½¿ç”¨ git branch æ¥åˆ›å»ºåˆ†æ”¯è¿›è¡Œå¼•ç”¨ã€‚ ","date":"2023-12-27","objectID":"/posts/git-learn/:5:1","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"View Branch åˆ—å‡ºä»“åº“çš„æ‰€æœ‰åˆ†æ”¯ï¼š git branch ä¹Ÿå¯ä»¥é€šè¿‡ log æ¥æŸ¥çœ‹åˆ†æ”¯ï¼š git log --decorate: åœ¨ log çš„é¦–è¡Œæ˜¾ç¤ºæ‰€æœ‰çš„ referencesï¼ˆå¯èƒ½éœ€è¦é€šè¿‡ git config log.decorate auto æ¥å¼€å¯ï¼‰ --graph: ä»¥å›¾å½¢åŒ–çš„æ–¹å¼æ˜¾ç¤º branch çš„å…³ç³»ï¼ˆä¸»è¦æ˜¯ commit çš„å¼•ç”¨ï¼‰ ","date":"2023-12-27","objectID":"/posts/git-learn/:5:2","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Delete Branch åˆ é™¤åˆ†æ”¯ï¼š git branch -d \u003cname\u003e å¯¹äºæœ‰æ²¡æœ‰ merge çš„ commit çš„åˆ†æ”¯ï¼ŒGit ä¼šè­¦å‘Šï¼Œéœ€è¦ä½¿ç”¨ -D æ¥å¼ºåˆ¶åˆ é™¤ï¼š git branch -D \u003cname\u003e for no-merge commit WARNING: Discard Commit Git ä¼šå‘å‡ºè­¦å‘Šçš„åŸå› åŒæ ·æ˜¯ no-merge commit åœ¨åˆ é™¤åˆ†æ”¯åå°±æ— æ³•è¢«å¼•ç”¨ï¼Œæ‰€ä»¥ä¼šå‘å‡ºè­¦å‘Šã€‚ ","date":"2023-12-27","objectID":"/posts/git-learn/:5:3","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Merge åˆå¹¶åˆ†æ”¯ã€‚é»˜è®¤ä½¿ç”¨ fast-forwardï¼Œå³å¦‚æœæ²¡æœ‰å†²çªï¼Œç›´æ¥å°†è¦åˆå¹¶çš„åˆ†æ”¯æå‰åˆ°è¢«åˆå¹¶åˆ†æ”¯çš„ commit å¤„ï¼Œè€Œä¸ä¼šå¦å¤–ç”Ÿæˆä¸€ä¸ª merge commitã€‚ä½†è¿™æ ·ä¼šä½¿å¾—è¢«åˆå¹¶çš„åˆ†æ”¯åœ¨åˆå¹¶åï¼Œæ²¡æœ‰å†å²ç—•è¿¹ã€‚å¯ä»¥é€šè¿‡ --no-ff (no fast forward) æ¥å¼ºåˆ¶ç”Ÿæˆ merge commitã€‚æ¨èä½¿ç”¨ merge æ—¶åŠ ä¸Š --no-ff è¿™ä¸ªå‚æ•°ã€‚ git merge \u003cbranch\u003e é€šå¸¸æ˜¯ main/master è¿™ç±»ä¸»åˆ†æ”¯åˆå¹¶å…¶å®ƒåˆ†æ”¯ï¼š git checkout main/master git merge \u003cbranch\u003e ","date":"2023-12-27","objectID":"/posts/git-learn/:5:4","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Resolve Conflict Manually resolve: Check every codes between \u003c\u003c\u003c\u003c\u003c\u003c\u003c, \u003e\u003e\u003e\u003e\u003e\u003e\u003e Edit code to what it should be Use mergetool like vimdiff: It shows: local, base, remote, file to be edited Edit â€œfile ro be editedâ€ to what is should be Add and Commit # 1. åˆå¹¶åˆ†æ”¯ git merge \u003cbranch\u003e # 2. æ£€æŸ¥çŠ¶æ€ï¼ŒæŸ¥çœ‹ unmerged çš„æ–‡ä»¶ git status # 3. ç¼–è¾‘ unmerged æ–‡ä»¶ï¼Œç¼–è¾‘å†²çªåŒºåŸŸä»£ç å³å¯ vim \u003cfile\u003e # 4. æ·»åŠ è§£å†³å®Œå†²çªçš„æ–‡ä»¶ git add \u003cfile\u003e # 5. è¿›è¡Œ merge commit git commit å†²çªåŒºåŸŸå°±æ˜¯ \u003c\u003c\u003c\u003c\u003c\u003c\u003c å’Œ \u003e\u003e\u003e\u003e\u003e\u003e\u003e å†…çš„åŒºåŸŸï¼Œåœ¨ merge æ“ä½œåï¼ŒGit å·²ç»å¸®æˆ‘ä»¬æŠŠ unmerged æ–‡ä»¶ä¿®æ”¹ä¸ºå¾…è§£å†³å†²çªçš„çŠ¶æ€ï¼Œç›´æ¥ç¼–è¾‘æ–‡ä»¶å³å¯ã€‚åœ¨ç¼–è¾‘å®Œæˆåï¼Œéœ€è¦æ‰‹åŠ¨è¿›è¡Œ add å’Œ commitï¼Œæ­¤æ¬¡ commit çš„ä¿¡æ¯ Git å·²ç»å¸®æˆ‘ä»¬å†™å¥½äº†ï¼Œä¸€èˆ¬ä¸éœ€è¦ä¿®æ”¹ã€‚ å¦‚æœä½¿ç”¨çš„æ˜¯ mergetoolï¼Œä»¥ vimdiff ä¸ºä¾‹ï¼Œåªéœ€å°†ç¬¬ 3 æ­¥çš„ vim \u003cfile\u003e æ”¹ä¸º git mergetool å³å¯ã€‚vimdiff ä¼šæä¾› 4 ä¸ªè§†çª—ï¼šåº•éƒ¨è§†çª—æ˜¯æˆ‘ä»¬çš„ç¼–è¾‘åŒºï¼Œé¡¶éƒ¨å·¦è¾¹æ˜¯å½“å‰åˆå¹¶åˆ†æ”¯çš„çŠ¶æ€ï¼Œé¡¶éƒ¨ä¸­é—´æ˜¯ base (åˆå¹¶åˆ†æ”¯å’Œè¢«åˆå¹¶çš„å…±åŒçˆ¶èŠ‚ç‚¹) çš„çŠ¶æ€ï¼Œé¡¶éƒ¨å³è¾¹æ˜¯ remote çš„çŠ¶æ€ï¼ŒæŒ‰éœ€è¦é€‰æ‹©ã€ç¼–è¾‘ã€‚ vimdiff åœ¨ç¼–è¾‘å®Œåä¼šä¿ç•™ *.orig çš„æ–‡ä»¶ï¼Œè¿™ä¸ªæ–‡ä»¶æ˜¯å¾…è§£å†³å†²çªçš„æ–‡ä»¶å‰¯æœ¬ã€‚ ","date":"2023-12-27","objectID":"/posts/git-learn/:5:5","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Merge Conflict Prevent very long development branch. Split source code clearly. ","date":"2023-12-27","objectID":"/posts/git-learn/:5:6","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Rebase æ³¨æ„ âœ… è§‚çœ‹å½±ç‰‡ Git æ•™å­¦ç³»åˆ— - Branch and Mergeï¼ŒæŒæ¡ TODO çš„æ–¹æ³•ã€‚git rebase æ˜¯ Git çš„ç²¾åï¼Œå¯ä»¥è®©æˆ‘ä»¬å®ç°æ›´ç»†ç²’åº¦çš„æ“ä½œï¼Œå¯ä»¥è¯´å­¦ä¼šäº† rebase æ‰ç®—çœŸæ­£å…¥é—¨äº† Gitã€‚ è¿™ä¸ªè§†é¢‘è®²å¾—æ¯”è¾ƒä¹±ï¼Œæ‰€ä»¥æ¨èé…åˆè§†é¢‘ç»™å‡ºçš„å‚è€ƒæ–‡ç«  Git-rebase å°ç¬”è®° æ¥å­¦ä¹ ã€‚ ","date":"2023-12-27","objectID":"/posts/git-learn/:6:0","tags":["Git","GitHub"],"title":"Git å­¦ä¹ è®°å½•","uri":"/posts/git-learn/"},{"categories":["Toolkit"],"content":"ç½‘ç»œä»£ç† æ ¹æ®é¡¹ç›® clash-for-linux-backup æ¥é…ç½® Ubuntu çš„ç½‘ç»œä»£ç†ã€‚ $ git clone https://github.com/Elegybackup/clash-for-linux-backup.git clash-for-linux è¿‡ç¨‹å½“ä¸­å¯èƒ½éœ€è¦å®‰è£… curl å’Œ net-toolsï¼Œæ ¹æ®æç¤ºè¿›è¡Œå®‰è£…å³å¯ï¼š sudo apt install curl sudo apt install net-tools å®‰è£…å¹¶å¯åŠ¨å®Œæˆåï¼Œå¯ä»¥é€šè¿‡ localhost:9090/ui æ¥è®¿é—® Dashboardã€‚ å¯åŠ¨ä»£ç†ï¼š $ cd clash-for-linux $ sudo bash start.sh $ source /etc/profile.d/clash.sh $ proxy_on å…³é—­ä»£ç†ï¼š $ cd clash-for-linux $ sudo bash shutdown.sh $ proxy_off ","date":"2023-12-27","objectID":"/posts/ubuntu22.04lts/:1:0","tags":["Linux","Ubuntu"],"title":"Ubuntu 22.04LTS ç›¸å…³é…ç½®","uri":"/posts/ubuntu22.04lts/"},{"categories":["Toolkit"],"content":"æœç‹—è¾“å…¥æ³• æ ¹æ® æœç‹—è¾“å…¥æ³• Linux å®‰è£…æŒ‡å¯¼ æ¥å®‰è£…æœç‹—è¾“å…¥æ³•ã€‚ å®‰è£…æ—¶æ— éœ€å¸è½½ç³»ç»Ÿ ibus è¾“å…¥æ³•æ¡†æ¶ (ä¸ä¸Šé¢çš„å®‰è£…æŒ‡å¯¼ä¸ä¸€è‡´) é€šè¿‡ Ctrl + space å”¤é†’æœç‹—è¾“å…¥æ³• é€šè¿‡ Ctrl + Shift + Z å‘¼å‡ºç‰¹æ®Šç¬¦å·è¡¨ ","date":"2023-12-27","objectID":"/posts/ubuntu22.04lts/:2:0","tags":["Linux","Ubuntu"],"title":"Ubuntu 22.04LTS ç›¸å…³é…ç½®","uri":"/posts/ubuntu22.04lts/"},{"categories":["Toolkit"],"content":"å¿«æ·é”® æ–°å»ºç»ˆç«¯ï¼š Ctrl + Alt + T é”å±ï¼š Super + Lï¼šé”å®šå±å¹•å¹¶ç†„å±ã€‚ æ˜¾ç¤ºæ¡Œé¢ï¼š Super + d æˆ–è€… Ctrl + Alt + d æœ€å°åŒ–æ‰€æœ‰è¿è¡Œçš„çª—å£å¹¶æ˜¾ç¤ºæ¡Œé¢ï¼Œå†æ¬¡é”®å…¥åˆ™é‡æ–°æ‰“å¼€ä¹‹å‰çš„çª—å£ã€‚ æ˜¾ç¤ºæ‰€æœ‰çš„åº”ç”¨ç¨‹åºï¼š Super + a å¯ä»¥é€šè¿‡ ESC æ¥é€€å‡ºè¯¥æ˜¾ç¤ºã€‚ æ˜¾ç¤ºå½“å‰è¿è¡Œçš„æ‰€æœ‰åº”ç”¨ç¨‹åºï¼š Super ç§»åŠ¨çª—å£ä½ç½®ï¼š Super + å·¦ç®­å¤´ï¼šå½“å‰çª—å£ç§»åŠ¨åˆ°å±å¹•å·¦åŠè¾¹åŒºåŸŸ Super + å³ç®­å¤´ï¼šå½“å‰çª—å£ç§»åŠ¨åˆ°å±å¹•å³åŠè¾¹åŒºåŸŸ Super + ä¸Šç®­å¤´ï¼šå½“å‰çª—å£æœ€å¤§åŒ– Super + ä¸‹ç®­å¤´ï¼šå½“å‰çª—å£æ¢å¤æ­£å¸¸ éšè—å½“å‰çª—å£åˆ°ä»»åŠ¡æ ï¼š Super + h åˆ‡æ¢å½“å‰çš„åº”ç”¨ç¨‹åºï¼š Super + Tabï¼šä»¥åº”ç”¨ç¨‹åºä¸ºç²’åº¦æ˜¾ç¤ºåˆ‡æ¢é€‰é¡¹ Alt + Tabï¼šä»¥çª—å£ä¸ºç²’åº¦æ˜¾ç¤ºåˆ‡æ¢é€‰é¡¹ åˆ‡æ¢è™šæ‹Ÿæ¡Œé¢/å·¥ä½œåŒºï¼š Ctrl + Alt + å·¦/å³æ–¹å‘é”® è‡ªå®šä¹‰é”®ç›˜å¿«æ·é”®ï¼š Settings -\u003e Keyboard -\u003e Keyboard Shortcus | View and Customize Shortcuts -\u003e Custom Shortcuts ","date":"2023-12-27","objectID":"/posts/ubuntu22.04lts/:3:0","tags":["Linux","Ubuntu"],"title":"Ubuntu 22.04LTS ç›¸å…³é…ç½®","uri":"/posts/ubuntu22.04lts/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":" æ‘˜è¦ GNU/Linux å¼€å‘å·¥å…·ï¼Œå‡ ä¹ä»ç¡¬ä»¶åˆ°è½¯ä»¶ï¼ŒLinux å¹³å°èƒ½å¤Ÿè‡ªä¸‹è€Œä¸Šæä¾›å„ç±»è§¦åŠâ€œçµé­‚â€çš„å­¦ä¹ æ¡ˆä¾‹ï¼Œè®©æ‰€æœ‰è¯¾ç¨‹ä»çº¸ä¸Šè°ˆå…µè½¬å˜æˆæ²™åœºå®æˆ˜ï¼Œä¼šæå¤§åœ°æå‡å·¥ç¨‹å®è·µçš„æ•ˆç‡å’ŒæŠ€èƒ½ã€‚ åŸæ–‡åœ°å€ ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:0:0","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"å®‰è£… Windows / Ubuntu åŒç³»ç»Ÿ å› ä¸ºæœ‰äº›æ“ä½œå¿…é¡»åœ¨ç‰©ç†ç¡¬ä»¶ä¸Šæ‰èƒ½æ‰§è¡Œã€‚ ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:1:0","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Markdown ä¸ LaTeX é€Ÿè§ˆ LaTeX è¯­æ³•ç¤ºä¾‹ä¸€èŠ‚ï¼Œä½œä¸ºå·¥å…·ä¹¦å†Œï¼Œåœ¨éœ€è¦ä½¿ç”¨æ—¶çŸ¥é“å¦‚ä½•æŸ¥è¯¢ã€‚ é€Ÿè§ˆ Markdown è¯­æ³•ç¤ºä¾‹ä¸€èŠ‚ï¼Œä½œä¸ºå·¥å…·ä¹¦å†Œï¼Œåœ¨éœ€è¦ä½¿ç”¨æ—¶çŸ¥é“å¦‚ä½•æŸ¥è¯¢ã€‚ æ³¨æ„ ç¼–å†™ Markdown æ–‡æœ¬ä»¥åŠ LaTeX è¯­æ³•è¡¨ç¤ºçš„æ•°å­¦å¼å¯ä»¥é€šè¿‡ï¼š Hugo + FixIt âœ… VS Code + Markdown Preview Enhanced ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:2:0","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Git å’Œ Github é˜…è¯» SSH key äº§ç”Ÿæ–¹æ³•ä¸€èŠ‚ï¼Œé…ç½®å¥½ Git å’Œ Github çš„ SSH keyã€‚åŒæ—¶ä¹Ÿå¯ä½œä¸ºå·¥å…·ä¹¦å†Œï¼Œåœ¨éœ€è¦ä½¿ç”¨æ—¶çŸ¥é“å¦‚ä½•æŸ¥è¯¢ã€‚ æ¨èé€šè¿‡ LearnGitBranching æ¥ç†Ÿæ‚‰ Git å‘½ä»¤ï¼ï¼ï¼ ä»¥ä¸‹èµ„æºä½œä¸ºè‡ªå­¦èµ„æºï¼Œç”¨äºè¡¥å……è‡ªå·±ä¸ç†Ÿæ‚‰çš„æ“ä½œï¼Œæˆ–è€…ä½œä¸ºä»¥ä¸Šèµ„æ–™çš„è¡¥å……å·¥å…·æ‰‹å†Œã€‚ Git ä¸­æ–‡æ•™å­¦ - YouTube (å­¦ä¹ è®°å½•) 30 å¤©ç²¾é€š Git ç‰ˆæœ¬æ§åˆ¶ - GitHub è­¦å‘Š åŸæ–‡æ¡£ä¸­çš„å°†å…¬é’¥å¤åˆ¶åˆ° clipboard ä¸­ä½¿ç”¨äº† clip å‘½ä»¤ï¼Œä½†æ˜¯è¿™ä¸ªå‘½ä»¤åœ¨ Ubuntu ä¸­å¹¶æ²¡æœ‰å¯¹åº”çš„å‘½ä»¤ã€‚å¯ä»¥ä½¿ç”¨ xclip + alias è¾¾åˆ°è¿‘ä¼¼æ•ˆæœã€‚ $ sudo apt install xclip # using alias to implement clip, you can add this to bashrc $ alias clip='xclip -sel c' $ clip \u003c ~/.ssh/id_rsa.pub ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:3:0","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"ç¼–è¾‘å™¨: Visual Studio Code è®¤çœŸé˜…è¯»ï¼Œè·Ÿéšæ•™å­¦æ–‡æ¡£è¿›è¡Œå®‰è£…ã€è®¾ç½®ã€‚é‡ç‚¹é˜…è¯» è®¾å®šã€é™¤é”™ï¼ˆè°ƒè¯•ï¼‰ è¿™ä¸¤éƒ¨åˆ†ã€‚æ›´æ–° VS Code éƒ¨åˆ†ä½œä¸ºæ‰‹å†Œï¼Œåœ¨éœ€è¦æ—¶è¿›è¡Œå‚è€ƒã€‚ ä»¥ä¸‹èµ„æºä½œä¸ºè‡ªå­¦èµ„æºï¼Œç”¨äºè¡¥å……è‡ªå·±ä¸ç†Ÿæ‚‰çš„æ“ä½œï¼Œæˆ–è€…ä½œä¸ºä»¥ä¸Šèµ„æ–™çš„è¡¥å……å·¥å…·æ‰‹å†Œã€‚ å¼€å¼€å¿ƒå¿ƒå­¦ Vistual Studio Code å®Œæˆ SSH key çš„ç”Ÿæˆã€‚ å®Œæˆ VS Code çš„è®¾ç½®ã€‚ å®‰è£… Git History æ’ä»¶ã€‚ å®‰è£… Native Debug æ’ä»¶ï¼Œå¹¶è¿›è¡Œ Debug (test-stopwatch.c) æ“ä½œã€‚ å®‰è£… VSCode Great Icons æ–‡ä»¶å›¾æ ‡ä¸»é¢˜ï¼Œå¦å¤–æ¨èä¸¤æ¬¾é¢œè‰²ä¸»é¢˜ï¼šOne Dark Pro, Learn with Sumitã€‚ VS Code æ§åˆ¶å°ä½¿ç”¨è¯´æ˜ï¼š å¯ä»¥åœ¨é¢æ¿çš„è¾“å‡ºï¼Œç‚¹å‡» GIT é€‰é¡¹æ˜¾ç¤º VS Code èƒŒåæ‰§è¡Œçš„ git å‘½ä»¤ã€‚ å¯ä»¥ä½¿ç”¨ ctrl + shift + P å‘¼å‡ºå‘½ä»¤åŒºï¼Œç„¶åé€šè¿‡è¾“å…¥ Git branch å’Œ Git checkout ç­‰å¹¶é€‰æ‹©å¯¹åº”é€‰é¡¹ï¼Œæ¥è¾¾åˆ°åˆ›å»ºåˆ†æ”¯ã€åˆ‡æ¢åˆ†æ”¯ç­‰åŠŸèƒ½ã€‚ æŠ€å·§ åœ¨ VS Code è®¾ç½®ä¸­ï¼Œéœ€è¦åœ¨è®¾ç½®ä¸­æ‰“å¼€ Open Default Settings é€‰é¡¹æ‰èƒ½åœ¨å·¦ä¾§é¢æ¿è§‚å¯Ÿåˆ°é¢„è®¾å€¼ã€‚é”®ä½ç»‘å®šåŒç†ã€‚ è¦æƒ³è¿›è¡Œè°ƒè¯•ï¼Œéœ€è¦åœ¨ä½¿ç”¨ gcc ç”Ÿæˆç›®æ ‡æ–‡ä»¶æ—¶ï¼ŒåŠ å…¥ -g å‚æ•°æ¥ç”Ÿäº§è°ƒè¯•ä¿¡æ¯ã€‚ åŸæ–‡æ¡£ä¸­çš„ GDB æ•™å­¦é“¾æ¥-é™¤é”™ç¨‹å¼-gdb å·²å¤±æ•ˆï¼Œè¿™æ˜¯ç›®å‰çš„æœ‰æ•ˆé“¾æ¥ã€‚ä¹Ÿå¯é€šè¿‡è¯¥å½±ç‰‡ æ‹¯æ•‘èµ„å·¥ç³»å­¦ç”Ÿçš„åŸºæœ¬ç´ å…»-ä½¿ç”¨ GDB é™¤é”™åŸºæœ¬æ•™å­¦ æ¥è¡¥å……å­¦ä¹  GDB çš„æ“ä½œã€‚ ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:4:0","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"ç»ˆç«¯å’Œ Vim è®¤çœŸé˜…è¯»ï¼Œè·Ÿéšæ•™å­¦å½±ç‰‡ å¿«å¿«ä¹ä¹å­¦ Vim å’Œæ•™å­¦æ–‡æ¡£é…ç½®å¥½ ç»ˆç«¯æç¤ºç¬¦ã€Vimã€‚ å®Œæˆå‘½ä»¤è¡Œæç¤ºç¬¦é…ç½® å®Œæˆ Vim çš„è®¾å®š å®‰è£…å¹¶ä½¿ç”¨ Minial Vim Plugin Manager æ¥ç®¡ç† Vim æ’ä»¶ (neocomplcache, nerdtree) å®‰è£…å¹¶ä½¿ç”¨ byobu æ¥ç®¡ç†å¤šä¸ªç»ˆç«¯è§†å›¾ã€‚ æŠ€å·§ åœ¨ .vimrc ä¸­å¢åŠ æ’ä»¶åï¼Œæ‰“å¼€ vimï¼Œæ‰§è¡Œ :PlugInstall æ¥å®‰è£…æ’ä»¶ï¼Œå®Œæˆååœ¨ vim æ‰§è¡Œ :source ~/.vimrcã€‚ï¼ˆå¯ä»¥é€šè¿‡ :PlugStatus æ¥æŸ¥çœ‹æ’ä»¶å®‰è£…çŠ¶æ€ï¼‰ ä½¿ç”¨ F4 é”®æ¥[æ˜¾ç¤º/ä¸æ˜¾ç¤º][è¡Œæ•°/ç›¸å¯¹è¡Œæ•°]ã€‚ ä½¿ç”¨ F5 é”®æ¥å‘¼å…¥/å‘¼å‡ºæ–‡ä»¶æ ‘(nerdtree)ï¼Œåœ¨æ–‡ä»¶æ ‘æ»é€šè¿‡ ENTER é”®æ¥è®¿é—®ç›®å½•/æ–‡ä»¶ã€‚ ä½¿ç”¨ Ctrl-w-h/Ctrl-w-l åˆ‡æ¢åˆ° æ–‡ä»¶æ ‘/ç¼–è¾‘åŒºã€‚ è‡ªåŠ¨è¡¥å…¨æ—¶ä½¿ç”¨ ENTER é”®æ¥é€‰ä¸­ï¼Œä½¿ç”¨æ–¹å‘é”®æˆ– Ctrl-N/Ctrl-U/Ctrl-P æ¥ä¸Šä¸‹é€‰æ‹©ã€‚ åœ¨ Vim ä¸­å¯ä»¥é€šè¿‡ :set pasteï¼Œå¹¶åœ¨ insert æ¨¡å¼ä¸‹ï¼Œå°†ç²˜è´´æ¿çš„å†…å®¹é€šè¿‡ Ctrl-Shift-V è¿›è¡Œç²˜è´´ã€‚ byobu ä½¿ç”¨è¯´æ˜ï¼š åœ¨ç»ˆç«¯è¾“å…¥ byobu F2 æ–°å¢ Terminial åˆ†é¡µã€‚F3, F4 åœ¨ Terminial åˆ†é¡µä¸­åˆ‡æ¢ã€‚Ctrl +F6 åˆ é™¤å½“å‰ Terminial åˆ†é¡µã€‚ Shift + F2 æ°´å¹³åˆ‡å‰² Terminialã€‚Ctrl +F2 å‚ç›´åˆ‡å‰² Terminialã€‚Shift + æ–¹å‘é”® åˆ‡æ¢ã€‚ åœ¨ byobu ä¸­æš‚æ—¶æ— æ³•ä½¿ç”¨ä¹‹å‰è®¾ç½®çš„ F4 æˆ– F5 å¿«æ·é”®ï¼Œä½†æ˜¯å¯ä»¥ç›´æ¥é€šè¿‡å‘½ä»¤ :set norelative æ¥å…³é—­ç›¸å¯¹è¡Œæ•°ã€‚ æ¨èè§‚çœ‹å½±ç‰‡ How to Do 90% of What Plugins Do (With Just Vim) æ¥æ‰©å±• Vim æ’ä»¶çš„ä½¿ç”¨å§¿åŠ¿ã€‚ ä»¥ä¸‹èµ„æºä¸º Cheat Sheetï¼Œéœ€è¦ä½¿ç”¨æ—¶å›æ¥å‚è€ƒå³å¯ã€‚ Vim Cheat Sheet Bash terminal Cheat Sheet ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:5:0","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Makefile é€Ÿè§ˆæ•™å­¦æ–‡æ¡£ï¼Œä½œä¸ºå·¥å…·ä¹¦å†Œï¼Œåœ¨éœ€è¦ä½¿ç”¨æ—¶çŸ¥é“å¦‚ä½•æŸ¥è¯¢ã€‚ gcc çš„ -MMD å’Œ -MF å‚æ•°å¯¹æˆ‘ä»¬ç¼–å†™ Makefile æ˜¯ä¸€ä¸ªå·¨å¤§åˆ©å™¨ã€‚ç†è§£ Makefile çš„å„ç§å˜é‡å®šä¹‰çš„åŸç†ã€‚ å¯¹ä¹‹å‰çš„ test-stopwatch.c ç¼–å†™äº†ä¸€ä¸ª Makefile æ¥è‡ªåŠ¨åŒ–ç®¡ç†ã€‚ ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:6:0","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Linux æ€§èƒ½åˆ†æå·¥å…·: Perf è®¤çœŸé˜…è¯»ï¼Œå¤ç°æ•™å­¦æ–‡æ¡£ä¸­çš„æ‰€æœ‰ä¾‹å­ï¼Œåˆæ­¥ä½“éªŒ perf åœ¨æ€§èƒ½åˆ†æä¸Šçš„å¼ºå¤§ã€‚ å®‰è£… perf å¹¶å°† kernel.perf_event_paranoid è®¾ç½®ä¸º 1ã€‚ åŠ¨æ‰‹ä½¿ç”¨ perf_top_example.cï¼Œä½“éªŒ perf çš„ä½œç”¨ã€‚ æ­é…å½±ç‰‡: Branch Prediction å¯¹ç…§é˜…è¯»: Fast and slow if-statements: branch prediction in modern processors ç¼–è¯‘å™¨æä¾›çš„è¾…åŠ©æœºåˆ¶: Branch Patterns, Using GCC åŠ¨æ‰‹ä½¿ç”¨ perf_top_while.cï¼Œä½“éªŒ perf top çš„ä½œç”¨ã€‚ åŠ¨æ‰‹ä½¿ç”¨ perf_stat_cache_miss.cï¼Œä½“éªŒ perf stat çš„ä½œç”¨ã€‚ï¼ˆåŸæ–‡çš„ç»“æœæœ‰äº›ä¸ç›´è§‚ï¼ŒåŠ¡å¿…äº²è‡ªåŠ¨æ‰‹éªŒè¯ï¼‰ åŠ¨æ‰‹ä½¿ç”¨ perf_record_example.cï¼Œä½“éªŒ perf record çš„ä½œç”¨ã€‚ï¼ˆåŸæ–‡çš„æ“ä½œä¸æ˜¯å¾ˆè¯¦ç»†ï¼Œå¯ä»¥å‚è€ƒä¸‹é¢çš„ Successï¼‰ Source æˆåŠŸ $ perf record -e branch-misses:u,branch-instructions:u ./perf_record_example [ perf record: Woken up 1 times to write data ] [ perf record: Captured and wrote 0.009 MB perf.data (94 samples) ] è¾“å‡ºç¬¬ä¸€è¡Œè¡¨ç¤º perf å·¥å…·åœ¨æ”¶é›†æ€§èƒ½æ•°æ®æ—¶è¢«å”¤é†’äº† 1 æ¬¡ï¼Œä»¥å°†æ•°æ®å†™å…¥è¾“å‡ºæ–‡ä»¶ã€‚ è¾“å‡ºç¬¬äºŒè¡Œè¡¨ç¤º perf å·¥å…·å·²ç»å–æ ·å¹¶å†™å…¥äº†ä¸€ä¸ªåä¸º perf.data çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œæ–‡ä»¶å¤§å°ä¸º 0.009 MBï¼Œå…¶ä¸­åŒ…å«äº† 94 ä¸ªé‡‡æ ·ã€‚ï¼ˆå¯ä»¥é€šè¿‡ ls å‘½ä»¤æ¥æ£€æŸ¥ perf.data æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼‰ æ¥ä¸‹æ¥é€šè¿‡ perf report å¯¹ä¹‹å‰è¾“å‡ºçš„äºŒè¿›åˆ¶æ–‡ä»¶ perf.data è¿›è¡Œåˆ†æã€‚å¯ä»¥é€šè¿‡æ–¹å‘é”®é€‰æ‹©ï¼Œå¹¶é€šè¿‡ ENTER è¿›å…¥ä¸‹ä¸€å±‚æŸ¥çœ‹åˆ†æç»“æœã€‚ $ perf report Available samples 5 branch-misses:u 89 branch-instructions:u æŠ€å·§ perf éœ€è¦åœ¨ root ä¸‹è¿›è¡Œæ€§èƒ½åˆ†æã€‚ perf top æ˜¯å¯¹äºå“ªä¸ªç¨‹åºæ˜¯æ€§èƒ½ç“¶é¢ˆæ²¡æœ‰å¤´ç»ªæ—¶ä½¿ç”¨ï¼Œå¯ä»¥æŸ¥çœ‹å“ªä¸ªç¨‹åºï¼ˆä»¥åŠç¨‹åºçš„å“ªä¸ªéƒ¨åˆ†ï¼‰æ˜¯çƒ­åº¦ç‚¹ã€‚ åœ¨ perf top æ—¶å¯ä»¥é€šè¿‡ h é”®å‘¼å‡ºå¸®åŠ©åˆ—è¡¨ã€‚ å¯ä»¥é€šè¿‡æ–¹å‘é”®é€‰æ‹©éœ€è¦è¿›ä¸€æ­¥åˆ†æçš„éƒ¨åˆ†ï¼Œå¹¶é€šè¿‡ a é”®æ¥æŸ¥çœ‹æŒ‡ä»¤çº§åˆ«ç²’åº¦çš„çƒ­ç‚¹ã€‚ perf stat æ˜¯å¯¹æŸä¸€ä¸ªè¦ä¼˜åŒ–çš„ç¨‹åºè¿›è¡Œæ€§èƒ½åˆ†æï¼Œå¯¹è¯¥ç¨‹åºæ¶‰åŠçš„ä¸€ç³»åˆ— events è¿›è¡Œå–æ ·æ£€æŸ¥ã€‚ perf record çš„ç²¾åº¦æ¯” perf stat æ›´é«˜ï¼Œå¯ä»¥å¯¹å–æ ·çš„ events è¿›è¡Œå‡½æ•°ç²’åº¦çš„åˆ†æã€‚ ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:7:0","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Linux ç»˜å›¾å·¥å…·: gnuplot é˜…è¯»æ•™ç¨‹ï¼Œæ­é…æ•™å­¦å½±ç‰‡ è½»è½»æ¾æ¾å­¦ gnuplotï¼Œä½¿ç”¨ gnuplot å®Œæˆæ‰€ç»™ä¾‹å­ç›¸åº”å›¾åƒçš„ç»˜åˆ¶ã€‚ ä½¿ç”¨ runtime.gp å®Œæˆ runtime.png çš„ç»˜åˆ¶ç”Ÿæˆã€‚ ä½¿ç”¨ statistic.gp å®Œæˆé™é›¨é‡æŠ˜çº¿å›¾ statistic.png çš„ç»˜åˆ¶ç”Ÿæˆã€‚ æ³¨æ„ åŸæ–‡æ‰€ç»™çš„ statistic.gp æ˜¯ä½¿ç”¨ Times_New_Roman æ¥æ˜¾ç¤ºä¸­æ–‡çš„ï¼Œä½†ç¬”è€…çš„ Ubuntu ä¸­å¹¶æ²¡æœ‰è¿™ä¸ªå­—ä½“ï¼Œæ‰€ä»¥ä¼šæ˜¾ç¤ºä¹±ç ã€‚å¯ä»¥é€šè¿‡ fc-list :lang=zh å‘½ä»¤æ¥æŸ¥è¯¢å½“å‰ç³»ç»Ÿä¸­çš„å·²å®‰è£…çš„ä¸­æ–‡å­—ä½“ã€‚ Source å®‰è£… gnuplot: $ sudo apt-get install gnuplot gnuplot script çš„ä½¿ç”¨æµç¨‹ï¼š # åˆ›å»ºå¹¶ç¼–å†™ä¸€ä¸ªåç¼€åä¸º .gp çš„æ–‡ä»¶ $ vim script.gp # æ ¹æ® script å†…çš„æŒ‡ä»¤è¿›è¡Œç»˜å›¾ $ gnuplot script.gp # æ ¹æ® script æŒ‡å®šçš„å›¾ç‰‡ä¿å­˜è·¯å¾„æ‰“å¼€å›¾ç‰‡ $ eog [name of picture] ä¸‹é¢ä»¥ä¸€ä¸ª script è¿›è¡Œå¸¸ç”¨æŒ‡ä»¤çš„è¯´æ˜ï¼š reset set ylabel 'time(sec)' set style fill solid set title 'performance comparison' set term png enhanced font 'Verdana,10' set output 'runtime.png' plot [:][:0.100]'output.txt' using 2:xtic(1) with histogram title 'original', \\ '' using ($0-0.06):($2+0.001):2 with labels title ' ', \\ '' using 3:xtic(1) with histogram title 'optimized' , \\ '' using 4:xtic(1) with histogram title 'hash' , \\ '' using ($0+0.3):($3+0.0015):3 with labels title ' ', \\ '' using ($0+0.4):($4+0.0015):4 with labels title ' ' reset æŒ‡ä»¤çš„ä½œç”¨ä¸ºï¼Œå°†ä¹‹å‰ set æŒ‡ä»¤è®¾ç½®è¿‡çš„å†…å®¹å…¨éƒ¨é‡ç½®ã€‚ set style fill solid å°†ç»˜åˆ¶å‡ºçš„æŸ±å½¢æˆ–åŒºåŸŸä½¿ç”¨å®å¿ƒæ–¹å¼å¡«å……ã€‚ set term png enhanced font 'Verdana,10' term png ç”Ÿæˆçš„å›¾åƒä»¥ png æ ¼å¼è¿›è¡Œä¿å­˜ã€‚(term æ˜¯ terminial çš„ç¼©å†™) enhanced å¯ç”¨å¢å¼ºæ–‡æœ¬æ¨¡å¼ï¼Œå…è®¸åœ¨æ ‡ç­¾å’Œæ³¨é‡Šä¸­ä½¿ç”¨ç‰¹æ®Šçš„æ–‡æœ¬æ ¼å¼ï¼Œå¦‚ä¸Šä¸‹æ ‡ã€æ–œä½“ã€ä¸‹åˆ’çº¿ç­‰ã€‚ font 'Verdana,10' æŒ‡å®šæ‰€ä½¿ç”¨çš„å­—ä½“ä¸º Verdanaï¼Œå­—å·ä¸º10ã€‚å¯è¿›è¡Œè‡ªå®šä¹‰è®¾ç½®ã€‚ å…¶å®ƒæŒ‡ä»¤æŸ¥è¯¢åŸæ–‡æˆ–æ‰‹å†Œå³å¯ã€‚ $0 åœ¨ gnuplot ä¸­è¡¨ç¤ºä¼ªåˆ—ï¼Œå¯ä»¥ç®€å•ç†è§£ä¸ºè¡Œå·ï¼Œä»¥ä¸‹ä¸ºç›¸åº”å›¾ç¤ºï¼š åŸå§‹æ•°æ®é›†ï¼š append() 0.048240 0.040298 0.057908 findName() 0.006495 0.002938 0.000001 ï¼ˆäººä¸ºï¼‰å¢åŠ äº† ä¼ªåˆ— è¡¨ç¤ºçš„æ•°æ®é›†ï¼ˆæœ€å·¦è¾¹ 0, 1 å³ä¸ºä¼ªåˆ—ï¼‰ï¼š 0 append() 0.048240 0.040298 0.057908 1 findName() 0.006495 0.002938 0.000001 æŠ€å·§ gnuplot åœ¨ç»˜åˆ¶ç”Ÿæˆå›¾åƒæ—¶æ˜¯å®‰è£…æŒ‡ä»¤çš„é¡ºåºè¿›è¡Œçš„ï¼Œå¹¶ä¸”å’Œä¸€èˆ¬çš„ç”»å›¾è½¯ä»¶ç±»ä¼¼ï¼Œåœ¨æœ€ä¸Šå±‚è¿›è¡Œç»˜åˆ¶ã€‚æ‰€ä»¥åœ¨ç¼–å†™ script çš„æŒ‡ä»¤æ—¶éœ€è¦æ³¨æ„é¡ºåºï¼Œå¦åˆ™ç”Ÿæˆå›¾åƒçš„éƒ¨åˆ†å¯èƒ½å¹¶ä¸åƒé¢„æœŸä¸€æ ·ä½äºæœ€ä¸Šå±‚ã€‚ï¼ˆæ€è€ƒä¸Šé¢ script çš„ 3, 4 åˆ—çš„ label çš„ç»˜åˆ¶é¡ºåºï¼‰ gnuplot script ä¸­çš„å­—ç¬¦ä¸²å¯ä»¥ä½¿ç”¨ '' æˆ–è€… \"\" æ¥åŒ…è£¹ï¼ŒåŒæ ·ç±»ä¼¼äº Pythonã€‚ ç›´æ¥åœ¨ç»ˆç«¯è¾“å…¥ gnuplot ä¼šè¿›å…¥äº¤äº’å¼çš„å‘½ä»¤ç•Œé¢ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ gnulpot æŒ‡ä»¤æ¥ç»˜å›¾ï¼ˆç±»ä¼¼ä¸ Pythonï¼‰ã€‚åœ¨è¿™ç§äº¤äº’å¼ç•Œé¢ç¯å¢ƒä¸­ï¼Œå¦‚æœéœ€è¦åœ¨è¾“å…¥å®ŒæŒ‡ä»¤åç«‹å³æ˜¾ç¤ºå›¾åƒåˆ°æ–°çª—å£ï¼Œè€Œä¸æ˜¯ä¿å­˜å›¾åƒå†æ‰“å¼€ï¼Œåªéœ€è¾“å…¥è¿›è¡ŒæŒ‡ä»¤ï¼š set term wxt ehanced persist raise term wxt å°†å›¾å½¢ç»ˆç«¯ç±»å‹è®¾ç½®ä¸ºWXTï¼Œè¿™ä¼šåœ¨æ–°çª—å£ä¸­æ˜¾ç¤ºç»˜å›¾ã€‚ ersist è¯¥é€‰é¡¹ä½¿ç»˜å›¾çª—å£ä¿æŒæ‰“å¼€çŠ¶æ€ï¼Œå³ä½¿è„šæœ¬æ‰§è¡Œå®Œæ¯•ä¹Ÿä¸ä¼šè‡ªåŠ¨å…³é—­ã€‚ raise è¯¥é€‰é¡¹å°†ç»˜å›¾çª—å£ç½®äºå…¶ä»–çª—å£çš„å‰é¢ï¼Œä»¥ç¡®ä¿å®ƒåœ¨å±å¹•ä¸Šçš„å¯è§æ€§ã€‚ ä¸€äº›é¢å¤–çš„æ•™ç¨‹ï¼š Youtube - gnuplot Tutorlal è¿™ä¸ªæ•™ç¨‹æœ‰äº”éƒ¨å½±ç‰‡ï¼Œåˆ°å‘å¸ƒè€…çš„ä¸»é¡µæœå¯»å³å¯ã€‚ ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:8:0","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"Linux ç»˜å›¾å·¥å…·: Graphviz å®˜æ–¹ç½‘ç«™ ä¸€å°æ—¶å®è·µå…¥é—¨ Graphviz å®‰è£…: $ sudo apt install graphviz æŸ¥çœ‹å®‰è£…ç‰ˆæœ¬: $ dot -V dot - graphviz version 2.43.0 (0) é€šè¿‡è„šæœ¬ç”Ÿæˆå›¾åƒ: $ dot -Tpng example.dot -o example.png Graphviz åœ¨æ¯å‘¨æµ‹éªŒé¢˜çš„åŸç†è§£é‡Šåˆ†ææ—¶ä¼šå¤§é‡ä½¿ç”¨åˆ°ï¼Œè¯·åŠ¡å¿…æŒæ¡ä»¥å®ä½œå‡º Readable çš„æŠ¥å‘Šã€‚ ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:9:0","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"å…¶å®ƒå·¥å…· ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:10:0","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"man $ man man The table below shows the section numbers of the manual followed by the types of pages they contain. 1 Executable programs or shell commands 2 System calls (functions provided by the kernel) 3 Library calls (functions within program libraries) 4 Special files (usually found in /dev) 5 File formats and conventions, e.g. /etc/passwd 6 Games 7 Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7), man-pages(7) 8 System administration commands (usually only for root) 9 Kernel routines [Non standard] ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:10:1","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"cloc man 1 cloc cloc - Count, or compute differences of, lines of source code and comments. ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:10:2","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"top man 1 top top - display Linux processes ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:10:3","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Toolkit","Linux Kernel Internals"],"content":"htop man 1 htop htop - interactive process viewer ","date":"2023-12-25","objectID":"/posts/gnu-linux-dev/:10:4","tags":["Sysprog","Linux"],"title":"GNU/Linux å¼€å‘å·¥å…·","uri":"/posts/gnu-linux-dev/"},{"categories":["Mathematics"],"content":"è¿™é‡Œè®°å½•ä¸€äº›æ”¶é›†åˆ°çš„æ•°å­¦å¼€æ”¾å¼è¯¾ç¨‹å­¦æ ¡èµ„æ–™ã€‚ ","date":"2023-12-23","objectID":"/posts/math/:0:0","tags":["Mathematics"],"title":"æ•°å­¦å¼€æ”¾å¼è¯¾ç¨‹å­¦ä¹ æŒ‡å¼•","uri":"/posts/math/"},{"categories":["Mathematics"],"content":"èµ„æºå¯¼èˆª ä¸­å¤§æ•¸å­¸ç³»é–‹æ”¾å¼èª²ç¨‹ åœ‹ç«‹å°ç£å¤§å­¸ é½Šéœ‡å®‡ æ•¸å­¸å°è«–ï¼šç›¸é—œè¬›ç¾© / æ•™å­¸éŒ„å½± æ•¸å­¸æ½›æ°´è‰‡ï¼šç¶«æ€§ä»£æ•¸ã€æ‹“æ’² å¾®ç©åˆ†: Part 1, Part 2 åˆ†æ åœ‹ç«‹å°ç£å¤§å­¸ è¬éŠ˜å€« ç¶«æ€§ä»£æ•¸ ","date":"2023-12-23","objectID":"/posts/math/:1:0","tags":["Mathematics"],"title":"æ•°å­¦å¼€æ”¾å¼è¯¾ç¨‹å­¦ä¹ æŒ‡å¼•","uri":"/posts/math/"},{"categories":["Mathematics"],"content":"é€»è¾‘ã€é›†åˆè®º ","date":"2023-12-23","objectID":"/posts/math/:2:0","tags":["Mathematics"],"title":"æ•°å­¦å¼€æ”¾å¼è¯¾ç¨‹å­¦ä¹ æŒ‡å¼•","uri":"/posts/math/"},{"categories":["Mathematics"],"content":"ç°¡æ˜“é‚è¼¯ åœ¨è”ç»“è¯æ„æˆçš„å¤åˆå‘½é¢˜ä¸­ï¼Œå‘½é¢˜çš„è¯­ä¹‰å’ŒçœŸå€¼éœ€è¦åˆ†å¼€è€ƒè™‘ï¼Œç‰¹åˆ«æ˜¯è”ç»“è¯ $\\implies$ã€‚ä»¥ $p \\implies q$ ä¸ºä¾‹ (æ³¨æ„ $p$ å’Œ $q$ éƒ½æ˜¯æŠ½è±¡å‘½é¢˜ï¼Œå¯æŒ‡ä»£ä»»æ„å‘½é¢˜ï¼Œç±»ä¼¼äºæœªçŸ¥æ•° $x$)ï¼Œå¦‚æœä» $p$ å’Œ $q$ çš„è¯­ä¹‰è€ƒè™‘ï¼Œå¾ˆå®¹æ˜“å°±é™·å…¥è¯­ä¹‰çš„ â€œå¦‚æœ $p$ åˆ™ $q$â€ è¿™ç±»è¯­ä¹‰æ··æ·†ä¸­ï¼Œå¯¼è‡´å¼ºåŠ å› æœï¼Œä½†å› ä¸ºåœ¨é€»è¾‘ä¸Š $p$ å’Œ $q$ å¯ä»¥æ²¡æœ‰ä»»ä½•å…³ç³»ï¼Œæ‰€ä»¥æ­¤æ—¶å¿½ç•¥å®ƒä»¬çš„è¯­ä¹‰ï¼Œè€Œåªæ ¹æ®å®ƒä»¬çš„çœŸå€¼å’Œç›¸å…³å®šä¹‰ä¸Šæ¨æ–­è¯¥å¤åˆå‘½é¢˜çš„çœŸå€¼ ($p \\implies q$ ç­‰ä»·äº $(\\neg p) \\lor q$)ã€‚ç®€å•æ¥è¯´ï¼Œé€»è¾‘ä¸Šçš„è•´æ¶µå¼åŒ…æ‹¬è¯­ä¹‰ä¸Šçš„å› æœå…³ç³»ï¼Œå³å› æœå…³ç³»æ˜¯è•´æ¶µå¼çš„çœŸå­é›†ã€‚ ç¬¬ 16 é¡µçš„è¶£å‘³é—®é¢˜å¯ä»¥é€šè¿‡ä»¥ä¸‹ â€œæ ‡å‡†â€ æ–¹å¼ (è¿™é‡Œçš„ â€œæ ‡å‡†â€ æŒ‡çš„æ˜¯ä¸€ç§é€šç”¨æ–¹æ³•æ€è·¯ï¼Œå¹¶éåº”è¯•æ•™è‚²ä¸­çš„å¾—åˆ†ç‚¹) æ¥è§£å†³: ä»¤æ‚Ÿç©ºã€å…«æˆ’ã€æ‚Ÿå‡€å’Œé¾™é©¬åˆ†åˆ«ä¸º $a, b, c, d$ï¼Œä»¤å‘½é¢˜ã€Œ$X$ ç¬¬ $Y$ã€ä¸º $XY$ï¼Œä¾‹å¦‚ â€œæ‚Ÿç©ºç¬¬ä¸€â€ åˆ™è¡¨ç¤ºä¸ºå‘½é¢˜ $a1$ï¼Œåˆ™æœ‰ä»¥ä¸‹å‘½é¢˜æˆç«‹: $$ \\begin{split} \u0026 (c1 \\land (\\neg b2)) \\lor ((\\neg c1) \\land b2) \\\\ \\land\\ \u0026 (c2 \\land (\\neg d3)) \\lor ((\\neg c2) \\land d3) \\\\ \\land\\ \u0026 (d4 \\land (\\neg a2)) \\lor ((\\neg d4) \\land a2) \\\\ \\end{split} $$ ç„¶ååŒ–ç®€è¯¥è¡¨è¾¾å¼å³å¯å¾—åˆ°ç»“æœ (å› ä¸ºè¿™ä¸ªé—®é¢˜æ˜¯ç²¾å¿ƒè®¾è®¡è¿‡çš„ï¼Œæ‰€ä»¥ä¼šæœ‰ä¸€ä¸ªå”¯ä¸€è§£)ã€‚ æ€§è´¨ä¹Ÿæ˜¯å‘½é¢˜ï¼Œå³å…¶çœŸå‡å€¼å¯ä»¥è°ˆè®º (ä½†æœªå¿…èƒ½ç¡®å®š)ã€‚ä½†æ­£å¦‚ç¬¬ 22 é¡µçš„æ³¨ä¸€æ‰€è¯´ï¼Œä¸€èˆ¬ä¸è®¨è®ºæ€§è´¨ $A(x)$ çš„çœŸå‡å€¼ï¼Œåªæœ‰å°†å…·ä½“æˆä»£å…¥æ—¶æ‰æœ‰å¯èƒ½è°ˆè®ºå…¶çœŸå‡å€¼ (è¿™å¾ˆå¥½ç†è§£ï¼ŒæŠ½è±¡çš„ä¸å®šå…ƒ $x$ å¯ä»¥ä»£è¡¨æ— é™å¤šçš„ä¸œè¥¿ï¼Œä»£å…¥æ€§è´¨ $A(x)$ çš„çœŸå‡å€¼å¯èƒ½å¹¶ä¸ç›¸åŒ)ã€‚ä½†æ˜¯éœ€è¦æ³¨æ„åé¢é›†åˆè®ºä¸­è™½ç„¶ä¹Ÿä½¿ç”¨äº†æ€§è´¨æ¥å®šä¹‰ç¾¤ä½“ï¼Œä½†æ˜¯æ­¤æ—¶çš„æ€§è´¨è¡¨ç¤º $A(x)$ è¿™ä¸ªå‘½é¢˜ä¸ºçœŸï¼Œå³ $x$ æ»¡è¶³ $A$ è¿™ä¸ªæ€§è´¨ã€‚æ‰€ä»¥éœ€è¦ç»†å¿ƒçœ‹å¾…é€»è¾‘å­¦å’Œé›†åˆè®ºçš„æ€§è´¨ä¸€æ¬¡ï¼Œå®ƒä»¬æœ‰å…±åŒç‚¹ä¹Ÿæœ‰ä¸åŒç‚¹ã€‚ å¤„ç†æ›´å¤šä¸å®šå…ƒçš„æ€§è´¨æ—¶ï¼ŒæŒ‰ç…§ç¬¬ 24 ~ 27 é¡µçš„æ³¨äºŒçš„æ–¹æ³•ï¼Œå°†å…¶è½¬æ¢æˆç®€å•å½¢å¼çš„å•ä¸€ä¸å®šå…ƒçš„æ€§è´¨è¿›è¡Œå¤„ç†ã€‚ ","date":"2023-12-23","objectID":"/posts/math/:2:1","tags":["Mathematics"],"title":"æ•°å­¦å¼€æ”¾å¼è¯¾ç¨‹å­¦ä¹ æŒ‡å¼•","uri":"/posts/math/"},{"categories":["Mathematics"],"content":"é›†åˆæ¦‚å¿µç°¡ä»‹ ç¬¬ 42 é¡µä¸Šè¿ç”¨äº†ç±»ä¼¼çš„åŒ–ç®€ä¸å®šå…ƒæŠ€å·§ï¼Œé€šè¿‡æ‹¬å·å°†åŒä¸€æ—¶é—´å¤„ç†ä¸å®šå…ƒæ•°é‡å‡å°‘ä¸º 1.é™¤æ­¤ä¹‹å¤–ï¼Œè¿™é‡Œè¿˜æœ‰ä¸€ä¸ªä¸ç­‰å¼å’ŒåŒºé—´/å°„çº¿ç¬¦å·çš„æŠ€å·§: ä¸å¸¦ç­‰å·çš„ä¸ç­‰å¼å’ŒåŒºé—´/å°„çº¿ç¬¦å·æ­é…ä½¿ç”¨æ—¶ï¼Œéœ€è¦åè½¬åŒºé—´/å°„çº¿ç¬¦å·ï¼Œè¿™ä¸ªæŠ€å·§å¯ä»¥ä»åŒºé—´/å°„çº¿ç¬¦å·çš„å®šä¹‰æ¨å¯¼è€Œæ¥ã€‚ä»¥è¯¥é¡µæœ€åçš„ä¾‹å­ä¸ºä¾‹: $$ (\\bigcup_{m \\in (0,1)}(1-\\frac{1}{k}, 9-m]) \\land (8 \u003c 9-m \u003c 9) \\\\ \\begin{split} (1-\\frac{1}{k}, 9-m] \u0026= \\{x \\in \\mathbb{R} | 1-\\frac{1}{k} \u003c x \u003c= 9-m \u003c 9 \\} \\\\ \u0026= \\{x \\in \\mathbb{R} | 1-\\frac{1}{k} \u003c x \u003c 9 \\} \\\\ \u0026= (1-\\frac{1}{k}, 9) \\\\ \\end{split} $$ å€’æ•°ç¬¬äºŒä¸ªä¾‹å­ä¹Ÿç±»ä¼¼: $$ (\\bigcap_{j \\in \\mathbb{R},\\ j\u003e0}(-j, 9)) \\land (-j\u003c0) \\\\ \\begin{split} (-j, 9) \u0026= \\{x \\in \\mathbb{R} | -j \u003c 0 \u003c= x \u003c 9 \\} \\\\ \u0026= \\{x \\in \\mathbb{R} | 0 \u003c= x \u003c 9 \\} \\\\ \u0026= [0, 9) \\\\ \\end{split} $$ ç¬¬ 45 ~ 46 é¡µåˆ†åˆ«å±•ç¤ºäº†ä¾‹è¡Œå…¬äº‹å¼çš„è¯æ˜å’Œå—è¿‡æ•™è‚²ä¼¼çš„è¯æ˜è¿™ä¸¤ç§æ–¹æ³•ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ç¬¬ä¸€é’Ÿæ–¹æ³•ä½¿ç”¨çš„æ˜¯ é€»è¾‘ä¸Šç­‰ä»· è¿›è¡Œæ¨å¯¼ (å› ä¸ºå®ƒä¸€æ¬¡æ¨å¯¼å³å¯è¯æ˜ä¸¤ä¸ªé›†åˆç­‰ä»·)ï¼Œè€Œç¬¬äºŒç§æ–¹æ³•ä½¿ç”¨çš„æ˜¯ è•´æ¶µ è¿›è¡Œæ¨å¯¼ (å› ä¸ºå®ƒæ˜¯é€šè¿‡ä¸¤ä¸ªæ–¹å‘åˆ†åˆ«è¯æ˜åŒ…å«å…³ç³»ï¼Œä¸éœ€è¦ç­‰ä»·æ€§æ¨å¯¼)ã€‚ä¾‹è¡Œå…¬äº‹å¼çš„è¯æ˜çš„è¦ç‚¹åœ¨äºï¼Œäº‹å…ˆè¯´æ˜åç»­è¯æ˜æ¶‰åŠçš„å…ƒç´  $x$ çš„æ€§è´¨ï¼Œç„¶ååœ¨åç»­è¯æ˜è¿‡ç¨‹ä¸­æŸä¸€æ­¥å°†è¿™ä¸ªæ€§è´¨åŠ å…¥ï¼Œè¿›è€Œæ„é€ å‡ºå¦ä¸€ä¸ªé›†åˆçš„å½¢å¼ã€‚ ç»ƒä¹ ä¸€: ä¾‹è¡Œå…¬äº‹å¼çš„è¯æ˜ ç»ƒä¹ äºŒ: ä¾‹è¡Œå…¬äº‹å¼çš„è¯æ˜ ","date":"2023-12-23","objectID":"/posts/math/:2:2","tags":["Mathematics"],"title":"æ•°å­¦å¼€æ”¾å¼è¯¾ç¨‹å­¦ä¹ æŒ‡å¼•","uri":"/posts/math/"},{"categories":["Mathematics"],"content":"åˆç­‰æ•´æ•¸è«– ç¬¬ 13 é¡µ (åè½¬äº†çš„) è¾—è½¬ç›¸é™¤æ³•çš„é˜…è¯»é¡ºåºæ˜¯ï¼šå…ˆé˜…è¯»å·¦è¾¹ï¼Œåœ¨é˜…è¯»å³è¾¹ï¼Œå³è¾¹çš„æ¨å¯¼æ˜¯å°†ä¸Šé¢çš„å¼å­ä»£å…¥åˆ°ä¸‹é¢çš„å¼å­å¾—æ¥ã€‚ ","date":"2023-12-23","objectID":"/posts/math/:3:0","tags":["Mathematics"],"title":"æ•°å­¦å¼€æ”¾å¼è¯¾ç¨‹å­¦ä¹ æŒ‡å¼•","uri":"/posts/math/"},{"categories":["Mathematics"],"content":"ç¾¤ã€ç¾¤ä½œç”¨èˆ‡ Burnside å¼•ç† ç¬¬ 16 é¡µçš„ $Perm(X)$ è¡¨ç¤º $X$ çš„å…ƒç´ è¿›è¡Œç½®æ¢å¯¹åº”çš„æ‰€æœ‰æ˜ å°„æ„æˆçš„é›†åˆï¼Œè¿™ä¸ªé›†åˆçš„åŸºæ•°ä¸º $8!$ã€‚è¡¨ç¤ºè¿™ä¸ªé›†åˆçš„æŸä¸ªå…ƒç´  (ä¹Ÿå°±æ˜¯ç½®æ¢å¯¹åº”çš„æ˜ å°„)ï¼Œå¯ä»¥ç”¨æŠ•å½±ç‰‡ä¸Šçš„å½¢å¦‚ $(1\\ 4\\ 2)(3\\ 7)(5)(6)$ æ¥è¡¨ç¤ºï¼Œæ¯”è¾ƒç›´è§‚çš„ä½“ç°è¿™ä¸ªæ˜ å°„çš„æ•ˆæœã€‚ ç¬¬ 18 é¡µå­ç¾¤å®šä¹‰çš„ç»“åˆå¾‹ä¸€èˆ¬ä¸éœ€è¦ç‰¹åˆ«è€ƒè™‘ï¼Œå› ä¸ºå­ç¾¤çš„ä»»æ„å…ƒç´ å±äºç¾¤ï¼Œè€Œç¾¤çš„å…ƒç´ éƒ½æ»¡è¶³ç»“åˆå¾‹ï¼Œæ‰€ä»¥å­ç¾¤çš„ä»»æ„å…ƒç´ éƒ½æ»¡è¶³ç»“åˆå¾‹ã€‚ ç¬¬ 18 é¡µçš„è¯æ˜æç¤ºã€Œæ¶ˆå»å¾‹ã€ï¼Œæ˜¯æŒ‡åœ¨è¯æ˜å­ç¾¤æ€§è´¨æ—¶åˆ©ç”¨ç¾¤çš„ å¯é€† å’Œ å•ä½å…ƒ æ€§è´¨è¿›è¡Œè¯æ˜ã€‚å› ä¸ºä¾æ®å®šä¹‰ï¼Œç¾¤çš„å•ä½å…ƒå¯ä½œç”¨çš„èŒƒå›´æ¯”å­ç¾¤çš„å•ä½å…ƒä½œç”¨èŒƒå›´å¹¿ã€‚ ç¬¬ 22 é¡µçš„æ­£å…«è¾¹å½¢å…±æœ‰ 16 ç§ä¿æŒè½®å»“çš„å˜æ¢ (8 ç§æ—‹è½¬å’Œ 8 ç§åé¢)ï¼Œç±»ä¼¼çš„ï¼Œæ­£åå…­è¾¹å½¢åˆ™æœ‰ 32 ç§ä¿æŒè½®å»“çš„å˜æ¢ (16 ç§æ—‹è½¬å’Œ 16 ç§åé¢)ã€‚è¿™åªæ˜¯ä¸€ç§æ‰¾è§„å¾‹é—®é¢˜ï¼Œè§‚å¯Ÿç¬¬ 23 å’Œ 24 é¡µåˆ†åˆ«åˆ—ä¸¾çš„æ—‹è½¬å’Œåé¢æ˜ å°„ï¼Œå¯ä»¥è·å¾—è¿™ä¸ªè§„å¾‹çš„ç›´è§‰ã€‚æ€»ç»“ä¸€ä¸‹ï¼Œæ­£ $n$ è¾¹å½¢ä¸€å…±æœ‰ $2n$ ç§ä¿æŒè½®å»“çš„å˜æ¢æ–¹æ³• ($n$ ç§æ—‹è½¬å’Œ $n$ ç§åé¢) ","date":"2023-12-23","objectID":"/posts/math/:4:0","tags":["Mathematics"],"title":"æ•°å­¦å¼€æ”¾å¼è¯¾ç¨‹å­¦ä¹ æŒ‡å¼•","uri":"/posts/math/"},{"categories":["Mathematics"],"content":"çº¿æ€§ä»£æ•° å°†ç°å®ä¸–ç•Œç»™æˆ‘ä»¬çš„å¯å‘ï¼Œä»å®ƒä»¬å½“ä¸­æŠ½å–å‡ºè§„åˆ™ï¼Œç„¶åä½œç”¨åˆ°æ•°å­¦çš„å¯¹è±¡ä¸Šï¼Œæ¥ç€å¯èƒ½åœ¨å‘å±•äº†ä¸€äº›ä¸œè¥¿åï¼Œå¥—å›ç°å®ä¸–ç•Œä¸­å»ï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦çŸ¥é“å®ƒä»¬ (æ•°å­¦ä¸–ç•Œå’Œç°å®ä¸–ç•Œ) çš„åˆ†åˆ«åœ¨å“ªé‡Œã€‚å¤§éƒ¨åˆ†åœºæ™¯ä¸éœ€è¦è®¨è®ºè¿™ä¸ªåˆ†åˆ«ï¼Œä½†åœ¨æŸäº›ç‰¹åˆ«åœºæ™¯ä¸‹ï¼ŒçŸ¥é“è¿™ä¸ªåˆ†åˆ«å¯¹æˆ‘ä»¬ä¼šæœ‰ç‰¹åˆ«çš„å¸®åŠ©ã€‚ å‘é‡ (vector) çš„åŠ æ³•ä¸€ä¸ªäºŒå…ƒè¿ç®—ï¼Œè€Œå‘é‡é›†åˆ $V$ å’Œå‘é‡åŠ æ³•è¿ç®— $+$ æ„æˆäº†ä¸€ä¸ªäº¤æ¢ç¾¤ $(V, +)$: $(V, +)$ æ˜¯ äº¤æ¢ çš„: $\\forall a, b \\in V (a + b = b + a)$ å¯ä»¥é€šè¿‡å¹³è¡Œå››è¾¹å½¢çš„å¯¹è§’çº¿æ¥è¯æ˜ $(V, +)$ æ˜¯ ç»“åˆ çš„: $\\forall a, b, c \\in V ((a + b) + c = a + (b + c))$ å¯ä»¥é€šè¿‡å¹³è¡Œå…­é¢ä½“çš„å¯¹è§’çº¿æ¥è¯æ˜ $(V, +)$ æœ‰ å•ä½å…ƒ: $\\exist e \\in V \\forall v \\in V (v + e = v = e + v)$ é›¶å‘é‡å³æ˜¯è¿™ä¸ªå•ä½å…ƒ $V$ çš„æ¯ä¸ªå…ƒç´ éƒ½å¯¹ $+$ å¯é€†: $\\forall v \\in V \\exist \\overset{\\sim}{v} (v + \\overset{\\sim}{v} = e = \\overset{\\sim}{v} + v)$ ä»»æ„å‘é‡ $v$ çš„åå…ƒç´ æ˜¯ $-v$ ","date":"2023-12-23","objectID":"/posts/math/:5:0","tags":["Mathematics"],"title":"æ•°å­¦å¼€æ”¾å¼è¯¾ç¨‹å­¦ä¹ æŒ‡å¼•","uri":"/posts/math/"},{"categories":["draft"],"content":"å„ä½å¥½ï¼Œè¿™é‡Œæ˜¯ KZnight çš„åšå®¢ åšå®¢ï¼ˆè‹±è¯­ï¼šBlogï¼‰æ˜¯ä¸€ç§åœ¨çº¿æ—¥è®°å‹å¼çš„ä¸ªäººç½‘ç«™ï¼Œå€Ÿç”±å¼ å¸–å­ç« ã€å›¾ç‰‡æˆ–è§†é¢‘æ¥è®°å½•ç”Ÿæ´»ã€æŠ’å‘æƒ…æ„Ÿæˆ–åˆ†äº«ä¿¡æ¯ã€‚åšå®¢ä¸Šçš„æ–‡ç« é€šå¸¸æ ¹æ®å¼ è´´æ—¶é—´ï¼Œä»¥å€’åºæ–¹å¼ç”±æ–°åˆ°æ—§æ’åˆ—ã€‚ ","date":"2023-12-23","objectID":"/posts/hello_world/:0:0","tags":["draft"],"title":"Hello World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"æ•°å­¦å…¬å¼ è¡Œå†…å…¬å¼ï¼š$N(b,d)=(b-1)M$ å…¬å¼å—ï¼š $$ \\int_{a}^{b}x(t)dt = \\dfrac{b - a}{N} \\\\ =\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} $$ $$ \\begin{aligned} \\int_{a}^{b}x(t)dt \u0026= \\dfrac{b - a}{N} \\\\ \u0026=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} \\\\ \\end{aligned} $$ $$ \\mathrm{Integrals\\ are\\ numerically\\ approximated\\ as\\ finite\\ series}:\\\\ \\begin{split} \\int_{a}^{b}x(t)dt \u0026= \\dfrac{b - a}{N} \\\\ \u0026=\\sum_{k=1}^{N}x(t_k)\\cdot\\dfrac{b-a}{N} \\end{split} \\\\ where\\ t_k = a + (b-a)\\cdot k/N $$ $$ \\begin{align*} p(x) = 3x^6 + 14x^5y \u0026+ 590x^4y^2 + 19x^3y^3 \\\\ \u0026- 12x^2y^4 - 12xy^5 + 2y^6 - a^3b^3 - a^2b - ab + c^5d^3 + c^4d^3 - cd \\end{align*} $$ $$ \\begin{split} \u0026(X \\in B) = X^{-1}(B) = {s \\in S: X(s) \\in B} \\subset S \\\\ \u0026\\Rightarrow P(x \\in B) = P({s \\in S: X(s) \\in B}) \\end{split} $$ ","date":"2023-12-23","objectID":"/posts/hello_world/:1:0","tags":["draft"],"title":"Hello World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"ä»£ç å— let i: i32 = 13; let v = vec![1, 2, 3, 4, 5, 65]; for x in v.iter() { println!(\"{}\", x); } typedef struct Block_t { int head; int data; } Block_t; ","date":"2023-12-23","objectID":"/posts/hello_world/:2:0","tags":["draft"],"title":"Hello World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"Admonition æ³¨æ„ 111å¹´åº¦è³‡å·¥æ‰€å¿ƒå¾— æ‘˜è¦ Udacity (Georgia Tech): Advanced Operating Systems: Part 1 / Part 2 / Part 3 / Part 4 High Performance Computer Architecture: Part 1 / Part 2 / Part 3 / Part 4 / Part 5 / Part 6 ä¿¡æ¯ Reddit: Best book to learn in-depth knowledge about the Linux Kernel? Project: Linux From Scratch Book: Linux Kernel Development Video: Steven Rostedt - Learning the Linux Kernel with tracing æŠ€å·§ Wikipedia: Xenix / Multics / Plan9 / FreeBSD æˆåŠŸ Talks: Developing Kernel Drivers with Modern C++ - Pavel Yosifovich Containers From Scratch â€¢ Liz Rice â€¢ GOTO 2018 Rich Hickey Talks é—®é¢˜ OSDI PLDI è­¦å‘Š ä¸€ä¸ª è­¦å‘Š æ¨ªå¹… å¤±è´¥ ä¸€ä¸ª å¤±è´¥ æ¨ªå¹… å±é™© ä¸€ä¸ª å±é™© æ¨ªå¹… Bug ä¸€ä¸ª Bug æ¨ªå¹… ç¤ºä¾‹ ä¸€ä¸ª ç¤ºä¾‹ æ¨ªå¹… å¼•ç”¨ ä¸€ä¸ª å¼•ç”¨ æ¨ªå¹… ","date":"2023-12-23","objectID":"/posts/hello_world/:3:0","tags":["draft"],"title":"Hello World","uri":"/posts/hello_world/"},{"categories":["draft"],"content":"References FixIt å¿«é€Ÿä¸Šæ‰‹ ä½¿ç”¨ Hugo + Github æ­å»ºä¸ªäººåšå®¢ Markdown åŸºæœ¬è¯­æ³• Emoji æ”¯æŒ æ‰©å±• Shortcodes æ¦‚è¿° å›¾è¡¨æ”¯æŒ URL management ","date":"2023-12-23","objectID":"/posts/hello_world/:4:0","tags":["draft"],"title":"Hello World","uri":"/posts/hello_world/"}]