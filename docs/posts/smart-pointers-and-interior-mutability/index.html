<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>Crust of Rust: Smart Pointers and Interior Mutability - KZnight&#39;s Blog</title><meta name="author" content="ccrysisa">
<meta name="author-link" content="https://github.com/ccrysisa">
<meta name="description" content="
In this fourth Crust of Rust video, we cover smart pointers and interior mutability, by re-implementing the Cell, RefCell, and Rc types from the standard library. As part of that, we cover when those types are useful, how they work, and what the equivalent thread-safe versions of these types are. In the process, we go over some of the finer details of Rust&#39;s ownership model, and the UnsafeCell type. We also dive briefly into the Drop Check rabbit hole (https://doc.rust-lang.org/nightly/nomicon/dropck.html) before coming back up for air.
" /><meta name="keywords" content='Rust, Smart pointer, Interior Mutability' /><meta itemprop="name" content="Crust of Rust: Smart Pointers and Interior Mutability">
<meta itemprop="description" content="
In this fourth Crust of Rust video, we cover smart pointers and interior mutability, by re-implementing the Cell, RefCell, and Rc types from the standard library. As part of that, we cover when those types are useful, how they work, and what the equivalent thread-safe versions of these types are. In the process, we go over some of the finer details of Rust&#39;s ownership model, and the UnsafeCell type. We also dive briefly into the Drop Check rabbit hole (https://doc.rust-lang.org/nightly/nomicon/dropck.html) before coming back up for air.
"><meta itemprop="datePublished" content="2024-02-20T17:33:06+08:00" />
<meta itemprop="dateModified" content="2024-03-04T23:05:35+08:00" />
<meta itemprop="wordCount" content="2332"><meta itemprop="image" content="https://ccrysisa.github.io/logo.png" />
<meta itemprop="keywords" content="Rust,Smart pointer,Interior Mutability," /><meta property="og:title" content="Crust of Rust: Smart Pointers and Interior Mutability" />
<meta property="og:description" content="
In this fourth Crust of Rust video, we cover smart pointers and interior mutability, by re-implementing the Cell, RefCell, and Rc types from the standard library. As part of that, we cover when those types are useful, how they work, and what the equivalent thread-safe versions of these types are. In the process, we go over some of the finer details of Rust&#39;s ownership model, and the UnsafeCell type. We also dive briefly into the Drop Check rabbit hole (https://doc.rust-lang.org/nightly/nomicon/dropck.html) before coming back up for air.
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/" /><meta property="og:image" content="https://ccrysisa.github.io/logo.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-20T17:33:06+08:00" />
<meta property="article:modified_time" content="2024-03-04T23:05:35+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://ccrysisa.github.io/logo.png" /><meta name="twitter:title" content="Crust of Rust: Smart Pointers and Interior Mutability"/>
<meta name="twitter:description" content="
In this fourth Crust of Rust video, we cover smart pointers and interior mutability, by re-implementing the Cell, RefCell, and Rc types from the standard library. As part of that, we cover when those types are useful, how they work, and what the equivalent thread-safe versions of these types are. In the process, we go over some of the finer details of Rust&#39;s ownership model, and the UnsafeCell type. We also dive briefly into the Drop Check rabbit hole (https://doc.rust-lang.org/nightly/nomicon/dropck.html) before coming back up for air.
"/>
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/" /><link rel="prev" href="https://ccrysisa.github.io/posts/c-numerics/" /><link rel="next" href="https://ccrysisa.github.io/posts/c-bitwise/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Crust of Rust: Smart Pointers and Interior Mutability",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/ccrysisa.github.io\/posts\/smart-pointers-and-interior-mutability\/"
    },"genre": "posts","keywords": "Rust, Smart pointer, Interior Mutability","wordcount":  2332 ,
    "url": "https:\/\/ccrysisa.github.io\/posts\/smart-pointers-and-interior-mutability\/","datePublished": "2024-02-20T17:33:06+08:00","dateModified": "2024-03-04T23:05:35+08:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "ccrysisa"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="KZnight&#39;s Blog"><img loading="lazy" src="/fixit.min.svg" data-title="KZnight&#39;s Blog" data-alt="KZnight&#39;s Blog" class="logo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const i of ['style', 'data-title','data-alt','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const i of ['style', 'data-title','data-alt','onerror','onload']){this.removeAttribute(i);}"/><span class="header-title-text">KZnight&#39;s Blog</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> Posts</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> Categories</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="搜索文章标题或内容……" id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
              <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
              <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
            </span>
          </li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="KZnight&#39;s Blog"><img loading="lazy" src="/fixit.min.svg" data-title="/fixit.min.svg" data-alt="/fixit.min.svg" class="logo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const i of ['style', 'data-title','data-alt','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const i of ['style', 'data-title','data-alt','onerror','onload']){this.removeAttribute(i);}"/><span class="header-title-text">KZnight&#39;s Blog</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="搜索文章标题或内容……" id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              取消
            </a>
          </li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> Posts</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> Categories</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="切换主题"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
  </div>
  <div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
  </div><main class="container"><aside class="toc" id="toc-auto"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside>

  <aside class="aside-custom">
    </aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span title="转载" class="icon-repost"><i class="fa-solid fa-share fa-fw" aria-hidden="true"></i></span><span>Crust of Rust: Smart Pointers and Interior Mutability</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><a href="https://github.com/ccrysisa" title="作者"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="https://avatars.githubusercontent.com/u/133117003?s=400&amp;v=4" data-title="ccrysisa" data-alt="ccrysisa" class="avatar" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const i of ['style', 'data-title','data-alt','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const i of ['style', 'data-title','data-alt','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;ccrysisa</a></span>
          <span class="post-category">收录于 <a href="/categories/rust/"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Rust</a></span></div>
      <div class="post-meta-line"><span title="发布于 2024-02-20 17:33:06"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden="true"></i><time datetime="2024-02-20">2024-02-20</time></span>&nbsp;<span title="更新于 2024-03-04 23:05:35"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden="true"></i><time datetime="2024-03-04">2024-03-04</time></span>&nbsp;<span title="2332 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>约 2400 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>预计阅读 5 分钟</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#影片注解">影片注解</a>
      <ul>
        <li><a href="#interior-mutability">Interior Mutability</a></li>
        <li><a href="#cell">Cell</a></li>
        <li><a href="#refcell">RefCell</a></li>
        <li><a href="#rc">Rc</a></li>
        <li><a href="#raw-pointers-vs-references">Raw pointers vs references</a></li>
        <li><a href="#phantomdata--drop-check">PhantomData &amp; Drop check</a></li>
        <li><a href="#thread-safety">Thread Safety</a></li>
        <li><a href="#copy-on-write-cow">Copy-on-Write (COW)</a></li>
      </ul>
    </li>
    <li><a href="#homework">Homework</a></li>
    <li><a href="#documentations">Documentations</a>
      <ul>
        <li><a href="#crate-stdhttpsdocrust-langorgstdindexhtml">Crate <a href="https://doc.rust-lang.org/std/index.html">std</a></a></li>
      </ul>
    </li>
    <li><a href="#references">References</a></li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><blockquote>
<p>In this fourth Crust of Rust video, we cover smart pointers and interior mutability, by re-implementing the Cell, RefCell, and Rc types from the standard library. As part of that, we cover when those types are useful, how they work, and what the equivalent thread-safe versions of these types are. In the process, we go over some of the finer details of Rust's ownership model, and the UnsafeCell type. We also dive briefly into the Drop Check rabbit hole (<a href="https://doc.rust-lang.org/nightly/nomicon/dropck.html"target="_blank" rel="external nofollow noopener noreferrer">https://doc.rust-lang.org/nightly/nomicon/dropck.html</a>) before coming back up for air.</p>
</blockquote>
<ul>
<li>整理自 <a href="https://www.youtube.com/watch?v=8O0Nt9qY_vo"target="_blank" rel="external nofollow noopener noreferrer">John Gjengset 的影片</a></li>
</ul>
<h2 id="影片注解">影片注解</h2>
<h3 id="interior-mutability">Interior Mutability</h3>
<p>Module <a href="https://doc.rust-lang.org/std/cell/index.html"target="_blank" rel="external nofollow noopener noreferrer">std::cell</a></p>
<blockquote>
<p>Rust memory safety is based on this rule: Given an object T, it is only possible to have one of the following:</p>
<ul>
<li>Having several immutable references (&amp;T) to the object (also known as aliasing).</li>
<li>Having one mutable reference (&amp;mut T) to the object (also known as mutability).</li>
</ul>
</blockquote>
<blockquote>
<p>Values of the <code>Cell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>, and <code>OnceCell&lt;T&gt;</code> types may be mutated through shared references (i.e. the common &amp;T type), whereas most Rust types can only be mutated through unique (&amp;mut T) references. We say these cell types provide ‘interior mutability’ (mutable via &amp;T), in contrast with typical Rust types that exhibit ‘inherited mutability’ (mutable only via &amp;mut T).</p>
</blockquote>
<ul>
<li>We can use (several) immutable references of a cell to mutate the thing inside of the cell.</li>
<li>There is (virtually) no way for you to get a reference to the thing inside of a cell.</li>
<li><strong>Because if no one else has a pointer to it (the thing inside of a cell), the changing it is fine.</strong></li>
</ul>
<p>Struct <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"target="_blank" rel="external nofollow noopener noreferrer">std::cell::UnsafeCell</a></p>
<blockquote>
<p>If you have a reference &amp;T, then normally in Rust the compiler performs optimizations based on the knowledge that &amp;T points to immutable data. Mutating that data, for example through an alias or by transmuting an &amp;T into an &amp;mut T, is considered undefined behavior. <code>UnsafeCell&lt;T&gt;</code> opts-out of the immutability guarantee for &amp;T: a shared reference &amp;<code>UnsafeCell&lt;T&gt;</code> may point to data that is being mutated. This is called “interior mutability”.</p>
</blockquote>
<blockquote>
<p>The UnsafeCell API itself is technically very simple: .get() gives you a raw pointer *mut T to its contents. It is up to you as the abstraction designer to use that raw pointer correctly.</p>
</blockquote>
<h3 id="cell">Cell</h3>
<p>Module <a href="https://doc.rust-lang.org/std/cell/index.html#cellt"target="_blank" rel="external nofollow noopener noreferrer">std::cell Cell&lt;T&gt;</a></p>
<blockquote>
<p><code>Cell&lt;T&gt;</code> implements interior mutability by moving values in and out of the cell. That is, an &amp;mut T to the inner value can never be obtained, and the value itself cannot be directly obtained without replacing it with something else. Both of these rules ensure that there is never more than one reference pointing to the inner value. This type provides the following methods:</p>
</blockquote>
<figure><a class="lightgallery" href="/images/rust/cell.drawio.svg?size=large" data-thumbnail="/images/rust/cell.drawio.svg?size=small" data-sub-html="<h2>Cell</h2>"><img loading="lazy" src="/images/rust/cell.drawio.svg" srcset="/images/rust/cell.drawio.svg?size=small, /images/rust/cell.drawio.svg?size=medium 1.5x, /images/rust/cell.drawio.svg?size=large 2x" sizes="auto" data-title="/images/rust/cell.drawio.svg" data-alt="/images/rust/cell.drawio.svg" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const i of ['style', 'data-title','data-alt','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const i of ['style', 'data-title','data-alt','onerror','onload']){this.removeAttribute(i);}"/></a><figcaption class="image-caption">Cell</figcaption>
  </figure>
<p>在 Rust 中对一个变量 (T)，在已存在其 immutable references (&amp;T) 时使用 mutable reference (&amp;mut T) 是禁止的，因为这样会因为编译器优化而导致程序的行为不一定符合我们的预期。考虑以下的代码:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rs" data-lang="rs"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">r3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设以上的代码可以通过编译，那么程序执行到第 6 行打印出来的可能是 3 而不是我们预期的 5，这是因为编译器会对 immtuable references 进行激进的优化，例如进行预取，所以在第 6 行时对于 r2 使用的还是先前预取的值 3 而不是内存中最新的值 5。这也是 Rust 制定对 immutable reference 和 mutable reference 的规则的原因之一。</p>
<p>为了达到我们的预期行为，可以使用 UnsafeCell 来实现:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rs" data-lang="rs"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">uc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnsafeCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">uc</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">uc</span><span class="err">，</span><span class="w"> </span><span class="n">r3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">uc</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">uc</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">uc</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">uc</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"> </span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码可以通过编译，并且在第 6 行时打印出来的是预期的 5。这是因为编译器会对 UnsafeCell 进行特判，而避免进行一些激进的优化 (例如预取)，从而使程序行为符合我们的预期。并且 UnsafeCell 的 get() 方法只需要接受 &amp;self 参数，所以可以对 UnsafeCell 进行多个 immutable references，这并不违反 Rust 的内存安全准则。同时每个对于 UnsafeCel 的 immutable references 都可以通过所引用的 UnsafeCell 来实现内部可变性 (interior mutability)。</p>
<p>上述代码片段存在大量的 unsafe 片段 (因为 UnsafeCell)，将这些 unsafe 操作封装一下就实现了 Cell。但是因为 Cell 的方法 get() 和 set() 都需要转移所有权，所以 Cell 只能用于实现了 Copy trait 的类型的内部可变性。但是对于 concurrent 情形，UnsafeCell 就是一个临界区，无法保证内部修改是同步的，所以 Cell 不是 thread safe 的。</p>
<blockquote>
<p>Cell<T> is typically used for more simple types where copying or moving values isn’t too resource intensive (e.g. numbers)</p>
</blockquote>
<div class="details admonition note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><code>Cell</code> 提供了这样一个“内部可变性”机制: <strong>在拥有对一个 object 多个引用时，可以通过任意一个引用对 object 进行内部可变，并保证在此之后其他引用对于该 object 的信息是最新的。</strong></div>
    </div>
  </div>
<h3 id="refcell">RefCell</h3>
<p>Module <a href="https://doc.rust-lang.org/std/cell/index.html#refcellt"target="_blank" rel="external nofollow noopener noreferrer">std::cell RefCell&lt;T&gt;</a></p>
<blockquote>
<p><code>RefCell&lt;T&gt;</code> uses Rust\’s lifetimes to implement &ldquo;dynamic borrowing&rdquo;, a process whereby one can claim temporary, exclusive, mutable access to the inner value. Borrows for <code>RefCell&lt;T&gt;\</code>s are tracked at runtime, unlike Rust’s native reference types which are entirely tracked statically, at compile time.</p>
</blockquote>
<ul>
<li><strong>Runtime Borrow Check</strong></li>
</ul>
<figure><a class="lightgallery" href="/images/rust/refcell.drawio.svg?size=large" data-thumbnail="/images/rust/refcell.drawio.svg?size=small" data-sub-html="<h2>RefCell</h2>"><img loading="lazy" src="/images/rust/refcell.drawio.svg" srcset="/images/rust/refcell.drawio.svg?size=small, /images/rust/refcell.drawio.svg?size=medium 1.5x, /images/rust/refcell.drawio.svg?size=large 2x" sizes="auto" data-title="/images/rust/refcell.drawio.svg" data-alt="/images/rust/refcell.drawio.svg" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const i of ['style', 'data-title','data-alt','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const i of ['style', 'data-title','data-alt','onerror','onload']){this.removeAttribute(i);}"/></a><figcaption class="image-caption">RefCell</figcaption>
  </figure>
<p><code>RefCell</code> 也提供了之前所提的“内部可变性”机制，但是是通过提供 <em><strong>引用</strong></em> 而不是转移所有权来实现。所以它常用于 Tree, Graph 这类数据结构，因为这些数据结构的节点 &ldquo;很大&rdquo;，不大可能实现 Copy 的 Trait (因为开销太大了)，所以一般使用 <code>RefCell</code> 来实现节点的相互引用关系。</p>
<h3 id="rc">Rc</h3>
<p>method <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw"target="_blank" rel="external nofollow noopener noreferrer">std::boxed::Box::into_raw</a></p>
<blockquote>
<p>After calling this function, the caller is responsible for the memory previously managed by the Box. In particular, the caller should properly destroy T and release the memory, taking into account the memory layout used by Box. The easiest way to do this is to convert the raw pointer back into a Box with the Box::from_raw function, allowing the Box destructor to perform the cleanup.</p>
</blockquote>
<figure><a class="lightgallery" href="/images/rust/rc.drawio.svg?size=large" data-thumbnail="/images/rust/rc.drawio.svg?size=small" data-sub-html="<h2>Rc</h2>"><img loading="lazy" src="/images/rust/rc.drawio.svg" srcset="/images/rust/rc.drawio.svg?size=small, /images/rust/rc.drawio.svg?size=medium 1.5x, /images/rust/rc.drawio.svg?size=large 2x" sizes="auto" data-title="/images/rust/rc.drawio.svg" data-alt="/images/rust/rc.drawio.svg" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const i of ['style', 'data-title','data-alt','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const i of ['style', 'data-title','data-alt','onerror','onload']){this.removeAttribute(i);}"/></a><figcaption class="image-caption">Rc</figcaption>
  </figure>
<h3 id="raw-pointers-vs-references">Raw pointers vs references</h3>
<p><code>* mut</code> and <code>* const</code> are not references, they are raw pointers. In Rust, there are a bunch of semantics you have to follow when you using references.</p>
<p>Like if you use <code>&amp;</code> symbol, an <code>&amp;</code> alone means a shared reference, and you have to guarantee that there are no exclusive references to that thing. And similarly, if you have a <code>&amp;mut</code>, a exclusive reference, you know that there are not shared references.</p>
<p>The <code>*</code> version of these, like <code>* mut</code> and <code>* const</code>, do not have these guarantees. If you have a <code>* mut</code>, there may be other <code>* mut</code>s to the same thing. There might be <code>* const</code> to the same thing.</p>
<p>You have no guarantee, but you also cann't do much with a <code>*</code>. If you have a raw pointer, the only thing you can really do to it is use an <strong>unsafe</strong> block to dereference it and turn it into reference. But that is unsafe, <em>you need to document wht it is safe.</em></p>
<p>You're not able to go from a const pointer to an exclusive reference. But you can go from a mutable pointer to an exclusive reference.</p>
<blockquote>
<p>To guarantee that you have to follow <strong>onwership</strong> semantics in Rust.</p>
</blockquote>
<h3 id="phantomdata--drop-check">PhantomData &amp; Drop check</h3>
<ul>
<li>The Rustonomicon: <a href="https://doc.rust-lang.org/nomicon/dropck.html"target="_blank" rel="external nofollow noopener noreferrer">Drop Check</a></li>
<li>Medium: <a href="https://medium.com/@0xor0ne/rust-notes-phantomdata-505757bf56a7"target="_blank" rel="external nofollow noopener noreferrer">Rust Notes: PhantomData</a></li>
</ul>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rs" data-lang="rs"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Default</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">v</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="nb">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Default</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>::<span class="n">default</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">v</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">drop</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">drop</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>最后的 2 行 drop 语句会导致编译失败，因为编译器知道 foo 引用了 t，所以会进行 drop check，保证 t 的 lifetime 至少和 foo 一样长，因为 drop 时会按照从内到外的顺序对结构体的成员及其本身进行 drop。但是对于我们实现的 Rc 使用的是 raw pointer，如果不加 PhantomData，那么在对 Rc 进行 drop 时并不会检查 raw pointer 所指向的 RcInner 的 lifetime 是否满足要求，即在 drop Rc 之前 drop RcInner 并不会导致编译失败。简单来说，PhantomData 就是让编译器以为 Rc 拥有 RcInner 的所有权或引用，由此进行期望的 drop check 行为。</p>
<h3 id="thread-safety">Thread Safety</h3>
<ul>
<li>Cell</li>
</ul>
<blockquote>
<p>Because even though you're not giving out references to things, having two threads modify the same value at the same time is just not okay. There actually is o thread-safe version of <code>Cell</code>. (<em>Think it as pointer in C</em> &#x1f923;)</p>
</blockquote>
<ul>
<li>RefCell</li>
</ul>
<blockquote>
<p>You could totally implement a thread-safe version of RefCell, one that uses an atomic counter instead of <code>Cell</code> for these numbers. So it turns out that the CPU has built-in instructions that can, in a thread-safe way, increment and decrement counters.</p>
</blockquote>
<ul>
<li>Rc</li>
</ul>
<blockquote>
<p>The thread-safe version of <code>Rc</code> is <code>Arc</code>, or Atomic Reference Count.</p>
</blockquote>
<h3 id="copy-on-write-cow">Copy-on-Write (COW)</h3>
<p>Struct <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html#"target="_blank" rel="external nofollow noopener noreferrer">std::borrow::Cow</a></p>
<blockquote>
<p>The type <code>Cow</code> is a smart pointer providing clone-on-write functionality: it can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required. The type is designed to work with general borrowed data via the <code>Borrow</code> trait.</p>
</blockquote>
<h2 id="homework">Homework</h2>
<div class="details admonition info open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-info-circle fa-fw" aria-hidden="true"></i>信息<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>实作说明:</p>
<ul>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> 尝试使用 RefCell 来实现 Linux kernel 风格的 linked list
<ul>
<li>数据结构为 circular doubly linked list</li>
<li>实现 insert_head, remove_head 方法</li>
<li>实现 insert_tail, remove_tail 方法</li>
<li>实现 list_size, list_empty, list_is_singular 方法</li>
<li>实现迭代器 (Iterator)，支持双向迭代 (DoubleEndedIterator)</li>
</ul>
</li>
</ul>
<p>参考资料:</p>
<ul>
<li><a href="https://github.com/sysprog21/linux-list/blob/master/include/list.h#L94"target="_blank" rel="external nofollow noopener noreferrer">sysprog21/linux-list</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/include/linux/list.h#L84"target="_blank" rel="external nofollow noopener noreferrer">linux/list.h</a></li>
</ul>
</div>
    </div>
  </div>
<h2 id="documentations">Documentations</h2>
<p>这里列举视频中一些概念相关的 documentation</p>
<blockquote>
<p>学习的一手资料是官方文档，请务必自主学会阅读规格书之类的资料</p>
</blockquote>
<h3 id="crate-stdhttpsdocrust-langorgstdindexhtml">Crate <a href="https://doc.rust-lang.org/std/index.html"target="_blank" rel="external nofollow noopener noreferrer">std</a></h3>
<blockquote>
<p>可以使用这里提供的搜素栏进行搜索 (BTW 不要浪费时间在 Google 搜寻上！)</p>
</blockquote>
<ul>
<li>
<p>Module <a href="https://doc.rust-lang.org/std/cell/index.html"target="_blank" rel="external nofollow noopener noreferrer">std::cell</a></p>
<ul>
<li>Struct <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"target="_blank" rel="external nofollow noopener noreferrer">std::cell::UnsafeCell</a></li>
<li>Struct <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"target="_blank" rel="external nofollow noopener noreferrer">std::cell::Cell</a></li>
<li>Struct <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"target="_blank" rel="external nofollow noopener noreferrer">std::cell::RefCell</a></li>
</ul>
</li>
<li>
<p>Module <a href="https://doc.rust-lang.org/std/rc/index.html"target="_blank" rel="external nofollow noopener noreferrer">std::rc</a></p>
</li>
<li>
<p>Module <a href="https://doc.rust-lang.org/std/sync/index.html"target="_blank" rel="external nofollow noopener noreferrer">std::sync</a></p>
<ul>
<li>Struct <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"target="_blank" rel="external nofollow noopener noreferrer">std::sync::Mutex</a></li>
<li>Struct <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"target="_blank" rel="external nofollow noopener noreferrer">std::sync::RwLock</a></li>
<li>Struct <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"target="_blank" rel="external nofollow noopener noreferrer">std::sync::Arc</a></li>
</ul>
</li>
<li>
<p>Struct <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"target="_blank" rel="external nofollow noopener noreferrer">std::boxed::Box</a></p>
<ul>
<li>method <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw"target="_blank" rel="external nofollow noopener noreferrer">std::boxed::Box::into_raw</a></li>
<li>method <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw"target="_blank" rel="external nofollow noopener noreferrer">std::boxed::Box::from_raw</a></li>
</ul>
</li>
<li>
<p>Struct <a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html"target="_blank" rel="external nofollow noopener noreferrer">std::ptr::NonNull</a></p>
<ul>
<li>method <a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.new_unchecked"target="_blank" rel="external nofollow noopener noreferrer">std::ptr::NonNull::new_unchecked</a></li>
<li>method <a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.as_ref"target="_blank" rel="external nofollow noopener noreferrer">std::ptr::NonNull::as_ref</a></li>
<li>method <a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.as_ptr"target="_blank" rel="external nofollow noopener noreferrer">std::ptr::NonNull::as_ptr</a></li>
</ul>
</li>
<li>
<p>Struct <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html"target="_blank" rel="external nofollow noopener noreferrer">std::marker::PhantomData</a></p>
</li>
<li>
<p>Struct <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html#"target="_blank" rel="external nofollow noopener noreferrer">std::borrow::Cow</a></p>
</li>
<li>
<p>Trait <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"target="_blank" rel="external nofollow noopener noreferrer">std::ops::Drop</a></p>
</li>
<li>
<p>Trait <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"target="_blank" rel="external nofollow noopener noreferrer">std::ops::Deref</a></p>
</li>
<li>
<p>Trait <a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"target="_blank" rel="external nofollow noopener noreferrer">std::ops::DerefMut</a></p>
</li>
<li>
<p>Trait <a href="https://doc.rust-lang.org/std/marker/trait.Sized.html"target="_blank" rel="external nofollow noopener noreferrer">std::marker::Sized</a></p>
</li>
<li>
<p>Function <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"target="_blank" rel="external nofollow noopener noreferrer">std::thread::spawn</a></p>
</li>
<li>
<p>Function <a href="https://doc.rust-lang.org/std/mem/fn.replace.html"target="_blank" rel="external nofollow noopener noreferrer">std::mem::replace</a></p>
</li>
<li>
<p>Function <a href="https://doc.rust-lang.org/std/mem/fn.drop.html"target="_blank" rel="external nofollow noopener noreferrer">std::mem::drop</a></p>
</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.bilibili.com/video/BV16e411n7h4"target="_blank" rel="external nofollow noopener noreferrer">可能不是你看过最无聊的 Rust 入门喜剧102 (2) 智能指针</a> [bilibili]</li>
</ul></div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="更新于 2024-03-04 23:05:35">更新于 2024-03-04&nbsp;</span>
      </div></div>
    <div class="post-info-line">
      <div class="post-info-md"><span><a href="/posts/smart-pointers-and-interior-mutability/index.md" title="阅读原始文档" class="link-to-markdown">阅读原始文档</a></span></div>
      <div class="post-info-share">
        <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/" data-title="Crust of Rust: Smart Pointers and Interior Mutability" data-hashtags="Rust,Smart pointer,Interior Mutability"><i class="fa-brands fa-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/" data-hashtag="Rust"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/" data-title="Crust of Rust: Smart Pointers and Interior Mutability" data-web><i class="fa-brands fa-whatsapp fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/" data-title="Crust of Rust: Smart Pointers and Interior Mutability"><i data-svg-src="/lib/simple-icons/icons/line.min.svg" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/" data-title="Crust of Rust: Smart Pointers and Interior Mutability"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Myspace" data-sharer="myspace" data-url="https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/" data-title="Crust of Rust: Smart Pointers and Interior Mutability" data-description=""><i data-svg-src="/lib/simple-icons/icons/myspace.min.svg" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Blogger" data-sharer="blogger" data-url="https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/" data-title="Crust of Rust: Smart Pointers and Interior Mutability" data-description=""><i class="fa-brands fa-blogger fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/" data-title="Crust of Rust: Smart Pointers and Interior Mutability"><i class="fa-brands fa-evernote fa-fw" aria-hidden="true"></i></a>
  </span>
      </div>
    </div>
  </div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/tags/rust/' class="post-tag">Rust</a><a href='/tags/smart-pointer/' class="post-tag">Smart pointer</a><a href='/tags/interior-mutability/' class="post-tag">Interior Mutability</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/c-numerics/" class="post-nav-item" rel="prev" title="你所不知道的 C 语言: 数值系统篇"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>你所不知道的 C 语言: 数值系统篇</a>
      <a href="/posts/c-bitwise/" class="post-nav-item" rel="next" title="你所不知道的 C 语言: bitwise 操作">你所不知道的 C 语言: bitwise 操作<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.121.2">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.2.18-lts.5"><img class="fixit-icon" src="/fixit.min.svg" alt="FixIt logo" />&nbsp;FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2021 - 2024</span><span class="author" itemprop="copyrightHolder">
              <a href="https://github.com/ccrysisa"target="_blank" rel="external nofollow noopener noreferrer">ccrysisa</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span></div><div class="footer-line statistics"></div><div class="footer-line visitor">
          <span id="busuanzi_container_site_uv" title='总访客数'><i class="fa-regular fa-user fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span><span id="busuanzi_container_site_pv" class="footer-divider" title='总访问量'><i class="fa-regular fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span>
        </div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><noscript>
    <div class="noscript-warning">FixIt 主题在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/lightgallery/css/lightgallery-bundle.min.css"><link rel="preload" href="/lib/katex/katex.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/katex/katex.min.css"></noscript><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/autocomplete/autocomplete.min.js" defer></script><script src="/lib/lunr/lunr.min.js" defer></script><script src="/lib/lunr/lunr.stemmer.support.min.js" defer></script><script src="/lib/lunr/lunr.zh.min.js" defer></script><script src="/lib/lightgallery/lightgallery.min.js" defer></script><script src="/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js" defer></script><script src="/lib/lightgallery/plugins/zoom/lg-zoom.min.js" defer></script><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":20},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"enablePWA":true,"lightgallery":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script src="/js/theme.min.js" defer></script></body>
</html>
