<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>Rust - 分类 - KZn&#39;s Blog</title>
    <link>https://ccrysisa.github.io/categories/rust/</link>
    <description>Rust - 分类 - KZn&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>caijiaxin@dragonos.org (ccrysisa)</managingEditor>
      <webMaster>caijiaxin@dragonos.org (ccrysisa)</webMaster><lastBuildDate>Tue, 20 Feb 2024 17:33:06 &#43;0800</lastBuildDate><atom:link href="https://ccrysisa.github.io/categories/rust/" rel="self" type="application/rss+xml" /><item>
  <title>Crust of Rust: Smart Pointers and Interior Mutability</title>
  <link>https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/</link>
  <pubDate>Tue, 20 Feb 2024 17:33:06 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/</guid>
  <description><![CDATA[<blockquote>
<p>In this fourth Crust of Rust video, we cover smart pointers and interior mutability, by re-implementing the Cell, RefCell, and Rc types from the standard library. As part of that, we cover when those types are useful, how they work, and what the equivalent thread-safe versions of these types are. In the process, we go over some of the finer details of Rust's ownership model, and the UnsafeCell type. We also dive briefly into the Drop Check rabbit hole (<a href="https://doc.rust-lang.org/nightly/nomicon/dropck.html"target="_blank" rel="external nofollow noopener noreferrer">https://doc.rust-lang.org/nightly/nomicon/dropck.html</a>) before coming back up for air.</p>
</blockquote>]]></description>
</item>
<item>
  <title>Implementing TCP/IP in Rust</title>
  <link>https://ccrysisa.github.io/posts/rust-tcp/</link>
  <pubDate>Sat, 17 Feb 2024 19:01:53 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/rust-tcp/</guid>
  <description><![CDATA[<blockquote>
<p>In this stream, we started implementing the ubiquitous TCP protocol that underlies much of the traffic on the internet! In particular, we followed RFC 793 — <a href="https://tools.ietf.org/html/rfc793"target="_blank" rel="external nofollow noopener noreferrer">https://tools.ietf.org/html/rfc793</a> — which describes the original protocol, with the goal of being able to set up and tear down a connection with a &ldquo;real&rdquo; TCP stack at the other end (netcat in particular). We&rsquo;re writing it using a user-space networking interface (see <a href="https://www.kernel.org/doc/Documentation/networking/tuntap.txt"target="_blank" rel="external nofollow noopener noreferrer">https://www.kernel.org/doc/Documentation/networking/tuntap.txt</a> and the Rust bindings at <a href="https://docs.rs/tun-tap/%29"target="_blank" rel="external nofollow noopener noreferrer">https://docs.rs/tun-tap/)</a>.</p>
</blockquote>]]></description>
</item>
<item>
  <title>Crust of Rust: Iterators</title>
  <link>https://ccrysisa.github.io/posts/iterators/</link>
  <pubDate>Mon, 05 Feb 2024 17:18:34 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/iterators/</guid>
  <description><![CDATA[<blockquote>
<p>In this third Crust of Rust video, we cover iterators and trait bounds, by re-implementing the &ldquo;flatten&rdquo; Iterator method from the standard library. As part of that, we cover some of the weirder trait bounds that are required, including what&rsquo;s needed to extend the implementation to support backwards iteration.</p>
</blockquote>]]></description>
</item>
<item>
  <title>Crust of Rust: Declarative Macros</title>
  <link>https://ccrysisa.github.io/posts/declarative-macros/</link>
  <pubDate>Wed, 31 Jan 2024 22:32:27 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/declarative-macros/</guid>
  <description><![CDATA[<blockquote>
<p>In this second Crust of Rust video, we cover declarative macros, macro_rules!, by re-implementing the vec! macro from the standard library. As part of that, we cover not only how to write these, but some of the gotchas and tricks you&rsquo;ll run into, and some common use-cases.</p>
</blockquote>]]></description>
</item>
<item>
  <title>Crust of Rust: Lifetime Annotations</title>
  <link>https://ccrysisa.github.io/posts/lifetime-annotations/</link>
  <pubDate>Thu, 25 Jan 2024 18:40:45 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/lifetime-annotations/</guid>
  <description><![CDATA[<blockquote>
<p>We&rsquo;re going to investigate a case where you need multiple explicit lifetime annotations. We explore why they are needed, and why we need more than one in this particular case. We also talk about some of the differences between the string types and introduce generics over a self-defined trait in the process.</p>
</blockquote>]]></description>
</item>
<item>
  <title>Rust: 进行中的未来</title>
  <link>https://ccrysisa.github.io/posts/rust-introduction/</link>
  <pubDate>Thu, 28 Dec 2023 20:18:03 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/rust-introduction/</guid>
  <description><![CDATA[Rust in 100 Seconds 观看短片: Rust in 100 Seconds &#x2705; 了解 Rust，初步了解其安全性原理 所有权 (ownership) 借用 (borrow) 警告 0:55 This is wrong, value mutability doesn&rsquo;t have anything to do with the value being stored on the stack or the heap (and the example let mut hello = &quot;hi]]></description>
</item>
</channel>
</rss>
