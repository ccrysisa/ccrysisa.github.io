<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>Rust - 标签 - KZnight&#39;s Blog</title>
    <link>https://ccrysisa.github.io/tags/rust/</link>
    <description>Rust - 标签 - KZnight&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>caijiaxin@dragonos.org (ccrysisa)</managingEditor>
      <webMaster>caijiaxin@dragonos.org (ccrysisa)</webMaster><lastBuildDate>Mon, 04 Mar 2024 15:02:28 &#43;0800</lastBuildDate><atom:link href="https://ccrysisa.github.io/tags/rust/" rel="self" type="application/rss+xml" /><item>
  <title>Crust of Rust: Sorting Algorithms</title>
  <link>https://ccrysisa.github.io/posts/orst/</link>
  <pubDate>Mon, 04 Mar 2024 15:02:28 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/orst/</guid>
  <description><![CDATA[<blockquote>
<p>In this Crust of Rust episode, we implement some common sorting algorithms in Rust. This episode doesn't aim to explain any single concept, but rather showcase what writing &ldquo;normal&rdquo; Rust code is like, and explaining various &ldquo;odd bits&rdquo; we come across along the way. The thinking here is that sorting algorithms are both familiar and easy to compare across languages, so this might serve as a good bridge into Rust if you are familiar with other languages.</p>
</blockquote>]]></description>
</item>
<item>
  <title>Crust of Rust: Channels</title>
  <link>https://ccrysisa.github.io/posts/channels/</link>
  <pubDate>Thu, 29 Feb 2024 20:30:30 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/channels/</guid>
  <description><![CDATA[<blockquote>
<p>In this (fifth) Crust of Rust video, we cover multi-produce/single-consumer (mpsc) channels, by re-implementing some of the std::sync::mpsc types from the standard library. As part of that, we cover what channels are used for, how they work at a high level, different common channel variants, and common channel implementations. In the process, we go over some common Rust concurrency primitives like Mutex and Condvar.</p>
</blockquote>]]></description>
</item>
<item>
  <title>Crust of Rust: Smart Pointers and Interior Mutability</title>
  <link>https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/</link>
  <pubDate>Tue, 20 Feb 2024 17:33:06 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/smart-pointers-and-interior-mutability/</guid>
  <description><![CDATA[<blockquote>
<p>In this fourth Crust of Rust video, we cover smart pointers and interior mutability, by re-implementing the Cell, RefCell, and Rc types from the standard library. As part of that, we cover when those types are useful, how they work, and what the equivalent thread-safe versions of these types are. In the process, we go over some of the finer details of Rust's ownership model, and the UnsafeCell type. We also dive briefly into the Drop Check rabbit hole (<a href="https://doc.rust-lang.org/nightly/nomicon/dropck.html"target="_blank" rel="external nofollow noopener noreferrer">https://doc.rust-lang.org/nightly/nomicon/dropck.html</a>) before coming back up for air.</p>
</blockquote>]]></description>
</item>
<item>
  <title>Implementing TCP/IP in Rust</title>
  <link>https://ccrysisa.github.io/posts/rust-tcp/</link>
  <pubDate>Sat, 17 Feb 2024 19:01:53 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/rust-tcp/</guid>
  <description><![CDATA[<blockquote>
<p>In this stream, we started implementing the ubiquitous TCP protocol that underlies much of the traffic on the internet! In particular, we followed RFC 793 — <a href="https://tools.ietf.org/html/rfc793"target="_blank" rel="external nofollow noopener noreferrer">https://tools.ietf.org/html/rfc793</a> — which describes the original protocol, with the goal of being able to set up and tear down a connection with a &ldquo;real&rdquo; TCP stack at the other end (netcat in particular). We&rsquo;re writing it using a user-space networking interface (see <a href="https://www.kernel.org/doc/Documentation/networking/tuntap.txt"target="_blank" rel="external nofollow noopener noreferrer">https://www.kernel.org/doc/Documentation/networking/tuntap.txt</a> and the Rust bindings at <a href="https://docs.rs/tun-tap/%29"target="_blank" rel="external nofollow noopener noreferrer">https://docs.rs/tun-tap/)</a>.</p>
</blockquote>]]></description>
</item>
<item>
  <title>Crust of Rust: Iterators</title>
  <link>https://ccrysisa.github.io/posts/iterators/</link>
  <pubDate>Mon, 05 Feb 2024 17:18:34 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/iterators/</guid>
  <description><![CDATA[<blockquote>
<p>In this third Crust of Rust video, we cover iterators and trait bounds, by re-implementing the &ldquo;flatten&rdquo; Iterator method from the standard library. As part of that, we cover some of the weirder trait bounds that are required, including what&rsquo;s needed to extend the implementation to support backwards iteration.</p>
</blockquote>]]></description>
</item>
<item>
  <title>Crust of Rust: Declarative Macros</title>
  <link>https://ccrysisa.github.io/posts/declarative-macros/</link>
  <pubDate>Wed, 31 Jan 2024 22:32:27 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/declarative-macros/</guid>
  <description><![CDATA[<blockquote>
<p>In this second Crust of Rust video, we cover declarative macros, macro_rules!, by re-implementing the vec! macro from the standard library. As part of that, we cover not only how to write these, but some of the gotchas and tricks you&rsquo;ll run into, and some common use-cases.</p>
</blockquote>]]></description>
</item>
<item>
  <title>Crust of Rust: Lifetime Annotations</title>
  <link>https://ccrysisa.github.io/posts/lifetime-annotations/</link>
  <pubDate>Thu, 25 Jan 2024 18:40:45 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/lifetime-annotations/</guid>
  <description><![CDATA[<blockquote>
<p>We&rsquo;re going to investigate a case where you need multiple explicit lifetime annotations. We explore why they are needed, and why we need more than one in this particular case. We also talk about some of the differences between the string types and introduce generics over a self-defined trait in the process.</p>
</blockquote>]]></description>
</item>
<item>
  <title>GDB 调试工具</title>
  <link>https://ccrysisa.github.io/posts/debug-gdb/</link>
  <pubDate>Tue, 16 Jan 2024 17:15:46 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/debug-gdb/</guid>
  <description><![CDATA[<p>大型开源项目的规模十分庞大，例如使用 Rust 编写的 Servo 浏览器，这个项目有近十万行代码。在开发规模如此庞大的项目时，了解如何通过正确的方式进行调试非常重要，因为这样可以帮助开发者快速地找到瓶颈。</p>]]></description>
</item>
<item>
  <title>Rust: 进行中的未来</title>
  <link>https://ccrysisa.github.io/posts/rust-introduction/</link>
  <pubDate>Thu, 28 Dec 2023 20:18:03 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/rust-introduction/</guid>
  <description><![CDATA[Rust in 100 Seconds 观看短片: Rust in 100 Seconds &#x2705; 了解 Rust，初步了解其安全性原理 所有权 (ownership) 借用 (borrow) 警告 0:55 This is wrong, value mutability doesn&rsquo;t have anything to do with the value being stored on the stack or the heap (and the example let mut hello = &quot;hi]]></description>
</item>
</channel>
</rss>
