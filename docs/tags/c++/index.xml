<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>C&#43;&#43; - 标签 - KZnight&#39;s Blog</title>
    <link>https://ccrysisa.github.io/tags/c&#43;&#43;/</link>
    <description>C&#43;&#43; - 标签 | KZnight&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>caijiaxin@dragonos.org (ccrysisa)</managingEditor>
      <webMaster>caijiaxin@dragonos.org (ccrysisa)</webMaster><lastBuildDate>Sun, 30 Jun 2024 00:19:25 &#43;0800</lastBuildDate><atom:link href="https://ccrysisa.github.io/tags/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
  <title>Modern C&#43;&#43; (MSVC)</title>
  <link>https://ccrysisa.github.io/posts/modern-cpp/</link>
  <pubDate>Sun, 30 Jun 2024 00:19:25 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/modern-cpp/</guid>
  <description><![CDATA[<p>&ldquo;Modern&rdquo; <a href="https://en.wikipedia.org/wiki/C%2B%2B"target="_blank" rel="external nofollow noopener noreferrer">C++</a> isn&rsquo;t afraid to use any or all of the following:</p>
<ul>
<li>RAII</li>
<li>standard library containers and algorithms</li>
<li>templates</li>
<li>metaprogramming</li>
<li>exceptions</li>
<li>Boost</li>
</ul>
<p>&ldquo;Old&rdquo; <a href="https://en.wikipedia.org/wiki/C%2B%2B"target="_blank" rel="external nofollow noopener noreferrer">C++</a> tends to avoid these things due to a perceived lack of compiler support or run-time performance. Instead, you&rsquo;ll find&hellip;</p>
<ul>
<li>lots of <code>new</code> and <code>delete</code></li>
<li>roll-your-own linked lists and other data structures</li>
<li>return codes as a mechanism for error handling</li>
<li>one of the millions of custom string classes that aren&rsquo;t <code>std::string</code></li>
</ul>
<p>As with all this-vs-that arguments, there are merits to both approaches. Modern C++ isn&rsquo;t universally better. Embedded enviornments, for example, often require extra restrictions that most people never need, so you&rsquo;ll see a lot of old-style code there. Overall though, I think you&rsquo;ll find that most of the modern features are worth using regularly. Moore&rsquo;s Law and compiler improvements have taken care of the majority of reasons to avoid the new stuff.</p>]]></description>
</item>
<item>
  <title>Atomic Weapons: The C&#43;&#43; Memory Model and Modern Hardware</title>
  <link>https://ccrysisa.github.io/posts/atomic-weapons/</link>
  <pubDate>Wed, 19 Jun 2024 09:43:11 &#43;0800</pubDate>
  <author>ccrysisa</author>
  <guid>https://ccrysisa.github.io/posts/atomic-weapons/</guid>
  <description><![CDATA[<blockquote>
<p>This is a two-part talk that covers the C++ memory model, how locks and atomics and fences interact and map to hardware, and more. Even though we’re talking about C++, much of this is also applicable to Java and .NET which have similar memory models, but not all the features of C++ (such as relaxed atomics).</p>
</blockquote>]]></description>
</item>
</channel>
</rss>
